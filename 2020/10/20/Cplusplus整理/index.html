<!DOCTYPE html>
<html lang=en>
<head>
    <meta charset="utf-8">
    
    <title>C/C++整理 | EpsilonJohn&#39;s Blog</title>
    
    
        <meta name="keywords" content="C/C++整理" />
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="一、基础知识 static关键字作用   全局静态变量  在全局变量前加上关键字 static,全局变量就定义成一个全局静态变量 存放地址：静态存储区 初始化：未经初始化的全局静态变量会被自动初始化为 0 作用域：全局静态变量在声明他的文件之外是不可见的, 准确地说是从定义之处开始, 到文件结尾。    局部静态变量  在局部变量之前加上关键字 static,局部变量就成为一个局部静态变量。 存放">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++整理">
<meta property="og:url" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="EpsilonJohn&#39;s Blog">
<meta property="og:description" content="一、基础知识 static关键字作用   全局静态变量  在全局变量前加上关键字 static,全局变量就定义成一个全局静态变量 存放地址：静态存储区 初始化：未经初始化的全局静态变量会被自动初始化为 0 作用域：全局静态变量在声明他的文件之外是不可见的, 准确地说是从定义之处开始, 到文件结尾。    局部静态变量  在局部变量之前加上关键字 static,局部变量就成为一个局部静态变量。 存放">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-09-22.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-14-53.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-15-06.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-15-31.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-24-56.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-31-22.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-54-25.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-56-06.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-35-08.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-42-10.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-46-32.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-53-32.png">
<meta property="og:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-57-19.png">
<meta property="article:published_time" content="2020-10-20T13:48:15.000Z">
<meta property="article:modified_time" content="2020-11-02T15:37:38.000Z">
<meta property="article:author" content="EpsilonJohn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-09-22.png">
    

    
        <link rel="alternate" href="/atom.xml" title="EpsilonJohn&#39;s Blog" type="application/atom+xml" />
    

    
        <link rel="icon" href="/css/images/bikabika.png" />
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">EpsilonJohn&#39;s Blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title"><span>links</span></h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://myledeopenwrt.ddnsto.com" target="_blank" rel="noopener">OpenWrt</a>
                    </li>
                
                    <li>
                        <a href="https://s1.nsloop.com:55000" target="_blank" rel="noopener">Synology</a>
                    </li>
                
                    <li>
                        <a href="https://s1.nsloop.com:59443" target="_blank" rel="noopener">Chevereto</a>
                    </li>
                
                    <li>
                        <a href="http://s1.nsloop.com:59900" target="_blank" rel="noopener">PicUpload</a>
                    </li>
                
                    <li>
                        <a href="http://s1.nsloop.com:58443" target="_blank" rel="noopener">BlogEdit</a>
                    </li>
                
                    <li>
                        <a href="http://s1.nsloop.com:53000" target="_blank" rel="noopener">Gitlab</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
        
    <div class="widget-wrap" id='categories'>
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id='allExpand' href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Autoware.ai
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/29/Autoware.ai/2D-NDT-%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">2D-NDT-匹配算法</a></li>  <li class="file"><a href="/2020/03/02/Autoware.ai/Autoware-ai%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB-NDT%E6%A8%A1%E5%9D%97-1/">Autoware.ai代码解读::NDT模块-1</a></li>  <li class="file"><a href="/2020/03/05/Autoware.ai/Overview(%E6%A6%82%E8%BF%B0)/">Autoware.ai-Overview(概述)</a></li>  <li class="file"><a href="/2020/03/05/Autoware.ai/Design-Rules(%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83)/">Design-Rules(设计规范)</a></li>  <li class="file"><a href="/2020/03/05/Autoware.ai/QuestionAbout-Localization/">Question-About-Localization(定位相关问题)</a></li>  <li class="file"><a href="/2020/03/06/Autoware.ai/3D-NDT-%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">3D-NDT-匹配算法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/08/C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-unique-ptr-shared-ptr-make-unique/">智能指针-unique_ptr-shared_ptr-make_unique</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cartographer-Google相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/22/Cartographer-Google%E7%9B%B8%E5%85%B3/%E4%BD%BF%E7%94%A8QT-Creator-Ros%E9%98%85%E8%AF%BBGoogle-Cartographer%E4%BB%A3%E7%A0%81-%E8%A7%A3%E5%86%B3%E4%BE%9D%E8%B5%96-%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98-%E5%85%A8%E7%BB%BF/">使用QT-Creator-Ros阅读Google-Cartographer代码_解决依赖-跳转问题-全绿_</a></li>  <li class="file"><a href="/2020/02/23/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Cartographer论文阅读</a></li>  <li class="file"><a href="/2020/03/07/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-1-%E6%A6%82%E8%BF%B0/">Cartographer-[1]概述</a></li>  <li class="file"><a href="/2020/03/08/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-2-%E7%B3%BB%E7%BB%9F%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/">Cartographer-[2]-系统参数配置说明</a></li>  <li class="file"><a href="/2020/03/08/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-3-ROS%E5%B0%81%E8%A3%85API/">Cartographer-[3]-ROS封装API</a></li>  <li class="file"><a href="/2020/03/08/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-4-%E4%BB%8Enode-main-cc%E5%BC%80%E5%A7%8B/">Cartographer-[4]-从node_main.cc开始</a></li>  <li class="file"><a href="/2020/03/15/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-X-%E9%A1%B6%E5%B1%82%E6%8E%A5%E5%8F%A3%E7%BB%93%E6%9E%84%E5%9B%BE/">Cartographer-[X]-顶层接口结构图</a></li>  <li class="file"><a href="/2020/03/16/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-X-%E5%88%9D%E5%A7%8B%E5%8C%96/">Cartographer-[X]-初始化</a></li>  <li class="file"><a href="/2020/03/16/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-X-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%B6%88%E6%81%AF%E5%9B%9E%E8%B0%83/">Cartographer-[X]-传感器消息回调</a></li>  <li class="file"><a href="/2020/03/16/Cartographer-Google%E7%9B%B8%E5%85%B3/Cartographer-0-%E8%BF%90%E8%A1%8CDemo%E6%95%B0%E6%8D%AE%E9%9B%86%E5%92%8CMIT%E6%95%B0%E6%8D%AE%E9%9B%86/">Cartographer-[0]-运行Demo数据集和MIT数据集</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Fast-LIO系列
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2022/02/27/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">IKFOM论文阅读</a></li>  <li class="file"><a href="/2022/02/28/Fast-LIO%E7%B3%BB%E5%88%97/IEKF%E8%BF%AD%E4%BB%A3%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/">IEKF迭代扩展卡尔曼滤波器</a></li>  <li class="file"><a href="/2022/03/06/Fast-LIO%E7%B3%BB%E5%88%97/ROLI%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEIMU%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%A0%87%E5%AE%9A/">ROLI激光雷达IMU初始化及标定</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            First_Principles_of_CV
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E6%8F%90%E5%8F%96%E5%86%85%E5%A4%96%E5%8F%82%E7%9F%A9%E9%98%B5.md/">相机标定|内参和外参矩阵提取</a></li>  <li class="file"><a href="/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E8%BF%87%E7%A8%8B.md/">相机标定|相机标定过程</a></li>  <li class="file"><a href="/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%AE%80%E5%8D%95%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA.md/">相机标定|简单立体相机</a></li>  <li class="file"><a href="/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%BA%BF%E6%80%A7%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B.md/">相机标定|线性相机模型</a></li>  <li class="file"><a href="/2021/08/08/First_Principles_of_CV/%E5%A4%96%E5%8F%82%E6%9C%AA%E7%9F%A5%E7%9A%84%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA_%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95.md/">外参未知的立体相机|对极几何</a></li>  <li class="file"><a href="/2021/08/08/First_Principles_of_CV/%E5%A4%96%E5%8F%82%E6%9C%AA%E7%9F%A5%E7%9A%84%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA_%E6%A6%82%E8%BF%B0.md/">外参未知的立体相机|概述</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IMU相关
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/21/IMU%E7%9B%B8%E5%85%B3/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC-Quaternion-kinematics-for-the-error-state-KF/">四元数的状态误差卡尔曼-Quaternion-kinematics-for-the-error-state-KF</a></li>  <li class="file"><a href="/2020/03/21/IMU%E7%9B%B8%E5%85%B3/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC-%E9%99%84%E5%BD%95-%E5%87%A0%E7%A7%8D%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/">四元数的状态误差卡尔曼-[附录]-几种积分方法</a></li>  <li class="file"><a href="/2020/03/30/IMU%E7%9B%B8%E5%85%B3/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC-%E5%AF%B9%E9%9A%8F%E6%9C%BA%E5%99%AA%E5%A3%B0%E5%92%8C%E5%B9%B2%E6%89%B0%E7%9A%84%E7%A7%AF%E5%88%86/">四元数的状态误差卡尔曼-对随机噪声和干扰的积分</a></li>  <li class="file"><a href="/2020/10/31/IMU%E7%9B%B8%E5%85%B3/imu_tk%E6%A0%87%E5%AE%9A%E8%AE%BA%E6%96%87/">imu_tk标定论文阅读</a></li>  <li class="file"><a href="/2020/11/27/IMU%E7%9B%B8%E5%85%B3/IMU%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B/">IMU噪声模型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Marker_SLAM
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/20/Marker_SLAM/Aruco-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/">Aruco-1-基本介绍</a></li>  <li class="file"><a href="/2020/03/20/Marker_SLAM/Aruco-2-%E5%A2%9E%E5%BC%BA%E5%9E%8Baruco-aruco%E6%9D%BF/">Aruco-2-增强型aruco---aruco板</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ROS2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/25/ROS2/ROS2-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1/">ROS2_快速入门_1</a></li>  <li class="file"><a href="/2020/02/28/ROS2/ROS2-2-turtlesim/">ROS2-2-turtlesim</a></li>  <li class="file"><a href="/2020/02/28/ROS2/ROS2-3-%E5%8A%A8%E4%BD%9C/">ROS2-3-动作</a></li>  <li class="file"><a href="/2020/02/29/ROS2/ROS2-4-Launch%E6%96%87%E4%BB%B6/">ROS2-4-Launch文件</a></li>  <li class="file"><a href="/2020/02/29/ROS2/ROS2-5-ROS2bag%E5%8C%85/">ROS2-5-ROS2bag包</a></li>  <li class="file"><a href="/2020/02/29/ROS2/ROS2-6-%E5%88%9B%E5%BB%BAPackage/">ROS2-6-创建Package</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SLAM代码课程
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            BASALT
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/05/13/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/BASALT/BASALT-2-3D%E7%82%B9%E7%9A%84%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE/">BASALT-2-3D点的参数化表达</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            DSO
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/16/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/DSO/DSO-1-%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96/">DSO-1-系统框架与初始化</a></li>  <li class="file"><a href="/2020/03/23/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/DSO/DSO-2-%E8%B7%9F%E8%B8%AA%E4%B8%8E%E5%BB%BA%E5%9B%BE/">DSO-2-跟踪与建图</a></li>  <li class="file"><a href="/2020/03/30/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/DSO/DSO-%E8%B5%84%E6%96%99%E9%9B%86%E5%90%88/">DSO-资料集合</a></li>  <li class="file"><a href="/2020/03/30/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/DSO/DSO-3-%E6%BB%91%E7%AA%97%E4%BC%98%E5%8C%96/">DSO-3-滑窗优化</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            MSCKF
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/06/15/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/MSCKF/MSCKF-1-%E5%89%8D%E7%AB%AF/">MSCKF-1-前端</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ORB_SLAM2
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/17/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/ORB_SLAM2/%E7%AC%AC%E4%B8%80%E8%AE%B2-ORB-SLAM2-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-1/">第一讲-ORB_SLAM2_预备知识_1</a></li>  <li class="file"><a href="/2020/02/17/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/ORB_SLAM2/%E7%AC%AC%E4%B8%80%E8%AE%B2-ORB-SLAM2-%E8%AF%8D%E8%A2%8B%E6%A8%A1%E5%9E%8B/">第一讲-ORB-SLAM2-词袋模型</a></li>  <li class="file"><a href="/2020/02/18/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/ORB_SLAM2/%E7%AC%AC%E4%B8%80%E8%AE%B2-ORB-SLAM2-%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86-2-ORB%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96&%E5%A4%96%E7%82%B9%E5%89%94%E9%99%A4/">第一讲-ORB-SLAM2-预备知识-2-ORB特征提取&外点剔除</a></li>  <li class="file"><a href="/2020/02/25/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/ORB_SLAM2/%E7%AC%AC%E4%BA%8C%E8%AE%B2-ORB-SLAM2-%E8%A7%86%E8%A7%89%E8%B7%9F%E8%B8%AA%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D/">第二讲-ORB_SLAM2-视觉跟踪与重定位</a></li>  <li class="file"><a href="/2020/02/28/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/ORB_SLAM2/ORB_SLAM2-%E8%B5%84%E6%96%99%E9%9B%86%E5%90%88/">ORB_SLAM2-资料集合</a></li>  <li class="file"><a href="/2020/03/02/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/ORB_SLAM2/%E7%AC%AC%E4%B8%89%E8%AE%B2-ORB-SLAM2-%E5%B1%80%E9%83%A8%E4%BC%98%E5%8C%96/">第三讲-ORB_SLAM2-局部优化</a></li>  <li class="file"><a href="/2020/03/03/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/ORB_SLAM2/%E7%AC%AC%E5%9B%9B%E8%AE%B2-ORB-SLAM2-%E5%85%A8%E5%B1%80%E9%97%AD%E7%8E%AF/">第四讲-ORB-SLAM2-全局闭环</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            VINS-MONO
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/04/13/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VINS-MONO/Vins-Mono%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Vins-Mono论文阅读</a></li>  <li class="file"><a href="/2020/04/18/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VINS-MONO/VINS-Mono-1-%E5%89%8D%E7%AB%AF/">VINS-Mono-1-前端</a></li>  <li class="file"><a href="/2020/04/20/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VINS-MONO/VINS-Mono-2-%E5%90%8E%E7%AB%AF/">VINS-Mono-2-后端</a></li>  <li class="file"><a href="/2020/04/30/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VINS-MONO/VINS-Mono-3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%97%AD%E7%8E%AF/">VINS-Mono-3-初始化和闭环</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/2020/02/26/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/PnP%E6%B1%82%E8%A7%A3-EPnP/">PnP求解--EPnP</a></li>  <li class="file"><a href="/2020/04/06/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/VI%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E8%87%AA%E7%94%B1%E5%BA%A6%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/">VI中的几种自由度处理方法的性能对比</a></li>  <li class="file"><a href="/2020/04/07/SLAM%E4%BB%A3%E7%A0%81%E8%AF%BE%E7%A8%8B/Gauges-and-Gauge-Transformations/">Gauges-and-Gauge-Transformations</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            VIO
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第一讲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/14/VIO/%E7%AC%AC%E4%B8%80%E8%AE%B2/%E7%AC%AC%E4%B8%80%E8%AE%B2_%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/">第一讲_预备知识</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第三讲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/16/VIO/%E7%AC%AC%E4%B8%89%E8%AE%B2/%E7%AC%AC%E4%B8%89%E8%AE%B2(%E4%B8%8A)_%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E7%9A%84IMU%E4%B8%8E%E8%A7%86%E8%A7%89%E4%BF%A1%E6%81%AF%E8%9E%8D%E5%90%88/">第三讲(上)_基于优化的IMU与视觉信息融合(上)</a></li>  <li class="file"><a href="/2020/02/16/VIO/%E7%AC%AC%E4%B8%89%E8%AE%B2/%E7%AC%AC%E4%B8%89%E8%AE%B2(%E4%B8%8B)_VIO%E6%AE%8B%E5%B7%AE%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E5%BB%BA/">第三讲(下)[未完成]_VIO残差函数的构建及雅克比推导</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二讲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/13/VIO/%E7%AC%AC%E4%BA%8C%E8%AE%B2/%E7%AC%AC%E4%BA%8C%E8%AE%B2_IMU%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9B%B8%E5%85%B3/">第二讲_IMU相关内容</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第五讲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/16/VIO/%E7%AC%AC%E4%BA%94%E8%AE%B2/%E7%AC%AC%E4%BA%94%E8%AE%B2_%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B1%82%E8%A7%A3%E5%99%A8Solver%E6%B5%81%E7%A8%8B&%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3&%E4%BB%A3%E7%A0%81/">第五讲(上)_最小二乘求解器Solver流程&代码</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第六讲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/14/VIO/%E7%AC%AC%E5%85%AD%E8%AE%B2/%E7%AC%AC%E5%85%AD%E8%AE%B2-%E8%A7%86%E8%A7%89%E5%89%8D%E7%AB%AF/">第六讲_视觉前端</a></li>  <li class="file"><a href="/2020/02/14/VIO/%E7%AC%AC%E5%85%AD%E8%AE%B2/%E7%AC%AC%E5%85%AD%E8%AE%B2-%E4%B8%89%E8%A7%92%E5%8C%96/">第六讲_三角化</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四讲
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/14/VIO/%E7%AC%AC%E5%9B%9B%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E8%AE%B2(%E4%B8%8B)_%E5%9F%BA%E4%BA%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E7%9A%84VIO/">第四讲(下)_基于滑动窗口算法的VIO系统</a></li>  <li class="file"><a href="/2020/02/14/VIO/%E7%AC%AC%E5%9B%9B%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E8%AE%B2(%E4%B8%8A)_%E5%9F%BA%E4%BA%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E7%9A%84VIO/">第四讲(上)_基于滑动窗口算法的VIO系统原理</a></li>  <li class="file"><a href="/2020/02/14/VIO/%E7%AC%AC%E5%9B%9B%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E8%AE%B2(%E6%8B%93%E5%B1%95)_%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B(%E8%BE%B9%E7%BC%98%E5%8C%96%E4%B8%8E%E6%9D%A1%E4%BB%B6%E4%BD%9C%E7%94%A8)/">第四讲(拓展)_高斯过程(边缘化与条件作用)</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/2020/02/14/VIO/%E6%89%8B%E5%86%99VIO%E8%AF%BE%E7%A8%8B-%E8%B5%84%E6%96%99%E9%9B%86%E5%90%88/">VIO-资料集合</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            utils
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/14/utils/%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E6%B1%82%E8%A7%A3/">线性方程组求解</a></li>  <li class="file"><a href="/2020/02/23/utils/protobuf-1/">protobuf_1</a></li>  <li class="file"><a href="/2020/02/24/utils/SVD%E5%88%86%E8%A7%A3/">SVD分解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            传感器标定
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2021/04/12/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_1/">LiDAR-Camera 标定-1</a></li>  <li class="file"><a href="/2021/04/12/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_2/">LiDAR-Camera 标定-2</a></li>  <li class="file"><a href="/2021/04/12/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_3/">LiDAR-Camera 标定-3</a></li>  <li class="file"><a href="/2021/04/14/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_4/">LiDAR-Camera 标定-4</a></li>  <li class="file"><a href="/2021/04/27/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_5/">LiDAR-Camera 标定-5</a></li>  <li class="file"><a href="/2021/09/04/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/Camera%E4%B8%8E%E5%8D%95%E7%BA%BF%E6%BF%80%E5%85%89%E6%A0%87%E5%AE%9A/">Camera与单线激光标定</a></li>  <li class="file"><a href="/2022/02/01/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_6/"></a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            四元数的状态误差卡尔曼
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/21/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC-Quaternion-kinematics-for-the-error-state-KF/">四元数的状态误差卡尔曼-Quaternion-kinematics-for-the-error-state-KF</a></li>  <li class="file"><a href="/2020/03/21/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC-%E9%99%84%E5%BD%95-%E5%87%A0%E7%A7%8D%E7%A7%AF%E5%88%86%E6%96%B9%E6%B3%95/">四元数的状态误差卡尔曼-[附录]-几种积分方法</a></li>  <li class="file"><a href="/2020/03/30/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC/%E5%9B%9B%E5%85%83%E6%95%B0%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%AF%E5%B7%AE%E5%8D%A1%E5%B0%94%E6%9B%BC-%E5%AF%B9%E9%9A%8F%E6%9C%BA%E5%99%AA%E5%A3%B0%E5%92%8C%E5%B9%B2%E6%89%B0%E7%9A%84%E7%A7%AF%E5%88%86/">四元数的状态误差卡尔曼-对随机噪声和干扰的积分</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            多传感器融合定位
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/10/07/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%80%E7%AB%A0_3D%E6%BF%80%E5%85%89%E9%87%8C%E7%A8%8B%E8%AE%A1/">第一章_3D激光里程计</a></li>  <li class="file"><a href="/2020/10/17/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%82%B9%E4%BA%91%E5%9C%B0%E5%9B%BE%E6%9E%84%E5%BB%BA%E5%8F%8A%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%BD%8D/">第二章_点云地图构建及基于地图的定位</a></li>  <li class="file"><a href="/2020/10/25/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90_1/">第三章-(1)-惯性器件误差分析及内参标定</a></li>  <li class="file"><a href="/2020/10/29/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/GNSS-IMU%E6%95%B0%E6%8D%AE%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/">GNSS-IMU数据仿真器使用说明</a></li>  <li class="file"><a href="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-2/">第三章-(2)-惯性导航解算原理</a></li>  <li class="file"><a href="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/">第三章-(3)-补充内容</a></li>  <li class="file"><a href="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/">第四章-(1)-概率基础及滤波器原理</a></li>  <li class="file"><a href="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/">第四章-(2)-基于滤波器的融合算法及可观测性分析</a></li>  <li class="file"><a href="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/">第五章-(2)-组合导航常见现象解释</a></li>  <li class="file"><a href="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/">第五章-(1)-基于滤波器的融合算法-进阶</a></li>  <li class="file"><a href="/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/">滤波器融合_1_惯导解算原理——捷联惯导更新算法及误差分析</a></li>  <li class="file"><a href="/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_2_%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%88%86%E6%9E%90/">滤波器分析——状态方程和观测方程</a></li>  <li class="file"><a href="/2020/12/07/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-3/">第四章-(3)-补充内容</a></li>  <li class="file"><a href="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/">第六章-(1)-基于预积分的建图方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            平台对比
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/04/03/%E5%B9%B3%E5%8F%B0%E5%AF%B9%E6%AF%94/Apollo-or-ROS/">Apollo_or_ROS</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            控制相关
                        </a>
                         <ul class="unstyled" id="tree" > 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            线性系统理论
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/05/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E6%8F%8F%E8%BF%B0/">第二章-状态空间描述</a></li>  <li class="file"><a href="/2020/03/23/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E5%8A%A8%E5%88%86%E6%9E%90/">第三章-线性系统的运动分析</a></li>  <li class="file"><a href="/2020/03/30/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%8E%E9%9B%85%E6%99%AE%E8%AF%BA%E5%A4%AB%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%88%86%E6%9E%90/">第四章-控制系统的李雅普诺夫稳定性分析</a></li>  <li class="file"><a href="/2020/04/29/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%83%BD%E6%8E%A7%E6%80%A7%E5%92%8C%E8%83%BD%E8%A7%82%E6%80%A7/">第五章-线性系统的能控性和能观性</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/2020/03/02/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E8%BD%A6%E8%BE%86%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B/">车辆动力学模型</a></li>  <li class="file"><a href="/2020/03/26/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%91%E4%BC%BC%E7%BA%BF%E6%80%A7%E5%8C%96/">线性系统的近似线性化</a></li>  <li class="file"><a href="/2020/04/22/%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3/%E5%80%92%E7%AB%8B%E6%91%86%E5%88%86%E6%9E%90/">倒立摆分析</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数学基础
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/31/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%88%97%E7%A9%BA%E9%97%B4%E4%B8%8E%E9%9B%B6%E7%A9%BA%E9%97%B4/">矩阵的列空间与零空间</a></li>  <li class="file"><a href="/2020/04/07/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3/">矩阵相关</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据集整理
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/05/26/%E6%95%B0%E6%8D%AE%E9%9B%86%E6%95%B4%E7%90%86/KAIST-Urban-%E6%95%B0%E6%8D%AE%E9%9B%86-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">KAIST-Urban-数据集-论文阅读</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            文献阅读
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/02/15/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/SLAM%E7%BB%BC%E8%BF%B0_2020_Baichuan_Huang/">SLAM综述_2020_Baichuan_Huang</a></li>  <li class="file"><a href="/2020/03/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/CVPR2020-D3VO-%E5%9F%BA%E4%BA%8E%E8%87%AA%E7%9B%91%E7%9D%A3%E7%9A%84%E5%8D%95%E7%9B%AEVO%E7%BD%91%E7%BB%9C/">CVPR2020-D3VO-基于自监督的单目VO网络</a></li>  <li class="file"><a href="/2020/03/31/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/FEJ-%E9%BB%84%E5%9B%BD%E6%9D%83/">FEJ-黄国权</a></li>  <li class="file"><a href="/2020/07/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LIO-SAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">LIO-SAM论文阅读</a></li>  <li class="file"><a href="/2020/10/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Scan-Context%20%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Scan-Context论文阅读</a></li>  <li class="file"><a href="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">BALM论文阅读</a></li>  <li class="file"><a href="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">LINS论文阅读</a></li>  <li class="file"><a href="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">LiLi-om论文阅读</a></li>  <li class="file"><a href="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">BaiDu-考虑lio的定位</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            深度学习
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/03/19/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E5%9F%BA%E7%A1%80/">强化学习-基础</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            激光SLAM
                        </a>
                         <ul class="unstyled" id="tree" >  <li class="file"><a href="/2020/04/21/%E6%BF%80%E5%85%89SLAM/Lego-Loam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Lego-Loam论文阅读</a></li>  <li class="file"><a href="/2020/06/02/%E6%BF%80%E5%85%89SLAM/Review-3D-Lidar-Localization/">Review-3D-Lidar-Localization</a></li>  <li class="file"><a href="/2020/06/08/%E6%BF%80%E5%85%89SLAM/LOAM-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">LOAM-论文阅读</a></li>  <li class="file"><a href="/2020/06/10/%E6%BF%80%E5%85%89SLAM/VLP-16-%E8%AF%B4%E6%98%8E%E4%B9%A6%E6%91%98%E8%A6%81/">VLP-16-说明书摘要</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/2020/05/18/%E9%A9%B1%E5%8A%A8-%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA-%E6%98%9F%E7%BD%91%E5%AE%87%E8%BE%BEM2/">驱动-组合导航-星网宇达M2</a></li>  <li class="file"><a href="/2020/09/06/SLAM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/">SLAM基础知识点</a></li>  <li class="file"><a href="/2020/09/10/%E4%B8%A4%E8%BD%AE%E5%B7%AE%E9%80%9F%E5%BA%95%E7%9B%98%E7%9A%84%E4%B8%89%E7%A7%8D%E8%88%AA%E8%BF%B9%E6%8E%A8%E7%AE%97%E6%A8%A1%E5%9E%8B/">两轮差速底盘的三种航迹推算模型</a></li>  <li class="file active"><a href="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/">C/C++整理</a></li>  <li class="file"><a href="/2020/10/31/%E6%B5%8B%E8%AF%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">测试工程师基础知识</a></li>  <li class="file"><a href="/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/">CUDA编程</a></li>  <li class="file"><a href="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/">第二章-相机模型与对极几何</a></li>  <li class="file"><a href="/2021/01/29/ICRA2020_dynamic_object_removing/">ICRA2020_dynamic_object_removing</a></li>  <li class="file"><a href="/2021/01/29/LiTAMIN%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">LiTAMIN</a></li>  <li class="file"><a href="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/">占用栅格更新过程</a></li>  <li class="file"><a href="/2021/02/01/Eigen%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">Eigen-Operation</a></li>  <li class="file"><a href="/2021/02/11/Zotero%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Zotero导入CNKI文献</a></li>  <li class="file"><a href="/2021/02/19/IMU%E9%A2%84%E7%A7%AF%E5%88%86%E6%A8%A1%E5%9E%8B%E6%8E%A8%E5%AF%BC/">IMU预积分模型</a></li>  <li class="file"><a href="/2021/04/21/utc%E6%97%B6%E9%97%B4%E4%B8%8Egps%E6%97%B6%E9%97%B4/">UTC Time and GPS Time Conversion</a></li>  <li class="file"><a href="/2021/05/09/Incremental_Segmental_localization/">Incremental-Segment-Based Localization in 3-D Point Clouds</a></li>  <li class="file"><a href="/2021/05/09/SE3%E4%BC%B4%E9%9A%8F/">Adjoints and Covariances（伴随与协方差）</a></li>  <li class="file"><a href="/2021/06/05/Cross_view_slam%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Cross_view_slam论文阅读</a></li>  <li class="file"><a href="/2021/06/08/UPSLAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">UPSLAM论文阅读</a></li>  <li class="file"><a href="/2021/06/09/LION%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">LION论文阅读</a></li>  <li class="file"><a href="/2021/06/11/T-LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">T-LOAM论文阅读</a></li>  <li class="file"><a href="/2021/07/11/Hector-SLAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Hector-SLAM论文阅读</a></li>  <li class="file"><a href="/2021/07/19/TEB%E5%B1%80%E9%83%A8%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">TEB局部路径规划论文阅读</a></li>  <li class="file"><a href="/2021/07/20/LT-mapper%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">LT-mapper论文阅读</a></li>  <li class="file"><a href="/2021/07/20/MSCKF%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">MSCKF论文阅读</a></li>  <li class="file"><a href="/2021/07/25/Localization_for_Ground_Robots%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">Localization_for_Ground_Robots论文阅读</a></li>  <li class="file"><a href="/2021/09/11/FAST-LIO2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">FAST-LIO2论文阅读</a></li>  <li class="file"><a href="/2021/10/13/FAST-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/">FAST-LIO论文阅读</a></li>  <li class="file"><a href="/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E6%9E%A2%E8%B0%83%E5%BA%A6Scheduler/">Cyber-RT系列之中枢调度Scheduler</a></li>  <li class="file"><a href="/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%8F%E7%A8%8BCroutine/">Cyber-RT系列之协程Croutine</a></li>  <li class="file"><a href="/2022/04/11/M_LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"></a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-Cplusplus整理" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
                        
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/">
            <time datetime="2020-10-20T13:48:15.000Z" itemprop="datePublished">2020-10-20</time>
        </a>
    </div>


                        
                            <i class="fa fa-bar-chart"></i>
                            <span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span>    
                        
                        
                            <div class="article-meta-button">
                                <a href='https://github.com/qpc001/qpc001.github.io/raw/master/source/_posts/Cplusplus整理.md' target="_blank" rel="noopener"> Source </a>
                            </div>
                            <div class="article-meta-button">
                                <a href='https://github.com/qpc001/qpc001.github.io/edit/master/source/_posts/Cplusplus整理.md' target="_blank" rel="noopener"> Edit </a>
                            </div>
                            <div class="article-meta-button">
                                <a href='https://github.com/qpc001/qpc001.github.io/commits/master/source/_posts/Cplusplus整理.md' target="_blank" rel="noopener"> History </a>
                            </div>
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            C/C++整理
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">Catalogue</strong>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一基础知识"><span class="toc-number">1.</span> <span class="toc-text">一、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#static关键字作用"><span class="toc-number">1.1.</span> <span class="toc-text">static关键字作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c中四种-cast-转换"><span class="toc-number">1.2.</span> <span class="toc-text">c++中四种 cast 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么不使用-c-的强制转换"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么不使用 C 的强制转换?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cc-中指针和引用的区别"><span class="toc-number">1.3.</span> <span class="toc-text">C&#x2F;C++ 中指针和引用的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#野指针是什么"><span class="toc-number">1.4.</span> <span class="toc-text">野指针是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针有没有内存泄露的情况"><span class="toc-number">1.5.</span> <span class="toc-text">智能指针有没有内存泄露的情况?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#智能指针的内存泄漏如何解决"><span class="toc-number">1.5.1.</span> <span class="toc-text">智能指针的内存泄漏如何解决?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数指针"><span class="toc-number">1.6.</span> <span class="toc-text">函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么析构函数必须是虚函数为什么-c默认的析构函数不是虚函数"><span class="toc-number">1.7.</span> <span class="toc-text">为什么析构函数必须是虚函数?为什么 C++默认的析构函数不是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c中析构函数的作用"><span class="toc-number">1.8.</span> <span class="toc-text">C++中析构函数的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#静态函数和虚函数的区别"><span class="toc-number">1.9.</span> <span class="toc-text">静态函数和虚函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#重载和覆盖"><span class="toc-number">1.10.</span> <span class="toc-text">重载和覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数和多态"><span class="toc-number">1.11.</span> <span class="toc-text">虚函数和多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚函数表具体是怎样实现运行时多态的"><span class="toc-number">1.12.</span> <span class="toc-text">虚函数表具体是怎样实现运行时多态的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#i-和-i的实现"><span class="toc-number">1.13.</span> <span class="toc-text">++i 和 i++的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c里是怎么定义常量的常量存放在内存的哪个位置"><span class="toc-number">1.14.</span> <span class="toc-text">C++里是怎么定义常量的?常量存放在内存的哪个位置?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-c"><span class="toc-number">1.15.</span> <span class="toc-text">extern “C”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#newdelete-与-mallocfree-的区别是什么"><span class="toc-number">1.16.</span> <span class="toc-text">new&#x2F;delete 与 malloc&#x2F;free 的区别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c中拷贝赋值函数的形参能否进行值传递"><span class="toc-number">1.17.</span> <span class="toc-text">C++中拷贝赋值函数的形参能否进行值传递?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stl容器"><span class="toc-number">2.</span> <span class="toc-text">STL容器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#map-和-set-有什么区别分别又是怎么实现的"><span class="toc-number">2.1.</span> <span class="toc-text">map 和 set 有什么区别,分别又是怎么实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl-迭代器删除元素"><span class="toc-number">2.2.</span> <span class="toc-text">STL 迭代器删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector-和-list-的区别应用"><span class="toc-number">2.3.</span> <span class="toc-text">vector 和 list 的区别,应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl-中迭代器的作用有指针为何还要迭代器"><span class="toc-number">2.4.</span> <span class="toc-text">STL 中迭代器的作用,有指针为何还要迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl-里-resize-和-reserve-的区别"><span class="toc-number">2.5.</span> <span class="toc-text">STL 里 resize 和 reserve 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类和数据抽象"><span class="toc-number">3.</span> <span class="toc-text">类和数据抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c中类成员的访问权限"><span class="toc-number">3.1.</span> <span class="toc-text">C++中类成员的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c中-struct-和-class-的区别"><span class="toc-number">3.2.</span> <span class="toc-text">C++中 struct 和 class 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#泛型编程"><span class="toc-number">4.</span> <span class="toc-text">泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是右值引用跟左值又有什么区别"><span class="toc-number">4.1.</span> <span class="toc-text">什么是右值引用,跟左值又有什么区别?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#编译与底层"><span class="toc-number">5.</span> <span class="toc-text">编译与底层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c源文件从文本到可执行文件经历的过程"><span class="toc-number">5.1.</span> <span class="toc-text">C++源文件从文本到可执行文件经历的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include-头文件的顺序以及双引号和尖括号的区别"><span class="toc-number">5.2.</span> <span class="toc-text">include 头文件的顺序以及双引号””和尖括号&lt;&gt;的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-的原理"><span class="toc-number">5.3.</span> <span class="toc-text">malloc 的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-和-malloc-的区别"><span class="toc-number">5.4.</span> <span class="toc-text">new 和 malloc 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c的内存管理是怎样的"><span class="toc-number">5.5.</span> <span class="toc-text">C++的内存管理是怎样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是-memory-leak也就是内存泄漏"><span class="toc-number">5.6.</span> <span class="toc-text">什么是 memory leak,也就是内存泄漏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存泄漏分类"><span class="toc-number">5.7.</span> <span class="toc-text">内存泄漏分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何判断内存泄漏"><span class="toc-number">5.8.</span> <span class="toc-text">如何判断内存泄漏?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c如何处理内存泄漏"><span class="toc-number">5.9.</span> <span class="toc-text">C++如何处理内存泄漏?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么时候会发生段错误"><span class="toc-number">5.10.</span> <span class="toc-text">什么时候会发生段错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何采用单线程的方式处理高并发"><span class="toc-number">5.11.</span> <span class="toc-text">如何采用单线程的方式处理高并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c11"><span class="toc-number">6.</span> <span class="toc-text">C++11</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#c11-有哪些新特性"><span class="toc-number">6.1.</span> <span class="toc-text">C++11 有哪些新特性?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍一下-c11-中的可变参数模板右值引用和-lambda-这几个新特性"><span class="toc-number">6.2.</span> <span class="toc-text">介绍一下 C++11 中的可变参数模板、右值引用和 lambda 这几个新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可变参数模板"><span class="toc-number">6.2.1.</span> <span class="toc-text">可变参数模板:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#右值引用"><span class="toc-number">6.2.2.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移动语义"><span class="toc-number">6.2.3.</span> <span class="toc-text">移动语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完美转发"><span class="toc-number">6.2.4.</span> <span class="toc-text">完美转发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda-表达式"><span class="toc-number">6.2.5.</span> <span class="toc-text">Lambda 表达式:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-number">7.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#进程与线程的概念以及为什么要有进程线程其中有什么区别"><span class="toc-number">7.1.</span> <span class="toc-text">进程与线程的概念,以及为什么要有进程线程,其中有什么区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间的通信方式"><span class="toc-number">7.2.</span> <span class="toc-text">进程间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程间通信的方式"><span class="toc-number">7.3.</span> <span class="toc-text">线程间通信的方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-虚拟地址空间"><span class="toc-number">7.4.</span> <span class="toc-text">Linux 虚拟地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统中的程序的内存结构"><span class="toc-number">7.5.</span> <span class="toc-text">操作系统中的程序的内存结构?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统中的缺页中断"><span class="toc-number">7.6.</span> <span class="toc-text">操作系统中的缺页中断?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作系统中的页表寻址"><span class="toc-number">7.7.</span> <span class="toc-text">操作系统中的页表寻址?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发concurrency和并行parallelism"><span class="toc-number">7.8.</span> <span class="toc-text">并发(concurrency)和并行(parallelism)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各数据库的默认端口"><span class="toc-number">7.9.</span> <span class="toc-text">各数据库的默认端口</span></a></li></ol></li></ol>
                </div>
            
        
        
            <h1 id="一基础知识">一、基础知识</h1>
<h2 id="static关键字作用">static关键字作用</h2>
<blockquote>
<ol type="1">
<li>全局静态变量</li>
</ol>
<p>在全局变量前加上关键字 static,全局变量就定义成一个全局静态变量</p>
<p>存放地址：静态存储区</p>
<p>初始化：未经初始化的全局静态变量会被<strong>自动初始化为 0</strong></p>
<p>作用域：全局静态变量在声明他的文件之外是不可见的, 准确地说是从定义之处开始, 到文件结尾。</p>
</blockquote>
<blockquote>
<ol start="2" type="1">
<li>局部静态变量</li>
</ol>
<p>在局部变量之前加上关键字 static,局部变量就成为一个局部静态变量。</p>
<p>存放地址：静态存储区</p>
<p>初始化：自动初始化为 0</p>
<p>作用域:作用域仍为局部作用域</p>
</blockquote>
<blockquote>
<ol start="3" type="1">
<li>静态函数</li>
</ol>
<p>在函数返回类型前加 static,函数就定义为静态函数。函数的定义和声明在默认情况下都是 extern 的,但静态函数只是在声明他的文件当中可见,不能被其他文件所用(函数的实现使用 static 修饰,那么这个函数只可在本 cpp 内使用)</p>
</blockquote>
<blockquote>
<ol start="4" type="1">
<li>类的静态成员</li>
</ol>
<p>在类中, 静态成员可以实现多个对象之间的数据共享, 并且使用静态数据成员还不会破坏隐藏的原则,即保证了安全性。因此,静态成员是类的所有对象中共享的成员,而不是某个对象的成员。对多个对象来说,静态数据成员只存储一处,供所有对象共用</p>
</blockquote>
<blockquote>
<ol start="5" type="1">
<li>类的静态函数</li>
</ol>
<p>在静态成员函数的实现中不能直接引用类中说明的非静态成员, 可以引用类中说明的静态成员, 调用静态成员函数使用如下格式:<类名>::<静态成员函数名>(<参数表>);</参数表></静态成员函数名></类名></p>
</blockquote>
<h2 id="c中四种-cast-转换">c++中四种 cast 转换</h2>
<blockquote>
<p>C++中四种类型转换是:static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<ol type="1">
<li><p>const_cast: 用于将 const 变量转为非 const</p></li>
<li><p>static_cast: 用于各种隐式转换,比如非 const 转 const,void*转指针等, static_cast 能用于多态向上转化,如果向下转能成功但是不安全,结果未知;</p></li>
<li><p>dynamic_cast: 用于动态类型转换。 只能用于含有虚函数的类, 用于类层次间的向上和向下转化。 只能转指针或引用。向下转化时,如果是非法的对于指针返回 NULL <img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-09-22.png"></p></li>
<li><p>reinterpret_cast</p></li>
</ol>
</blockquote>
<h3 id="为什么不使用-c-的强制转换">为什么不使用 C 的强制转换?</h3>
<blockquote>
<p>C 的强制转换表面上看起来功能强大什么都能转,但是转化不够明确,不能进行错误检查, 容易出错。</p>
</blockquote>
<h2 id="cc-中指针和引用的区别">C/C++ 中指针和引用的区别?</h2>
<blockquote>
<p>1.指针有自己的一块空间,而引用只是一个别名;</p>
<p>2.使用 sizeof 看一个指针的大小是 4,而引用则是被引用对象的大小;</p>
<p>3.指针可以被初始化为 NULL,而引用必须被初始化且必须是一个已有对象 的引用;</p>
<p>4.作为参数传递时,指针需要被解引用才可以对对象进行操作,而直接对引 用的修改都会改变引用所指向的对象;</p>
<p>5.可以有 const 指针,但是没有 const 引用;</p>
<p>6.指针在使用中可以指向其它对象,但是引用只能是一个对象的引用,不能 被改变;</p>
<p>7.指针可以有多级指针(**p),而引用至于一级;</p>
<p>8.指针和引用使用++运算符的意义不一样;</p>
<p>9.如果返回动态内存分配的对象或者内存,必须使用指针,引用可能引起内存泄露。</p>
</blockquote>
<h2 id="野指针是什么">野指针是什么?</h2>
<blockquote>
<p>野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针</p>
</blockquote>
<h2 id="智能指针有没有内存泄露的情况">智能指针有没有内存泄露的情况?</h2>
<blockquote>
<p>当两个对象相互使用一个 shared_ptr 成员变量指向对方,会造成循环引用,使引用计数失效,从而导致内存泄漏。例如:</p>
<p><img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-14-53.png"> <img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-15-06.png"> <img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-15-31.png"></p>
<p>上述代码中, parent 有一个 shared_ptr 类型的成员指向孩子, 而 child 也有一个 shared_ptr 类型的成员指向父亲。然后在创建孩子和父亲对象时也使用了智能指针 c 和 p,随后将 c 和 p 分别又赋值给 child 的智能指针成员 parent 和 parent 的智能指针成员 child。 从而形成了一个循环引用</p>
</blockquote>
<h3 id="智能指针的内存泄漏如何解决">智能指针的内存泄漏如何解决?</h3>
<blockquote>
<p>为了解决循环引用导致的内存泄漏,引入了 weak_ptr 弱指针,weak_ptr 的构造函数不会修改引用计数的值, 从而不会对对象的内存进行管理, 其类似一个普通指针, 但不指向引用计数的共享内存,但是其可以检测到所管理的对象是否已经被释放,从而避免非法访问。</p>
</blockquote>
<h2 id="函数指针">函数指针</h2>
<blockquote>
<ol type="1">
<li>定义：函数指针是指向函数的指针变量。</li>
</ol>
<p>函数指针本身首先是一个指针变量, 该指针变量指向一个具体的函数。 这正如用指针变量可指向整型变量、字符型、数组一样,这里是指向函数。</p>
<p>C 在编译时,每一个函数都有一个入口地址,该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后, 可用该指针变量调用函数, 就如同用指针变量可引用其他类型变量一样, 在这些概念上是大体一致的。</p>
<ol start="2" type="1">
<li>示例：</li>
</ol>
<p><img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-24-56.png"></p>
</blockquote>
<h2 id="为什么析构函数必须是虚函数为什么-c默认的析构函数不是虚函数">为什么析构函数必须是虚函数?为什么 C++默认的析构函数不是虚函数</h2>
<blockquote>
<p>将可能会被继承的父类的析构函数设置为虚函数, 可以保证当我们 new 一个子类, 然后使用基类指针指向该子类对象,释放基类指针时可以释放掉子类的空间,防止内存泄漏。</p>
<p>C++默认的析构函数不是虚函数是因为虚函数需要额外的虚函数表和虚表指针,<strong>占用额外的内存</strong>。而对于不会被继承的类来说,其析构函数如果是虚函数,就会浪费内存。因此 C++默认的析构函数不是虚函数,而是只有当需要当作父类时,设置为虚函数。</p>
</blockquote>
<h2 id="c中析构函数的作用">C++中析构函数的作用</h2>
<blockquote>
<ol type="1">
<li>析构函数与构造函数对应, 当对象结束其生命周期, 如对象所在的函数已调用完毕时, 系统会自动执行析构函数。</li>
</ol>
<p>析构函数名也应与类名相同,只是在函数名前面加一个位取反符<sub>,例如</sub>stud( ),以区别于构造函数。它不能带任何参数,也没有返回值(包括 void 类型)。只能有一个析构函数,不能重载。</p>
<p>如果用户没有编写析构函数, 编译系统会自动生成一个缺省的析构函数 (即使自定义了析构函数, 编译器也总是会为我们合成一个析构函数, 并且如果自定义了析构函数, 编译器在执行时会先调用自定义的析构函数再调用合成的析构函数) , 它也不进行任何操作。 所以许多简单的类中没有用显式的析构函数。</p>
<p>如果一个类中有指针, 且在使用的过程中动态的申请了内存, 那么最好显示构造析构函数在销毁类之前,释放掉申请的内存空间,避免内存泄漏。</p>
<ol start="2" type="1">
<li>类析构顺序: 1)派生类本身的析构函数; 2)对象成员析构函数; 3)基类析构函数。</li>
</ol>
</blockquote>
<h2 id="静态函数和虚函数的区别">静态函数和虚函数的区别</h2>
<blockquote>
<p>静态函数在编译的时候就已经确定运行时机, 虚函数在运行的时候动态绑定。 虚函数因为用了虚函数表机制,调用的时候会增加一次内存开销</p>
</blockquote>
<h2 id="重载和覆盖">重载和覆盖</h2>
<blockquote>
<p>重载: 两个函数名相同,但是参数列表不同(个数,类型),返回值类型没有要求,在同一作用域中</p>
<p>重写: 子类继承了父类,<strong>父类中的函数是虚函数</strong>,在<strong>子类中重新定义了这个虚函数</strong>,这种情况是重写</p>
</blockquote>
<h2 id="虚函数和多态">虚函数和多态</h2>
<blockquote>
<p>多态的实现主要分为静态多态和动态多态</p>
<p>静态多态: 主要是重载, 在编译的时候就已经确定;</p>
<p>动态多态: 用虚函数机制实现的, 在运行期间动态绑定。 举个例子: 一个父类类型的指针指向一个子类对象时候, 使用父类的指针去调用子类中重写了的父类中的虚函数的时候, 会调用子类重写过后的函数,在父类中声明为加了 virtual 关键字的函数,在子类中重写时候不需要加 virtual 也是虚函数。</p>
</blockquote>
<h2 id="虚函数表具体是怎样实现运行时多态的">虚函数表具体是怎样实现运行时多态的?</h2>
<blockquote>
<p>子类若重写父类虚函数,虚函数表中,该函数的地址会被替换</p>
</blockquote>
<h2 id="i-和-i的实现">++i 和 i++的实现</h2>
<blockquote>
<p><img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-31-22.png"></p>
</blockquote>
<h2 id="c里是怎么定义常量的常量存放在内存的哪个位置">C++里是怎么定义常量的?常量存放在内存的哪个位置?</h2>
<blockquote>
<p>常量在 C++里的定义就是一个 top-level const 加上对象类型,常量定义必须初始化。</p>
<p>对于局部对象,常量存放在栈区</p>
<p>对于全局对象,常量存放在全局/静态存储区。</p>
<p>对于字面值常量,常量存放在常量存储区。</p>
</blockquote>
<h2 id="extern-c">extern “C”</h2>
<blockquote>
<p>C++调用 C 函数需要 extern C,因为 C 语言没有函数重载。</p>
</blockquote>
<h2 id="newdelete-与-mallocfree-的区别是什么">new/delete 与 malloc/free 的区别是什么</h2>
<blockquote>
<p>首先, new/delete 是 C++的关键字, 而 malloc/free 是 C 语言的库函数, 后者使用必须指明申请内存空间的大小,对于类类型的对象,后者不会调用构造函数和析构函数</p>
</blockquote>
<h2 id="c中拷贝赋值函数的形参能否进行值传递">C++中拷贝赋值函数的形参能否进行值传递?</h2>
<blockquote>
<p>不能。如果是这种情况下,调用拷贝构造函数的时候,首先要将实参传递给形参,这个传递的时候又要调用拷贝构造函数。。如此循环,无法完成拷贝,栈也会满。</p>
</blockquote>
<h1 id="stl容器">STL容器</h1>
<h2 id="map-和-set-有什么区别分别又是怎么实现的">map 和 set 有什么区别,分别又是怎么实现的?</h2>
<blockquote>
<p>map 和 set 都是 C++的关联容器,其底层实现都是红黑树(RB-Tree)。由于 map 和 set 所开放的各种操作接口,RB-tree 也都提供了,所以几乎所有的 map 和 set 的操作行为,都只是转调 RB-tree 的操作行为。</p>
<p>map 和 set 区别在于:</p>
<p>(1)map 中的元素是 <code>key-value</code>(关键字—值)对:关键字起到索引的作用,值则表示与索引相关联的数据;Set 与之相对就是关键字的简单集合,set 中每个元素只包含一个关键字。</p>
<p>(2)set 的迭代器是 <code>const</code> 的,不允许修改元素的值; map 允许修改 <code>value</code>,但不允许修改<code>key</code>。其原因是因为 map 和 set 是根据关键字排序来保证其有序性的,如果允许修改 <code>key</code>的话, 那么首先需要删除该键,然后调节平衡,再插入修改后的键值,调节平衡,如此一来,严重破坏了 map 和 set 的结构,导致 <code>iterator</code> 失效,不知道应该指向改变前的位置,还是指向改变后的位置。所以 STL 中将 set 的迭代器设置成 <code>const</code>,不允许修改迭代器的值;而 map 的迭代器则不允许修改 key 值,允许修改 <code>value</code> 值。</p>
<ol start="3" type="1">
<li>map 支持下标操作, set 不支持下标操作。 map 可以用 <code>key</code> 做下标, map 的下标运算符[ ] 将<code>key</code>作为下标去执行查找,如果<code>key-value</code>不存在,则插入一个具有该关键码和 mapped_type 类型默认值的元素至 map 中,因此下标运算符[ ]在 map 应用中需要慎用,<strong>如果 find 能解决需要,尽可能用 find</strong>。</li>
</ol>
</blockquote>
<h2 id="stl-迭代器删除元素">STL 迭代器删除元素</h2>
<blockquote>
<p>1.对于序列容器 vector,deque 来说,使用<code>erase(itertor)</code>后, 后边的每个元素的迭代器都会失效, 但是后边每个元素都会往前移动一个位置,但是 erase 会返回下一个有效的迭代器;</p>
<p>2.对于关联容器 map set 来说,使用了<code>erase(iterator)</code>后,当前元素的迭代器失效,但是其结构是红黑树,删除当前元素的,不会影响到下一个元素的迭代器, 所以在调用 erase 之前, 记录下一个元素的迭代器即可。</p>
<p>3.对于 list 来说,它使用了不连续分配的内存,并且它的 erase 方法也会返回下一个有效的 iterator,因此上面两种正确的方法都可以使用。</p>
</blockquote>
<h2 id="vector-和-list-的区别应用">vector 和 list 的区别,应用</h2>
<blockquote>
<ol type="1">
<li>vector:</li>
</ol>
<ul>
<li>连续存储的容器</li>
<li>动态数组: 在堆上分配空间</li>
<li>底层实现: 数组</li>
<li>两倍容量增长: vector 增加(插入)新元素时,如果未超过当时的容量,则还有剩余空间,那么直接添加到最后(插入指定位置),然后调整迭代器。如果没有剩余空间了,则会重新配置原有元素个数的两倍空间,然后将原空间元素通过复制的方式初始化新空间,再向新空间增加元素,最后析构并释放原空间,之前的迭代器会失效。</li>
<li>适用场景: 经常随机访问,且不经常对非尾节点进行插入删除. vector 拥有一段连续的内存空间,因此支持随机访问,如果需要高效的随即访问,而不在乎插入和删除的效率,使用 vector。</li>
<li>性能: <img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-54-25.png"></li>
</ul>
<ol start="2" type="1">
<li>list:</li>
</ol>
<ul>
<li>动态链表,在堆上分配空间</li>
<li>每插入一个元数都会分配空间,每删除一个元素都会释放空间。</li>
<li>底层: 双向链表</li>
<li>适用场景: 经常插入删除大量数据. list 拥有一段不连续的内存空间,如果需要高效的插入和删除,而不关心随机访问,则应使用 list。</li>
<li>性能： <img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-10-20-22-56-06.png"></li>
</ul>
</blockquote>
<h2 id="stl-中迭代器的作用有指针为何还要迭代器">STL 中迭代器的作用,有指针为何还要迭代器</h2>
<blockquote>
<ol type="1">
<li>迭代器</li>
</ol>
<p>Iterator(迭代器)模式又称 Cursor(游标)模式,用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解:Iterator 模式是运用于聚合对象的一种模式, 通过运用该模式, 使得我们可以在不知道对象内部表示的情况下,按照一定顺序(由 iterator 提供的方法)访问聚合对象中的各个元素。</p>
<ol start="2" type="1">
<li>迭代器和指针的区别</li>
</ol>
<p>迭代器不是指针,是类模板,表现的像指针。他只是模拟了指针的一些功能,通过重载了指针的一些操作符, -&gt;、 *、 ++、 --等。 迭代器封装了指针, 是一个 “可遍历 STL ( Standard Template Library)容器内全部或部分元素”的对象, 本质是封装了原生指针,是指针概念的一种提升(lift),提供了比指针更高级的行为,相当于一种智能指针,他可以根据不同类型的数据结构来实现不同的++,--等操作。</p>
<p>**迭代器返回的是对象引用而不是对象的值,所以 cout 只能输出迭代器使用*取值后的值而不能直接输出其自身。**</p>
<ol start="3" type="1">
<li>迭代器产生原因</li>
</ol>
<p>Iterator 类的访问方式就是把不同集合类的访问逻辑抽象出来,使得不用暴露集合内部的结构而达到循环遍历集合的效果。</p>
</blockquote>
<h2 id="stl-里-resize-和-reserve-的区别">STL 里 resize 和 reserve 的区别</h2>
<blockquote>
<ol type="1">
<li>resize():</li>
</ol>
<ul>
<li>改变当前容器内含有元素的数量, eg: <code>vector&lt;int&gt;v; v.resize(len);</code> , v 的 size 变为 len</li>
<li>如果原来 v 的 <code>size()</code> 小于 len, 那么容器<front color="red">新增</front>(len-size)个元素, 元素的值为默认为 0.</li>
</ul>
<ol start="2" type="1">
<li>reserve():</li>
</ol>
<ul>
<li>改变当前容器的最大容量(capacity),它不会生成元素,只是确定这个容器允许放入多少对象,</li>
<li>如果 <code>reserve(len)</code>的值大于当前的 <code>capacity()</code>,那么会重新分配一块能存 len 个对象的空间,然后把之前 <code>v.size()</code> 个对象通过 copy construtor 复制过来,销毁之前的内存;</li>
<li>注意，这个操作并不会创建新的元素对象</li>
</ul>
</blockquote>
<h1 id="类和数据抽象">类和数据抽象</h1>
<h2 id="c中类成员的访问权限">C++中类成员的访问权限</h2>
<blockquote>
<p>C++通过 public、 protected、 private 三个关键字来控制成员变量和成员函数的访问权限, 它们分别表示公有的、受保护的、私有的,被称为成员访问限定符。在类的内部(定义类的代码内部),无论成员被声明为 public、protected 还是 private,都是可以互相访问的,没有访问权限的限制。在类的外部(定义类的代码之外),只能通过对象访问成员,并且通过对象只能访问 public 属性的成员,不能访问 private、protected 属性的成员</p>
</blockquote>
<h2 id="c中-struct-和-class-的区别">C++中 struct 和 class 的区别</h2>
<blockquote>
<p>在 C++中,可以用 struct 和 class 定义类,都可以继承。 区别在于: struct 的默认继承权限和默认访问权限是 <code>public</code> , 而 class 的默认继承权限和默认访问权限是 <code>private</code>。 另外,class 还可以定义模板类形参,比如 <code>template &lt;class T, int i&gt;</code>。</p>
</blockquote>
<h1 id="泛型编程">泛型编程</h1>
<h2 id="什么是右值引用跟左值又有什么区别">什么是右值引用,跟左值又有什么区别?</h2>
<blockquote>
<p>右值引用是 C++11 中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面: - 消除两个对象交互时不必要的对象拷贝,节省运算存储资源,提高效率。 - 能够更简洁明确地定义泛型函数。</p>
<p>左值和右值的概念: - 左值: 能对表达式取地址、或具名对象/变量。<strong>一般指表达式结束后依然存在的持久对象</strong>。 - 右值: 不能对表达式取地址,或匿名对象。<strong>一般指表达式结束就不再存在的临时对象</strong>。 - 举例: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A a;</span><br><span class="line">A&amp; a_ref=a;</span><br><span class="line">A&amp;&amp; temp_rref = A();</span><br></pre></td></tr></table></figure></p>
<p>右值引用和左值引用的区别: - 左值可以寻址,而右值不可以。 - 左值可以被赋值,右值不可以被赋值,可以用来给左值赋值。</p>
<p><a href="https://zhuanlan.zhihu.com/p/85668787" target="_blank" rel="noopener">《左右值与右值引用》</a></p>
</blockquote>
<h1 id="编译与底层">编译与底层</h1>
<h2 id="c源文件从文本到可执行文件经历的过程">C++源文件从文本到可执行文件经历的过程</h2>
<blockquote>
<p>对于 C++源文件,从文本到可执行文件一般需要四个过程: 1) 预处理阶段: 对源代码文件中文件包含关系(头文件)、预编译语句(宏定义)进行分析和替换,生成预编译文件。 2) 编译阶段: 将经过预处理后的预编译文件转换成特定汇编代码,生成汇编文件 3) 汇编阶段: 将编译阶段生成的汇编文件转化成机器码,生成可重定位目标文件 4) 链接阶段: 将多个目标文件及所需要的库连接成最终的可执行目标文件</p>
</blockquote>
<h2 id="include-头文件的顺序以及双引号和尖括号的区别">include 头文件的顺序以及双引号””和尖括号&lt;&gt;的区别?</h2>
<blockquote>
<p>Include 头文件的顺序: 对于 include 的头文件来说, 如果在文件 a.h 中声明一个在文件 b.h 中定义的变量,而不引用 b.h。那么要在 a.c 文件中引用 b.h 文件,并且要先引用 b.h,后引用a.h,否则汇报变量类型未声明错误。</p>
</blockquote>
<blockquote>
<p>双引号和尖括号的区别: <strong>编译器预处理阶段查找头文件的路径不一样</strong> 1) 对于使用双引号<code>""</code>包含的头文件,查找头文件路径的顺序为: (1) 当前头文件目录 (2) 编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径) (3) 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径 2) 对于使用尖括号包含的头文件,查找头文件的路径顺序为: (1) 编译器设置的头文件路径(编译器可使用-I 显式指定搜索路径) (2) 系统变量 CPLUS_INCLUDE_PATH/C_INCLUDE_PATH 指定的头文件路径</p>
</blockquote>
<h2 id="malloc-的原理">malloc 的原理</h2>
<blockquote>
<p>Malloc 函数用于动态分配内存。为了减少内存碎片和系统调用的开销,malloc 其采用内存池的方式, 先申请大块内存作为堆区, 然后将堆区分为多个内存块, 以块作为内存管理的基本单位。当用户申请内存时,直接从堆区分配一块合适的空闲块。</p>
</blockquote>
<h2 id="new-和-malloc-的区别">new 和 malloc 的区别</h2>
<blockquote>
<ol type="1">
<li>new 分配内存按照数据类型进行分配, malloc 分配内存按照指定的大小分配;</li>
<li>new 返回的是指定对象的指针, 而 malloc 返回的是 void*, 因此 malloc 的返回值一般都需要进行类型转化。</li>
<li>new 不仅分配一段内存,而且会调用构造函数,malloc 不会。</li>
<li>new 分配的内存要用 delete 销毁,malloc 要用 free 来销毁;delete 销毁的时候会调用对象的析构函数,而 free 则不会。</li>
<li>new 是一个操作符可以重载,malloc 是一个库函数。</li>
<li>malloc 分配的内存不够的时候, 可以用 realloc 扩容。</li>
<li>new 如果分配失败了会抛出 bad_malloc 的异常,而 malloc 失败了会返回 NULL。</li>
<li>申请数组时: new[]一次分配所有内存, 多次调用构造函数, 搭配使用 delete[], delete[] 多次调用析构函数,销毁数组中的每个对象。而 malloc 则只能 <code>sizeof(int) * n</code>。</li>
</ol>
</blockquote>
<h2 id="c的内存管理是怎样的">C++的内存管理是怎样的</h2>
<blockquote>
<p>在 C++中,虚拟内存分为<code>代码段</code>、<code>数据段</code>、<code>BSS 段</code>、<code>堆区</code>、<code>文件映射区</code>以及<code>栈区</code>六部分。 1) 代码段:包括只读存储区和文本区,其中只读存储区存储字符串常量,文本区存储程序的机器代码。 2) 数据段:存储程序中已初始化的全局变量和静态变量 3) bss 段:存储未初始化的全局变量和静态变量(局部+全局),以及所有被初始化为 0 的全局变量和静态变量。 4) 堆区: 调用 new/malloc 函数时在堆区动态分配内存, 同时需要调用 delete/free 来手动释放申请的内存。 5) 映射区:存储动态链接库以及调用 mmap 函数进行的文件映射 6) 栈:使用栈空间存储函数的返回地址、参数、局部变量、返回值</p>
</blockquote>
<h2 id="什么是-memory-leak也就是内存泄漏">什么是 memory leak,也就是内存泄漏</h2>
<blockquote>
<p>内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。 内存泄漏并非指内存在物理上的消失, 而是应用程序分配某段内存后, 由于设计错误, 失去了对该段内存的控制,因而造成了内存的浪费。</p>
</blockquote>
<h2 id="内存泄漏分类">内存泄漏分类</h2>
<blockquote>
<ol type="1">
<li>堆内存泄漏 (Heap leak): 指的是程序运行中根据需要分配通过 malloc,realloc new 等从堆中分配的一块内存,再是完成后必须通过调用对应的 free 或者 delete 删掉。如果程序的设计的错误导致这部分内存没有被释放, 那么此后这块内存将不会被使用, 就会产生 Heap Leak.</li>
<li>系统资源泄露(Resource Leak): 主要指程序使用系统分配的资源比如Bitmap,handle ,SOCKET 等没有使用相应的函数释放掉,导致系统资源的浪费,严重可导致系统效能降低,系统运行不稳定。</li>
<li>没有将基类的析构函数定义为虚函数: 当基类指针指向子类对象时,如果基类的析构函数不是 virtual,那么子类的析构函数将不会被调用,子类的资源没有正确是释放,因此造成内存泄露。</li>
</ol>
</blockquote>
<h2 id="如何判断内存泄漏">如何判断内存泄漏?</h2>
<blockquote>
<p>内存泄漏通常是由于调用了 <code>malloc/new</code> 等内存申请的操作, 但是缺少了对应的 <code>free/delete</code>。 为了判断内存是否泄露, 我们一方面可以使用 linux 环境下的内存泄漏检查工具 <code>Valgrind</code>,另一方面我们在写代码时可以添加内存申请和释放的统计功能, 统计当前申请和释放的内存是否一致, 以此来判断内存是否泄露。</p>
</blockquote>
<h2 id="c如何处理内存泄漏">C++如何处理内存泄漏?</h2>
<blockquote>
<p>使用 varglind,mtrace 检测</p>
</blockquote>
<h2 id="什么时候会发生段错误">什么时候会发生段错误</h2>
<blockquote>
<p>段错误通常发生在<strong>访问非法内存地址</strong>的时候,具体来说分为以下几种情况: 1) 使用野指针 2) 试图修改字符串常量的内容</p>
</blockquote>
<h2 id="如何采用单线程的方式处理高并发">如何采用单线程的方式处理高并发</h2>
<blockquote>
<p>在单线程模型中, 可以采用 I/O 复用来提高单线程处理多个请求的能力, 然后再采用事件驱动模型,基于异步回调来处理事件来</p>
</blockquote>
<h1 id="c11">C++11</h1>
<h2 id="c11-有哪些新特性">C++11 有哪些新特性?</h2>
<blockquote>
<p>C++11 最常用的新特性如下： 1) auto 关键字:编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导 2) nullptr 关键字: nullptr 是一种特殊类型的字面值, 它可以被转换成任意其它的指针类型; 而 NULL 一般被宏定义为 0,在遇到重载时可能会出现问题。 3) 智能指针: C++11 新增了 std::shared_ptr、std::weak_ptr 等类型的智能指针,用于解决内存管理的问题。 4) 初始化列表:使用初始化列表来对类进行初始化 5) 右值引用: 基于右值引用可以实现移动语义和完美转发, 消除两个对象交互时不必要的对象拷贝,节省运算存储资源,提高效率 6) atomic 原子操作用于多线程资源互斥操作 7) 新增 STL 容器 array 以及 tuple</p>
</blockquote>
<h2 id="介绍一下-c11-中的可变参数模板右值引用和-lambda-这几个新特性">介绍一下 C++11 中的可变参数模板、右值引用和 lambda 这几个新特性</h2>
<h3 id="可变参数模板">可变参数模板:</h3>
<blockquote>
<p>C++11 的可变参数模板,对参数进行了高度泛化,可以表示任意数目、任意类型的参数,其语法为:在 class 或 typename 后面带上省略号<code>...</code></p>
<p>省略号作用如下: 1) 声明一个包含 0 到任意个模板参数的参数包 2) 可以将参数包展成一个个独立的参数</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T 叫做模板参数包,args 叫做函数参数包</span></span><br><span class="line">Template&lt;<span class="class"><span class="keyword">class</span> ... <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> ... <span class="title">args</span>)&#123;</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"num is"</span>&lt;&lt;<span class="keyword">sizeof</span> ...(args)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>func();//args 不含任何参数</li>
<li>func(1);//args 包含一个 int 类型的实参</li>
<li>func(1,2.0)//args 包含一个 int 一个 double 类型的实参</li>
</ul>
</blockquote>
<p>C++11 可以使用递归函数的方式展开参数包,获得可变参数的每个值。通过递归函数展开参数包,需要提供一个参数包展开的函数和一个递归终止函数。例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载最终递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"empty"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 展开函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T head, Args ... args)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;head&lt;&lt;<span class="string">","</span>;</span><br><span class="line">    <span class="built_in">print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数包 Args ...在展开的过程中递归调用自己,没调用一次参数包中的参数就会少一个, 直到所有参数都展开为止。当没有参数时就会调用非模板函数 printf 终止递归过程。</p>
<h3 id="右值引用">右值引用</h3>
<p>基于右值引用可以实现转移语义和完美转发新特性。</p>
<h3 id="移动语义">移动语义</h3>
<p>对于一个包含指针成员变量的类, 由于编译器默认的拷贝构造函数都是浅拷贝, 所有我们一般需要通过实现深拷贝的拷贝构造函数, 为指针成员分配新的内存并进行内容拷贝, 从而避免悬挂指针的问题。</p>
<p>如下代码所示:</p>
<p><img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-35-08.png"></p>
<p>上述代码中，函数<code>GetTemp()</code>返回了一个类型为<code>HasPtrMem</code>的对象，此外，该类定义了<code>深拷贝</code>的拷贝构造函数，因此，<code>main()</code>函数，两次调用拷贝构造函数，第一次是调用<code>GetTemp()</code>函数返回时的<code>临时变量</code>，第二次是将函数返回值拷贝给变量<code>a</code>时。</p>
<p>而在上述过程中, 使用临时变量构造 a 时会调用拷贝构造函数分配对内存, 而临时对象在语句结束后会释放它所使用的堆内存。 这样<code>重复申请和释放内存</code>, 在申请内存较大时会<code>严重影响性能</code>。因此 C++使用<code>移动构造函数</code>,从而保证使用临时对象构造 a 时不分配内存,从而提高性能.</p>
<blockquote>
<p>解决方案:</p>
<p>如下列代码所示, 移动构造函数<code>接收一个右值引用作为参数</code>, <strong>使用右值引用的参数初始化其指针成员变量</strong>。 <img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-42-10.png"></p>
<p>其原理就是使用在构造对象 a 时,使用 h.d 来初始化 a,然后将临时对象 h 的成员变量 d 指向 nullptr,从而保证临时变量析构时不会释放对内存。</p>
<p><img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-46-32.png"></p>
</blockquote>
<h3 id="完美转发">完美转发</h3>
<blockquote>
<p>完美转发是指在函数模板中, 完全依照模板的参数的类型, 将参数传递给函数模板中调用的另一个函数, 即传入转发函数的是左值对象, 目标函数就能获得左值对象, 转发函数是右值对象, 目标函数就能获得右值对象,而不产生额外的开销。</p>
<p>因此转发函数和目标函数参数一般采用引用类型, 从而避免拷贝的开销。 其次, 由于目标函数可能需要能够既接受左值引用,又接受右值引用,所以考虑转发也需要兼容这两种类型。</p>
<p>C++11 采用引用折叠的规则,结合新的模板推导规则实现完美转发。其引用折叠规则如下:</p>
<p><img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-53-32.png"></p>
</blockquote>
<h3 id="lambda-表达式">Lambda 表达式:</h3>
<blockquote>
<p>Lambda 表达式定义一个匿名函数,并且可以捕获一定范围内的变量,其定义如下:</p>
<p><code>[capture](params)mutable-&gt;return-type{statement}</code></p>
<p>其中, - [capture]:捕获列表,捕获上下文变量以供 lambda 使用。同时[]是 lambda 寅初复,编译器根据该符号来判断接下来代码是否是 lambda 函数。 - (Params):参数列表,与普通函数的参数列表一致,如果不需要传递参数,则可以连通括号一起省略。 - mutable 是修饰符, 默认情况下 lambda 函数总是一个 const 函数, Mutable 可以取消其常量性。在使用该修饰符时,参数列表不可省略。 - -&gt;return-type:返回类型是返回值类型 - {statement}:函数体, 内容与普通函数一样, <strong>除了可以使用参数之外, 还可以使用所捕获的变量</strong>。</p>
<p>特点： Lambda 表达式与普通函数最大的区别就是其可以通过捕获列表访问一些上下文中的数据。</p>
<p><img src="/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/2020-11-02-22-57-19.png"></p>
</blockquote>
<h1 id="操作系统">操作系统</h1>
<h2 id="进程与线程的概念以及为什么要有进程线程其中有什么区别">进程与线程的概念,以及为什么要有进程线程,其中有什么区别?</h2>
<blockquote>
<p>基本概念 - 进程是对运行时程序的封装, 是<code>系统进行资源调度和分配的的基本单位</code>, 实现了操作系统的并发; - 线程是进程的子任务, 是<code>CPU调度和分派的基本单位</code>, 用于保证程序的实时性, 实现进程内部的并发; 每个线程都独自占用一个虚拟处理器: 独自的寄存器组, 指令计数器和处理器状态。 每个线程完成不同的任务, 但是共享同一地址空间(也就是同样的动态内存,映射文件,目标代码等等), 打开的文件队列和其他内核资源。</p>
<p>区别: 1. 一个线程只能属于一个进程, 而一个进程可以有多个线程, 但至少有一个线程。 线程依赖于进程而存在。 2. 进程在执行过程中拥有独立的内存单元, 而多个线程共享进程的内存。 3. 进程是资源分配的最小单位,线程是 CPU 调度的最小单位; 4. 系统开销: 由于在创建或撤消进程时,系统都要为之分配或回收资源,如内存空间、I/O设备等。因此,操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。进程切换的开销也远大于线程切换的开销。 5. 进程编程调试简单可靠性高,但是创建销毁开销大;线程正相反,开销小,切换速度快, 但是编程调试相对复杂 6. 进程间不会相互影响 ;线程一个线程挂掉将导致整个进程挂掉</p>
</blockquote>
<h2 id="进程间的通信方式">进程间的通信方式</h2>
<p>进程间通信主要包括管道、系统 IPC(包括消息队列、信号量、信号、共享内存等)、以及套接字 socket。</p>
<p><strong>1.管道</strong></p>
<p>管道主要包括<code>无名管道</code>和<code>命名管道</code>:</p>
<p>管道可用于具有亲缘关系的父子进程间的通信,有名管道除了具有管道所具有的功能外,它还允许无亲缘关系进程间的通信</p>
<p>1.1 普通管道 PIPE:</p>
<ol type="1">
<li>它是半双工的(即数据只能在一个方向上流动),具有固定的读端和写端</li>
<li>它只能用于具有亲缘关系的进程之间的通信(也是父子进程或者兄弟进程之间)</li>
<li>它可以看成是一种特殊的文件, 对于它的读写也可以使用普通的 read、 write 等函数。 但是它不是普通的文件,并不属于其他任何文件系统,并且只存在于内存中。</li>
</ol>
<p>1.2 命名管道 FIFO:</p>
<ol type="1">
<li>FIFO 可以在无关的进程之间交换数据</li>
<li>FIFO 有路径名与之相关联,它以一种特殊设备文件形式存在于文件系统中。</li>
</ol>
<p><strong>2.系统 IPC</strong></p>
<p>2.1 消息队列:</p>
<ol type="1">
<li>消息队列,是消息的链接表,存放在内核中。</li>
<li>消息队列克服了信号传递信息少, <code>管道只能承载无格式字节流以及缓冲区大小受限</code>等特点</li>
<li>一个消息队列由一个标识符(即队列 ID)来标记</li>
<li>具有写权限得进程可以按照一定得规则向消息队列中添加新信息;</li>
<li>对消息队列有读权限得进程则可以从消息队列中读取信息;</li>
</ol>
<p>2.2 信号量 semaphore:</p>
<ol type="1">
<li>信号量(semaphore)是一个计数器,可以用来控制多个进程对共享资源的访问。 信号量用于实现进程间的互斥与同步, 而不是用于存储进程间通信数据。</li>
<li>信号量用于进程间同步,若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作,程序对信号量的操作都是原子操作。</li>
<li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1,而且可以加减任意正整数。</li>
<li>支持信号量组。</li>
</ol>
<p>2.3 信号 signal</p>
<ol type="1">
<li>信号是一种比较复杂的通信方式,用于通知接收进程某个事件已经发生。</li>
</ol>
<p>2.4 共享内存(Shared Memory):</p>
<ol type="1">
<li>它使得多个进程可以访问同一块内存空间, 不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作,如互斥锁和信号量等</li>
<li>共享内存是<code>最快的一种 IPC</code>,因为进程是直接对内存进行存取</li>
<li>因为多个进程可以同时操作,所以需要进行同步</li>
<li>信号量+共享内存通常结合在一起使用,信号量用来同步对共享内存的访问</li>
</ol>
<p><strong>3.套接字 SOCKET</strong></p>
<p>socket 也是一种进程间通信机制,与其他通信机制不同的是,它可用于不同主机之间的进程通信。</p>
<h2 id="线程间通信的方式">线程间通信的方式?</h2>
<ol type="1">
<li>临界区:通过多线程的<code>串行化</code>来访问公共资源或一段代码,速度快,适合控制数据访问;</li>
<li>互斥量 Synchronized/Lock: 采用互斥对象机制, 只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个,所以可以保证公共资源不会被多个线程同时访问</li>
<li>信号量 Semphare: 为控制具有有限数量的用户资源而设计的,它允许多个线程在同一时刻去访问同一个资源,但一般需要限制同一时刻访问此资源的最大线程数目。</li>
<li>事件(信号),Wait/Notify:通过通知操作的方式来保持多线程同步,还可以方便的实现多线程优先级的比较操作</li>
</ol>
<h2 id="linux-虚拟地址空间">Linux 虚拟地址空间</h2>
<blockquote>
<p>为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏, 采用了虚拟内存。</p>
<p>虚拟内存技术使得不同进程在运行过程中,它所看到的是<code>自己独自占有了当前系统的 4G 内存</code>。 所有进程共享同一物理内存, 每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。</p>
<p>事实上,在每个进程创建加载时,内核只是为进程“创建”了虚拟内存的布局,具体就是初始化进程控制表中内存相关的链表, <code>实际上并不立即就把虚拟内存对应位置的程序数据和代码(比如.text .data 段)拷贝到物理内存中</code>,只是建立好虚拟内存和磁盘文件之间的映射就好(叫做存储器映射),等到运行到对应的程序时,才会通过缺页异常,来拷贝数据。</p>
<p>还有进程运行过程中,要动态分配内存,比如 malloc 时,也只是分配了虚拟内存,即为这块虚拟内存对应的页表项做相应设置,当进程真正访问到此数据时,才引发缺页异常。</p>
<p>请求分页系统、 请求分段系统和请求段页式系统都是针对虚拟内存的, 通过请求实现内存与外存的信息置换。</p>
<p>虚拟内存的好处: 1. 扩大地址空间; 2. 内存保护: 每个进程运行在各自的虚拟内存地址空间, 互相不能干扰对方。 虚存还对特定的内存地址提供写保护,可以防止代码或数据被恶意篡改。 3. 公平内存分配。采用了虚存之后,每个进程都相当于有同样大小的虚存空间。 4. 当进程通信时,可采用虚存共享的方式实现。 5. 当不同的进程使用同样的代码时, 比如库文件中的代码, 物理内存中可以只存储一份这样的代码,不同的进程只需要把自己的虚拟内存映射过去就可以了,节省内存 6. 虚拟内存很适合在多道程序设计系统中使用, 许多程序的片段同时保存在内存中。 当一个程序等待它的一部分读入内存时, 可以把 CPU 交给另一个进程使用。 在内存中可以保留多个进程, 系统并发度提高 7. 在程序需要分配连续的内存空间的时候, 只需要在虚拟内存空间分配连续空间, 而不需要实际物理内存的连续空间,可以利用碎片</p>
<p>虚拟内存的代价: 1. 虚存的管理需要建立很多数据结构,这些数据结构要占用额外的内存 2. 虚拟地址到物理地址的转换,增加了指令的执行时间。 3. 页面的换入换出需要磁盘 I/O,这是很耗时的 4. 如果一页中只有一部分数据,会浪费内存。</p>
</blockquote>
<h2 id="操作系统中的程序的内存结构">操作系统中的程序的内存结构?</h2>
<ol type="1">
<li>数据段: 存放程序中<code>已初始化的全局变量</code>的一块内存区域。数据段也属于静态内存分配</li>
<li>bss段: (未进行初始化的数据)的内容并不存放在磁盘上的程序文件中。其原因是内核在程序开始运行前将它们设置为 0。需要存放在程序文件中的只有正文段和初始化数据段。</li>
<li>data段: (已经初始化的数据)则为数据分配空间,数据保存到目标文件中</li>
<li>代码段: <code>存放程序执行代码</code>的一块内存区域。这部分区域的大小在程序运行前就已经确定, 并且内存区域属于只读。在代码段中,也有可能包含一些只读的常数变量</li>
</ol>
<ul>
<li>text 段和 data 段在编译时已经分配了空间,而 BSS 段并不占用可执行文件的大小,它是由链接器来获取内存的。</li>
<li>数据段包含<code>经过初始化的全局变量以及它们的值</code>。 BSS段的大小从可执行文件中得到,然后链接器得到这个大小的内存块, 紧跟在数据段的后面。 当这个内存进入程序的地址空间后全部清零。<strong>包含数据段和 BSS 段的整个区段此时通常称为数据区。</strong></li>
</ul>
<p>可执行程序在运行时又多出两个区域:<code>栈区和堆区</code></p>
<ol type="1">
<li>栈区: 由编译器自动释放,存放函数的参数值、局部变量等。每当一个函数被调用时,该函数的返回类型和一些调用的信息被存放到栈中，然后这个被调用的函数再为他的自动变量和临时变量在栈上进行分配空间。每调用一个函数一个新的栈就会被使用。栈区是<code>从高地址位向低地址位增长</code>的,是一块连续的内存区域,最大容量是由系统预先定义好的,申请的栈空间超过这个界限时会提示溢出,用户能从栈中获取的空间较小。</li>
<li>堆区: 用于动态分配内存,位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是<code>从低地址位向高地址位增长</code>,采用链式存储结构。频繁的 malloc/free 造成内存空间的不连续, 产生碎片。 当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。 因此堆的效率比栈要低的多。</li>
</ol>
<h2 id="操作系统中的缺页中断">操作系统中的缺页中断?</h2>
<blockquote>
<p><code>malloc()</code>和 <code>mmap()</code>等内存分配函数,在分配时只是建立了进程虚拟地址空间,并没有分配虚拟内存对应的物理内存。 当进程访问这些没有建立映射关系的虚拟内存时, 处理器自动触发一个缺页异常。 缺页中断: 在请求分页系统中, 可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。 每当所要访问的页面不在内存是, 会产生一次缺页中断, 此时操作系统会根据页表中的外存地址在外存中找到所缺的一页,将其调入内存。</p>
<p>缺页中断是由于所要访问的页面不存在于内存时, 由硬件所产生的一种特殊的中断, 因此,与一般的中断存在区别: 缺页中断返回是,执行产生中断的一条指令,而一般的中断返回是,执行下一条指令</p>
</blockquote>
<h2 id="操作系统中的页表寻址">操作系统中的页表寻址?</h2>
<blockquote>
<p>页式内存管理, 内存分成固定长度的一个个页片。 <strong>操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构, 叫页表, 页表的内容就是该进程的虚拟地址到物理地址的一个映射。</strong> 页表中的每一项都记录了这个页的基地址。 通过页表, 由逻辑地址的高位部分先找到逻辑地址对应的页基地址, 再由页基地址偏移一定长度就得到最后的物理地址, 偏移的长度由逻辑地址的低位部分决定。一般情况下,这个过程都可以由硬件完成,所以效率还是比较高的。</p>
<p>页式内存管理的优点就是比较灵活, 内存管理以较小的页为单位, 方便内存换入换出和扩充地址空间。</p>
</blockquote>
<h2 id="并发concurrency和并行parallelism">并发(concurrency)和并行(parallelism)</h2>
<blockquote>
<ul>
<li>并发(concurrency): 指宏观上看起来两个程序在同时运行,比如说在单核 cpu 上的多任务。 但是从微观上看两个程序的指令是交织着运行的, 你的指令之间穿插着我的指令, 我的指令之间穿插着你的, 在单个周期内只运行了一个指令。 这种并发并不能提高计算机的性能, 只能提高效率。</li>
<li>并行(parallelism): 指严格物理意义上的同时运行,比如多核 cpu,两个程序分别运行在两个核上, 两者之间互不影响, 单个周期内每个程序都运行了自己的指令, 也就是运行了两条指令。这样说来并行的确提高了计算机的效率。</li>
</ul>
</blockquote>
<h2 id="各数据库的默认端口">各数据库的默认端口</h2>
<blockquote>
<p>查看端口号: 使用命令 show global variables like 'port' - mysql 的默认端口是 3306 - sqlserver 默认端口号为: 1433 - oracle 默认端口号为: 1521 - DB2 默认端口号为: 5000 - PostgreSQL 默认端口号为:5432</p>
</blockquote>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/2020/10/25/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90_1/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    第三章-(1)-惯性器件误差分析及内参标定
                
            </div>
        </a>
    
    
        <a href="/2020/10/17/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%82%B9%E4%BA%91%E5%9C%B0%E5%9B%BE%E6%9E%84%E5%BB%BA%E5%8F%8A%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%BD%8D/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">第二章_点云地图构建及基于地图的定位</div>
        </a>
    
</nav>





    
    
        <section id="comments"> 
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
    </div>
 </section>
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            EpsilonJohn &copy; 2022 
            <a rel="license noopener" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" target="_blank" rel="noopener">wikitten</a>
            
                <br>
                <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span></span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_pv"><i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span></span>
            
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_config = function () {
        
            this.page.url = 'http://yoursite.com/2020/10/20/Cplusplus%E6%95%B4%E7%90%86/';
        
        this.page.identifier = 'Cplusplus整理';
    };
    (function() { 
        var d = document, s = d.createElement('script');  
        s.src = '//' + 'EpsilonJohn' + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>



    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>