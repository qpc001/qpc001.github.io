<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EpsilonJohn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-21T07:50:30.793Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EpsilonJohn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UTC Time and GPS Time Conversion</title>
    <link href="http://yoursite.com/2021/04/21/utc%E6%97%B6%E9%97%B4%E4%B8%8Egps%E6%97%B6%E9%97%B4/"/>
    <id>http://yoursite.com/2021/04/21/utc%E6%97%B6%E9%97%B4%E4%B8%8Egps%E6%97%B6%E9%97%B4/</id>
    <published>2021-04-21T06:55:30.000Z</published>
    <updated>2021-04-21T07:50:30.793Z</updated>
    
    <content type="html"><![CDATA[<h1 id="时钟系统的前世今生">时钟系统的前世今生</h1><blockquote><p>最近在完善惯导ros驱动，发现GPGGA语句和GPFPD语句输出的时间不一致，一个是utc时间，另一个是gps时间。为了实现时钟同步，就要完成二者之间的转换。</p></blockquote><h2 id="格林威治标准时间greenwich-mean-timegmt">格林威治标准时间（Greenwich Mean Time，GMT）</h2><p><code>格林尼治平均时间（Greenwich Mean Time，GMT）</code>是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，格林尼治标准时间的正午是指当平太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治平时基于天文观测本身的缺陷，已经被原子钟报时的协调世界时（UTC）所取代。</p><blockquote><p>自1924年2月5日开始，格林尼治天文台负责每隔一小时向全世界发放调时信息。</p></blockquote><h2 id="世界时universal-time-ut">世界时（Universal Time, UT）</h2><p>后来，由于1925年以前人们在天文观测中，常常把每天的起始（0时）定为正午，而不是通常民用的午夜，给格林尼治平时的意义造成含糊，人们使用<code>世界时（Universal Time, UT）</code>一词来明确表示每天从午夜开始的格林尼治平时。</p><p>世界时是以地球自转为基准得到的时间尺度，其精度受到地球自转不均匀变化和极移的影响，为了解决这种影响，1955年国际天文联合会定义了UT0、UT1和UT2三个系统：</p><ul><li>UT0系统是由一个天文台的天文观测直接测定的世界时，没有考虑极移造成的天文台地理坐标变化。</li><li>UT1系统是在UT0的基础上加入了极移改正 Δλ，修正地轴摆动的影响。UT1是目前使用的世界时标准。被作为目前世界民用时间标准UTC在增减闰秒时的参照标准。</li><li>UT2系统是UT1的平滑处理版本，在UT1基础上加入了地球自转速率的季节性改正 ΔT。</li></ul><p>目前使用的世界时测算标准又称UT1。在UT1之前人们曾使用过UT0，但由于UT0没有考虑极移导致的天文台地理坐标变动的问题，因此测出的世界时不准确，现在已经不再被使用。</p><p>在UT1之后，由于人们发现，因为<strong>地球自转本身不均匀的问题</strong>，UT1定义的时间的流逝仍然不均匀，于是人们又发展了一些对UT1进行平滑处理后的时间标准，包括UT1R和UT2，但它们都未能彻底解决定义的时间的流逝不均匀的问题，这些<strong>时间标准现在都不再被使用</strong>。</p><h2 id="原子时international-atomic-time-tai">原子时（International Atomic Time, TAI）</h2><p>为了彻底解决定义的时间的流逝不均匀的问题，开始使用原子钟定义时间。人们首先用全世界的原子钟共同为地球确立了一个均匀流动的时间，称为<code>国际原子时（International Atomic Time, TAI）</code>。</p><blockquote><p>1967年第13届国际计量大会上通过一项决议，定义一秒为铯-133原子基态两个超精细能级间跃迁辐射振荡9,192,631,770周所持续的时间。[2][3]其起点为世界时1958年的开始。</p></blockquote><p>原子时起点定在1958年1月1日0时0分0秒（UT），即规定在这一瞬间原子时时刻与世界时刻重合。但事后发现，在该瞬间原子时与世界时的时刻之差为0.0039秒。这一差值就作为历史事实而保留下来。在确定原子时起点之后，由于<code>地球自转速度</code>的问题，使得原子时钟不能与世界时间保持协调。</p><h2 id="协调世界时coordinated-universal-time-utc">协调世界时（Coordinated Universal Time, UTC）</h2><p>为了使定义的时间与地球自转相配合，人们通过在TAI的基础上不定期<code>增减闰秒</code>的方式，使定义的时间与世界时（UT1）保持差异在0.9秒以内，这样定义的时间就是<code>协调世界时（Coordinated Universal Time, UTC）</code>。</p><blockquote><p>协调世界时是最接近格林威治标准时间（GMT）的几个替代时间系统之一。对于大多数用途来说，UTC时间被认为能与GMT时间互换，但<strong>GMT时间已不再被科学界所确定</strong>。</p></blockquote><p>UTC基于国际原子时，并通过不规则的加入闰秒来抵消地球自转变慢的影响。闰秒在必要的时候会被插入到UTC中，以保证协调世界时（UTC）与世界时（UT1）相差不超过0.9秒。</p><blockquote><p>这就是所谓的跳秒，由于需要适应地球自转变化，需要在不定时进行跳秒，截止2019年2月，已经18次跳秒。正因为跳秒的存在，才会导致后面介绍的GPS时与UTC时不一致。</p></blockquote><h2 id="gps时">GPS时</h2><p>GPS时是用于卫星定位系统时间，由于卫星系统是连续运行的，其要求时间系统也是连续的，因此采用原子钟的方法。GPS时间系统就是采用基于美国海军观测实验室维持的原子时。</p><p>GPS时在1980年1月6日0点0分与世界协调时(UTC)一致，此后就只按原子时来累计，不受外界影响，也不会产生跳秒。因此与UTC时间的差为秒的整数倍，即:</p><p><span class="math display">\[    Time_{GPS} = Time_{UTC}+n\]</span></p><p>特别的，GPS时间的计时方法采用星期数和秒周数来表示，其中周数作为C/A和P码中的十位字段发送，所以<span class="math inline">\(2^{10}=1024\)</span>周(19.6年)后会再次归零。</p><p>为了解决这个问题，现代化的GPS导航消息采用了13位的字段，每隔8192周(157年)才归零。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;时钟系统的前世今生&quot;&gt;时钟系统的前世今生&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在完善惯导ros驱动，发现GPGGA语句和GPFPD语句输出的时间不一致，一个是utc时间，另一个是gps时间。为了实现时钟同步，就要完成二者之间的转换。&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Spatiotemporal Calibration of Camera and 3D Laser Scanner</title>
    <link href="http://yoursite.com/2021/04/14/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_4/"/>
    <id>http://yoursite.com/2021/04/14/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_4/</id>
    <published>2021-04-13T20:55:30.000Z</published>
    <updated>2021-04-26T12:42:35.647Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spatiotemporal-calibration-of-camera-and-3d-laser-scanner">Spatiotemporal Calibration of Camera and 3D Laser Scanner</h1><p><img src="http://s1.nsloop.com:59080/images/2021/04/14/20210414165501.png"></p><h1 id="摘要">摘要</h1><p>我们提出了一种用于相机和3D激光扫描仪的开源时空校准框架。我们的解决方案基于常用的棋盘标记，需要在操作前进行一分钟校准，以提供准确和可重复的结果。该框架基于点对平面约束的批量优化，并且可以通过新颖的最小化来实现时间偏移校准，李代数中平面方程的连续表示以及B样条的使用。在仿真中评估了框架的属性，同时使用Velodyne VLP-16和SICK MRS6124 3D激光扫描仪通过两种不同的感官设置验证了性能。</p><h1 id="介绍">介绍</h1><p>提出的标定方法基于棋盘格的运动，以及一系列的来自相机和激光雷达的观测。然后执行批量优化来估计6dof刚体变换矩阵以及时间偏差。</p><p>该优化基于独立的激光雷达指向相机的平面约束，该平面约束由连续时间平面表示扩展，使得时间偏差可以得到优化。本文贡献在：</p><ul><li>使用通用的棋盘格标记来估计lidar、camera的外参和时间偏移</li><li>新颖的李代数形式的连续时间最小化平面表示，使用B样条</li><li>对初值不敏感，可以收敛到预期结果</li></ul><h1 id="方法">方法</h1><p>提出的框架专用于刚体连接的具有全局快门相机和3D Lidar，并且假设相机内参已知且已经校正了。此外，假设传感器之间的时间偏移未知，且较小近似于常值。</p><p>标定过程需要包含标定板与传感器之间的相对运动，因此应该被激光雷达和相机连续观测得到。录制数据之后，按照下图的过程进行处理：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/14/20210414171512.png"></p><p>其中，对于相机，则使用opencv传统检测算法进行检测；对于激光雷达，首先将点投影成range-image，然后通过手动标记或半自动跟踪的方法来提取标定板对应的平面点。</p><p>如果不考虑时间偏移，标定可以描述为基于待求解位姿的点-面优化问题：</p><p><span class="math display">\[T^{*} = \arg \min \sum_{i} \sum_{j} \pi(t_i)^{T}Tp_{i}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(T^{*}\)</span>是期望得到的从激光雷达坐标系到相机坐标系的变换矩阵</li><li><span class="math inline">\(p_i\)</span>表示标定板上第i个3D点的齐次坐标表示</li><li><span class="math inline">\(\pi(t_i)\)</span>表示由相机在<span class="math inline">\((t_i+\Delta t)\)</span>时刻估计得到的标定板平面等式。</li></ul><p>提出的方法还注意到时间的校准，即考虑到点云中的每个点都对应一个时间戳，则目标函数变为：</p><p><span class="math display">\[T^{*},\Delta t^{*} = \arg \min \sum_{i} \sum_{j} \pi(t_i+\Delta t)^{T}Tp_{i}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\Delta t^{*}\)</span>是待估计的时间差</li><li>要形成上式，需要知道每个3d激光点对应的时间戳以及对应任意时间的平面表示</li><li>本文使用LM以及g2o来求解</li></ul><h2 id="d激光雷达时间偏移">3D激光雷达时间偏移</h2><p>对于机械旋转式激光雷达，都有一定的扫描周期，根据扫描起始和扫描结束，可以推断出对应点的时间：</p><h3 id="vlp16">vlp16</h3><p><span class="math display">\[t_{i}=t_{\text {cloud }}+\frac{\phi_{i}-\phi_{s}}{f\left(\phi_{e}-\phi_{s}\right)}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(t_{cloud}\)</span>表示扫描起始时间</li></ul><h3 id="sick-mrs6124">sick-mrs6124</h3><p><img src="http://s1.nsloop.com:59080/images/2021/04/15/20210415101745.png"></p><h2 id="连续时间平面表示">连续时间平面表示</h2><p>标定板在每一帧图像中都能检测到，由于相机内参、以及标定板物理参数已知，所以可以确定标定板坐标系到相机坐标系的变换。</p><p>因此，标定板的平面可以使用4维向量<span class="math inline">\((\bm{n},d)\)</span>来表示，其中<span class="math inline">\(\bm{n}\)</span>是平面法向量，<span class="math inline">\(d\)</span>是到坐标系原点的距离。对于所有的图像，可以获取到离散时间下的一组平面方程集合。</p><p>为了确定各个时间戳的平面方程，需要对这些方程进行插值，因为4维的平面表示形式并非最小的表示方式，因此可能还需要做归一化处理。为了避免这个问题，提出一种使用类似于SO(3)以及对应的李代数so(3)的思想来表示平面法向量</p><p>该思想只需要使用两个参数就可以表示归一化法向量，因此，提出的方法几乎与[21]提出的球面插值法相同。</p><p>因此，平面的超参数化是因为法向量<span class="math inline">\(\bm{n}\)</span>，如果使用两个成分来表示，那么平面可以表示为：<span class="math inline">\((\bm{n},d) \rightarrow (\omega_x,\omega_y,d)_{3\times 1}\)</span>:</p><p><span class="math display">\[\begin{aligned}\theta = acos(\bm{n}[2]) \\\omega_{x}=-\bm{n}[1]*\frac{\theta}{\sin \theta} \\\omega_{y}=\bm{n}[0]*\frac{\theta}{\sin \theta}\end{aligned}\]</span></p><blockquote><p>这个思想来源于 [20]A. Bartoli, “On the non-linear optimization of projective motion using minimal parameters“ European Conference on Computer Vision (ECCV), Copenhagen, 2002, 340–354. <img src="http://s1.nsloop.com:59080/images/2021/04/15/20210415161745.png"></p></blockquote><p>就是说，在3维欧氏空间中，以点(0,0,1)作为原点，以平行于x轴、y轴的方向作为坐标轴，展开一个超平面，那么3维欧氏空间中的矢量可以通过对数变换投影到该超平面上的一个点。</p><p><strong>二维情况</strong></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/15/20210415163816.png"></p><p><strong>三维情况</strong></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/15/20210415204817.png"></p><p>因此，选取3维欧氏空间中的单位向量<span class="math inline">\(q=[0,0,1]^{T}\)</span>，然后根据<span class="math inline">\(\cos \theta = q^{T} n\)</span>，那么可以得到<span class="math inline">\(\theta = \arccos (q^{T}n)=\arccos(\bm{n}[2])\)</span>，表示两个向量之间的夹角，特别的又因为球面半径是单位向量，因此，<span class="math inline">\(\theta\)</span>也表示两个向量之间的球面距离。</p><p>特别的，根据下式可构成超平面上的点<span class="math inline">\(p=(\omega_x,\omega_y)\)</span>：</p><p><span class="math display">\[\begin{aligned}\theta = \arccos(\bm{n}[2]) \\\omega_{x}=-\bm{n}[1]*\frac{\theta}{\sin \theta} \\\omega_{y}=\bm{n}[0]*\frac{\theta}{\sin \theta}\end{aligned}\]</span></p><p>其中，</p><p><span class="math display">\[\begin{aligned}    \sqrt{\omega_x^2 + \omega_y^2}     &amp;=     \sqrt{        \frac{\arccos^{2} (n[2])}{\sin^{2}( \arccos(n[2])) }        (n[0]^{2}+n[1]^{2})    }    \\    &amp;=    \sqrt{        \frac{\arccos^{2} (n[2])}{1- \cos^{2}(\arccos(n[2])) }        (1-n[2]^{2})    }    \\    &amp;= \arccos (n[2]) = \theta\end{aligned}\]</span></p><p>可以发现，在超平面上，点q和点p的距离等于球面上向量q和另一个向量之间的球面距离。</p><p>因此，实现了使用两个参数来表示欧氏空间中的向量，需要注意的是，<span class="math inline">\(\theta==0\)</span>时，取<span class="math inline">\(\frac{\theta}{\sin \theta}=1\)</span>，特别的，仅适用于<span class="math inline">\(\theta &lt; \pi\)</span>的情况下。</p><h2 id="平面方程插值">平面方程插值</h2><p>使用最小化的平面表示使得可以进行插值，然后返回到所需时间戳对应的4维的平面方程表示形式。</p><p>对于此任务，我们尝试了参数的线性插值，由于缺乏连续的微分导致优化陷入局部最小值。因此，提出了使用三次样条插值，确保最小平面表示具有一阶和二阶的连续微分。如下：</p><p><span class="math display">\[\mathbf{s}(t)=\mathbf{s}_{0} B_{0}(t)+\sum_{i=1}^{n}\left(\mathbf{s}_{i}-\mathbf{s}_{i-1}\right) B_{i}(t)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(s(t)\)</span>是在时间t插值得到的结果</li><li><span class="math inline">\(s_i\)</span>是根据测量得到的第i个控制点的值</li><li><span class="math inline">\(B_i(t)\)</span>是cumulative basis function的第i个成分</li><li><span class="math inline">\(n\)</span>是B样条的阶数</li></ul><p>对于李代数，则有插值方程如下：</p><p><span class="math display">\[\mathbf{r}(t)=\log \left\{\exp \left(\mathbf{r}_{0} B_{0}(t)\right) \prod_{i=1}^{n} \exp \left(\boldsymbol{\Omega}_{i} B_{i}(t)\right)\right\}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(r(t)\)</span>表示t时刻的李代数插值结果</li><li><span class="math inline">\(r_i\)</span>表示李代数表示的第i个控制点</li><li><span class="math inline">\(\Omega_i=\log(\exp(r_{i-1})^{T}\exp(r_i))\)</span>表示两个李代数之间的差值</li></ul><blockquote><p>来源于文献[23]：A. Patron-Perez, S. Lovegrove, and G. Sibley, “A spline-based trajec- tory representation for sensor fusion and rolling shutter cameras“, in International Journal of Computer Vision, vol. 113, no. 3, 208–219, 2015.</p></blockquote><p>使用4阶B样条插值，cumulative basis function 如下：</p><p><span class="math display">\[\mathbf{B}(u)=\frac{1}{6}\left[    \begin{array}{cccc}    6 &amp; 0 &amp; 0 &amp; 0 \\     5 &amp; 3 &amp; -3 &amp; 1 \\     1 &amp; 3 &amp; 3 &amp; -2 \\     0 &amp; 0 &amp; 0 &amp; 1\end{array}    \right]    \left[\begin{array}{c}    1 \\ u \\ u^{2} \\ u^{3}    \end{array}    \right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(u\)</span>是从t2到t3之间的归一化时间(0~1)，在实践中，我们还检查了检测到的棋盘的时间戳（T1，T2，T3，T4）是否均匀地分布在时间内，如果不满足这种情况，则不会执行插值</li></ul><p>重要的是，可以使用[23]的已知方程来导出B样条曲线的jacobians，特别的，本系统使用了[24]所述的更有效的雅可比表示。</p><blockquote><p>[24]C. Sommer, V. Usenko, D. Schubert, N. Demmel, and D. Cremers, “Efficient derivative computation for cumulative B-splines on Lie groups“, arXiv preprint, 1911.08860v1, 2019.</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spatiotemporal-calibration-of-camera-and-3d-laser-scanner&quot;&gt;Spatiotemporal Calibration of Camera and 3D Laser Scanner&lt;/h1&gt;
&lt;p&gt;&lt;img sr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Calibration of RGB Camera With Velodyne LiDAR</title>
    <link href="http://yoursite.com/2021/04/12/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_2/"/>
    <id>http://yoursite.com/2021/04/12/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_2/</id>
    <published>2021-04-12T13:05:30.000Z</published>
    <updated>2021-04-26T12:41:11.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="calibration-of-rgb-camera-with-velodyne-lidar">Calibration of RGB Camera With Velodyne LiDAR</h1><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412212556.png"></p><blockquote><p>适用于32线以上</p></blockquote><h1 id="摘要">摘要</h1><p>本文提出了一种从粗到细的lidar-camera的标定方法，以前的方法用于计算校准参数的已知棋盘标记的多个视图，或者它们仅限于具有小相互位移的传感器的校准。</p><p>我们的方法提出了一种用于粗校准的新型3D标记，可以在相机图像和激光扫描中鲁棒地检测到粗略校准。只需要单帧的cam-lidar数据就可以估计比较大的平移外参，后续的refinement步骤将在标定参数子空间中寻找更准确的参数。</p><p>本文同样提出了一种基于投影误差的标定准确度度量。</p><h1 id="介绍">介绍</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;calibration-of-rgb-camera-with-velodyne-lidar&quot;&gt;Calibration of RGB Camera With Velodyne LiDAR&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com:
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Automatic Extrinsic Calibration Method for LiDAR and Camera Sensor Setups</title>
    <link href="http://yoursite.com/2021/04/12/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_3/"/>
    <id>http://yoursite.com/2021/04/12/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_3/</id>
    <published>2021-04-12T13:05:30.000Z</published>
    <updated>2021-04-26T12:41:11.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="automatic-extrinsic-calibration-method-for-lidar-and-camera-sensor-setups">Automatic Extrinsic Calibration Method for LiDAR and Camera Sensor Setups</h1><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413113205.png"></p><h1 id="摘要">摘要</h1><p>本文提出了一种无需用户干预即可进行激光雷达-立体相机对的外在校准的方法。我们的校准方法旨在解决汽车设置中常见的限制，例如低分辨率和特定的传感器姿态。</p><h1 id="介绍">介绍</h1><p>现有的校准方法要么需要复杂的设置，要么缺乏通用性，因此结果的准确性在很大程度上取决于传感器的参数或环境的结构性。</p><p>与现有方法不同，没有进行严格的假设，因此允许中等分辨率如16线lidar，以及适用于传感器之间的相对姿势较大的情况。</p><p>我们的方法可以使用简单的设置在合理的时间内执行，该设置旨在利用来自两个设备的数据中的对应关系。</p><h1 id="标定">标定</h1><p>一个定制的平面target用于提供两个传感器之间的特征配对关系，如图2所示</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413141802.png"></p><p>图2所示的模式具有几何和视觉特性，可以估计lidar、双目、单目的关键点。一方面，4个圆孔可以利用激光、双目点云的不连续性获取，另一方面，4个ArUco标记放置于4个角点附近，可以使用单目摄像头获取。</p><p>这种方法不会对传感器之间的相对姿态有较强的限制，因此适用于平移和旋转较大的情况。实际上，只需要满足两个约束即可：</p><ul><li>传感器之间必须有包含校准目标的共视区域</li><li>传感器可以良好的观察到校准目标（如圆孔），特别的，当校准中包含距离数据时，每一个圆至少需要3个点来表示。对于多线激光雷达而言，必须要有两根线达到同一个圆上</li><li>特别的，对于视觉传感器而言，需要提前知道设备内参</li></ul><p>提出的方法如图3所示，分为两个阶段：</p><ol type="1"><li>第一阶段包括校准目标的分割和每个传感器的参考点定位</li><li>第二阶段是求解参考点的转换</li></ol><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413142957.png"></p><h2 id="目标分割">目标分割</h2><p>这第一阶段旨在在每个传感器的数据中对校准目标进行定位，在此阶段中的信息是相对于该传感器坐标系而言的。最终输出一组包含4个3D点数据，</p><h3 id="激光雷达数据">激光雷达数据</h3><p>在将数据馈送到分割处理之前，通过了三个笛卡尔坐标的pass-through滤波器来提出无关数据的影响，因此必须根据传感器重叠区域的位置和大小来设置pass-through滤波器的限制。</p><p>预处理后的点云<span class="math inline">\(\mathcal{P}_{1}^{L}\)</span>包含校准目标和激通过孔中可见的点。对于<span class="math inline">\(\mathcal{P}_{1}^{L}\)</span>中的每一个点，按下式计算其深度梯度幅值：</p><p><span class="math display">\[p_{i, \Delta}=\max \left(p_{i-1, r}-p_{i, r}, p_{i+1, r}-p_{i, r}, 0\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(p_{i,r}\)</span>表示关于点<span class="math inline">\(p_i\)</span>的测量</li><li><span class="math inline">\(p_{i-1},p_{i+1}\)</span>是点<span class="math inline">\(p_i\)</span>的同一线束扫描的邻近点</li></ul><p>然后，利用一个阈值对所有不连续性较高的点进行提取，得到点云<span class="math inline">\(\mathcal{P}_{2}^{L}\)</span></p><h3 id="双目立体摄像头数据">双目/立体摄像头数据</h3><p>当要校准的传感器之一是立体视觉系统时，首先通过立体声匹配过程将原始图像对转换为3D点云。</p><blockquote><p>在我们的实验中，我们使用OpenCV实现的[28]的半全局块匹配（SGBM）变体，我们发现我们发现合理准确地进行深度估计。注意，当涉及这种模态时，预计校准目标将具有一些纹理（例如，木纹），以便可以成功解决立体声对应问题。但是，在我们的实验中，我们发现由模式边界引起的强度差异通常是足够的，。</p></blockquote><p>与激光雷达数据处理类似，首先通过pass-through滤波器进行过滤。不同的是，对于立体视觉，通过提取点云目标的边缘，具体地，使用sobel算子来对图像提取边缘，然后根据边缘强度对点云进行滤除，得到点云<span class="math inline">\(\mathcal{P}_{2}^{S}\)</span></p><h3 id="对深度数据提取目标点">对深度数据提取目标点</h3><p>这一步主要是对激光雷达/立体视觉预处理后的数据进行下一步处理：</p><p>（1）平面分割：</p><p>首先，使用RANSAC算法对点云<span class="math inline">\(\mathcal{P}_{1}\)</span>(包括激光雷达/立体视觉)进行平面拟合得到模型<span class="math inline">\(\pi\)</span>，为了确保模型的准确，使用了较为严格的RANSAC阈值，并且提取的平面必须大概与传感器坐标系成垂直关系，使用一个容限<span class="math inline">\(\alpha_{plane}\)</span>.</p><p>然后，根据得到的平面模型<span class="math inline">\(\pi\)</span>，对点云<span class="math inline">\(\mathcal{P}_{2}\)</span>中的点进行剔除，然后得到点云<span class="math inline">\(\mathcal{P}_{3}\)</span></p><p>（2）转换到2d空间：</p><p>由于所有其余点都属于同一平面，因此在该点执行降维：通过转换x-y平面与模型<span class="math inline">\(\pi\)</span>重合，可以将点云<span class="math inline">\(\mathcal{P}_{3}\)</span>转换到平面点<span class="math inline">\(\mathcal{P}_{4}\)</span></p><p>（3）圆形提取</p><p>接下来，使用2D圆分割来提取<span class="math inline">\(\mathcal{P}_{4}\)</span>中存在的图案孔的模型，此步骤是迭代地执行的过程中，在寻找最可能的圆圈，并且在寻找下一个圆之前，剔除掉已经找到的圆。如果找到4个圆，才进入下一步。</p><p>为此，将中心分成四个一组，并将它们形成的矩形的尺寸（对角线，高度，宽度和周长）与理论值进行比较，公差δ一致性表示为与中心线的偏差百分比。 期望值。 大概只有一组中心可以满足这些限制，</p><p>一旦识别到圆，就可以将其圆心反投影回3d空间，形成点云<span class="math inline">\(\mathcal{P}_{p}\)</span>，<span class="math inline">\(\mathcal{P}_{p}\)</span>必须正好是4个中心点。</p><h3 id="单目摄像头数据">单目摄像头数据</h3><p>如果要校准的传感器是单眼相机，则参考点的提取需要检测ARUCO标记，其提供所需的提示来检索目标的几何形状。Aruco标记是由黑色边界和内部二进制矩阵制成的合成方标记，旨在允许其明确识别[27]。 在我们的校准目标中，使用四个ARUCO标记，每个角落都是一个; 由于此位置，它们不会影响其他方式的目标或孔检测。</p><p>如果相机内参以及标记的尺寸已知，就可以通过Pnp恢复每个标记相对于相机坐标系的位姿，在我们的实施中，我们将四个标记设置为一个ARUCO板，这个板允许利用4个标记来共同估计校准目标的位姿。</p><p>然后通过LM优化来最小化重投影误差来求解ARUCO板的位姿，使用4个标记的位姿均值作为初始值，最后得到了ARUCO板中心的3d位姿。</p><p>为了生成与点云<span class="math inline">\(\mathcal{P}_{p}\)</span>同等的4个点，利用已知的相对位置关系来分别提取4个圆孔中心的3D点，得到点云<span class="math inline">\(\mathcal{P}_{M}\)</span></p><h3 id="点云聚类">点云聚类</h3><p>在分割阶段的最后，已经得到了两组点云<span class="math inline">\(\mathcal{P}_{p}\)</span>，每一组点云都是相对于传感器坐标系的。</p><p>这些数据足以找到转换传感器的相对姿势的转换，然而，方法固有的不同噪声源（例如，传感器噪声和诸如Ransac等非确定性程序）可能会影响结果的准确性。为了提高算法的稳健性，我们通过反复应用分割步骤并以两种不同的方式累积结果来增加可用的信息</p><p>（1）数据帧累积</p><p>由于场景可以是静止的，因此可以通过累积N帧的点云<span class="math inline">\(\mathcal{P}_{p}\)</span>来得到<span class="math inline">\(\mathcal{P}_{p}^{&#39;}\)</span>，如果找到的超过4个圆，则不可用</p><p>（2）目标板不同位姿的数据累积</p><p>本方法可以通过单个目标板的位姿来求解，然而，通过考虑超过四个参考点，可以提高估计的准确性。另一方面，单帧提取得到的4个点有可能不共面，通过多帧可以提高标定效果。</p><h2 id="配准">配准</h2><p>在分割阶段结束后，一共获取到两组<span class="math inline">\(\mathcal{P}_{p}^{&#39;}\)</span>点云，每组分别对应一个传感器，主要包含每个圆圈中心相对于该传感器坐标系的点。并且，两组点云的点对关系是已知的。</p><h3 id="点关联">点关联</h3><p>提出了一种策略，来避免设置两组<span class="math inline">\(\mathcal{P}_{p}^{&#39;}\)</span>点云的点具有相同的顺序关系。</p><p>首先将<span class="math inline">\(\mathcal{P}_{p}^{&#39;}\)</span>点云中的4个点投影到球面坐标系，然后（only assume that the point that appears highest in the cloud, that is, the one with the lowest inclination angle, belongs to the upper row of the calibration target (i.e., either the top-left or the top-right circle).）</p><p>上面步骤首先确定了一个上方的点，然后根据这一点到另外三个的距离确定了正确的排序。因此，可以建立起关联：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413220250.png"></p><h3 id="求解">求解</h3><p>排序好的两组点云，记为<span class="math inline">\(\mathcal{P}_{c}^{&#39;X},\mathcal{P}_{c}^{&#39;Y}\)</span>，通过使用<code>Umeyama</code>配准[30]，可以寻找两组点云的刚体变换，其中，两组点云中的点具有匹配关系如下：</p><p><span class="math display">\[p_{i, a}^{X}=p_{i, a}^{Y} \wedge p_{i, m}^{X}=p_{i, m}^{Y}\]</span></p><p>即目标函数为两组点云之间的距离：</p><p><span class="math display">\[\frac{1}{4 \cdot M} \sum_{i=0}^{4 \cdot M}\left\|\mathbf{p}_{i}^{X}-\mathbf{T}_{X Y} \mathbf{p}_{i}^{Y}\right\|^{2}\]</span></p><p>由于点云配对关系已知，所以使用svd即可求得闭式解。方便的是，<code>Umeyama</code>方法可以处理所有点都在同一平面上的情况，例如使用单个图案位置（M = 1）时，这样可以避免将它们误认为是反射。</p><h1 id="实验">实验</h1><p>除了需要人工放置标记板之外，其他参数使用固定值如下表：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413221315.png"></p><p>其中，除非另有说明，否则参考点累积超过30帧（n = 30）</p><h2 id="gazebo仿真">gazebo仿真</h2><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413222309.png"></p><p>在实验中，将目标放置在后面的墙壁，使得穿过圆孔的LIDAR梁到达表面，在前景和背景点之间产生必要的梯度。</p><p>高斯噪声<span class="math inline">\(\epsilon \sim \mathcal{N}(0,(K\sigma_{0})^{2})\)</span>被施加到传感器的捕获数据，对于像素强度和激光距离，<span class="math inline">\(\sigma_{0}= 0.007\)</span> m和<span class="math inline">\(\sigma_{0}= 0.008\)</span>米，其中：</p><ul><li>K=0表示理想环境</li><li>K=1表示真实环境</li><li>K=2表示噪声环境</li></ul><h3 id="特征提取实验">特征提取实验</h3><p>实际上，该方法无法在一些极端配置中提供结果; 具体为在LIDAR扫描仪的情况下，它们有限的分辨率使得不可能在远距离找到圆圈，而立体声受到深度估计的实质性降级的影响，即这种模块遭受的距离增加。</p><p>因此，在典型用例中，应该通过将图案位置限制为相对于传感器的合理距离范围来避免这些情况</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413225825.png"></p><h3 id="求解结果">求解结果</h3><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413230741.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413230807.png"></p><h2 id="真实环境实验">真实环境实验</h2><p><img src="http://s1.nsloop.com:59080/images/2021/04/13/20210413230839.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;automatic-extrinsic-calibration-method-for-lidar-and-camera-sensor-setups&quot;&gt;Automatic Extrinsic Calibration Method for LiDAR and Came
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LiDAR-Camera Calibration using 3D-3D Point correspondences</title>
    <link href="http://yoursite.com/2021/04/12/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_1/"/>
    <id>http://yoursite.com/2021/04/12/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_1/</id>
    <published>2021-04-12T01:05:30.000Z</published>
    <updated>2021-04-26T12:41:11.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lidar-camera-calibration-using-3d-3d-point-correspondences">LiDAR-Camera Calibration using 3D-3D Point correspondences</h1><p><img src="https://chevereto.epsilonjohn.club/images/2021/04/12/20210412091225.png"></p><h1 id="摘要">摘要</h1><p>采用多个传感器来提供冗余信息，该信息可以减少具有错误测量的可能性。 在上述情况下，必须相对于单个参考帧从各种传感器获得数据，以便可以融合数据，并且可以利用冗余。</p><p>基于标记的[2]以及LIDAR和摄像机的自动校准已经提出，但在这些使用的方法和实验中讨论了高密度，更昂贵的激光雷达，并且当较低密度的LIDAR时，不太适用，例如 使用VLP-16。 我们提出了一种非常准确和可重复的方法来估计相机和激光器之间的6度自由度的外部校准参数</p><h1 id="传感器及参数准备">传感器及参数准备</h1><p>我们提出的方法利用LIDAR和相机的传感器数据。 在启动激光雷达相机校准过程之前应该知道相机的内在参数.</p><p>每次收集数据，LIDAR和相机都在3D空间中的任意距离保持,它们之间的转换是手动测量的。虽然，使用卷尺测量是粗糙的，但它用作使用各种算法获得的值的进行检查，测量平移量比旋转量容易的多，在其他情况下，当旋转极小时，我们假定它们为零。如果存在较大的角度，只能用三角板估计一下 。</p><h1 id="d-3d关联">2D-3D关联</h1><p>在使用3D-3D点对应关系的方法之前，我们尝试了涉及2D-3D对应关系的方法。我们设计了自己的实验设置，以帮助校准激光器和相机。</p><h2 id="实验设置">实验设置</h2><p><strong>需要设置的标记</strong>：中空矩形纸板。</p><p>即使是普通纸板也可以很好地工作，因为我们将在即将到来的讨论中看到，提供更少的对应关系，而不是挖空的矩形纸板</p><p><img src="https://chevereto.epsilonjohn.club/images/2021/04/12/20210412093538.png"></p><h2 id="数据提取">数据提取</h2><p>首先使用2D-3D方法：这种方法涉及通过匹配2D-3D点对应的方式在相机和激光器之间找到6-DOF变换，可以通过手动在图像中标记<strong>具有3-4像素的精度</strong>的图像中的特征点来容易地获得2D对应关系。</p><p>直接获取对应3d点的方法并不直接，这是因为lidar点云稀疏</p><p>平面纸板可以提供4个角点，在3D中，这些点可以通过直线拟合交点得到，在2D中，可以直接从marker的像素坐标获得。</p><p>如果空心纸板的外边框也使用，那么就可以提供8个3D-2D点关联，这样的设置允许有足够的数据来运行PNP算法的Ransac版本，并且还将有助于减少嘈杂的数据。</p><p>如果纸板的一侧与地面平行，由于激光水平扫描，那么可能只能获取到纸板的竖直边缘，而不能获取到水平边缘。为了克服这一点，我们将板倾斜以在一个边缘和地面平面之间制作大约45度来获取所有四个边缘获得点。 Ransac用于拟合LIDAR的点的直线。</p><p>这个节点允许手动绘制多边形，然后自动提取内部直线：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412100207.png"></p><p>纸板上最突出的特征是角点，它可以在图像上相对容易地标记，并且由于我们对四个边缘具有相当准确的线条方程，因此它们的交叉点在3D中计算，这些空间中的直线实际上可能无法相交，但是非常接近。 我们将角点近似于两行之间最短线段的中点。</p><p>实验发现：两个线段之间的距离是<span class="math inline">\(10^{-4}\)</span>米的距离，边缘长度之间的误差平均约为1厘米.</p><p>本实验获取到了20个角点：2个空心矩阵（2*8）+ 1个实心纸板（4）</p><h2 id="问题求解">问题求解</h2><p>Perspective n-Point (PnP)方法用于寻找2D-3D匹配点对之间的刚体变换，其中式（1）展示了3D点投影方程：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412101804.png"></p><p>式（2）展示了使用的通用cost-function：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412101850.png"></p><p>首先，使用了PNP和EPNP方法来最小化上述cost-func，然后通过手动剔除外点，进一步降低重投影误差到1.88个像素，但是，并没有求解出接近手动测量值的<span class="math inline">\(\{R,t\}\)</span></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412103120.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412104259.png"></p><p>在上述实验中，由于激光雷达和相机比较接近，仅相差12厘米，且实验中仅使用了12个点进行EPNP，并没有达到预期效果。在随后的实验中，相机和lidar距离更远，减轻了误差的影响。</p><p>在检查数据时，我们发现了一些噪声点，这些噪声点造成了较大的重投影误差，我们运行了一个自定义的EPNP和RanSac算法，理论上可以确保滤除噪声点的影响。</p><p>通过实验发现，重投影误差小于1个像素，但是得到的<span class="math inline">\(\{R,t\}\)</span>与期望值相差更大，这可能意味着最小化重投影误差可能不是一种整体最优的方法，因此必须使用其他更好的度量。</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412104559.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412104615.png"></p><h1 id="d-3d关联-1">3D-3D关联</h1><p>2D-3D对应方法在我们的实验设置中结果似乎不太理想，这可能是由于2D标记点的不准确或者使用含有噪声点进行PnP。尽管重投影误差似乎已经最小化，但是求出来的结果与测量值相差较大。</p><p>因此，这部分涉及使用增强 - 现实（AR）标签和LIDAR点云来找到外部校准参数，开源社区[7] [5]已释放多个版本的AR标签。 这里提出的方法使用ARUCO标签[5]。</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412105046.png"></p><p>为了找到相机与Velodyne之间的转换，我们需要两组3D点：一个在相机坐标系中，另一组在Velodyne坐标系中。 一旦发现这些点对应，就可以求解了。</p><h2 id="实验设置-1">实验设置</h2><p>矩形纸板可以是任何任意尺寸。 我们执行的实验使用了一个Velodyne VLP-16 [3]，其在单次扫描中仅具有16个环，与较高密度的LIDAR相比（每次扫描的32和64环）相比。 对于低密度的LIDAR，如果板的尺寸很小，并且LIDAR保持比特定距离更远，则击中板的环数变为低（2至3个环，导致边缘仅2至3点） ，使其非常困难地适应边缘（使用Ransac）</p><p>实验中使用的纸板的长度/宽度在45.0-55.0厘米之间，保持距离激光雷达2米左右距离，就可以有足够的点来拟合直线和计算交点。</p><h3 id="相机坐标系中的3d点">相机坐标系中的3D点</h3><p>ARUCO标记是特殊编码的模式，其促进标记本身的检测和纠错。 有关如何在这里找到工作的更多详细信息[5]</p><p>ArcoTag贴在纸板上，如果已知<strong>纸板的尺寸</strong>和<strong>ARUCO标记的位置</strong>，则可以容易地计算角落的位置（来自aruco标记的中心）。</p><p>ArcoTag提供相机坐标系和标记中心的<span class="math inline">\(\{R,t\}\)</span>变换，这个变换可以用来将角点从标记所在的坐标系转换到相机坐标系。</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412154023.png"></p><h3 id="激光雷达坐标系中的3d点">激光雷达坐标系中的3D点</h3><p>通过检测纸板的边缘可以找到激光雷达中的点，这又可以以类似的方式为拐角又可以解决第3节中描述的类似方式。</p><p>使用ArcoTag获取到的转换矩阵（特别是平移量）非常准确，一旦获取到两组3D点集合，就可以使用ICP算法进行求解了。</p><h2 id="求解">求解</h2><p>ICP算法最小化式（3）表示的cost-func：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412154220.png"></p><p>一般ICP算法认为点云中的最近点作为对应关系（有其他选择最接近点的其他变体,找到正确的对应关系可能是棘手的，可能导致不期望的解决方案.</p><p>由于在本方法中，点与点之间的对应关系是已知的，因此icp算法存在闭式解（Kabsch算法[9] [10]找到两点云之间的旋转，并且坐标系对齐后就可以找到平移）：</p><p>下面的推导使用与[10]中的相同的参数。</p><p>首先，我们假设旋转是已知的，所以先求解平移量：</p><p>已知目标函数：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412154803.png"></p><p>对平移量t求导并等于0：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412154827.png"></p><p>进一步有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412155111.png"></p><p>即：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412155139.png"></p><p>使用求出来的平移量替换式（4）中的部分，有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412155524.png"></p><p>令：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412155545.png"></p><p>目标函数变成：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412155655.png"></p><hr><p>解释如下： 令<span class="math inline">\(X_{i}^{&#39;}-Y_{i}=[x_i,y_i,z_i]^{T}\)</span></p><p>对不同的点得到的[x_i,y_i,z_i]进行堆叠，则有：</p><p><span class="math display">\[\begin{aligned}    (X&#39;-Y)^{T}(X&#39;-Y)&amp;=    \begin{bmatrix}        x_1 &amp; y_1 &amp; z_1 \\        x_2 &amp; y_2 &amp; z_2    \end{bmatrix}    \begin{bmatrix}        x_1 &amp; x_2 \\        y_1 &amp; y_2 \\        z_1 &amp; z_2 \\    \end{bmatrix}    \\    &amp;=    \begin{bmatrix}        x_1^{2}+y_1^{2}+z_1^{2} &amp; m \\        n &amp; x_2^{2}+y_2^{2}+z_2^{2}    \end{bmatrix}\end{aligned}\]</span></p><p>实际上，我们的目标函数就是对角线元素之和。</p><hr><p>进一步的，利用矩阵的迹的性质，可以进一步简化：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412161346.png"></p><p>又因为旋转矩阵<span class="math inline">\(R\)</span>是正交矩阵，因此有<span class="math inline">\(|X_i^{&#39;}|^{2}=|X_i|^{2}\)</span>，进一步有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412161850.png"></p><p>观察可知，前半部分是固定的，只有后半部分与旋转<span class="math inline">\(R\)</span>有关，而且我们的目标是最小化，因此，即最大化后面的部分：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412162006.png"></p><p>使用旋转<span class="math inline">\(R\)</span>替换回<span class="math inline">\(X^{&#39;}\)</span>，有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412162046.png"></p><p>问题转化为，求<span class="math inline">\(R\)</span>使得<span class="math inline">\(Tr(XY^{T}R)\)</span>最大</p><p>进一步的，根据定理：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412170421.png"></p><p>因此，对<span class="math inline">\(XY^{T}\)</span>进行SVD分解，得到<span class="math inline">\(XY^{T}=UDV^{T}\)</span>，</p><p>令<span class="math inline">\(R=VU^T\)</span>，则</p><p><span class="math display">\[Tr(XY^{T}R)=Tr(UDV^{T}VU^{T})=Tr((UD^{\frac{1}{2}})(UD^{\frac{1}{2}})^{T})\]</span></p><p>因此，旋转<span class="math inline">\(R=VU^T\)</span></p><h2 id="多帧求解">多帧求解</h2><p>在初步实验中，观察到尽管在封闭空间中，激光雷达点云并非静止，为了减少噪声，采用多次扫描的方法。多帧数据中，保持激光雷达与相机空间关系不变：</p><p>对于每一帧数据估计出来的平移量，求均值有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412171816.png"></p><p>对于旋转量，先转换到四元数，然后求平均：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412171922.png"></p><p>然后，还要进行归一化：</p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412172144.png"></p><h2 id="结果">结果</h2><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412173750.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412173818.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/04/12/20210412173831.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lidar-camera-calibration-using-3d-3d-point-correspondences&quot;&gt;LiDAR-Camera Calibration using 3D-3D Point correspondences&lt;/h1&gt;
&lt;p&gt;&lt;img 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>WGS-84转局部ENU坐标</title>
    <link href="http://yoursite.com/2021/03/01/%E7%BB%8F%E7%BA%AC%E5%BA%A6%E8%BD%AC%E5%B1%80%E9%83%A8ENU/"/>
    <id>http://yoursite.com/2021/03/01/%E7%BB%8F%E7%BA%AC%E5%BA%A6%E8%BD%AC%E5%B1%80%E9%83%A8ENU/</id>
    <published>2021-03-01T09:05:33.000Z</published>
    <updated>2021-03-03T07:12:00.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wgs-84转ecef">WGS-84转ECEF</h1><p><span class="math display">\[\mathbf{R}_0=\begin{bmatrix}    -\sin(\lambda_0) &amp; \cos(\lambda_0) &amp; 0 \\    -\cos(\lambda_0)\sin(\phi_0) &amp; -\sin(\lambda_0) \sin(\phi_0) &amp; \cos(\phi_0) \\    \cos(\lambda_0)\cos(\phi_0) &amp; \sin(\lambda_0)\cos(\phi_0) &amp; \sin(\phi_0)\end{bmatrix} \]</span></p><p><span class="math display">\[\begin{bmatrix}    e_i \\ n_i \\ u_i\end{bmatrix}=\mathbf{R}_0 \begin{bmatrix}    x_i-x_0 \\ y_i-y_0 \\ z_i-z_0\end{bmatrix}\]</span></p><p><span class="math display">\[s_f=\frac{t_{1}^{gnss-deq}-t_{i}^{lidar}}{t_{1}^{gnss-deq}-t_{0}^{gnss-deq}}\]</span></p><p><span class="math display">\[    bel(\boldsymbol{P}_{i})=    \begin{cases}    \exp \left( \frac{ - \| \tilde{\boldsymbol{P}}_{i}-\boldsymbol{P}_{i} \|}{\|(\Delta \boldsymbol{T}_{i,i-1})_{\left [ x,y,z \right]} \|} \right ) &amp;     \| \tilde{\boldsymbol{P}}_{i}-\boldsymbol{P}_{i} \|    \leq     \|(\Delta \boldsymbol{T}_{i,i-1})_{\left [ x,y,z \right]} \|    \\     0 &amp;     \| \tilde{\boldsymbol{P}}_{i}-\boldsymbol{P}_{i} \|    &gt;    \|(\Delta \boldsymbol{T}_{i,i-1})_{\left [ x,y,z \right]} \|     \end{cases}\]</span></p><p><span class="math display">\[E_i^{gnss} = k_p^{i} \|  (\boldsymbol{T}_{i})_{\left [ x,y,z \right]} - \boldsymbol{P}_{i} \|_{2}^{2}\]</span></p><p><span class="math display">\[[I_{k-n}^{imu-deq},I_{k-n+1}^{imu-deq},\cdots,I_k^{imu-deq},\cdots,I_{k+n-1}^{imu-deq},I_{k+n}^{imu-deq}]\]</span></p><p><span class="math display">\[    F_{G}^{i}=    \begin{cases}    1 &amp;     \| \| (I_{i}^{&#39;})_{\left [ acc \right]}\|-\mathbf{G}_{0} \|_2    \leq 0.3    \\     0 &amp;     \| \| (I_{i}^{&#39;})_{\left [ acc \right]}\|-\mathbf{G}_{0} \|    &gt; 0.3    \end{cases}\]</span></p><p><span class="math display">\[E_{i}^{atti}=F_{G}^{i}k_{G}^{i} \left \| H((\boldsymbol{T}_i)_{\left[r,p\right]},(\mathbf{I}_{i})_{\left[acc \right]})-\frac{\mathbf{G}_0}{\|\mathbf{G}_0\|} \right \|\]</span></p><p><span class="math display">\[E_i^{loop}=k_{L}^{i} \| L(\Delta \boldsymbol{T}_{ji}^{-1} \boldsymbol{T}_{i}^{-1} \boldsymbol{T}_{i}) \|_{2}^{2}\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wgs-84转ecef&quot;&gt;WGS-84转ECEF&lt;/h1&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[
\mathbf{R}_0=
\begin{bmatrix}
    -\sin(\lambda_0) &amp;amp; \cos(\lambda
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IMU预积分模型</title>
    <link href="http://yoursite.com/2021/02/19/IMU%E9%A2%84%E7%A7%AF%E5%88%86%E6%A8%A1%E5%9E%8B%E6%8E%A8%E5%AF%BC/"/>
    <id>http://yoursite.com/2021/02/19/IMU%E9%A2%84%E7%A7%AF%E5%88%86%E6%A8%A1%E5%9E%8B%E6%8E%A8%E5%AF%BC/</id>
    <published>2021-02-19T07:05:33.000Z</published>
    <updated>2021-02-26T09:56:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是预积分">什么是预积分</h1><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/19/20210219155712.png"></p><blockquote><p>即对两个关键帧之间的imu数据进行整合，得到一个factor，并且该factor基本上不随两个关键帧的状态改变而变化</p></blockquote><h1 id="预积分计算">预积分计算</h1><p>回顾惯导解算，已知系统位置、速度、姿态的微分方程如下：</p><p><span class="math display">\[\begin{array}{l}\dot{\mathbf{p}}_{w b_{t}}=\mathbf{v}_{t}^{w} \\\dot{\mathbf{v}}_{t}^{w}=\mathbf{a}_{t}^{w} \\\dot{\mathbf{q}}_{w b_{t}}=\mathbf{q}_{w b_{t}} \otimes\left[\begin{array}{c}0 \\\frac{1}{2} \boldsymbol{\omega}^{b_{t}}\end{array}\right]\end{array}\]</span></p><p>基于上述微分方程，可以得到连续时间下的状态传播方程：</p><p><span class="math display">\[\mathbf{p}_{w b_{j}}=\mathbf{p}_{w b_{i}}+\mathbf{v}_{i}^{w} \Delta t+\iint_{t \in[i, j]}\left(\mathbf{q}_{w b_{t}} \mathbf{a}^{b_{t}}-\mathbf{g}^{w}\right) \delta t^{2}\]</span></p><p><span class="math display">\[\mathbf{v}_{j}^{w}=\mathbf{v}_{i}^{w}+\int_{t \in[i, j]}\left(\mathbf{q}_{w b_{t}} \mathbf{a}^{b_{t}}-\mathbf{g}^{w}\right) \delta t\]</span></p><p><span class="math display">\[\mathbf{q}_{w b_{j}}=\int_{t \in[i, j]} \mathbf{q}_{w b_{t}} \otimes\left[\begin{array}{c}0 \\ \frac{1}{2} \boldsymbol{\omega}^{b_{t}}\end{array}\right] \delta t\]</span></p><p>由于上面三个公式都与前一个时刻的状态有关，因此需要进行变换：</p><p>根据<span class="math inline">\(\mathbf{q}_{w b_{t}}=\mathbf{q}_{w b_{i}} \otimes \mathbf{q}_{b_{i} b_{t}}\)</span>，即可将上面三个公式中的前一个时刻的位姿项提取出来：</p><p><span class="math display">\[\mathbf{p}_{w b_{j}}=\mathbf{p}_{w b_{i}}+\mathbf{v}_{i}^{w} \Delta t-\frac{1}{2} \mathbf{g}^{w} \Delta t^{2}+\mathbf{q}_{w b_{i}} \underbrace{\iint_{t \in[i, j]}\left(\mathbf{q}_{b_{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t^{2}}_{\mathbf{\alpha}}\]</span></p><p><span class="math display">\[\mathbf{v}_{j}^{w}=\mathbf{v}_{i}^{w}-\mathbf{g}^{w} \Delta t+\mathbf{q}_{w b_{i}}\underbrace{\int_{t \in[i, j]}\left(\mathbf{q}_{b_{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t}_{\mathbf{\beta}}\]</span></p><p><span class="math display">\[\mathbf{q}_{w b_{j}}=\mathbf{q}_{w b_{i}}\underbrace{\int_{t \in[i, j]} \mathbf{q}_{b_{i} b_{t}} \otimes\left[\begin{array}{c}0 \\ \frac{1}{2} \boldsymbol{\omega}^{b_{t}}\end{array}\right] \delta t}_{\mathbf{\gamma}}\]</span></p><p>将上式的积分项分别提取出来，有：</p><p><span class="math display">\[\boldsymbol{\alpha}_{b_{i} b_{j}}=\iint_{t \in[i, j]}\left(\mathbf{q}_{b_{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t^{2}\]</span></p><p><span class="math display">\[\boldsymbol{\beta}_{b_{i} b_{j}}=\int_{t \in[i, j]}\left(\mathbf{q}_{b_{i} b_{t}} \mathbf{a}^{b_{t}}\right) \delta t\]</span></p><p><span class="math display">\[\mathbf{q}_{b_{i} b_{j}}=\int_{t \in[i, j]} \mathbf{q}_{b_{i} b_{t}} \otimes\left[    \begin{array}{c}    0 \\     \frac{1}{2} \boldsymbol{\omega}^{b_{t}}    \end{array}\right] \delta t\]</span></p><p>由于上面的推导都是基于连续时间下的，在实际使用中，通常使用离散形式计算，采用中值积分法：</p><p><span class="math display">\[\boldsymbol{\omega}=\frac{1}{2}\left[\left(\boldsymbol{\omega}^{b_{k}}-\mathbf{b}_{k}^{g}\right)+\left(\boldsymbol{\omega}^{b_{k+1}}-\mathbf{b}_{k}^{g}\right)\right]\]</span></p><p><span class="math display">\[\mathbf{a}=\frac{1}{2}\left[\mathbf{q}_{b_{i} b_{k}}\left(\mathbf{a}^{b_{k}}-\mathbf{b}_{k}^{a}\right)+\mathbf{q}_{b_{i} b_{k+1}}\left(\mathbf{a}^{b_{k+1}}-\mathbf{b}_{k}^{a}\right)\right]\]</span></p><p>那么预积分量<span class="math inline">\(\boldsymbol{\alpha}_{b_{i} b_{j}},\boldsymbol{\beta}_{b_{i} b_{j}},\mathbf{q}_{b_{i} b_{j}}\)</span>可以通过迭代计算得到，当新的一帧imu数据到达时，计算该imu预积分的第k+1次迭代，有：</p><p><span class="math display">\[\boldsymbol{\alpha}_{b_{i} b_{k+1}}=\boldsymbol{\alpha}_{b_{i} b_{k}}+\boldsymbol{\beta}_{b_{i} b_{k}} \delta t+\frac{1}{2} \mathbf{a} \delta t^{2}\]</span></p><p><span class="math display">\[\boldsymbol{\beta}_{b_{i} b_{k+1}}=\boldsymbol{\beta}_{b_{i} b_{k}}+\mathbf{a} \delta t\]</span></p><p><span class="math display">\[\mathbf{q}_{b_{i} b_{k+1}}=\mathbf{q}_{b_{i} b_{k}} \otimes\left[    \begin{array}{c}    1 \\     \frac{1}{2} \boldsymbol{\omega} \delta t    \end{array}\right]\]</span></p><p>预积分量计算完成</p><p><strong>基于预积分量</strong>的导航状态更新公式为：</p><p><span class="math display">\[\left[    \begin{array}{c}        \mathbf{p}_{w b_{j}} \\         \mathbf{v}_{j}^{w} \\         \mathbf{q}_{w b_{j}} \\         \mathbf{b}_{j}^{a} \\         \mathbf{b}_{j}^{g}    \end{array}\right]=\left[    \begin{array}{c}        \mathbf{p}_{w b_{i}}+\mathbf{v}_{i}^{w} \Delta t-\frac{1}{2} \mathbf{g}^{w} \Delta t^{2}+\mathbf{q}_{w b_{i}} \boldsymbol{\alpha}_{b_{i} b_{j}} \\         \mathbf{v}_{i}^{w}-\mathbf{g}^{w} \Delta t+\mathbf{q}_{w b_{i}} \boldsymbol{\beta}_{b_{i} b_{j}} \\         \mathbf{q}_{w b_{i}} \mathbf{q}_{b_{i} b_{j}} \\         \mathbf{b}_{i}^{a} \\         \mathbf{b}_{i}^{g}    \end{array}\right]\]</span></p><blockquote><p>此中，陀螺仪和加速度计的零偏不变是认为在这个预积分中，由于时间很短，bias基本没有变化。然而，在整个系统中，其实是认为bias在缓慢变化的，因此，陀螺仪加速度计的模型为： <img src="https://chevereto.epsilonjohn.club/images/2021/02/23/20210223212141.png"></p></blockquote><h1 id="预积分更新">预积分更新</h1><p>从上面的推导可以发现，预积分量中包含了bias，而在后续的优化过程中，bias作为待优化状态量会随优化而发生改变，因此，预积分量应该随之更新，为了避免完全重新计算预积分，一个技巧是把预积分结果在bias处进行泰勒展开，通过线性近似得到更新的预积分：</p><p><span class="math display">\[\boldsymbol{\alpha}_{b_{i} b_{j}}=\overline{\boldsymbol{\alpha}}_{b_{i} b_{j}}+\mathbf{J}_{b_{i}^{a}}^{\alpha} \boldsymbol{b}_{i}^{a}+\mathbf{J}_{b_{i}^{g}}^{\alpha} \delta \mathbf{b}_{i}^{g}\]</span></p><p><span class="math display">\[\boldsymbol{\beta}_{b_{i} b_{j}}=\overline{\boldsymbol{\beta}}_{b_{i} b_{j}}+\mathbf{J}_{b_{i}^{a}}^{\beta} \delta \mathbf{b}_{i}^{a}+\mathbf{J}_{b_{i}^{g}}^{\beta} \delta \mathbf{b}_{i}^{g}\]</span></p><p><span class="math display">\[\mathbf{q}_{b_{i} b_{j}}=\overline{\mathbf{q}}_{b_{i} b_{j}} \otimes\left[    \begin{array}{c}        1 \\         \frac{1}{2} \mathbf{J}_{b_{i}^{g}}^{q} \delta \mathbf{b}_{i}^{g}    \end{array}\right]\]</span></p><p>其中，（详细计算见后续）</p><p><span class="math display">\[\begin{aligned} \mathbf{J}_{b_{i}^{a}}^{\alpha} &amp;=\frac{\partial \boldsymbol{\alpha}_{b_{i} b_{j}}}{\partial \delta \mathbf{b}_{i}^{a}} \\ \mathbf{J}_{b_{i}^{g}}^{\alpha} &amp;=\frac{\partial \boldsymbol{\alpha}_{b_{i} b_{j}}}{\partial \delta \mathbf{b}_{i}^{g}} \\ \mathbf{J}_{b_{i}^{a}}^{\beta} &amp;=\frac{\partial \boldsymbol{\beta}_{b_{i} b_{j}}}{\partial \delta \mathbf{b}_{i}^{a}} \\ \mathbf{J}_{b_{i}^{g}}^{\beta} &amp;=\frac{\partial \beta_{b_{i} b_{j}}}{\partial \delta \mathbf{b}_{i}^{g}} \\ \mathbf{J}_{b_{i}^{g}}^{q} &amp;=\frac{\mathbf{q}_{i_{i} b_{j}}}{\partial \mathbf{b}_{i}^{g}} \end{aligned}\]</span></p><h1 id="预积分误差协方差计算">预积分(误差)协方差计算</h1><p>由于预积分量是由imu数据迭代计算得到的，然而imu单次测量包含噪声，时间越长，预积分量越不准确，因此，需要计算对应的协方差来表示其不确定性，方差计算公式如下：</p><p><span class="math display">\[\boldsymbol{P}_{i, k+1}=\mathbf{F}_{k} \boldsymbol{P}_{i, k} \mathbf{F}_{k}^{\top}+\mathbf{G}_{k} \boldsymbol{Q} \mathbf{G}_{k}^{\top}\]</span></p><blockquote><p>注意：上式的<span class="math inline">\(\mathbf{F}_{k},\mathbf{G}_{k}\)</span>是离散时间下的状态转移矩阵</p></blockquote><p>下面需要求关于预积分误差的微分方程：</p><p>已知连续时间下的微分方程形式为：</p><p><span class="math display">\[\dot{\boldsymbol{X}}=\boldsymbol{F}_{t} \boldsymbol{X}+\boldsymbol{G}_{t} \boldsymbol{N}\]</span></p><p>其中，</p><p><span class="math display">\[\boldsymbol{X}=\left[    \begin{array}{l}    \delta \boldsymbol{\alpha}_{t}^{b_{k}} \\     \delta \boldsymbol{\theta}_{t}^{b_{k}} \\     \delta \boldsymbol{\beta}_{t}^{b_{k}} \\     \delta \boldsymbol{b}_{a_{t}} \\     \delta \boldsymbol{b}_{w_{t}}    \end{array}\right]\]</span></p><p><span class="math display">\[\boldsymbol{N}=\left[    \begin{array}{l}    \boldsymbol{n}_{a} \\    \boldsymbol{n}_{w} \\    \boldsymbol{n}_{b_{a}} \\     \boldsymbol{n}_{b_{w}}    \end{array}\right]\]</span></p><h2 id="delta-dottheta_tb_k微分方程推导"><span class="math inline">\(\delta \dot{\theta}_t^{b_k}\)</span>微分方程推导</h2><p>符号简化：<span class="math inline">\(\delta \dot{\theta}_t^{b_k} \rightarrow \delta \dot \theta\)</span></p><ol type="1"><li>写出不考虑误差的微分方程</li></ol><p><span class="math display">\[\dot{\boldsymbol{q}}_{t}=\frac{1}{2} \boldsymbol{q}_{t} \otimes\left[    \begin{array}{c}    0 \\     \boldsymbol{\omega}_{t}-\boldsymbol{b}_{\omega_{t}}    \end{array}\right]\]</span></p><ol start="2" type="1"><li>写出考虑误差的微分方程</li></ol><p><span class="math display">\[\dot{\tilde{\boldsymbol{q}}}_{t}=\frac{1}{2} \tilde{\boldsymbol{q}}_{t} \otimes\left[    \begin{array}{c}    0 \\     \tilde{\boldsymbol{\omega}}_{t}-\tilde{\boldsymbol{b}}_{\omega_{t}}    \end{array}\right]\]</span></p><ol start="3" type="1"><li>写出带有误差的参数与理想真实值之间的关系</li></ol><p><span class="math display">\[\tilde{\boldsymbol{q}}_{t}=\boldsymbol{q}_{t} \otimes \delta \boldsymbol{q}\]</span></p><p><span class="math display">\[\tilde{\boldsymbol{\omega}}_{t}=\boldsymbol{\omega}_{t}+\boldsymbol{n}_{\omega}\]</span></p><p><span class="math display">\[\tilde{\boldsymbol{b}}_{\omega_{t}}=\boldsymbol{b}_{\omega_{t}}+\delta \boldsymbol{b}_{\omega_{t}}\]</span></p><p>其中，<span class="math inline">\(\delta \theta\)</span>是计算坐标系与真实导航坐标系的偏差 或者 在body系与计算误差body系之间的偏差</p><p><span class="math display">\[\delta \boldsymbol{q}=\left[    \begin{array}{c}    \cos \left(\frac{|\delta \theta|}{2}\right) \\     \frac{\delta \boldsymbol{\theta}}{|\delta \theta|} \sin \left(\frac{|\delta \theta|}{2}\right)    \end{array}\right]     \approx\left[    \begin{array}{c}    1 \\     \frac{\delta \boldsymbol{\theta}}{2}    \end{array}\right]\]</span></p><ol start="4" type="1"><li>将误差值与理想真实值的关系代入(2)</li></ol><p><span class="math display">\[\left(\boldsymbol{q}_{t} \dot{\otimes} \delta \boldsymbol{q}\right)=\frac{1}{2} \boldsymbol{q}_{t} \otimes \delta \boldsymbol{q} \otimes\left[    \begin{array}{c}    0 \\     \boldsymbol{\omega}_{t}+\boldsymbol{n}_{\omega}-\boldsymbol{b}_{\omega_{t}}-\delta \boldsymbol{b}_{\omega_{t}}    \end{array}\right]\]</span></p><p>其中，</p><p><span class="math display">\[\left(\boldsymbol{q}_{t} \dot{\otimes} \delta \boldsymbol{q}\right)=\dot{\boldsymbol{q}}_{t} \otimes \delta \boldsymbol{q}+\boldsymbol{q}_{t} \otimes \delta \dot{\boldsymbol{q}}\]</span></p><ol start="5" type="1"><li>把(1)中的关系代入(4)</li></ol><p><span class="math display">\[\begin{aligned}\left(\boldsymbol{q}_{t} \dot{\otimes} \delta \boldsymbol{q}\right) &amp;= \frac{1}{2} \boldsymbol{q}_{t} \otimes \delta \boldsymbol{q} \otimes\left[\begin{array}{c}0 \\ \boldsymbol{\omega}_{t}+\boldsymbol{n}_{\omega}-\boldsymbol{b}_{\omega_{t}}-\delta \boldsymbol{b}_{\omega_{t}}\end{array}\right] \\\dot{\boldsymbol{q}}_{t} \otimes \delta \boldsymbol{q}+\boldsymbol{q}_{t} \otimes \delta \boldsymbol{q} &amp;= \\\frac{1}{2} \boldsymbol{q}_{t} \otimes\left[\begin{array}{c}0 \\ \boldsymbol{\omega}_{t}-\boldsymbol{b}_{\omega_{t}}\end{array}\right] \otimes \delta \boldsymbol{q}+\boldsymbol{q}_{t} \otimes \dot{\delta \boldsymbol{q}} &amp;=\end{aligned}\]</span></p><ol start="6" type="1"><li>化简</li></ol><p>(5)两边同时左乘<span class="math inline">\((\boldsymbol{q}_t)^{-1}\)</span>，然后移项得到：</p><p><span class="math display">\[\delta \dot{\boldsymbol{q}}=\frac{1}{2} \delta \boldsymbol{q} \otimes\left[    \begin{array}{c}    0 \\     \boldsymbol{\omega}_{t}+\boldsymbol{n}_{\omega}-\boldsymbol{b}_{\omega_{t}}-\delta \boldsymbol{b}_{\omega_{t}}    \end{array}\right]-\frac{1}{2}\left[    \begin{array}{c}    0 \\     \boldsymbol{\omega}_{t}-\boldsymbol{b}_{\omega_{t}}    \end{array}\right] \otimes \delta \boldsymbol{q}\]</span></p><blockquote><p>根据四元数乘法性质，可以将四元数乘法转换成矩阵与向量相乘： <img src="https://chevereto.epsilonjohn.club/images/2021/02/26/20210226173136.png"></p></blockquote><p>因此，可得：</p><p><span class="math display">\[\begin{aligned}\delta \dot{\boldsymbol{q}}&amp;=\frac{1}{2}\left[    \begin{array}{c}0 \\     \boldsymbol{\omega}_{1}    \end{array}\right]_{R} \delta \boldsymbol{q}-\frac{1}{2}\left[    \begin{array}{c}0 \\     \boldsymbol{\omega}_{2}    \end{array}\right]_{L} \delta \boldsymbol{q} \\&amp;=\frac{1}{2}\left[    \begin{array}{cc}    0 &amp; \left(\boldsymbol{\omega}_{2}-\boldsymbol{\omega}_{1}\right)^{T} \\     \left(\boldsymbol{\omega}_{1}-\boldsymbol{\omega}_{2}\right) &amp; -\left[\boldsymbol{\omega}_{1}+\boldsymbol{\omega}_{2}\right]_{\times}    \end{array}\right] \delta \boldsymbol{q}\end{aligned}\]</span></p><p>其中,</p><p><span class="math display">\[\boldsymbol{\omega}_{1}=\boldsymbol{\omega}_{t}+\boldsymbol{n}_{\omega}-\boldsymbol{b}_{\omega_{t}}-\delta \boldsymbol{b}_{\omega_{t}}\]</span></p><p><span class="math display">\[\boldsymbol{\omega}_{2}=\boldsymbol{\omega}_{t}-\boldsymbol{b}_{\omega_{t}}\]</span></p><p>又因为：</p><p><span class="math display">\[\delta \dot{\boldsymbol{q}}=\left[    \begin{array}{l}    0 \\     \frac{\delta \dot{\theta}}{2}    \end{array}\right]\]</span></p><p>可以得到关于<span class="math inline">\(\delta \dot{\theta}\)</span>的方程：</p><p><span class="math display">\[\begin{aligned}\delta \dot{\boldsymbol{\theta}}&amp;=-\left[\boldsymbol{\omega}_{1}+\boldsymbol{\omega}_{2}\right] \times \frac{\delta \boldsymbol{\theta}}{2}+\left(\boldsymbol{\omega}_{1}-\boldsymbol{\omega}_{2}\right)\\&amp;=-\left[2 \boldsymbol{\omega}_{t}+\boldsymbol{n}_{\omega}-2 \boldsymbol{b}_{\omega_{t}}-\delta \boldsymbol{b}_{\omega_{t}}\right]_\times \frac{\delta \boldsymbol{\theta}}{2}+\boldsymbol{n}_{\omega}-\delta \boldsymbol{b}_{\omega_{t}}\end{aligned}\]</span></p><p>忽略上式中的二阶小项，可得<span class="math inline">\(\delta \dot{\theta}_t^{b_k}\)</span>微分方程</p><p><span class="math display">\[\delta \dot{\boldsymbol{\theta}}=-\left[\boldsymbol{\omega}_{t}-\boldsymbol{b}_{\omega_{t}}\right]_{\times} \delta \boldsymbol{\theta}+\boldsymbol{n}_{\omega}-\delta \boldsymbol{b}_{\omega_{t}}\]</span></p><h2 id="delta-dotbeta_tb_k微分方程推导"><span class="math inline">\(\delta \dot{\beta}_t^{b_k}\)</span>微分方程推导</h2><p>符号简化：<span class="math inline">\(\delta \dot{\beta}_t^{b_k} \rightarrow \delta \dot \beta\)</span></p><ol type="1"><li>写出不考虑误差的微分方程</li></ol><p><span class="math display">\[\dot{\boldsymbol{\beta}}=\boldsymbol{R}_{t}\left(\boldsymbol{a}_{t}-\boldsymbol{b}_{a_{t}}\right)\]</span></p><p>其中，<span class="math inline">\(\boldsymbol{R}_{t}\)</span>表示载体姿态</p><ol start="2" type="1"><li>写出考虑误差的微分方程</li></ol><p><span class="math display">\[\dot{\tilde{\boldsymbol{\beta}}}=\tilde{\boldsymbol{R}}_{t}\left(\tilde{\boldsymbol{a}}_{t}-\tilde{\boldsymbol{b}}_{a_{t}}\right)\]</span></p><ol start="3" type="1"><li>写出带有误差的参数与理想真实值之间的关系</li></ol><p><span class="math display">\[\tilde{\boldsymbol{\beta}}=\boldsymbol{\beta}+\delta \boldsymbol{\beta}\]</span></p><p><span class="math display">\[\tilde{\boldsymbol{a}}_{t}=\boldsymbol{a}_{t}+\boldsymbol{n}_{a}\]</span></p><p><span class="math display">\[\tilde{\boldsymbol{b}}_{a_{t}}=\boldsymbol{b}_{a_{t}}+\delta \boldsymbol{b}_{a_{t}}\]</span></p><p><span class="math display">\[\begin{aligned}\tilde{\boldsymbol{R}}_{t}&amp;=\boldsymbol{R}_{t} \exp \left([\delta \boldsymbol{\theta}]_{\times}\right) \\&amp;=\boldsymbol{R}_{t}\left(\boldsymbol{I}+[\delta \boldsymbol{\theta}]_{\times}\right)\end{aligned}\]</span></p><blockquote><p>关于姿态与理想真实值的关系： 因为 <span class="math inline">\(\delta \boldsymbol{\theta}\)</span>表示的是在载体姿态上的误差，直接右乘即可</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是预积分&quot;&gt;什么是预积分&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://chevereto.epsilonjohn.club/images/2021/02/19/20210219155712.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即对两个关
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Zotero导入CNKI文献</title>
    <link href="http://yoursite.com/2021/02/11/Zotero%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2021/02/11/Zotero%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2021-02-11T09:05:33.000Z</published>
    <updated>2021-02-11T13:35:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="why-zotero">Why Zotero?</h1><ul><li>可以一键导入并下载CNKI文献(pdf)</li><li>可以抓取硕士论文目录</li><li>与Word兼容性良好(安装插件即可实现gb7714等参考文献引用格式)</li><li>……</li></ul><h1 id="zotero以及浏览器插件安装">Zotero以及浏览器插件安装</h1><p>参考官网即可： https://www.zotero.org/</p><p>下载地址： https://www.zotero.org/download/</p><h1 id="cnki中文插件安装">CNKI中文插件安装</h1><p>参考： https://github.com/l0o0/translators_CN</p><h2 id="zotero-translator_cn-安装">Zotero translator_CN 安装</h2><p><strong>1 下载网页翻译器(web translator)文件</strong></p><p><img src="https://s1.ax1x.com/2020/08/19/dlKNRK.png"></p><p><strong>2 解压下载的压缩包，找到</strong>translators<strong>目录，将目录中的文件复制到 Zotero 的 translators 目录</strong></p><p><img src="https://s1.ax1x.com/2020/09/07/wnDwlV.jpg"><br><img src="https://s1.ax1x.com/2020/08/19/dlM36S.png"></p><blockquote><p>如果是macos系统，Zotero的目录就在用户主目录下</p></blockquote><p><strong>3 更新 translator 信息，Firefox 和 Chrome 浏览器操作类似。下面以 Firefox 为例</strong><br><img src="https://s1.ax1x.com/2020/08/19/dlQgKS.gif"></p><p>Chrome 浏览器按照下面信息找到更新按钮</p><p><img src="https://s1.ax1x.com/2020/08/19/dlKUxO.png"></p><p><strong>更新时请多点几下，根据我的经验，Chrome 浏览器更新比较快，Firefox 会比较慢</strong></p><p>如果你使用学校的 VPN 来登录知网，可以参考这个<a href="https://zhuanlan.zhihu.com/p/111857132" target="_blank" rel="noopener">链接</a>进行设置。设置过程不复杂，就是用特殊符号把网址中的字符替换掉。</p><h2 id="如何在zotero-connector-中添加中文姓名处理以及保留知网caj格式文件的设置"><span id="jump">🍇 如何在Zotero Connector 中添加中文姓名处理以及保留知网CAJ格式文件的设置</span></h2><p>需要特别注意的是，这里在 Zotero Connector 中添加的参数，只是方便控制的网页翻译器的数据抓取行为，限本页面列出的一些翻译器中起作用，并不影响其他翻译器和Zotero的其他功能。 添加的参数有：</p><ul><li><code>translators.zhnamesplit</code>，默认为true，抓取过程会拆分姓和名，如果想全并姓名，请设置为false</li><li><code>translators.CNKIPDF</code>,默认为true，~<del>下载知网上文章的PDF文件，如果想要下载学位论文的CAJ格式，请设置为false</del>~ (这个方法有点问题，建议直接下载pdf版本即可，后面会有利用插件添加硕士论文目录的部分)</li></ul><p>设置方法请参考下面：</p><p><img src="https://s1.ax1x.com/2020/08/19/dl1AyT.gif"></p><p>为防止设置错误，可以把参数名复制过去。设置完成后，请刷新网页，再重新抓取。如果你参数名写错了也没事，不会有什么问题，放着就好。</p><h2 id="使用方法">使用方法</h2><p><strong>1 打开<a href="https://www.cnki.net/" target="_blank" rel="noopener">知网</a></strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211211932.png"></p><p><strong>2 点击插件，选择需要导入的文献</strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212044.png"></p><p><strong>3 确认即可导入Zotero</strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212218.png"></p><p><strong>4 双击即可打开对应的pdf</strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212359.png"></p><blockquote><p>由于直接下载的硕士论文pdf版本没有目录，因此下面通过安装插件的方法来解决这个问题</p></blockquote><h1 id="jasminum---茉莉花插件安装使用">Jasminum - 茉莉花插件安装使用</h1><p>插件官方地址：https://github.com/l0o0/jasminum</p><h2 id="安装步骤">安装步骤</h2><p><strong>1 Jasminum插件</strong></p><p>下载最新的<a href="https://github.com/l0o0/jasminum/releases/latest" target="_blank" rel="noopener">xpi</a>文件进行安装，安装方法：打开 Zotero -&gt; 工具 -&gt; 插件 -&gt; 右上小齿轮图标 -&gt; Install Add-on From File ... -&gt; 选择下载好的xpi文件。</p><p><strong>2 PDFtk server插件</strong></p><p>PDFtk server，该书签添加工具有 Windows， Linux 和 Mac，请根据自己的系统下载对应的版本进行安装，并在选项中设置好对应的目录。<a href="https://www.pdflabs.com/tools/pdftk-server/" target="_blank" rel="noopener">PDFtk server 下载链接</a></p><blockquote><p>官网：https://www.pdflabs.com/tools/pdftk-server/<br><font color="red">After installation, open a Terminal, type pdftk and press Return. Pdftk will respond by displaying brief usage information(注意！安装后请试试这一步，出现使用说明说明安装成功)</font>. Access pdftk documenation by running man pdftk.</p></blockquote><p><strong>Mac 用户</strong>（感谢<span class="citation" data-cites="GuokaiLiu">[@GuokaiLiu]</span>(https://github.com/GuokaiLiu)同学在 <a href="https://github.com/l0o0/jasminum/issues/7#issuecomment-706448964" target="_blank" rel="noopener">issue</a> 中的补充） macos(10.15)用户： 下载：https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/pdftk_server-2.02-mac_osx-10.11-setup.pkg</p><blockquote><p>关于Mac系统的插件路径配置（我没有进行这一步，有需要的再看）<br>配置方法： 打开Zotero-&gt;首选项-&gt;茉莉花<br><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212937.png"> 路径：<code>/opt/pdflabs/pdftk/</code>. （该路径默认对外隐藏无法选取） 选择路径的技巧：<code>shift+command+G</code>: 输入：<code>/opt/pdflabs/pdftk/</code>，选择<code>bin</code>确认</p></blockquote><h2 id="使用方法同上">使用方法（同上）</h2><p>稍微等一会，插件就抓取到目录了</p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211213244.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;why-zotero&quot;&gt;Why Zotero?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;可以一键导入并下载CNKI文献(pdf)&lt;/li&gt;
&lt;li&gt;可以抓取硕士论文目录&lt;/li&gt;
&lt;li&gt;与Word兼容性良好(安装插件即可实现gb7714等参考文献引用格式)&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Eigen-Operation</title>
    <link href="http://yoursite.com/2021/02/01/Eigen%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2021/02/01/Eigen%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2021-02-01T03:05:32.000Z</published>
    <updated>2021-02-02T02:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eigen常用操作eigen-cheatsheet">Eigen常用操作|Eigen Cheatsheet</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A simple quickref for Eigen. Add anything that&#39;s missing.</span><br><span class="line">&#x2F;&#x2F; Main author: Keir Mierle</span><br></pre></td></tr></table></figure><h2 id="包含头文件">1. 包含头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="矩阵向量声明">2. 矩阵、向量声明</h2><h3 id="矩阵声明">2.1 矩阵声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;               <span class="comment">// Fixed rows and cols. Same as Matrix3d.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, Dynamic&gt; B;         <span class="comment">// Fixed rows, dynamic cols.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt; C;   <span class="comment">// Full dynamic. Same as MatrixXd.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>, RowMajor&gt; E;     <span class="comment">// Row major; default is column-major.</span></span><br><span class="line">Matrix3f P, Q, R;                     <span class="comment">// 3x3 float matrix.</span></span><br></pre></td></tr></table></figure><h3 id="向量声明">2.2 向量声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector3f x, y, z;                     <span class="comment">// 3x1 float matrix.</span></span><br><span class="line">RowVector3f a, b, c;                  <span class="comment">// 1x3 float matrix.</span></span><br><span class="line">VectorXd v;                           <span class="comment">// Dynamic column vector of doubles</span></span><br><span class="line"><span class="keyword">double</span> s;</span><br></pre></td></tr></table></figure><h2 id="基础操作">3. 基础操作</h2><h3 id="计算大小">3.1 计算大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic usage</span></span><br><span class="line"><span class="comment">// Eigen          // Matlab           // comments</span></span><br><span class="line">x.<span class="built_in">size</span>()          <span class="comment">// length(x)        // vector size</span></span><br><span class="line">C.rows()          <span class="comment">// size(C,1)        // number of rows</span></span><br><span class="line">C.cols()          <span class="comment">// size(C,2)        // number of columns</span></span><br></pre></td></tr></table></figure><h3 id="访问元素">3.2 访问元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x(i)              <span class="comment">// x(i+1)           // Matlab is 1-based</span></span><br><span class="line">C(i,j)            <span class="comment">// C(i+1,j+1)       //</span></span><br></pre></td></tr></table></figure><h3 id="改变大小">3.3 改变大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.resize(<span class="number">4</span>, <span class="number">4</span>);   <span class="comment">// Runtime error if assertions are on.</span></span><br><span class="line">B.resize(<span class="number">4</span>, <span class="number">9</span>);   <span class="comment">// Runtime error if assertions are on.</span></span><br><span class="line">A.resize(<span class="number">3</span>, <span class="number">3</span>);   <span class="comment">// Ok; size didn't change.</span></span><br><span class="line">B.resize(<span class="number">3</span>, <span class="number">9</span>);   <span class="comment">// Ok; only dynamic cols changed.</span></span><br></pre></td></tr></table></figure><h3 id="矩阵赋值">3.4 矩阵赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,     <span class="comment">// Initialize A. The elements can also be</span></span><br><span class="line">     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,     <span class="comment">// matrices, which are stacked along cols</span></span><br><span class="line">     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;     <span class="comment">// and then the rows are stacked.</span></span><br><span class="line">B &lt;&lt; A, A, A;     <span class="comment">// B is three horizontally stacked A's.</span></span><br><span class="line">A.<span class="built_in">fill</span>(<span class="number">10</span>);       <span class="comment">// Fill A with all 10's.</span></span><br></pre></td></tr></table></figure><h2 id="特殊矩阵">4. 特殊矩阵</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eigen                                    // Matlab</span></span><br><span class="line">MatrixXd::Identity(rows,cols)               <span class="comment">// eye(rows,cols)</span></span><br><span class="line">C.setIdentity(rows,cols)                    <span class="comment">// C = eye(rows,cols)</span></span><br><span class="line">MatrixXd::Zero(rows,cols)                   <span class="comment">// zeros(rows,cols)</span></span><br><span class="line">C.setZero(rows,cols)                        <span class="comment">// C = zeros(rows,cols)</span></span><br><span class="line">MatrixXd::Ones(rows,cols)                   <span class="comment">// ones(rows,cols)</span></span><br><span class="line">C.setOnes(rows,cols)                        <span class="comment">// C = ones(rows,cols)</span></span><br><span class="line">MatrixXd::Random(rows,cols)                 <span class="comment">// rand(rows,cols)*2-1            // MatrixXd::Random returns uniform random numbers in (-1, 1).</span></span><br><span class="line">C.setRandom(rows,cols)                      <span class="comment">// C = rand(rows,cols)*2-1</span></span><br><span class="line">VectorXd::LinSpaced(<span class="built_in">size</span>,low,high)          <span class="comment">// linspace(low,high,size)'</span></span><br><span class="line">v.setLinSpaced(<span class="built_in">size</span>,low,high)               <span class="comment">// v = linspace(low,high,size)'</span></span><br><span class="line">VectorXi::LinSpaced(((hi-low)/<span class="built_in">step</span>)+<span class="number">1</span>,      <span class="comment">// low:step:hi</span></span><br><span class="line">                    low,low+<span class="built_in">step</span>*(<span class="built_in">size</span><span class="number">-1</span>))  <span class="comment">//</span></span><br></pre></td></tr></table></figure><h2 id="矩阵元素提取与替换">5. 矩阵元素提取与替换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix slicing and blocks. All expressions listed here are read/write.</span></span><br><span class="line"><span class="comment">// Templated size versions are faster. Note that Matlab is 1-based (a size N</span></span><br><span class="line"><span class="comment">// vector is x(1)...x(N)).</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                  PLEASE HELP US IMPROVING THIS SECTION                     */</span></span><br><span class="line"><span class="comment">/* Eigen 3.4 supports a much improved API for sub-matrices, including,        */</span></span><br><span class="line"><span class="comment">/* slicing and indexing from arrays:                                          */</span></span><br><span class="line"><span class="comment">/* http://eigen.tuxfamily.org/dox-devel/group__TutorialSlicingIndexing.html   */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">x.head(n)                          <span class="comment">// x(1:n)</span></span><br><span class="line">x.head&lt;n&gt;()                        <span class="comment">// x(1:n)</span></span><br><span class="line">x.tail(n)                          <span class="comment">// x(end - n + 1: end)</span></span><br><span class="line">x.tail&lt;n&gt;()                        <span class="comment">// x(end - n + 1: end)</span></span><br><span class="line">x.segment(i, n)                    <span class="comment">// x(i+1 : i+n)</span></span><br><span class="line">x.segment&lt;n&gt;(i)                    <span class="comment">// x(i+1 : i+n)</span></span><br><span class="line">P.block(i, j, rows, cols)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></span><br><span class="line">P.block&lt;rows, cols&gt;(i, j)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></span><br><span class="line">P.row(i)                           <span class="comment">// P(i+1, :)</span></span><br><span class="line">P.col(j)                           <span class="comment">// P(:, j+1)</span></span><br><span class="line">P.leftCols&lt;cols&gt;()                 <span class="comment">// P(:, 1:cols)</span></span><br><span class="line">P.leftCols(cols)                   <span class="comment">// P(:, 1:cols)</span></span><br><span class="line">P.middleCols&lt;cols&gt;(j)              <span class="comment">// P(:, j+1:j+cols)</span></span><br><span class="line">P.middleCols(j, cols)              <span class="comment">// P(:, j+1:j+cols)</span></span><br><span class="line">P.rightCols&lt;cols&gt;()                <span class="comment">// P(:, end-cols+1:end)</span></span><br><span class="line">P.rightCols(cols)                  <span class="comment">// P(:, end-cols+1:end)</span></span><br><span class="line">P.topRows&lt;rows&gt;()                  <span class="comment">// P(1:rows, :)</span></span><br><span class="line">P.topRows(rows)                    <span class="comment">// P(1:rows, :)</span></span><br><span class="line">P.middleRows&lt;rows&gt;(i)              <span class="comment">// P(i+1:i+rows, :)</span></span><br><span class="line">P.middleRows(i, rows)              <span class="comment">// P(i+1:i+rows, :)</span></span><br><span class="line">P.bottomRows&lt;rows&gt;()               <span class="comment">// P(end-rows+1:end, :)</span></span><br><span class="line">P.bottomRows(rows)                 <span class="comment">// P(end-rows+1:end, :)</span></span><br><span class="line">P.topLeftCorner(rows, cols)        <span class="comment">// P(1:rows, 1:cols)</span></span><br><span class="line">P.topRightCorner(rows, cols)       <span class="comment">// P(1:rows, end-cols+1:end)</span></span><br><span class="line">P.bottomLeftCorner(rows, cols)     <span class="comment">// P(end-rows+1:end, 1:cols)</span></span><br><span class="line">P.bottomRightCorner(rows, cols)    <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></span><br><span class="line">P.topLeftCorner&lt;rows,cols&gt;()       <span class="comment">// P(1:rows, 1:cols)</span></span><br><span class="line">P.topRightCorner&lt;rows,cols&gt;()      <span class="comment">// P(1:rows, end-cols+1:end)</span></span><br><span class="line">P.bottomLeftCorner&lt;rows,cols&gt;()    <span class="comment">// P(end-rows+1:end, 1:cols)</span></span><br><span class="line">P.bottomRightCorner&lt;rows,cols&gt;()   <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Of particular note is Eigen's swap function which is highly optimized.</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.row(i) = P.col(j);               <span class="comment">// R(i, :) = P(:, j)</span></span><br><span class="line">R.col(j1).swap(mat1.col(j2));      <span class="comment">// R(:, [j1 j2]) = R(:, [j2, j1])</span></span><br></pre></td></tr></table></figure><h2 id="矩阵操作">6. 矩阵操作</h2><h3 id="转置与旋转">6.1 转置与旋转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Views, transpose, etc;</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                  PLEASE HELP US IMPROVING THIS SECTION                     */</span></span><br><span class="line"><span class="comment">/* Eigen 3.4 supports a new API for reshaping:                                */</span></span><br><span class="line"><span class="comment">/* http://eigen.tuxfamily.org/dox-devel/group__TutorialReshape.html           */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.adjoint()                        <span class="comment">// R'</span></span><br><span class="line">R.transpose()                      <span class="comment">// R.' or conj(R')       // Read-write</span></span><br><span class="line">R.diagonal()                       <span class="comment">// diag(R)               // Read-write</span></span><br><span class="line">x.asDiagonal()                     <span class="comment">// diag(x)</span></span><br><span class="line">R.transpose().colwise().reverse()  <span class="comment">// rot90(R)              // Read-write</span></span><br><span class="line">R.rowwise().reverse()              <span class="comment">// fliplr(R)</span></span><br><span class="line">R.colwise().reverse()              <span class="comment">// flipud(R)</span></span><br><span class="line">R.replicate(i,j)                   <span class="comment">// repmat(P,i,j)</span></span><br></pre></td></tr></table></figure><h3 id="矩阵运算">6.2 矩阵运算</h3><h4 id="基本算数运算">6.2.1 基本算数运算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All the same as Matlab, but matlab doesn't have *= style operators.</span></span><br><span class="line"><span class="comment">// Matrix-vector.  Matrix-matrix.   Matrix-scalar.</span></span><br><span class="line">y  = M*x;          R  = P*Q;        R  = P*s;</span><br><span class="line">a  = b*M;          R  = P - Q;      R  = s*P;</span><br><span class="line">a *= M;            R  = P + Q;      R  = P/s;</span><br><span class="line">                   R *= Q;          R  = s*P;</span><br><span class="line">                   R += Q;          R *= s;</span><br><span class="line">                   R -= Q;          R /= s;</span><br></pre></td></tr></table></figure><h4 id="点运算">6.2.2 点运算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vectorized operations on each element independently</span></span><br><span class="line"><span class="comment">// Eigen                       // Matlab</span></span><br><span class="line">R = P.cwiseProduct(Q);         <span class="comment">// R = P .* Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() * s.<span class="built_in">array</span>();     <span class="comment">// R = P .* s</span></span><br><span class="line">R = P.cwiseQuotient(Q);        <span class="comment">// R = P ./ Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() / Q.<span class="built_in">array</span>();     <span class="comment">// R = P ./ Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() + s.<span class="built_in">array</span>();     <span class="comment">// R = P + s</span></span><br><span class="line">R = P.<span class="built_in">array</span>() - s.<span class="built_in">array</span>();     <span class="comment">// R = P - s</span></span><br><span class="line">R.<span class="built_in">array</span>() += s;                <span class="comment">// R = R + s</span></span><br><span class="line">R.<span class="built_in">array</span>() -= s;                <span class="comment">// R = R - s</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt; Q.<span class="built_in">array</span>();         <span class="comment">// R &lt; Q</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt;= Q.<span class="built_in">array</span>();        <span class="comment">// R &lt;= Q</span></span><br><span class="line">R.cwiseInverse();              <span class="comment">// 1 ./ P</span></span><br><span class="line">R.<span class="built_in">array</span>().inverse();           <span class="comment">// 1 ./ P</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sin</span>()                <span class="comment">// sin(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">cos</span>()                <span class="comment">// cos(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">pow</span>(s)               <span class="comment">// P .^ s</span></span><br><span class="line">R.<span class="built_in">array</span>().square()             <span class="comment">// P .^ 2</span></span><br><span class="line">R.<span class="built_in">array</span>().cube()               <span class="comment">// P .^ 3</span></span><br><span class="line">R.cwiseSqrt()                  <span class="comment">// sqrt(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sqrt</span>()               <span class="comment">// sqrt(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">exp</span>()                <span class="comment">// exp(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">log</span>()                <span class="comment">// log(P)</span></span><br><span class="line">R.cwiseMax(P)                  <span class="comment">// max(R, P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">max</span>(P.<span class="built_in">array</span>())       <span class="comment">// max(R, P)</span></span><br><span class="line">R.cwiseMin(P)                  <span class="comment">// min(R, P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">min</span>(P.<span class="built_in">array</span>())       <span class="comment">// min(R, P)</span></span><br><span class="line">R.cwiseAbs()                   <span class="comment">// abs(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">abs</span>()                <span class="comment">// abs(P)</span></span><br><span class="line">R.cwiseAbs2()                  <span class="comment">// abs(P.^2)</span></span><br><span class="line">R.<span class="built_in">array</span>().abs2()               <span class="comment">// abs(P.^2)</span></span><br><span class="line">(R.<span class="built_in">array</span>() &lt; s).select(P,Q );  <span class="comment">// (R &lt; s ? P : Q)</span></span><br><span class="line">R = (Q.<span class="built_in">array</span>()==<span class="number">0</span>).select(P,R) <span class="comment">// R(Q==0) = P(Q==0)</span></span><br><span class="line">R = P.unaryExpr(ptr_fun(func)) <span class="comment">// R = arrayfun(func, P)   // with: scalar func(const scalar &amp;x);</span></span><br></pre></td></tr></table></figure><h4 id="矩阵函数">6.2.3 矩阵函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reductions.</span></span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">R.minCoeff()              <span class="comment">// min(R(:))</span></span><br><span class="line">R.maxCoeff()              <span class="comment">// max(R(:))</span></span><br><span class="line">s = R.minCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);</span></span><br><span class="line">s = R.maxCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);</span></span><br><span class="line">R.sum()                   <span class="comment">// sum(R(:))</span></span><br><span class="line">R.colwise().sum()         <span class="comment">// sum(R)</span></span><br><span class="line">R.rowwise().sum()         <span class="comment">// sum(R, 2) or sum(R')'</span></span><br><span class="line">R.prod()                  <span class="comment">// prod(R(:))</span></span><br><span class="line">R.colwise().prod()        <span class="comment">// prod(R)</span></span><br><span class="line">R.rowwise().prod()        <span class="comment">// prod(R, 2) or prod(R')'</span></span><br><span class="line">R.trace()                 <span class="comment">// trace(R)</span></span><br><span class="line">R.all()                   <span class="comment">// all(R(:))</span></span><br><span class="line">R.colwise().all()         <span class="comment">// all(R)</span></span><br><span class="line">R.rowwise().all()         <span class="comment">// all(R, 2)</span></span><br><span class="line">R.any()                   <span class="comment">// any(R(:))</span></span><br><span class="line">R.colwise().any()         <span class="comment">// any(R)</span></span><br><span class="line">R.rowwise().any()         <span class="comment">// any(R, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dot products, norms, etc.</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">x.norm()                  <span class="comment">// norm(x).    Note that norm(R) doesn't work in Eigen.</span></span><br><span class="line">x.squaredNorm()           <span class="comment">// dot(x, x)   Note the equivalence is not true for complex</span></span><br><span class="line">x.dot(y)                  <span class="comment">// dot(x, y)</span></span><br><span class="line">x.cross(y)                <span class="comment">// cross(x, y) Requires #include &lt;Eigen/Geometry&gt;</span></span><br></pre></td></tr></table></figure><h4 id="类型转换">6.2.4 类型转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// Type conversion</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">A.cast&lt;<span class="keyword">double</span>&gt;();         <span class="comment">// double(A)</span></span><br><span class="line">A.cast&lt;<span class="keyword">float</span>&gt;();          <span class="comment">// single(A)</span></span><br><span class="line">A.cast&lt;<span class="keyword">int</span>&gt;();            <span class="comment">// int32(A)</span></span><br><span class="line">A.real();                 <span class="comment">// real(A)</span></span><br><span class="line">A.imag();                 <span class="comment">// imag(A)</span></span><br><span class="line"><span class="comment">// if the original type equals destination type, no work is done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that for most operations Eigen requires all operands to have the same type:</span></span><br><span class="line">MatrixXf F = MatrixXf::Zero(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">A += F;                <span class="comment">// illegal in Eigen. In Matlab A = A+F is allowed</span></span><br><span class="line">A += F.cast&lt;<span class="keyword">double</span>&gt;(); <span class="comment">// F converted to double and then added (generally, conversion happens on-the-fly)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen can map existing memory into Eigen matrices.</span></span><br><span class="line"><span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">Vector3f::Map(<span class="built_in">array</span>).<span class="built_in">fill</span>(<span class="number">10</span>);            <span class="comment">// create a temporary Map over array and sets entries to 10</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">Matrix2i <span class="title">mat2x2</span><span class="params">(data)</span></span>;                    <span class="comment">// copies data into mat2x2</span></span><br><span class="line">Matrix2i::Map(data) = <span class="number">2</span>*mat2x2;           <span class="comment">// overwrite elements of data with 2*mat2x2</span></span><br><span class="line">MatrixXi::Map(data, <span class="number">2</span>, <span class="number">2</span>) += mat2x2;      <span class="comment">// adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)</span></span><br></pre></td></tr></table></figure><h4 id="求解线性方程组">6.2.5 求解线性方程组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Solve Ax = b. Result stored in x. Matlab: x = A \ b.</span></span><br><span class="line">x = A.ldlt().solve(b);  <span class="comment">// A sym. p.s.d.    #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.llt() .solve(b);  <span class="comment">// A sym. p.d.      #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.lu()  .solve(b);  <span class="comment">// Stable and fast. #include &lt;Eigen/LU&gt;</span></span><br><span class="line">x = A.qr()  .solve(b);  <span class="comment">// No pivoting.     #include &lt;Eigen/QR&gt;</span></span><br><span class="line">x = A.svd() .solve(b);  <span class="comment">// Stable, slowest. #include &lt;Eigen/SVD&gt;</span></span><br><span class="line"><span class="comment">// .ldlt() -&gt; .matrixL() and .matrixD()</span></span><br><span class="line"><span class="comment">// .llt()  -&gt; .matrixL()</span></span><br><span class="line"><span class="comment">// .lu()   -&gt; .matrixL() and .matrixU()</span></span><br><span class="line"><span class="comment">// .qr()   -&gt; .matrixQ() and .matrixR()</span></span><br><span class="line"><span class="comment">// .svd()  -&gt; .matrixU(), .singularValues(), and .matrixV()</span></span><br></pre></td></tr></table></figure><h4 id="求解特征值">6.2.6 求解特征值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eigenvalue problems</span></span><br><span class="line"><span class="comment">// Eigen                          // Matlab</span></span><br><span class="line">A.eigenvalues();                  <span class="comment">// eig(A);</span></span><br><span class="line"><span class="function">EigenSolver&lt;Matrix3d&gt; <span class="title">eig</span><span class="params">(A)</span></span>;     <span class="comment">// [vec val] = eig(A)</span></span><br><span class="line">eig.eigenvalues();                <span class="comment">// diag(val)</span></span><br><span class="line">eig.eigenvectors();               <span class="comment">// vec</span></span><br><span class="line"><span class="comment">// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ol type="1"><li><a href="http://eigen.tuxfamily.org/dox-devel/AsciiQuickReference.txt" target="_blank" rel="noopener">Eigen short ASCII reference</a>eference.txt)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;eigen常用操作eigen-cheatsheet&quot;&gt;Eigen常用操作|Eigen Cheatsheet&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>占用栅格更新过程</title>
    <link href="http://yoursite.com/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/</id>
    <published>2021-01-30T03:05:20.000Z</published>
    <updated>2021-02-03T01:12:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="占用栅格更新from-概率机器人">占用栅格更新(From 《概率机器人》)</h1><h2 id="静态二值贝叶斯滤波">静态二值贝叶斯滤波</h2><p>机器人技术中的某些问题表达为不随时间变化的二值状态的最优估计间题。这些问题通过二值贝叶斯滤波 (binary Bayes filter) 来阐述。</p><p>如果一个机器人从传感器测量的序列中估计环境的一个固定的二值数,此时这类问题就产生了。例如,一个机器人可能想知道门是开着的还是关着的,并认为在检测期间门的状态不改变。</p><h3 id="更新算法">更新算法</h3><p>当状态静止时,置信度就仅是测量的函数:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-19-56-28.png"></p><p>这里状态有两种：</p><ul><li><span class="math inline">\(x\)</span></li><li><span class="math inline">\(\neg x\)</span></li></ul><p>具体来说，有</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-04-09.png"></p><blockquote><p>状态 x 不含时间项反映了状态不会改变的事实</p></blockquote><p>自然的,这类二值估计问题可以利用程序 4. 1 的离散贝叶斯滤波来处理。但是,置信度通常由一个<code>概率比的对数 (log odds ratio)</code>来实现。状态 x 的概率比(odds) 定义为此事件的概率除以该事件不发生的概率</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-06-20.png"></p><p>概率对数就是这个表达式的对数</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-06-53.png"></p><blockquote><p>逆向公式，即置信度<span class="math inline">\({bel}_t(x)\)</span>可以根据概率比对数<span class="math inline">\(l_t\)</span>通过下面的方程来求得: : <img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-34-49.png"></p></blockquote><p>概率对数将(0,1)映射到<span class="math inline">\(-\infty\)</span> ~ <span class="math inline">\(\infty\)</span>，用于更新以概率对数表示的置信度的贝叶斯滤波计算很简洁。它避免了概率接近<code>0</code>或<code>1</code>引起的截断间题。</p><p><code>程序 4.2</code>给出了其基本的更新算法。这种算法是加法。</p><p>事实上,任何对测量做出反应的变量的递增和递减都可以解释为贝叶斯滤波的概率对数形式。该二值贝叶斯滤波利用一个反向测量模型 (inverse measurement model) <span class="math inline">\(p(x|z_t)\)</span>代替熟 悉的前向模型<span class="math inline">\(p(z_i|x)\)</span> 。反向测量模型将关于(二值)状态变量的一个分布指定为测量<span class="math inline">\(z_t\)</span>的一个函数。</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-27-46.png"></p><blockquote><p>反向模型经常用于测凰比二值状态更复杂的情况。这种情况的一个实例就是: <code>从相机图像中估计门是否为关的问题</code>。这里状态很简单,但需要进行所有测量的空间却是很大的。通过设计一个函数<code>根据相机图像来计算门为关着的概率</code>, 要比<code>描述所有相机图像中显示门为关着的分布</code>更容易些。换旬话说,<strong>实现一个反向传感器模型比前向传感器模型更容易</strong>。</p></blockquote><h3 id="具体证明">具体证明</h3><p>根据贝叶斯公式及马尔可夫假设:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-36-49.png"></p><p>将贝叶斯准则应用于测量模型<span class="math inline">\(p(z_t|x)\)</span></p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-37-32.png"></p><p>将上述两式结合，得到:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-40-28.png"></p><p>对于对立事件<span class="math inline">\(\neg x\)</span>，可得:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-41-03.png"></p><p>用<code>式 (4. 18)</code>除以<code>式 (4. 17)</code> 可以将各种难以计算的概率抵消:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-41-30.png"></p><p>对上式两边同时取对数，用<span class="math inline">\(l_t(x)\)</span>表示，即为置信度 <span class="math inline">\({bel}_t (x)\)</span>的概率比对数<span class="math inline">\(log \frac{p(x|z_{1:t})}{1-p(x|z_{1:t})}\)</span>，有:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-49-03.png"></p><p>这里 <span class="math inline">\(p(x)\)</span> 是状态 x 的先验 (prior) 概率。在<code>式 (4. 20)</code>中, 每个测最更新涉及先验(以概率对数形式)的求和。先验也定义为处理传感器测量前的初始置信度的概率对数:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-58-10.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;占用栅格更新from-概率机器人&quot;&gt;占用栅格更新(From 《概率机器人》)&lt;/h1&gt;
&lt;h2 id=&quot;静态二值贝叶斯滤波&quot;&gt;静态二值贝叶斯滤波&lt;/h2&gt;
&lt;p&gt;机器人技术中的某些问题表达为不随时间变化的二值状态的最优估计间题。这些问题通过二值贝叶斯滤波 (bin
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ICRA2020_dynamic_object_removing</title>
    <link href="http://yoursite.com/2021/01/29/ICRA2020_dynamic_object_removing/"/>
    <id>http://yoursite.com/2021/01/29/ICRA2020_dynamic_object_removing/</id>
    <published>2021-01-29T03:05:30.000Z</published>
    <updated>2021-02-03T01:11:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从点云中删除动态对象的稳健方法">从点云中删除动态对象的稳健方法</h1><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-09-49.png"></p><h1 id="摘要">摘要</h1><p>提出了一种从3D点云地图中删除动态对象的可靠方法。给定一组已配准的3D点云，我们构建一个占据栅格地图，其中体素表示扩展时间段内空间量的占用状态。构建占用地图后，我们将其用作过滤器，以在将激光雷达扫描中的动态点添加到地图之前将其删除。此外，我们使用对象检测和新颖的体素遍历方法来加速构建占用地图的过程。一旦构建了占用图，就可以实时运行动态对象移除。我们的方法在交通停滞或移动的宽阔城市道路上效果很好，并且由于包含了来自同一场景的更多激光雷达扫描，因此占用地图变得更好。</p><h1 id="介绍">介绍</h1><p>算法的输入是一组已配准的3D点云，通常由3D激光扫描仪获取。首先，我们使用地平面检测和对象检测算法将点云中的点分为三类：对象点，地面点和未知点。接下来，我们对未知点和地面点执行体素遍历，并降低从传感器原点到端点的光线路径上所有体素的占用分数，但增加端点体素的占用分数。类似地，我们在对象点上执行体素遍历，但是不增加端点体素的占用率，而是降低其占用率，因为我们从对象检测中已经知道端点落在移动的对象上。我们还维护了一组与地面点相对应的地面体素，并防止在两个体素遍历步骤中将它们标记为空闲。我们对注册集中的所有点云重复此过程，并构建一个占用图。最后，我们将完整的占用地图覆盖在点云地图上，并删除空闲体素中的点（请参阅图2）。应当注意，随着时间的推移，随着更多点云的集成，占用图将变得更加稳定和准确。</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-54-25.png"></p><p>具体贡献为：</p><ul><li>提出了一种新的占用概率更新策略，该策略通过考虑体素的占用历史来构建持久的占用图。与我们的方法不同，[3]赞成快速更新体素的占用分数，赞成最新看到的占用状态</li><li>提供了一种可选方法，可通过使用对象检测方法对对象点进行分类来加速占用地图的构建过程，并提供一种使用这些点更新占用地图的策略。</li><li>提供了一种生成手工端点的独特方法，该终点用于更新体素的占用分数。</li></ul><h1 id="相关工作">相关工作</h1><p>在检测/移除激光扫描中的动态对象方面已经完成了大量工作，并且已经提出了解决该问题的不同方法。这些方法可以大致分为三类：</p><ul><li><p>基于模型的无变化检测方法，该方法依赖于将当前激光扫描与之前或之前的一组扫描和将来的扫描进行比较[6]，[7]，[8]，[9]，[10]。</p></li><li><p>基于神经网络模型的方法，将动态对象对应的点分类[11]，并在激光扫描[12]，[13]，[14]中在对象周围生成边界框并将这些边界框内的点分类为动态对象点。</p></li><li><p>基于地图的方法，其中使用贝叶斯规则[3]通过激光扫描构建全局占用图/体素网格，或者仅将激光扫描标识符存储在体素中[5]，并且占用图用作过滤器以删除在自由空间中的点。本文提出的动态对象去除方法是基于神经网络模型和基于占用图的方法的混合。</p></li></ul><h1 id="算法介绍">算法介绍</h1><ul><li>在III-A节中，我们描述了为什么我们偏爱八叉树数据结构</li><li>在III-B节中，我们描述了如何使用对象检测来加快在地图中插入点云的过程</li><li>第III-D，III-E和III-F节讨论了使用自由计数器使占用图更倾向于持久性而不是易于更新的能力，以及如何使用自由计数器值修剪节点</li><li>第III-G节介绍了一种独特的过滤策略，以提高我们的入住地图的质量</li></ul><h2 id="占据八叉树">占据八叉树</h2><p>Octree是用于存储有关3D空间的信息的分层数据结构，八叉树中的每个节点代表一个空间容量，称为体素。我们使用<code>log odds</code>表格来表示空间的占用信息。另外，我们还记录着每个节点没有被观测到的次数作为<code>free counter</code>，后面会介绍使用<code>free counter</code>来更新体素的占用率</p><p>常用来表示3D空间数据结构的有：体素网格，k-d树和八叉树，我们选择octree作为占用地图，因为octree的层次结构可以紧凑有效地表示空间，与体素网格相反，我们只需在当观测到<code>occupancy information</code>时创建一个节点，在本文中，我们使用最大深度为16的八叉树和0.3米的叶节点体素大小 。</p><h2 id="目标检测与体素遍历">目标检测与体素遍历</h2><p>对象检测可用于加快生成占用图的过程，并提高动态对象去除的精度和召回得分，我们的方法不依赖于任何特定的对象检测方法，但是在我们的实验中，我们使用了AVOD（聚合视图对象检测）[13]网络来获取边界框，目前，该网络已接受训练以检测小型和大型车辆。</p><p>但是，许多基于神经网络的对象检测方法有时都无法检测到对象。这些模型只能检测对其进行训练的对象类别。此外，边界框通常不会完全包围检测到的对象，如图（3）所示。因此，使用上述方法构建的点云图仍将具有一些动态点。</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-44-04.png"></p><p>为了去除物体检测方法遗漏的动态物体，我们使用上述方法将点云中的点分为两类：</p><ul><li>对象点（位于检测到的对象的边界框内的点）</li><li>非对象点（位于边界框外的点）</li></ul><h3 id="非对象点遍历">非对象点遍历</h3><p><strong>对于点云中的每个非对象点，我们执行体素遍历以找到从传感器原点到终点沿激光射线的所有体素</strong>，我们降低了除端点体素以外的所有这些体素的占用率，并增加了端点体素的占用率</p><h3 id="对象点遍历">对象点遍历</h3><p>接下来，我们按照相同的步骤插入对象点，但是不增加端点体素的占用率外，而是降低其占用率，这是因为从对象检测中我们已经知道对象点对应于动态对象。</p><p>如前所述，有时，围绕对象生成的边界框不会完全包围对象。 我们通过在将非对象点插入到占用图中之后插入对象点来部分解决此问题。<strong>此顺序可确保在对对象点执行体素遍历时，将删除动态对象未被边界框包围的部分</strong></p><h2 id="地面点检测">地面点检测</h2><p>如[3]中所述，对以浅角度扫过平面的激光进行体素遍历会导致不良的离散化效果，当遍历另一个附近的体素时，在体素遍历期间被测量为占用的体素可能会标记为空闲，这种影响通常发生在平坦的表面（例如地面和平坦的墙壁）上，并且该影响呈现为平坦表面上的孔，如图（4）所示。</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-50-02.png"></p><blockquote><p>就是体素网格大小导致的</p></blockquote><p>此外，通过对象检测生成的边界框可能包括检测到的对象下方的地面点，并且将地面点错误地分类为动态对象点。 因此，某些地面体素可能仍被标记为空闲。</p><p>为了解决此问题，我们为每个地面体素维护一个计数器，该计数器指示将体素分类为地面体的次数，我们还将维护所有检测到的地面体素的集合，并为每次激光雷达扫描更新此集合。</p><p>只有地面体素集中那些计数器值大于某个阈值的体素才被视为真实地面体素，这些地面体素在射线遍历期间不会被标记为空闲体素。</p><p>我们使用[14]，[18]中所述的基于RANSAC的接地平面检测</p><h2 id="权重概率">权重概率</h2><p>Octomap [3]使用钳制策略允许占用八叉树图的易于更新性和可压缩性，钳位策略可确保节点的<code>log-odds</code>值不低于下限阈值<span class="math inline">\(l_{min}\)</span>，并且不会超出最高值<span class="math inline">\(l_{max}\)</span>.</p><p>当一个节点的<code>log-odds</code>值达到两个阈值中的任意一个时，就认为该节点是稳定的，并且具有较高的置信度。钳位策略可确保所有稳定的空闲和占用节点具有相同的对数奇数值，从而可以修剪具有相同<code>log-odds</code>值的相邻节点，还确保了节点的占用状态很容易更新</p><p>举例：考虑一个机器人已经绘制了某个区域并观测到其前面几个节点是空闲状态的，现在，如果有人走在机器人前面并站在机器人的路径上，则机器人应该能够快速将节点更新为已占用</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-11-19-04.png"></p><p>其中，<span class="math inline">\(L()\)</span>表示计算<code>log-odds</code>值</p><p>然而，[3]中的占用率更新策略倾向于体素的最新占用率状态 ，相反的，本文的目标是创建<code>代表环境长期占用状态的区域的占用地图</code>，我们希望占用率更新算法对动态对象不那么敏感。</p><p>本文通过维持每个体素的空闲计数器并使用加权概率来实现此目的。每个体素的计数器用于记录该体素被观测为空闲状态的次数，每次在体素遍历期间，当被观测为空闲状态时，将其递增1；如果其值大于1，并且在体素遍历期间观测到体素被占用，则将其减1。</p><p>为了理解原理，考虑两个场景：</p><ol type="1"><li><p>第一个情况是体素的空闲计数器值&gt;1，并且插入当前帧点云时，观测到这个体素是占用状态，由于空闲计数器值&gt;1，这表明这个体素先前被记录为空闲，因此该体素很有可能被当前帧点云中的动态对象所占用，因此，我们通过将体素的命中值概率除以空闲计数器值来减轻概率更新，如公式（2）所示，这个策略的动机是：其难以增加先前已经被观测为空闲的体素的占用概率。 体素的空闲计数器值越高，则增加体素的占用概率就越难。</p></li><li><p>第二种情况是由于对象检测方法的错误检测导致体素被错误地标记为已占用，在这种情况下，我们使用原始公式（1）。 这使得属于动态点的体素易于更新状态。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从点云中删除动态对象的稳健方法&quot;&gt;从点云中删除动态对象的稳健方法&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-09-49.png&quot;&gt;&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LiTAMIN</title>
    <link href="http://yoursite.com/2021/01/29/LiTAMIN%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/01/29/LiTAMIN%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-01-29T03:05:30.000Z</published>
    <updated>2021-03-05T07:38:59.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="litamin-lidar-based-tracking-and-mapping-by-stabilized-icp-for-geometry-approximation-with-normal-distributions">LiTAMIN: LiDAR-based Tracking And MappINg by Stabilized ICP for Geometry Approximation with Normal Distributions</h1><p><img src="https://chevereto.epsilonjohn.club/images/2021/03/05/20210305145257.png"></p><h1 id="摘要">摘要</h1><p>提出一种3D SLAM方法，采用一种使用正态分布集群来局部近似几何体的icp算法，与基于正太分布的icp，GICP等方法相比，提出的icp方法通过使用<span class="math inline">\(Frobenius\)</span>范数以及正规化的协方差矩阵简单地稳定了cost func的规范形式。</p><p>过去的方法使用pca来进行stabilize，其计算成本高于提出的方法，并且，提出的slam方法可以减少错误的闭环带来的影响.</p><h1 id="提出的icp">提出的icp</h1><p>在SLAM系统中，这需要实时处理，ICP方法必须平衡精度和鲁棒性以获得计算效率, 减少3D点的数量是提高计算效率最有效的解决方案之一。任何基于ICP的SLAM系统[9]，[17] - [20]经常使用具有体素网格和正常分布的ICP方法，因为它们可以降低计算成本，同时仍然保持足够的几何信息。 其中，NDT [17]和GICP [9]是最流行的方法</p><p><img src="https://chevereto.epsilonjohn.club/images/2021/03/05/20210305152132.png"></p><h2 id="地图表示和点关联">地图表示和点关联</h2><p>Voxel网格或K-D树用于地图表示和关联搜索,Voxel网格表示具有计算效率的优势，因为体素数量明显低于原始点云中的点数.</p><p>关于相应点查找方面，K-D树表示可以找到具有最近邻居（NN）搜索的关联点，而Voxel网格表示没有保证NN搜索</p><p>关于计算成本方面，voxel具有优势，计算成本是O(n)；而k-d树是O(n log n )</p><p>提出的LiTAMIN系统结合两种方式，使用voxel 滤波器来减少点数，每个voxel代表一个点，该点表示voxel的质心, 地图也采用voxel来表示，用于减少点数并看起来密度更加均匀。</p><h2 id="cost-func-和-退化情况避免">Cost func 和 退化情况避免</h2><p>LITAMIN采用了一个由正态分布近似局部几何的ICP，应该应对协方差矩阵的退化关系, 如果局部几何形状是平面，则协方差矩阵的最小特征值为0或极小 ，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;litamin-lidar-based-tracking-and-mapping-by-stabilized-icp-for-geometry-approximation-with-normal-distributions&quot;&gt;LiTAMIN: LiDAR-base
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第二章-相机模型与对极几何</title>
    <link href="http://yoursite.com/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/"/>
    <id>http://yoursite.com/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/</id>
    <published>2021-01-24T04:05:29.000Z</published>
    <updated>2021-01-24T09:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="成像原理与图像特征">成像原理与图像特征</h1><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-11-55-55.png"></p><h2 id="针孔相机模型">针孔相机模型</h2><p>外参矩阵： 世界坐标系与相机坐标系</p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-11-58-39.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-11-59-52.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-01-57.png"></p><blockquote><p>相机朝向就是外参矩阵中的旋转矩阵第三行</p></blockquote><p>内参矩阵：</p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-03-23.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-48-28.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-48-49.png"></p><p>小结：</p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-49-34.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-51-10.png"></p><h2 id="径向畸变">径向畸变</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-52-01.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-53-04.png"></p><h1 id="对极几何">对极几何</h1><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-24-34.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-26-00.png"></p><h2 id="八点法求基础矩阵">八点法求基础矩阵</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-31-43.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-32-27.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-34-01.png"></p><h2 id="ransac求基础矩阵">RANSAC求基础矩阵</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-39-38.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-42-02.png"></p><h3 id="ransac拟合直线举例">ransac拟合直线举例</h3><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-42-26.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-42-49.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-43-00.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-43-10.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-43-41.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-45-32.png"></p><h3 id="ransac估计基础矩阵流程">ransac估计基础矩阵流程</h3><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-47-19.png"></p><h2 id="本征矩阵e">本征矩阵E</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-49-30.png"></p><h3 id="本质矩阵e恢复相机运动四种情况">本质矩阵E恢复相机运动（四种情况）</h3><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-51-03.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-55-41.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-59-47.png"></p><blockquote><p>H矩阵有效的情况：<br>(1) 空间点都在同一平面上<br>(2) 相机运动只有旋转</p></blockquote><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-17-01-02.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-17-01-47.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;成像原理与图像特征&quot;&gt;成像原理与图像特征&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BaiDu-考虑lio的定位</title>
    <link href="http://yoursite.com/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-01-20T03:34:33.000Z</published>
    <updated>2021-01-21T08:03:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lidar-inertial-odometry-aided-robust-lidar-localization-system-in-changing-city-scenes">LiDAR Inertial Odometry Aided Robust LiDAR Localization System in Changing City Scenes</h1><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-20-08-42-25.png"></p><h1 id="摘要">摘要</h1><p>提出一种将激光惯性里程计(LIO)和激光扫描配定位模块进行整合，然后将两种观测融入到pose graph中进行联合优化的框架。基于激光扫描的global matching和 lio是互补的，这使的可以达到鲁棒的定位，以解决环境的短暂变化以及地图的误差问题，如图1所示。</p><p>本文贡献：</p><ul><li>一种车辆定位的联合框架，可自适应融合激光扫描匹配和局部里程计，从而有效保护定位系统，使其免受城市场景变化的影响</li><li>一种LIO方法，并结合了占据栅格和激光强度</li><li>每天在拥挤繁忙的城市街道上经过严格测试的强大车辆定位系统，证明了其在充满挑战和动态变化的环境中的强大能力</li></ul><h1 id="相关工作">相关工作</h1><h2 id="长期定位long-term-localization">长期定位（Long-term Localization）</h2><p>建立一个7天24小时的全天候定位系统是一项艰巨的任务，近年来受到了极大的关注。文献[6]表明，可以通过归一化每一帧的LiDAR扫描的亮度和标准偏差来调整由潮湿路面引起的较少反射率。文献[2][3]通过在地图中引入<strong>多分辨率高斯混合</strong>表示法，展示了一种强大的LiDAR定位系统，该系统可以通过道路翻修和降雪环境下运行。文献[5]，LiDAR定位系统<strong>通过结合高度信息</strong>成功地通过了具有挑战性的路段，其中包括新建的墙壁和重新铺设的道路。文献[4]通过引入<strong>主成分分析（PCA）</strong>和<strong>边缘轮廓</strong>来增强其定位系统的鲁棒性，尤其是在下雨天或下雪天时。</p><p>这些工作着重于利用利基技术解决特定问题，但我们力图通过将里程表和全局匹配模块中的补充线索自适应地融合在一起，从而寻求更通用的解决方案。</p><p>其他工作如[7,8,9,10,11]解决了类似的长期定位问题，但使用的视觉传感器对时间，光线或天气导致的场景外观变化敏感。</p><h2 id="激光惯性里程计lidar-inertial-odometry">激光惯性里程计（LiDAR Inertial Odometry）</h2><p>目前有大量关于激光里程计的工作，如[12,13,14,15,16,17,18,19,20,21,22,23,24]。如[14],[18],[17],[17]，惯性测量可通过提供先验估计并补偿运动失真来帮助解决问题。[18]构建更加紧密的局部运动约束，[23],[24]进一步建立紧密耦合的里程表。</p><p>在这项工作中，我们遵循Hess的工作[13]，并将基于占用栅格的LiDAR惯性里程表集成到我们的定位框架中，因为它的地图表示与我们的全局匹配模块相似，并且与多个激光扫描仪兼容</p><h2 id="融合定位方法">融合定位方法</h2><p>一类重要的是松耦合融合方法[25]，[5]，[26]利用误差状态卡尔曼滤波器并通过不同方法实现了松耦合的位姿估计。类似于[26]，我们的方法不是使用卡尔曼滤波器，而是利用基于图的融合框架，该框架以每单位计算时间的精度更高的性能优于滤波方法[27]，[28]。[29]展示了融合GNSS，LiDAR和惯性测量的紧密耦合导航系统。</p><h1 id="系统框架">系统框架</h1><p>提出的系统包含四个模块：LiDAR惯性里程计（LIO），LiDAR全局匹配（LGM），基于姿态图的融合（PGF）和环境变化检测（ECD），如图2所示。</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-20-09-06-51.png"></p><p>我们遵循G. Wan[5]等人的最新LiDAR定位工作来构建系统，并在我们的框架中将其作为子模块LGM。LGM模块是一种global定位方法，可将在线LiDAR扫描与预先构建的地图进行匹配，并进行3 DoF（x，y，yaw）估计，一旦我们成功地水平定位，就可以通过读取IMU重力测量值和数字高程模型（DEM）地图来估算其他3个自由度（侧倾，俯仰，高度）。</p><p>其他两个模块是，LIO和PGF，根据解决不同的最大后验概率（MAP）估计问题来实现。</p><p>最大后验概率（MAP）估计问题通常是在滑动窗口下定义的非线性优化问题，设<span class="math inline">\(\kappa\)</span>记为窗口中的所有帧集合</p><ul><li>滑动窗口中的状态<span class="math inline">\(\mathcal{X}=\left\{\mathbf{x}_{k}\right\}_{k \in \mathcal{K}}\)</span></li><li>观测集合分别记为<span class="math inline">\(\mathcal{Z}=\left\{\mathbf{z}_{k}\right\}_{k \in \mathcal{K}}\)</span></li><li>第k帧的状态<span class="math inline">\(\mathbf{x}_{k}=\left[\boldsymbol{\omega}_{k}, \mathbf{t}_{k}, \mathbf{v}_{k}, \mathbf{b}_{k}\right]\)</span>分别表示旋转、位置、速度和bias，其中<span class="math inline">\(\omega_k\)</span>是李代数中的<span class="math inline">\(so(3)\)</span>，即有<span class="math inline">\(R_k=\exp(\omega_k)\)</span>。</li></ul><h2 id="提出的lio框架">提出的LIO框架</h2><p>LiDAR惯性里程计在我们的系统中起着至关重要的作用，可在严峻的环境（例如，由于道路建设或恶劣天气导致的地图过期或环境变化）中提高定位性能。其中，激光里程计估计相邻帧的相对位姿变换，同时<strong>构建局部地图，称为子图</strong>，该子图始终是最新的，并且随着每个新的LiDAR SCAN不断更新。</p><p>我们的LiDAR惯性里程计的实现遵循W. Hess的工作[13] （注：cartographer），但有许多重要的扩展可提高其准确性。</p><ul><li>使用了3d占据栅格来代替2d，来实现6自由度的里程计，这种扩展可将系统应用到3维环境中，如停车场结构或立交桥，同时简化了下面提到的imu预积分</li><li>重要的惯性测量数据被合并以提供运动预测和帧之间的相对约束，更重要的是，惯性测量的结合使我们能够对由载体运动引起的扭曲的LiDAR扫描进行运动补偿，为了控制计算时间，我们在实现中采用了[30]<strong>引入的惯性测量值的预积分</strong></li><li>考虑到某些情况下来自车道或者路面标记的丰富信息，在占据栅格配准过程中整合了激光强度信息，用来补充每个网格单元的占用概率，它提供了有价值的环境纹理信息</li><li>最后，通过将多分辨率的占据栅格来实现求解非线性优化问题中的从粗到精细化的方法，它不仅有助于网格配准的收敛，而且可以避免计算需求</li></ul><p>LIO问题描述：在给定先前的状态<span class="math inline">\(x_{k-1}^L\)</span>、使用k-1帧更新后的子图<span class="math inline">\(\mathcal{S}_{k-1}\)</span>以及观测<span class="math inline">\(z_k\)</span>，求状态<span class="math inline">\(x_{k}^L\)</span>的最大后验概率。</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-24-22.png"></p><p>其中，<span class="math inline">\(\mathbf{z}_{k}=\left\{\mathbf{z}_{k}^{P}, \mathbf{z}_{k}^{I}\right\}\)</span>，<span class="math inline">\(\mathbf{z}_{k}\)</span>和<span class="math inline">\(\mathbf{z}_{I}\)</span>分别是点云和惯性测量的观测，上标<span class="math inline">\(L\)</span>表示由子图和里程计表示的局部帧的状态<span class="math inline">\(\mathbf{x}_{k}^L\)</span>.</p><p>在零均值高斯似概率的假设下，观测的似然概率通过构建cost func来定义：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-29-59.png"></p><p>其中，<span class="math inline">\(\|\mathbf{r}\|_{\Lambda}^{2}=\mathbf{r}^{T} \Lambda^{-1} \mathbf{r}\)</span>，并且有：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-31-20.png"></p><p>其中，</p><ul><li>等式(2)根据imu预积分方法计算，可参考文献<a href="On-manifold%20preintegration%20for%20real-time%20visual–inertial%20odometry">30</a></li><li>等式(3)中的<code>SSOP</code> （Sum of Squared Occupancy Probability）和<code>SSID</code>（Sum of Squared Intensity Difference）分别代表占用栅格概率和LiDAR强度损失，其定义如下：</li></ul><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-38-14.png"></p><p>给定一个激光点<span class="math inline">\(\mathbf{p}_j \in \R^3\)</span>，一个分辨率为<span class="math inline">\(i\)</span>的子图以及一个位姿状态<span class="math inline">\(\mathbf{x}_{k}^{L}=\left[\mathrm{R}_{k}, \mathbf{t}_{k}\right]\)</span>，子图中被击中的单元<span class="math inline">\(s\)</span>可以被找到。<span class="math inline">\(P(s)\)</span>是在分辨率i下击中子图的占用概率，这个占用概率的维持是通过以最大化后验概率<span class="math inline">\(P\left(\mathbf{x}_{k}^{L} \mid \mathbf{z}_{k}, \mathbf{x}_{k-1}^{L}, \mathcal{S}_{k-1}\right)\)</span>的方法不断的将新的激光雷达扫描插入到子图中。</p><p>这个增量式升级问题可以通过使用<code>inverse measurement</code>模型以及[31]中引入的<code>log adds ratio</code> 的二进制贝叶斯滤波器来解决。</p><p><span class="math inline">\(I(\mathbf{p}_j)\)</span>是点<span class="math inline">\(\mathbf{p}_j\)</span>的强度，<span class="math inline">\(u_s\)</span>和<span class="math inline">\(\sigma_s\)</span>是击中单元的激光强度均值和方差，（注：归一化到标准正态分布）。为了更好的确保配准性能，采用了三次插值从子图中获得概率和强度。方差<span class="math inline">\(\sigma_{Oi}\)</span>和<span class="math inline">\(\sigma_{ri}\)</span>用于在不同分辨率下对优化中的占据概率和强度项分别进行加权。</p><blockquote><p>MAP估计值与负对数后验的最小值相对应，后者可以写为残差平方的总和，从而产生非线性最小二乘优化问题</p></blockquote><h2 id="位姿图融合">位姿图融合</h2><p>虽然LiDAR惯性里程计可以在局部坐标系中提供良好的相对约束，但我们仍然需要全局约束才能实现全局定位，baidu-LGM模块为我们的系统提供了全局定位信息，我们的LGM遵循[5].</p><p>将此融合问题公式化为MAP估计，并假设先验分布具有统一形式，将后验概率分解为:</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-09-03.png"></p><p>分解可以可视化为如图3所示的贝叶斯网络。在零均值高斯似概率的假设下，观测的似然概率如下：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-10-27.png"></p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-10-49.png"></p><p>其中，<span class="math inline">\(\mathbf{r}_{k s}^{O}\)</span>、<span class="math inline">\(\mathbf{r}_{k}^{I}\)</span>、<span class="math inline">\(\mathbf{r}_{k}^{G}\)</span>分别代表里程计、惯性测量、全局匹配的残差。</p><p>坐标系定义如下：</p><ul><li>Local Frame: 局部坐标系，如使用utm投影，再划分，以某个位置作为原点</li><li>Global Frame: 全局坐标系，utm/wgs-84等</li><li>Submap Pose: 子图相对于局部坐标系的位姿</li><li>Lidar Local Frame: 激光雷达坐标系相对于局部坐标系的位姿</li></ul><p>如果定义如下：</p><ul><li>某帧相对于局部坐标系的位姿（待估计位姿）：<span class="math inline">\(\mathbf{x}_{k}^{L}=\left[\mathrm{R}_{k}^{L},\mathbf{t}_{k}^{L}\right]\)</span></li><li>局部坐标系到全局坐标系的变换（应该是已知的）：<span class="math inline">\(\mathbf{x}_{L}^{G}=\left[\mathrm{R}_{L}^{G}, \mathbf{t}_{L}^{G}\right]\)</span></li><li>由[5]中的LGM模块输出的全局位姿观测<span class="math inline">\(\mathbf{z}_{k}^{G}=\left[\mathrm{R}_{k}^{G}, \mathbf{t}_{k}^{G}\right]\)</span></li><li>全局残差可用如下表示： <span class="math inline">\(\left(\mathbf{r}_{k}^{G}\right)^{T}=\left[\log ^{T}\left(\mathrm{R}_{r G}\right), \mathbf{t}_{r G}^{T}\right]\)</span>，其中：</li></ul><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-26-37.png"></p><p>关于全局残差的协方差<span class="math inline">\(\Lambda_{k}^{G}\)</span>，我们将其写为：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-29-55.png"></p><p>其中，</p><ul><li><span class="math inline">\(\Lambda^{G_\omega} \in \R^{3\times3}\)</span>是旋转协方差</li><li><span class="math inline">\(\Lambda^{G_{z}} \in \mathbb{R}^{1 \times 1}\)</span>是高度方差</li><li>上述协方差矩阵是恒定的对角矩阵，因为我们的LGM模块仅使用[5]中讨论的2D直方图滤波器来估计水平定位的不确定性</li><li>如[5]中的等式12所示，相应地针对每个帧k计算水平匹配协方差矩阵<span class="math inline">\(\Lambda_{k}^{G_{h}} \in \mathbb{R}^{2 \times 2}\)</span></li></ul><blockquote><p>注意，此处介绍的不确定性估计对于定位系统的性能至关重要，从而产生自适应融合</p></blockquote><p>关于里程计的残差问题，将会采用随着激光里程计的运行终结旧的子图更新并且创建新的子图。</p><p>由LIO模块输出的载体局部位姿与子图的之间的相对位姿关系约束<span class="math inline">\(\mathbf{z}_{ks}^O\)</span>被构建并存在于滑动窗口的生命周期中。相似的，如果由如下定义：</p><ul><li>某个子图的位姿:<span class="math inline">\(\mathbf{x}_{s}^{S}=\left[\mathrm{R}_{s}^{S}, \mathbf{t}_{s}^{S}\right]\)</span></li><li>某帧相对于子图的位姿观测: <span class="math inline">\(\mathbf{z}_{k s}^{O}=\left[\mathrm{R}_{k s}^{O}, \mathbf{t}_{k s}^{O}\right]\)</span></li><li>里程计残差可定义为： <span class="math inline">\(\left(\mathbf{r}_{k s}^{O}\right)^{T}=\left[\log ^{T}\left(R_{r O}\right), \mathbf{t}_{r O}^{T}\right]\)</span></li></ul><p>其中，</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-14-54-18.png"></p><p>根据里程残差中的协方差<span class="math inline">\(\Lambda^O\)</span>，假设估计不确定性在所有帧之间均匀分布，我们在所有帧和子图上使用全局常数对角矩阵</p><p>惯性约束的预积分的处理方法与[30]中介绍的相同。 使用Ceres解算器[32]求解非线性最小二乘优化。</p><h1 id="实验">实验</h1><h2 id="传感配置">传感配置：</h2><ul><li>Velodyne HDL- 64E 360◦LiDAR</li><li>NovAtel PwrPak7D-E1 GNSS RTK receiver integrated with dual antennas and an Epson EG320N IMU.</li></ul><h2 id="基准参考">基准参考：</h2><p>没有用rtk，用的啥离线slam方法？</p><blockquote><p>The ground truth poses used in the evaluation are generated using offline LiDAR SLAM methods typically formulated as a large-scale global least-square optimization problem, which are beyond the scope of this work.</p></blockquote><h2 id="运行速度分析">运行速度分析</h2><ul><li>lio、pose graph fuse 运行在CPU上</li><li>全局激光匹配运行在FPGA上</li></ul><p> <img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-16-01-23.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lidar-inertial-odometry-aided-robust-lidar-localization-system-in-changing-city-scenes&quot;&gt;LiDAR Inertial Odometry Aided Robust LiDAR L
      
    
    </summary>
    
    
      <category term="文献阅读" scheme="http://yoursite.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>CUDA编程</title>
    <link href="http://yoursite.com/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/</id>
    <published>2020-12-24T14:05:33.000Z</published>
    <updated>2021-02-11T10:10:50.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gpu硬件架构综述">GPU硬件架构综述</h1><h2 id="fermi-gpu">Fermi GPU</h2><p><img src="/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-05-29.png"></p><h2 id="相关术语">相关术语</h2><p><img src="/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-07-19.png"> <img src="/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-12-01.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gpu硬件架构综述&quot;&gt;GPU硬件架构综述&lt;/h1&gt;
&lt;h2 id=&quot;fermi-gpu&quot;&gt;Fermi GPU&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-05-29.png&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第六章-(1)-基于预积分的建图方法</title>
    <link href="http://yoursite.com/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/</id>
    <published>2020-12-21T00:36:46.000Z</published>
    <updated>2020-12-24T14:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于预积分优化的建图方法">基于预积分优化的建图方法</h1><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-45-26.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-48-29.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-51-20.png"></p><h1 id="预积分模型推导">预积分模型推导</h1><h2 id="导航方程">导航方程</h2><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-55-22.png"></p><h2 id="连续时间的预积分计算">连续时间的预积分计算</h2><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-58-03.png"></p><h2 id="离散时间的预积分计算中值积分">离散时间的预积分计算（中值积分）</h2><h3 id="预积分量的计算">预积分量的计算</h3><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-00-36.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-02-48.png"></p><h3 id="预积分的更新">预积分的更新</h3><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-06-09.png"></p><h3 id="预积分的方差传递">预积分的方差（传递）</h3><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-09-50.png"></p><h4 id="姿态误差微分方程推导">姿态误差微分方程推导</h4><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-19-27.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-22-17.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-26-22.png"></p><blockquote><p>这是定义在local的误差角</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于预积分优化的建图方法&quot;&gt;基于预积分优化的建图方法&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>LiLi-om论文阅读</title>
    <link href="http://yoursite.com/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-12-09T03:34:33.000Z</published>
    <updated>2020-12-09T14:56:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="towards-high-performance-solid-state-lidar-inertial-odometry-and-mapping">Towards High-Performance Solid-State-LiDAR-Inertial Odometry and Mapping</h1><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-11-35-01.png"></p><blockquote><p>IN2LAAMA: Inertial Lidar Localization Autocalibration and Mapping. 用预积分去畸变，可以参考</p></blockquote><h1 id="系统架构">系统架构</h1><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-20-57-17.png"></p><ul><li>10hz激光雷达</li><li>Xsens MTi-670 200Hz imu</li></ul><ol type="1"><li>首先使用陀螺仪对点云去畸变（旋转）</li><li>提取平面、边缘线特征</li><li>基于点-线、点-面距离，进行scan-matching，求出相对运动后进一步对点云去畸变（平移）</li><li>选择关键帧策略</li><li>滑动窗口优化</li></ol><p>融合窗口通常包含了几个关键帧，当窗口滑动时，将对窗口内的关键帧状态进行优化，</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-21-03-30.png"></p><p>其中,</p><ul><li><span class="math inline">\(\breve{x}_k , \breve{q}_k\)</span>表示关键帧位姿</li><li><span class="math inline">\(\breve{v}_k\)</span>表示速度</li><li><span class="math inline">\(\breve{b}_k = [\breve{b}_{k,a}^T,\breve{b}_{k,g}^T]^T\)</span>表示imu的bias</li></ul><p>最终，维护一个全局的位姿图，对所有的lidar关键帧位姿进行整合</p><h1 id="特征点提取">特征点提取</h1><blockquote><p>这里关于Livox激光雷达的特征提取</p></blockquote><p>提出出来的边缘线特征和平面特征对前端里程计以后后端滑动窗口都有用</p><p>为了量化传感器融合过程中每个LiDAR残差的贡献，根据关联质量提出了度量加权函数，如下：</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-21-18-15.png"></p><p>其中，</p><ul><li><span class="math inline">\(o\)</span>表示特征（e表示边缘，s表示平面）</li><li>对于边缘线特征，<span class="math inline">\(\nu_e, n_e\)</span>分别表示在<span class="math inline">\(p_k^l\)</span>处的边缘线的方向向量，和最近5个边缘点特征所近似得到的边缘线</li><li>对于平面特征，<span class="math inline">\(\nu_s,n_s\)</span>分别表示在点<span class="math inline">\(p_k^l\)</span>处的平面法向量和由最近5个点形成的</li><li><span class="math inline">\(\gamma(p_k^l),\gamma_j\)</span>分别代表特征点<span class="math inline">\(p_k^l\)</span>及其关联的最近5个特征点的关联值</li></ul><p>因此，建议的度量加权函数考虑了特征关联的几何和外观一致性</p><h1 id="基于关键帧的imu-lidar紧耦合滑动窗口优化">基于关键帧的imu-lidar紧耦合滑动窗口优化</h1><p>基于关键帧的策略首先应用于视觉slam，LIO-SAM，使用isam2对前端激光前端里程计的关键帧和imu预积分约束进行融合，liom中紧密耦合的LiDAR惯性里程计系统通过滑动窗口优化实现了LiDAR和预集成IMU测量的直接融合，但是实时性不够，因为融合了每一帧lidar扫描</p><h2 id="关键帧策略">关键帧策略</h2><p>因此，保持后端直接LiDAR-惯性融合优化方案的稀疏性非常重要，如图5所示，提出的融合方案利用关键帧建立滑动窗口，其中，激光雷达和imu预积分观测使用非线性优化的方法进行融合。</p><p>但是关键帧的选取标准会影响前端里程计的准确性，由于imu积分在相邻两关键帧之间存在漂移，因此，提出了两个准则：</p><ul><li>当前帧的特征与局部特征地图重叠率&lt;60%</li><li>如果最后一个关键帧的时间差大于指定阈值</li></ul><p>在窗口优化后向前滑动时，构造一个局部因子图，对两个最旧的关键帧位姿作为约束，而regular-frame帧位姿则通过imu测量作为初始化值。使用一个小规模的因子图优化以获取与激光雷达采样频率一致的regular-frame位姿</p><h2 id="滑动窗口">滑动窗口</h2><p>目标是求解式(1)中的滑动窗口内关键帧状态，方法是通过求解激光特征点和imu预积分约束构成的非线性优化问题，使用一个包含三个分量的最大后验(MAP)目标函数：</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-21-47-49.png"></p><p>其中，</p><ul><li><span class="math inline">\(\breve{X}=[\breve{x}_1^T,\cdots,\breve{x}_2^T]^T \in \R^{15\times \tau_w}\)</span>表示滑动窗口中的关键帧状态，<span class="math inline">\(\tau_w\)</span>表示滑窗大小</li><li><span class="math inline">\(\mathcal{R}_{p}(\breve{X})\)</span>表示由于滑动窗口滑动时进行marginalized得到的关于观测的先验项</li><li><span class="math inline">\(\mathcal{R}_L(\breve{x}_k^w,\breve{p}_{k,i}^l,\breve{\Mu}^w)\)</span>表示激光雷达残差项（根据待估计的关键帧位姿<span class="math inline">\(\breve{x}_k^w\)</span>将观测到的点<span class="math inline">\(\breve{p}_{k,i}^l\)</span>对齐到局部特征点地图<span class="math inline">\(\breve{\Mu}^w\)</span>），m表示特征关联数</li><li>局部特征点地图<span class="math inline">\(\breve{\Mu}^w\)</span>结合了最近30帧关键帧观察到的特征</li><li><span class="math inline">\(\mathcal{R}_J(\breve{x}_k,\hat{z}_{k+1}^k)\)</span>是第k个关键帧以及imu数据从第k帧到k+1帧的imu预积分约束所构建的残差项</li></ul><h3 id="先验因子">先验因子</h3><p>为了在不造成实质性信息损失的情况下限制LiDAR惯性融合的计算负担，我们在基于关键帧的窗口中利用边缘化，vins-mono中，使用Schur-complement对最旧的关键帧及其观测进行边缘化，相应的计算得到一个新的先验，并将其添加到一存在的先验因子的顶部。</p><h3 id="激光雷达残差">激光雷达残差</h3><p>加权的点-线、点-面距离</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-22-36-30.png"></p><h3 id="imu观测残差预积分误差">imu观测残差（预积分误差）</h3><p>为了避免每次优化窗口滑动时都重新传播IMU状态，所以将两个连续的关键帧k和k+1之间的imu原始数据进行积分，并将预积分看作是两个关键帧之间的相对位姿观测，可以得到预积分误差：</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-22-38-47.png"></p><p>其中，</p><ul><li><span class="math inline">\(\Delta \tau_k\)</span>表示第k关键帧与k+1帧的时间间隔</li><li><span class="math inline">\([\cdot]_{2:4}\)</span>表示取四元数向量中的最后3个元素</li><li><span class="math inline">\(\hat{z}_{k+1}^{k}=[\hat{\alpha}_{k+1}^{kT},\hat{\beta}_{k+1}^{kT},\hat{\gamma}_{k+1}^{kT}]\)</span>表示从第k帧到第k+1帧的imu预积分量</li><li>由于篇幅所限，论文不提供IMU预积分的推导和相应的噪声协方差<span class="math inline">\(C_{k+1}^{k}\)</span>,具体可参考vins-mono</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;towards-high-performance-solid-state-lidar-inertial-odometry-and-mapping&quot;&gt;Towards High-Performance Solid-State-LiDAR-Inertial Odomet
      
    
    </summary>
    
    
      <category term="文献阅读" scheme="http://yoursite.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>LINS论文阅读</title>
    <link href="http://yoursite.com/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-12-07T12:52:33.000Z</published>
    <updated>2020-12-09T03:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lins-a-lidar-inertial-state-estimator-for-robust-and-efficient-navigation">LINS: A Lidar-Inertial State Estimator for Robust and Efficient Navigation</h1><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-20-54-00.png"></p><h1 id="eskf模型">ESKF模型</h1><p>坐标系定义：</p><ul><li><span class="math inline">\(\mathcal{F}_w\)</span>表示固定的世界坐标系</li><li><span class="math inline">\(\mathcal{F}_{bk}\)</span>表示第k个激光雷达时间步的imu坐标系</li><li><span class="math inline">\(\mathcal{F}_{lk}\)</span>表示第k个激光雷达时间步的lidar坐标系</li><li>local frame是指前一个激光雷达时间步的imu坐标系</li></ul><h2 id="状态定义">状态定义</h2><ul><li><span class="math inline">\(x_w^{bk}\)</span>表示<span class="math inline">\(\mathcal{F}_{bk}\)</span>坐标系到<span class="math inline">\(\mathcal{F}_w\)</span>世界坐标系的变换</li><li><span class="math inline">\(x_{bk+1}^{bk}\)</span>表示从<span class="math inline">\(\mathcal{F}_{bk+1}\)</span>坐标系到<span class="math inline">\(\mathcal{F}_{bk}\)</span>坐标系的变换</li></ul><p><span class="math display">\[    x_w^{bk} = [p_w^{bk},q_w^{bk}]\]</span></p><p><span class="math display">\[    x_{bk+1}^{bk} = [p_{bk+1}^{bk},v_{bk+1}^{bk},q_{bk+1}^{bk},b_a,b_g,g^{bk}]\]</span></p><h2 id="误差状态定义">误差状态定义</h2><p><span class="math display">\[    \delta x=[\delta p, \delta v ,\delta \theta, \delta b_a , \delta b_g ,\delta g]\]</span></p><p>根据误差状态卡尔曼，一旦<span class="math inline">\(\delta x\)</span>被估计出来，我们就可以获得最终的结果<span class="math inline">\(x_{bk+1}^{bk}\)</span>，通过向state nominal的<span class="math inline">\(^-x_{bk+1}^{bk}\)</span>注入误差状态<span class="math inline">\(\delta\)</span>，即：</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-11-39.png"></p><h2 id="状态传播预测">状态传播（预测）</h2><p>这一步进行如下参数的传播</p><ul><li>误差状态<span class="math inline">\(\delta x\)</span></li><li>误差状态协防差矩阵<span class="math inline">\(P_k\)</span></li><li>state nominal的<span class="math inline">\(^-x_{bk+1}^{bk}\)</span></li></ul><p>当新的imu测量到达，线性连续时间模型如下：</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-14-58.png"></p><p>其中，</p><ul><li><span class="math inline">\(w=[n_a^T,n_g^G,n_{ba}^T,n_{bg}^T]\)</span>，分别表示高斯噪声模型，与VINS-Mono一致</li><li><span class="math inline">\(F_t\)</span>是误差状态转移矩阵</li><li><span class="math inline">\(G_t\)</span>是噪声雅克比矩阵</li></ul><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-21-26.png"></p><blockquote><p>论文公式有误，详细可参考 误差状态卡尔曼P69——The error state Jacobian and perturbation matrices 式(311)</p></blockquote><p>其中，</p><ul><li><span class="math inline">\([\cdot]_{\times} \in \R^{3\times 3}\)</span>表示将3D向量转换成反对称矩阵</li><li><span class="math inline">\(R_t^{bk}\)</span>表示将k时刻的imu坐标系转换到<span class="math inline">\(\mathcal{F}_{bk}\)</span>坐标系的旋转</li><li><span class="math inline">\(\hat{a}^t,\hat{\omega}_t\)</span>表示去除bias以及(重力影响?)的加速度计输出和陀螺仪输出</li></ul><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-27-08.png"></p><p>对式(5)进行离散化，得到离散时间的传播方程(预测)</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-27-47.png"></p><p>其中,</p><ul><li><span class="math inline">\(\Delta_t=t_\tau-t_{\tau-1}\)</span></li><li><span class="math inline">\(t_\tau,t_{\tau-1}\)</span>是imu数据时间戳</li><li>Q表示噪声w的协方差矩阵，可以由离线的传感器参数标定获取</li></ul><h2 id="更新">更新</h2><blockquote><p>文章的主要贡献在此</p></blockquote><p>在iekf里面，更新步骤其实可以与优化问题建立关联：</p><blockquote><p>参考文献:</p><ul><li>A review of point cloud registration algorithms for mobile robotics.</li><li>Iterated extended kalman filter based visual-inertial odometry using direct photometric feedback.</li></ul></blockquote><p>即以误差状态作为待求解的变量<span class="math inline">\(\delta x\)</span></p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-39-00.png"></p><p>其中，</p><ul><li><span class="math inline">\(f(\cdot)\)</span>是残差函数，其输出是点——线、点——面距离的对叠向量</li><li><span class="math inline">\(||\cdot||\)</span>是马氏距离</li><li><span class="math inline">\(J_k\)</span>是残差函数<span class="math inline">\(f(\cdot)\)</span>对观测噪声的雅克比</li><li><span class="math inline">\(M_k\)</span>是观测噪声的协方差矩阵</li></ul><p>当给定一个<span class="math inline">\(x_{bk+1}^{bk}\)</span>，<span class="math inline">\(f(\cdot)\)</span>中关于点<span class="math inline">\(p_i^{lk+1}\)</span>（<span class="math inline">\(\mathcal{F}_{lk+1}\)</span>坐标系中的第i个点）的误差项可以描述如下:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-45-57.png"></p><blockquote><p>就是LOAM的距离计算公式</p></blockquote><p>然后有:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-47-18.png"></p><p>其中,</p><ul><li><span class="math inline">\(\hat{p}_i^{lk}\)</span>表示将点<span class="math inline">\(p_i^{lk+1}\)</span>从<span class="math inline">\(\mathcal{F}_{lk+1}\)</span>坐标系转换到<span class="math inline">\(\mathcal{F}_{lk}\)</span>坐标系后的点</li><li><span class="math inline">\(R_l^b,p_l^b\)</span>表示激光雷达到imu的外參(可离线标定获取)</li></ul><p>关于式(13)的物理解释是：对于一个边缘线上的点，它描述了点<span class="math inline">\(\hat{p}_i^{lk}\)</span>到与他相关联的边缘线<span class="math inline">\(p_a^{lk}p_b^{lk}\)</span>，对于平面点，同理 (就是LOAM嘛)</p><p>然后使用iekf来求解式(12)所描述的优化问题:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-52-01.png"></p><p>其中，</p><ul><li><span class="math inline">\(\Delta x_j\)</span>表示在第j次迭代的矫正，即求解出来的增量</li><li><span class="math inline">\(H_{k,j}\)</span>表示<span class="math inline">\(f(^-x_{bk+1}^{bk}\boxplus\delta x_j)\)</span>关于<span class="math inline">\(\delta x_j\)</span>的雅克比</li></ul><blockquote><p>注意到，在每一次迭代中，将重新关联边缘线特征和平面特征，这样就可以重新计算<span class="math inline">\(H_{k,j},J_{k,j}和K_{k,j}\)</span>，相当于更新线性化点，重新关联特征</p></blockquote><p>当<span class="math inline">\(f(x_{bk+1}^{bk})\)</span>降低到一个特定的阈值，就对协方差<span class="math inline">\(P_k\)</span>进行更新，结束迭代</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-22-10-58.png"></p><p>使用式(4)，即可获取到最终的结果<span class="math inline">\(x_{bk+1}^{bk}\)</span>，然后还可以进行去畸变操作。</p><p>最后，可以对下一个状态<span class="math inline">\(x_{bk+2}^{bk+1}\)</span>进行初始化:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-22-18-51.png"></p><p>其中，</p><ul><li><span class="math inline">\(q_0\)</span>表示单位四元数</li><li><span class="math inline">\(v_{bk+1}^{bk+1}=R_{bk}^{bk+1}v_{bk+1}^{bk}\)</span></li><li><span class="math inline">\(g^{bk+1}=R_{bk}^{bk+1}g^{bk}\)</span></li></ul><p>注意到，在协方差矩阵中，速度、bias、重力都保持，而其他关于相对位姿的项都被置零，因为相对于自身坐标系没有不确定性.</p><h2 id="状态补偿">状态补偿</h2><p>每一个更新步完成，需要对全局位姿<span class="math inline">\(x_w^{bk}\)</span>进行更新，如下:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-22-37-02.png"></p><h2 id="初始化">初始化</h2><ul><li>初始加速度bias，Lidar-imu外參都通过离线标定获取</li><li>初始的陀螺仪bias通过求均值获取</li><li>初始roll和pitch在运动之前可通过去除bias的加速度计算得到</li><li>初始的重力向量使用前面获取的roll和pitch将导航坐标系的重力向量转换到载体坐标系(imu系)获取</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lins-a-lidar-inertial-state-estimator-for-robust-and-efficient-navigation&quot;&gt;LINS: A Lidar-Inertial State Estimator for Robust and Eff
      
    
    </summary>
    
    
      <category term="文献阅读" scheme="http://yoursite.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章-(3)-补充内容</title>
    <link href="http://yoursite.com/2020/12/07/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-3/"/>
    <id>http://yoursite.com/2020/12/07/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-3/</id>
    <published>2020-12-07T04:36:46.000Z</published>
    <updated>2020-12-07T07:35:06.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>IMU噪声模型</title>
    <link href="http://yoursite.com/2020/11/27/IMU%E7%9B%B8%E5%85%B3/IMU%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/11/27/IMU%E7%9B%B8%E5%85%B3/IMU%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-11-27T05:05:29.000Z</published>
    <updated>2020-11-27T05:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kalibr">Kalibr</h1><p>Kalibr使用的IMU观测模型包含两种误差：</p><ul><li><code>n</code>，白噪声（波动较快）</li><li><code>b</code>，缓慢变化的bias</li></ul><p>因此，以陀螺仪为例子，角速度测量可写成：</p><p><span class="math display">\[    \tilde{\omega}(t) = \omega(t) + b(t) +n(t)\]</span></p><h2 id="附加白噪声">附加白噪声</h2><h3 id="连续时间">连续时间</h3><p>可以使用<code>零均值</code>、<code>独立</code>、<code>连续时间</code>的高斯白噪声来描述，即</p><p><span class="math display">\[ E[n(t)] =0\]</span></p><p><span class="math display">\[ E[n(t_1)n(t_2)]=\sigma_g^2 \delta(t_1-t_2)\]</span></p><ul><li><span class="math inline">\(\sigma_g\)</span>越大，表明陀螺仪测量越<code>嘈杂</code></li><li>这是连续时间的模型</li></ul><h3 id="离散化时间">离散化时间</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kalibr&quot;&gt;Kalibr&lt;/h1&gt;
&lt;p&gt;Kalibr使用的IMU观测模型包含两种误差：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;，白噪声（波动较快）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;，缓慢变化的bias&lt;/li&gt;
&lt;/ul&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="IMU相关" scheme="http://yoursite.com/categories/IMU%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
</feed>
