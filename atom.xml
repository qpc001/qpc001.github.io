<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EpsilonJohn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2024-01-24T12:47:45.057Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EpsilonJohn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【nuScene】Synthetic 2D LIDAR for Precise Vehicle Localization in 3D Urban Environment</title>
    <link href="http://yoursite.com/2024/01/24/nuScene%E5%AE%9A%E4%BD%8D%E8%AE%BA%E6%96%87/"/>
    <id>http://yoursite.com/2024/01/24/nuScene%E5%AE%9A%E4%BD%8D%E8%AE%BA%E6%96%87/</id>
    <published>2024-01-24T11:30:30.000Z</published>
    <updated>2024-01-24T12:47:45.057Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synthetic-2d-lidar-for-precise-vehicle-localization-in-3d-urban-environment">Synthetic 2D LIDAR for Precise Vehicle Localization in 3D Urban Environment</h1><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706095909-0.png"></p><h1 id="摘要">摘要</h1><p>本文提出了一种精确的三维城市环境中车辆定位算法，该算法只有一个二维激光雷达和里程计信息。提出了一种新的合成二维激光雷达思想来解决虚拟二维平面上的定位问题。基于合成激光雷达测量和里程计信息，采用蒙特卡罗定位方案进行车辆位置估计。通过在NUS校园区域内1.5公里的驾驶测试中进行实时定位，证明了该算法的精度和鲁棒性。</p><h1 id="介绍">介绍</h1><p>本文提出了一种新的合成激光雷达概念，以二维的方式解决三维定位问题。合成激光雷达是由3D滑动窗口中提取的兴趣点来实时构建的。基本假设是城市环境中的许多平面在垂直方向上是直线的。从直线表面提取兴趣点，然后投影到虚拟水平面上，形成合成激光雷达。合成激光雷达作为世界三维环境和虚拟化的水平二维平面之间的桥梁。利用合成激光雷达的思想，二维定位算法可以很容易地适应三维问题。本文提出了一种基于合成激光雷达的蒙特卡罗定位算法，并通过实验验证了该算法的准确性和鲁棒性。</p><p>本文的其余部分组织如下。第二部分讨论了将3D世界投射到2D平面的想法，并给出了定位系统的概述。第三节介绍了合成激光雷达的构成。定位算法见第四节，实验结果及分析见第五节。</p><h1 id="虚拟平面上的定位">虚拟平面上的定位</h1><h2 id="将3d世界投影到2d平面">将3D世界投影到2D平面</h2><p>机器人在平面上的定位已经研究了几十年，提出了许多算法。二维扫描匹配算法由于其准确性和鲁棒性可能是最受欢迎的选择[27]。然而，它不能直接应用于在3D世界中移动的车辆。由于室外道路有时非常崎岖，平面激光雷达的激光点可能会投射到路面上，而不是像[2]中所讨论的那样投射到所需的垂直物体上。我们之前的研究[22]利用倾斜向下的激光雷达在城市道路上提取道路边界特征，然后利用这些特征进行车辆定位。实际上，城市环境中还有许多其他显著的特征有利于定位。</p><p>提取哪些特征，如何提取，以及如何将它们提供给定位方案是需要进一步解决的问题。</p><p>通常需要三维距离数据来提取机器人在三维世界中导航的特征[20]。在本文中，我们使用倾斜的激光雷达在倾斜扫描中生成环境的3D点云。<strong>我们不是直接对原始数据进行三维扫描匹配[2]，而是尝试从三维点云中提取特征，并使用垂直特征进行定位</strong>。我们的方法假设城市环境中有丰富的垂直表面，如路边、建筑物的墙壁，甚至垂直的树干。</p><p>“垂直世界”假设实际上是许多文学作品中普遍使用的假设。Harrison等人在[8]中提出了一种在机器人运动时生成高质量三维激光距离数据的方法。通过利用垂直世界的假设，可以推断出有用的信息(例如，滚转角和俯仰角)。Kohlbrecher等人[13]仅使用单个2D LIDAR和IMU就实现了2D SLAM和6DOF姿态估计。虽然没有明确解释，但这项工作的<strong>基本假设是环境包含许多垂直表面</strong>。</p><p>Weingarten等[30]利用这一假设实现了结构化环境的快速重构。在本文中，由于室外环境可能比结构环境具有更多的任意形状物体，因此在使用垂直假设之前必须进行分类步骤。在分类过程中，基于表面法向估计提取垂直表面上的激光点。当倾斜的激光雷达扫描环境时，一些垂直表面将被连续激光扫描从下到上扫描到。如果我们对这个扫描过程进行鸟瞰，并将垂直特征投射到虚拟水平面上，它与在二维表面上移动水平激光雷达的机器人完全相同。从数学的角度来看，垂直表面限制了不同高度的激光点如何相互匹配。基于上述直觉，提出了合成激光雷达的思想。合成激光雷达是在投影虚拟平面上的平面二维激光雷达，其激光束的终点是三维环境中垂直表面的投影点。</p><p>合成激光雷达的思想有助于解决二维平面上的三维定位问题。虽然车辆以6DOF在3D世界中移动，但一般来说，地面车辆最感兴趣的是其2D姿态向量(x, y，偏航)。通过将三维垂直特征投影到虚拟平面上，可以通过标记这些垂直特征来使用二维占用网格地图。这样，就可以在合成激光雷达的思想下，利用SLAM获得先验地图。需要说明的是，我们的算法仅适用于只有一个垂直可遍历级别的环境。对于具有更多可遍历级别的情况，可以使用一些其他2.5D或全3D算法，例如[12]。</p><h2 id="系统概述">系统概述</h2><p>定位系统主要由两部分组成，即提取关键特征点的三维感知和解决水平面上定位的二维定位。合成激光雷达作为连接3D世界和2D虚拟平面的桥梁，如图1（a）所示。</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706097408-0.png"></p><p>该系统使用IMU和车轮编码器来提供6DOF里程计信息，使用2D向下倾斜的LIDAR来提供激光扫描，并使用占用网格图作为定位的先验。使用简单的航位推算来获得里程计信息。假设车轮编码器在第n个时间步长测量的距离为<span class="math inline">\(r_n\)</span>，旋转由pitch角θ和偏航角Ψ给出，则车辆位置的变化由下式给出：</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706097519-0.png"></p><p>3D感知假设里程计系统在短时间内足够精确，并积累激光扫描的3D点云数据。然后应用分类程序从累积的数据中提取兴趣点。然后将提取的激光点投影到虚拟水平面上(忽略它们的z值)，并构建合成二维激光雷达。在蒙特卡罗定位方案中，二维定位融合了来自里程计的信息和来自合成二维激光雷达的测量结果。通过事先生成的垂直特征先验地图，可以实现二维水平面上的定位。</p><h1 id="d感知模块">3D感知模块</h1><p>对合成激光雷达的要求之一是具有良好的适应能力，在城市场景中能够适应不同类型的环境。我们通过在合成激光雷达生成之前，从重建的环境模型中适当提取兴趣点构成先验地图来实现这一点。为了能够识别垂直于地面的特征，一个精确的世界模型是必要的。</p><p>有许多方法可以建立精确的环境模型，包括nodding LIDAR和Velodyne。如第II-A节所述，一个固定的、向下倾斜的单平面激光雷达可以通过扫描地面来精确地重建环境。这是一个有吸引力的解决方案，因为它成本低，只需要传感器的刚性安装。它还允许进行优化，从而允许对该配置特有的特征提取进行实时计算。</p><h2 id="d滑动窗口">3D滑动窗口</h2><p>重建采用滚动窗采样，以保持测距传感器反射最近样本的高概率。因此，使用3D滚动窗口来积累短距离内记录的不同扫描。窗口的大小是灵活的，滑动窗口形成了3D环境的局部地图，即它与车辆一起滚动，新的传入扫描将添加到窗口中，而旧的样本将被丢弃。</p><p>更具体地，给定窗口大小<span class="math inline">\(w\)</span>，点<span class="math inline">\(p\)</span>为第n次扫描的点，<span class="math inline">\(P_{n}\)</span>通过累积得到：</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706098171-0.png"></p><p>如图6所示，如图1（b）所示，<span class="math inline">\(w\)</span>用于控制累积扫描的数量，使得窗口的大小不会无限增长。此外，只有当达到足够的距离β时，才插入新的扫描，这有两个影响，一个小的β会有更密集的点，但整个窗口大小会变短，反之亦然。滑动窗口在系统的里程计框架中工作，其中物理激光雷达的每次扫描都是基于IMU和车轮编码器得出的里程计信息来进行投影的，如第II-B节所述。</p><h2 id="垂直点云分类">垂直点云分类</h2><p>为了提取垂直于地面的特征，使用表面法线的估计。虽然存在许多方法[11]，但我们使用了[3]提出的法向量估计，基于一阶3D平面拟合，其中通过对点的局部邻域<span class="math inline">\({P^{K}}\)</span>[25]执行最小二乘平面拟合来近似空间中每个点的法线。</p><p>平面由一个点<span class="math inline">\(x\)</span>和法向量<span class="math inline">\(n\)</span>与点<span class="math inline">\(p_i \in P^{K}\)</span>的距离<span class="math inline">\(d_i\)</span>表示，其中<span class="math inline">\(d_i\)</span>定义为:</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706098764-0.png"></p><p>通过取<span class="math inline">\(x=\bar{p} = \frac{1}{k} \sum_{k=1}^{k} p_i\)</span>作为<span class="math inline">\(p_{k}\)</span>的质心，可以在最小二乘意义上计算<span class="math inline">\(n\)</span>的值，使得<span class="math inline">\(d_i=0\)</span>，通过计算以下协方差矩阵<span class="math inline">\(C\in \R^{3x3}\)</span>的特征值和特征向量，可以得到法向量<span class="math inline">\(n\)</span>的解[24]：</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706099036-0.png"></p><p>其中，<span class="math inline">\(k\)</span>是局部邻域中的点数，<span class="math inline">\(\bar{p}\)</span>是邻域的质心，<span class="math inline">\(λ_j\)</span>是第j个特征值，<span class="math inline">\(v_j\)</span>是第j个特征向量。<span class="math inline">\(P^{K}\)</span>的主分量于特征向量<span class="math inline">\(v_j\)</span>相关联。因此，可以从最小特征值<span class="math inline">\(λ_0\)</span>中找到法向量<span class="math inline">\(n\)</span>的近似值。一旦找到法向量<span class="math inline">\(n\)</span>，就可以通过简单地取沿z轴的阈值<span class="math inline">\(n\)</span>来获得垂直点，例如0.5。这取决于传感器数据的噪声程度。</p><p>为了有效地找到局部邻域点，从滚动窗口中获得的所有点构建KDtree[19]，并在每个点执行固定半径搜索。尽管曲面法线可以作为一个整体进行计算，但在滚动窗口中的每个点执行法线计算可能非常昂贵。为了进一步降低计算复杂度，保留了两个连续的滚动窗口，其中:</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706099204-0.png"></p><p>其中Φ可以是任何点分类函数，<span class="math inline">\(P^{\phi}\)</span>包含处理过点，P包含原始点。这样，相比于直接计算滚动窗口Pn+1，需要的计算量小得多。换句话说，这确保了只对新累积的点云进行分类，并且可以重用以前实例中处理过的点。</p><h2 id="合成激光雷达构造">合成激光雷达构造</h2><p>来自分类点的结果由3D中的兴趣点的集合组成。对于合成LIDAR的构建，将3D中的兴趣点投影到虚拟水平面（z＝0）中。可以看出，这种合成激光雷达有一个非常特殊的特点：能够“看透”障碍物。这是可能的，因为点的解释是在3D中完成的。</p><p>合成激光雷达的构建是通过将<strong>虚拟传感器放置在车辆底部并将所有兴趣点从里程计转换到车辆底部</strong>来完成的。</p><p>在许多需要标准激光雷达（等距角度增量）的应用中，可以进一步重建合成激光雷达以满足这一约束。这将涉及以每个固定角度增量执行光线跟踪，以从可能的端点获得最小范围值。总体3D感知可以在图2中进行总结。3D感知是通过PointCloud库[23]完成的，该库提供了本节中描述的许多操作。</p><h1 id="在线定位">在线定位</h1><h3 id="mcl定位">MCL定位</h3><p>本文采用[1]中的蒙特卡罗定位（MCL）方案来估计车辆姿态。MCL是一种基于贝叶斯定理和蒙特卡罗思想的概率定位方法[28]。MCL的核心是粒子滤波器，其中车辆位置的置信度由一组粒子维持。MCL主要由预测、校正和重采样三个步骤组成。对于预测步骤所需的运动模型，使用我们之前工作[22]中的“伪3D”里程测量运动模型。观测模型的选择如下所述。</p><h3 id="虚拟雷达观测模型">虚拟雷达观测模型</h3><p>为了将测量用于定位，合成激光雷达需要一个测量模型。合成激光雷达采用似然模型。由于虚拟光束的端点是兴趣点从垂直表面的投影，因此来自不同垂直表面的不同点可能具有相同的角度。在其他工作中，存在两个角度相同但具有两个不同范围值的激光束。因此，合成2D激光雷达是一种特殊的激光雷达，它只检测垂直表面，也可以透过这些表面。有鉴于此，仅需要激光束端点的似然模型非常适合于合成激光雷达。</p><h1 id="实验">实验</h1><h2 id="experiment-setup">Experiment Setup</h2><p>我们的测试台是雅马哈G22E高尔夫球车，配备了各种类型的传感器。硬件配置如图3所示。安装在前上方的倾斜式激光雷达是用于定位的SICK LMS-291激光雷达。</p><p>4层激光雷达SICK LD-MRS400001安装在腰部，用于障碍物检测。高尔夫球车的两个后轮都安装有编码器，用于提供行驶距离的估计值。惯性测量单元（IMU）MicroStrain 3DM-GX3-25安装在实际车轴的中心，以提供车辆的方位信息。</p><p>定位算法在新加坡国立大学工程学院进行了测试，那里的道路上下起伏，道路外有许多高层建筑。</p><p>通过使用合成激光雷达作为输入，首先使用图优化SLAM技术生成先验地图。为了进行姿态优化，[29]被用作检测环路闭合的前端。然后，使用[10]中的isam优化库恢复完全优化的姿态。</p><p>为了评估从合成激光雷达构建的恢复地图的质量，将地图投影到卫星地图上，如图5所示。该地图显示出与卫星地图的一致性和良好相关性，面积约为550米×487米。尽管地图左侧存在差异（由于道路沿线的地理特征），但总体拓扑结构得到了保持。这表明该地图可以用于精确定位。</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706100025-0.png"></p><h2 id="experimental-results">Experimental Results</h2><p>合成激光雷达能够在带有酷睿i7处理器的笔记本电脑上以50Hz的输出速率执行，这表明合成激光雷达可以用于执行实时定位。定位结果如图6所示。从之前的地图来看，我们算法的定位结果总是与我们的行驶路径一致，在长距离的道路上清晰地显示出与道路边界的平行线。</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706100161-0.png"></p><p>由于我们的算法不依赖于GPS，我们的估计在高楼密集的区域附近仍然表现良好。注意，在实验中，给出了一个粗略的初始位置，因此定位主要与姿态跟踪有关。</p><p>然而，该系统能够处理小的绑架问题，例如来自激光雷达的短暂数据错误，因为里程计系统仍然能够提供信息。如果发生大的绑架，例如车辆在放置之间移动而没有打开定位模块，则可以提供粗略的初始位置以加快收敛速度。</p><p>图4显示了“定位方差”与“行驶距离”的关系：</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706100209-0.png"></p><p>角度估计方差通常小于1◦, 如图4（a）所示。图4（b）显示了相对于车辆在纵向和横向方向上的“位置估计方差”与“行驶距离”的关系。结果表明，在整个测试过程中，两个方向的方差都很小。较差的方差发生在纵向上，其值约为0.2m。这表明定位算法对其位姿估计具有高置信度。同时，还可以看出，横向方差通常小于纵向方差。这与我们之前的工作[22]中讨论的事实一致，<strong>即在城市道路环境中，横向的特征比纵向的特征丰富得多</strong>。</p><p>这种提出的方法已被用于执行类似于[22]的自主导航。为了表明定位结果是一致的，进行了两次自主运行，如图7所示。高尔夫球车有一条从A到E的路径。为了验证定位的准确性，选择了5个检查点，其中执行从每次自主跑步中捕获的2个灰度图像之间的每像素绝对差。为了确保相同的照明条件，两次自主运行在同一天连续进行。图中的5张较小的图像。图7是视觉验证的结果。图像的尖锐边缘提供了强有力的证据，证明定位系统能够重复地提供精确的位置。请注意，图像B、C和E中出现的黑点是移动物体的自然结果。这表明，只需一个二维激光雷达就可以实现精确导航。</p><p><img src="https://s1.nsloop.com:58443/images/2024/01/24/1706100461-0.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;synthetic-2d-lidar-for-precise-vehicle-localization-in-3d-urban-environment&quot;&gt;Synthetic 2D LIDAR for Precise Vehicle Localization in 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>LOG-LIO论文阅读</title>
    <link href="http://yoursite.com/2023/10/08/LOG-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/10/08/LOG-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-10-08T12:00:53.000Z</published>
    <updated>2023-10-08T01:41:19.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="log-lio-a-lidar-inertial-odometry-with-efficient-local-geometric-information-estimation">LOG-LIO: A LiDAR-Inertial Odometry with Efficient Local Geometric Information Estimation</h1><p><img src="https://s1.nsloop.com:58443/images/2023/10/08/1696729208-0.png"></p><h1 id="摘要">摘要</h1><p>局部几何信息，即点的法向量和分布，对于基于lidar的同步定位和映射(SLAM)至关重要，因为它为数据关联提供了约束，进一步决定了优化的方向，最终影响了定位精度。然而，即使在kdtree或体积图的帮助下，估计点的正态分布和分布也是耗时的任务。为了实现快速法线估计，我们研究了激光雷达扫描的结构，提出了一种基于环的快速近似最小二乘(Ring FALS)方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;log-lio-a-lidar-inertial-odometry-with-efficient-local-geometric-information-estimation&quot;&gt;LOG-LIO: A LiDAR-Inertial Odometry with Eff
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>Voxel-Hashing论文阅读</title>
    <link href="http://yoursite.com/2023/08/09/%E5%9C%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/Voxel-Hashing%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/08/09/%E5%9C%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/Voxel-Hashing%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-08-09T13:30:53.000Z</published>
    <updated>2023-08-09T14:08:27.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="real-time-3d-reconstruction-at-scale-using-voxel-hashing">Real-time 3D Reconstruction at Scale using Voxel Hashing</h1><p><img src="https://s1.nsloop.com:58443/images/2023/08/09/1691587468-0.png"></p><h1 id="摘要">摘要</h1><p>由于实时消费深度相机的可用性，在线三维重建正在获得新的兴趣。基本问题以实时重叠的深度图作为输入，并将它们增量地融合到单个3D模型中。</p><p>这具有挑战性，特别是如何满足实时性能需求同时质量和规模性能都不下降。我们提供了一个在线系统，用于基于内存和速度高效的数据结构的大规模和精细的体积重建。</p><p>我们的系统使用简单的空间散列方案来压缩空间，并允许实时访问和更新隐式表面数据，而不需要常规或分层的网格数据结构。表面数据仅在观察到测量值的地方密集存储。此外，数据可以在哈希表或哈希表中有效地流式传输，从而在传感器运动期间实现进一步的可扩展性。我们展示了各种场景的交互式重建，重建细粒度的细节和大规模的环境。我们展示了我们的管道的所有部分如何从深度图预处理、摄像机姿态估计、深度图融合和表面渲染以商品图形硬件上的实时速率执行。并总结了与当前最先进的在线系统的比较，说明了改进的性能和重建质量。</p><h1 id="介绍">介绍</h1><p>我们提供了一个新的实时表面重建系统，该系统支持大规模的高质量重建。我们的方法具有体积方法的好处，但<strong>不需要内存受限的体素网格或分层数据结构的计算开销</strong>。我们的方法基于一种简单的内存和速度高效的空间哈希技术，该技术压缩空间，并允许实时融合参考隐式表面数据，而不需要分层数据结构。表面数据仅密集存储在观察测量的cell中。此外，数据可以在哈希表或哈希表中有效地流式传输，从而在传感器运动期间实现进一步的可扩展性。</p><h1 id="相关工作">相关工作</h1><p>略</p><h1 id="算法概述">算法概述</h1><p>我们扩展了Curless和Levoy[1996]的体积方法，通过将噪声深度图增量融合到存储器和速度高效的数据结构中，实时和大规模地重建高质量的3D表面。鉴于样本的简单累积平均值，Curless 和 Levoy 已被证明会产生令人信服的结果。该方法支持增量更新，对曲面没有拓扑假设，有效地逼近基于三角剖分的传感器的噪声特征。此外，虽然隐式表示，但可以很容易地提取存储的等值面。我们的方法解决了 Curless 和 Levoy 的主要缺点：支持高效的可扩展性。接下来，我们在描述我们的新方法之前回顾了Curless和Levoy方法</p><blockquote><p>Curless&amp;Levoy[1996]: A volumetric method for building complex models from range images</p></blockquote><h2 id="implicit-volumetric-fusionsdf和tsdf简介">Implicit Volumetric Fusion(SDF和TSDF简介)</h2><p>Curless 和 Levoy 的方法基于在体积数据结构中存储隐式符号距离场 (SDF)。让我们考虑一个规则的密集体素网格，并假设输入是一系列深度图。相对于这个网格(通常是网格的中心)，深度传感器在某些原点初始化。首先，估计传感器的刚性六自由度(6DoF)自我运动，通常使用ICP的变体[Besl和McKay 1992;Chen和Medioni 1992]。</p><p>网格中的每个体素包含两个值：有符号距离和权重。对于单个深度图，通过均匀扫描视图截锥外的体积、剔除体素、将所有体素中心投影到深度图并更新存储的SDF值，将数据集成到网格中。投射到同一像素上的所有体素都被认为是深度样本足迹的一部分。在这些体素中的每一个中，存储从体素中心到观察到的表面测量的符号距离，正面距离、负面后面和表面界面处接近零。</p><p>为了减少计算成本，支持传感器运动和近似传感器噪声，Curless和Levoy引入了截断SDF (TSDF)的概念，它只存储观测表面周围区域的符号距离。该区域的大小可以适应，将传感器噪声近似为基于深度方差的高斯 [Chang et al.1994;阮等人。 2012]。仅使用加权平均值更新存储在这些区域体素中的TSDF值，以获得表面的估计。最后，作为每个深度样本足迹一部分的体素（在表面前面），但在截断区域之外明确标记为自由空间。这允许基于自由空间违规删除异常值。</p><h2 id="voxel-hashing">Voxel Hashing</h2><p>给定Curless和Levoy方法的截断曲面周围的sdf，存储在规则网格中的大多数数据被标记为自由空间或未观察到的空间，而不是表面数据。所以，关键挑战变成了如何设计数据结构来利用TSDF表示中的这种潜在稀疏性。</p><p>我们的方法特别避免了使用密集或分层数据结构，消除了对内存密集型规则网格的需求或计算复杂的层次结构进行体积融合。相反，我们使用一个简单的散列方案来紧凑存储、访问和更新隐式表面表示。提出了一种高效的<strong>基于gpu的哈希方法，大大减少了哈希条目冲突的数量</strong>。</p><p>我们的目标是构建一个实时系统，该系统采用空间哈希方案进行可扩展的体积重建。这对于 3D 重建来说并非易事，因为几何提前未知并且不断变化。因此，我们的散列技术<strong>必须支持动态分配和更新，同时最小化和解决潜在的散列条目冲突</strong>，而不需要包含的表面几何的先验知识。在接近我们数据结构的设计时，我们有目的地选择和扩展了一个简单的哈希方案 [Teschner et al.2003]，虽然存在更复杂的方法，但我们凭经验表明我们的方法在速度、质量和可扩展性方面是有效的。</p><p>特性如下：</p><ul><li>在保持表面分辨率的同时，有效压缩体积TSDF的能力，而不需要分层空间数据结构。</li><li>基于插入和更新，将新的TSDF样本有效地融合到哈希表中，同时最小化哈希碰撞。</li><li>体素块的去除和垃圾收集，而不需要对数据结构进行昂贵的重组。</li><li>主机和GPU之间体素块的轻量级双向流，允许无界重建</li><li>使用标准光线投射或多边形化操作有效地从数据结构中提取等值面，用于渲染和相机姿态估计</li></ul><h2 id="系统流程">系统流程</h2><p>我们的管道如图2所示。Central是一个散列表数据结构，它存储包含sdf的子块，称为体素块。哈希表中每个被占用的条目都指向一个已分配的体素块。在每个体素中，我们存储一个TSDF、权重和一个额外的颜色值。哈希表是非结构化的;也就是说，相邻的体素块不是存储在空间上的，而是可以存储在哈希表的不同部分。我们的哈希函数允许使用指定的(整数四舍五入)世界坐标高效地查找体素块。我们的哈希函数旨在最小化冲突的数量，并确保表中不存在重复项。</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/09/1691589654-0.png"></p><p>给定一个新的输入深度图，我们首先执行融合(也称为集成)。我们首先分配新的体素块，并根据输入深度图将块描述符插入哈希表。只分配已占用的体素，不存储空白空间。接下来，我们扫描每个分配的体素块，根据输入深度和颜色样本更新每个包含体素的SDF、颜色和权重。此外，我们对离等值面太远且不包含权重的体素块进行垃圾收集。这包括<strong>释放分配的内存</strong>以及<strong>从哈希表中删除体素</strong>。这些步骤确保我们的数据结构随着时间的推移保持稀疏。</p><p>融合（integration）后，我们从当前估计的相机姿态对隐式表面进行光线投射，以提取等值面，包括相关的颜色。提取的深度和颜色缓冲用作相机姿态估计的输入:给定下一个输入深度图，执行投影点平面ICP [Chen和Medioni 1992]来估计新的6DoF相机姿态。这确保了姿态估计是帧对模型进行的，而不是帧对帧，减轻了一些漂移问题(特别是对于小场景)[Newcombe等人]。2011]。最后，我们的算法实现了GPU和主机之间的双向流。哈希条目(以及相关的体素块)在它们的世界位置退出估计的摄像机视图截锥体时流式传输到主机。当重访区域时，先前流出的体素块也可以流回GPU数据结构。</p><h1 id="数据结构核心">数据结构（核心）</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;real-time-3d-reconstruction-at-scale-using-voxel-hashing&quot;&gt;Real-time 3D Reconstruction at Scale using Voxel Hashing&lt;/h1&gt;
&lt;p&gt;&lt;img src=
      
    
    </summary>
    
    
      <category term="地图结构相关" scheme="http://yoursite.com/categories/%E5%9C%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>RH-MAP论文阅读</title>
    <link href="http://yoursite.com/2023/08/07/%E5%9C%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/RH-MAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/08/07/%E5%9C%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/RH-MAP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-08-07T12:30:53.000Z</published>
    <updated>2023-08-08T08:58:27.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rh-map-online-map-construction-framework-of-dynamic-object-removal-based-on-3d-region-wise-hash-map-structure">RH-Map: Online Map Construction Framework of Dynamic Object Removal Based on 3D Region-wise Hash Map Structure</h1><p><img src="https://s1.nsloop.com:58443/images/2023/08/07/1691411549-0.png"></p><h1 id="摘要">摘要</h1><p>移动机器人在室外环境中导航经常遇到动态对象留下的不良痕迹问题，表现为地图上的障碍，阻碍了机器人实现精确定位和有效的导航。</p><p>为了解决这个问题，提出了一种新的基于三维区域哈希映射结构(RH-Map)的地图构建框架，该框架由前端扫描刷新器和后端去除模块组成，实现了实时地图构建和在线动态对象去除(dynamic object removal, DOR)。</p><p>首先，提出了一种用于有效在线DOR的地图管理的两层3D区域哈希映射结构。然后，在前端扫描刷新器的情况下，采用区域地平面估计(R-GPE)对地面信息进行估计和保留，提出了扫描到地图去除算法(S2M-R)来区分和去除动态区域。此外，为了进一步DOR，提出了保持关键帧的轻量级后端移除模块。</p><p>正如SemanticKITTI 的实验验证的那样，与最先进的方法相比，我们提出的框架在地图构建的在线 DOR 上取得了可喜的性能。我们还在现实世界的环境中验证了所提出的框架。源代码发布给社区（https://github.com/YZH-bot/RH-Map）</p><h1 id="介绍">介绍</h1><p>清洁可靠的地图在室外环境中无人地面车辆(UGV)和无人机(UAV)等移动机器人平台的导航和探索中发挥着重要作用。同时定位和映射(SLAM)技术通常用于提供周围环境的鲁棒定位和映射[3][4]。</p><p>然而，大多数SLAM方法假设环境相对是静态的;因此，环境中的动态对象可能会在地图上留下残余痕迹，如图1(a)所示，称为幽灵轨迹效应[5]。</p><p>这些通常会导致环境表示混乱和路径规划的次优结果。SLAM 研究旨在通过使用在线动态对象移除 (DOR) [8]、[9]、[19] 或在优化过程中利用动态对象的状态 [10] 来解决这一假设，以确保在动态环境中更可靠的定位。然而，他们更多地关注提高定位精度，而不是提供密集和干净的地图。</p><p>在这项工作中，我们专注于使用 3D LiDAR 在大规模环境中在线密集地图构建的实时动态去除。一些在地图构建中处理DOR任务的研究通常需要长序列历史信息、子图或预先构建的全局地图<a href="DynamicFilter:%20an%20Online%20Dynamic%20Objects%20Removal%20Framework%20for%20Highly%20Dynamic%20Environments">2</a>、<a href="Remove,%20then%20Revert:%20Static%20Point%20cloud%20Map%20Construction%20using%20Multiresolution%20Range%20Images">15</a>、<a href="ERASOR:%20Egocentric%20Ratio%20of%20Pseudo%20Occupancy-Based%20Dynamic%20Object%20Removal%20for%20Static%203D%20Point%20Cloud%20Map%20Building">16</a>，不适合实时性要求较高的场景。</p><blockquote></blockquote><p>此外，在线DOR方法依赖于LiDAR信息的短期相邻帧，可以过滤掉当前扫描中的大部分动态对象。然而，由于激光雷达在远距离区域的<strong>稀疏性</strong>和<strong>入射角模糊特性</strong>，一些动态对象可能会无限期地持续并保持在地图上，而一些静态点被错误分类，从而降低地图质量。</p><p>我们总结了以下挑战：</p><ul><li><ol type="1"><li>在同时过滤掉动态对象的同时保持地图构建的及时性的困难，</li></ol></li><li>(2）由于激光雷达数据的特点，在线DOR的弱性能，对地图的质量产生负面影响。</li></ul><p>这项工作提出了一种新的动态环境下的DOR在线地图构建框架，称为RH-Map。首先，我们提出了一种两层地图结构，用3D区域和最小分辨率立方体来管理地图，带来的好处是：利用区域结构和哈希映射实现了高效的O(1)复杂度的在线DOR和实时地图更新。</p><p>基于区域结构，引入了一种两阶段在线建图框架，用于构建静态地图，包括前端和后端模块。</p><ul><li>前端模块估计地面信息进行保存，并利用当前扫描去除地图上潜在的动态区域。</li><li>后端模块维护历史信息的关键帧队列，以有效去除残差动态对象，</li></ul><p>如图1所示。我们将贡献总结如下:</p><ul><li>提出了一种高效的地图管理的区域哈希地图结构，以便在线DOR，保证实时地图更新，在SemanticKITTI上实现了超过10Hz的实时性能</li><li>RH-Map，提出了一种新的DOR在线地图构建框架，该框架由实时前端扫描新鲜和轻量级后端移除模块组成。前端实现了鲁棒的地面估计和实时在线DOR，后端模块实现了进一步去除动态对象以提高地图质量</li><li>我们在SemanticKITTI上彻底验证了所提出的方法，并展示了现实场景中的在线性能。我们的方法在 DOR 中实现了最先进的性能，可以应用于现实世界中的机器人导航。</li></ul><p><img src="https://s1.nsloop.com:58443/images/2023/08/07/1691412809-0.png"></p><h1 id="相关工作">相关工作</h1><p>（略）</p><h2 id="occupancy-map-based-methods">Occupancy map-based methods</h2><h2 id="visibility-based-methods">Visibility-based methods</h2><h2 id="segmentation-based-methods">Segmentation-based methods</h2><h3 id="scan-pre-segmentation-methods">Scan pre-segmentation methods</h3><h3 id="ground-segmentation-methods">Ground segmentation methods</h3><h1 id="具体实现">具体实现</h1><p>RH-Map原理图如图2所示。基于所提出的两层哈希地图结构，RHMap利用3D区域来表示DOR局部区域的信息，每个区域存储空间中的立方体状态(最小分辨率)。RH-Map 由两部分组成：前端扫描刷新器和基于所提出的数据结构的后端移除模块。</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/07/1691413273-0.png"></p><h2 id="问题描述">问题描述</h2><p>与之前的工作<a href="Remove,%20then%20Revert:%20Static%20Point%20cloud%20Map%20Construction%20using%20Multiresolution%20Range%20Images">15</a>、<a href="ERASOR:%20Egocentric%20Ratio%20of%20Pseudo%20Occupancy-Based%20Dynamic%20Object%20Removal%20for%20Static%203D%20Point%20Cloud%20Map%20Building">16</a>、<a href="The%20Peopleremover%20-%20Removing%20Dynamic%20Objects%20From%203-D%20Point%20Cloud%20Data%20by%20Traversing%20a%20Voxel%20Occupancy%20Grid">13</a>不同，我们专注于连续激光雷达扫描构建的地图的在线动态去除。在这项工作中，我们使用最先进的基于激光雷达的里程计或SLAM方法，如[3][4]，在世界坐标系<span class="math inline">\(W\)</span>和LiDAR坐标系<span class="math inline">\(B\)</span>之间提供SE(3)位姿<span class="math inline">\(T_B^W\)</span>，并接收实时扫描<span class="math inline">\(P^B\)</span>作为输入。</p><blockquote></blockquote><h2 id="基于region的hash地图结构">基于Region的hash地图结构</h2><p>在本节中，我们介绍了一种两层哈希映射结构，如图2所示，与ERASOR<a href="ERASOR:%20Egocentric%20Ratio%20of%20Pseudo%20Occupancy-Based%20Dynamic%20Object%20Removal%20for%20Static%203D%20Point%20Cloud%20Map%20Building">16</a>的2D自我中心区域伪占用描述符(RPOD)不同，全局3D占用网格图被划分为大小均匀的区域(在我们的实验中为绿色框，0.8m)，每个区域进一步划分为最小分辨率占用网格(Cubes, 0.1m)。</p><p>地图结构如图3所示，二进制掩码<span class="math inline">\(m\)</span>和最小分辨率立方体大小<span class="math inline">\(s_c\)</span>的值决定了区域的大小<span class="math inline">\(s_r=(m+1) * s_c\)</span>，举例：如果二进制掩码<span class="math inline">\(m=00000111, s_c=0.1 m\)</span>, 则有<span class="math inline">\(s_r=0.8 m\)</span>，可以理解为，低位每多一个1，那么在一个region里面的xyz维度可以分别增加1个小立方体。</p><p>对于地图构建，首先将扫描的点云转换为世界坐标系，并转换为全局索引<span class="math inline">\(I\)</span>，然后在每个维度上使用二进制掩码<span class="math inline">\(m\)</span>进行二进制操作，得到相应的3D区域索引<span class="math inline">\(I_r\)</span>和3D立方体索引<span class="math inline">\(I_c\)</span>，它们在RH-Map中组成一个唯一的索引:</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/07/1691416550-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\left[p_x, p_y, p_z\right] \in \mathbb{R}^3\)</span>是全局坐标系下点的坐标</li><li>显然，<span class="math inline">\(I=I_r \| I_c\)</span>，也就是说，二进制掩码m的高位表明了region的编码部分，低位表明了一个region内部的小立方体的编码</li><li>请注意，16位掩码（在我们的实验中）可以处理 6553.5<span class="math inline">\(m^3\)</span> 的地图大小，扩展掩码的位大小足以容纳更大的范围。（会不会小了一点? [EpsilonJohn]）</li></ul><p>在得到<span class="math inline">\(I_r\)</span>和<span class="math inline">\(I_c\)</span>后，我们使用[34]这样的3D哈希函数将索引映射到地图中，并更新占用概率<span class="math inline">\(p\)</span>如下:</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/07/1691417002-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(I(\cdot)\)</span>表示获取索引<span class="math inline">\(I\)</span>中（x,y,z）其中一个维度的值</li><li><span class="math inline">\(n_x, n_y, n_z\)</span>是大的素数</li><li><span class="math inline">\(N\)</span>是地图的size</li><li><span class="math inline">\(L(\cdot)\)</span>表示log odds.</li></ul><p>为了简化，我们使用 如下记号：</p><ul><li><span class="math inline">\(M_I=M_{I_r, I_c}\)</span> 来表示索引 <span class="math inline">\(I=I_r \| I_c\)</span> 的地图上的唯一立方体，</li><li><span class="math inline">\(M_{I_r}\)</span>表示地图上索引为<span class="math inline">\(I_r\)</span>的区域</li><li><span class="math inline">\(O=(I(x), I(y))\)</span>表示索引为<span class="math inline">\(I\)</span>的立方体在xy平面上的2D索引</li><li><span class="math inline">\(O_r=(I_r(x),I_r(y))\)</span>表示索引为<span class="math inline">\(I_r\)</span>的区域在xy平面上的2D索引</li></ul><p>RH-Map记录和更新的数据如下：</p><ul><li>RH-Map 记录索引为 <span class="math inline">\(O_r\)</span> 2D区域最高点和最低点在H{max, min} 中</li><li>以及计算地图上xy平面索引为<span class="math inline">\(O\)</span>的立方体的地面点平均高度</li><li>以及每个区域的<strong>最小-最大-平均 高度</strong>和<strong>平面参数</strong></li><li>它还更新每个立方体的占用概率和地面</li></ul><p>我们的方法支持在线操作，哈希地图结构只更新占用位置的状态，不受传统占用网格图或八叉数地图[12]等预设建图范围的限制，而R-POD<a href="ERASOR:%20Egocentric%20Ratio%20of%20Pseudo%20Occupancy-Based%20Dynamic%20Object%20Removal%20for%20Static%203D%20Point%20Cloud%20Map%20Building">16</a>由于数据组织的不规则性，只能离线应用，随着全局地图变大，消耗的时间将增加。</p><h2 id="前端扫描刷新器">前端扫描刷新器</h2><p>前端扫描刷新器包含基于区域的地平面估计(R-GPE)和scan-to-map去除(S2M-R)。我们的扫描刷新器在 S2M-R 中实现在线动态去除，并应用 R-GPE 根据我们上述提到的基于区域的地图结构来保持地面的完整性。</p><h3 id="region-wise-ground-plane-estimation-r-gpe">Region-wise Ground Plane Estimation (R-GPE)</h3><p>首先，实时扫描数据<span class="math inline">\(P^{B}\)</span>被转换为世界坐标系<span class="math inline">\(P^W =T^W_B P^B\)</span>，并插入到我们的地图中，更新区域的H(最低点-最高点)和区域的最大-最小-平均 高度属性，用于后续进行检测。</p><p>接下来，我们进行候选地面区域选举，以确定需要执行地平面拟合的范围。此外，扫描中有许多噪声点对地面估计有很大的影响。因此，如果一个区域在其八个相邻区域内没有地面，我们引入了一个异常值过滤过程，将该区域视为噪声。这是建立在地面通常是连续且噪声点通常离散出现的假设下建立的。然后，得到候选地面区域集<span class="math inline">\({}^{cgr}\mathbb{I}_r\)</span>如下:</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/08/1691460252-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbb{I}^{P^W}\)</span>表示通过公式(1)转换后的点云索引</li><li><span class="math inline">\(M_{I_{r}^{i}}\)</span>表示第i个点对应的<span class="math inline">\(M_{I_{r}^{i}}\)</span>地图区域</li><li><span class="math inline">\(M_{I_{r}^{i}}^{N}\)</span>表示地图区域<span class="math inline">\(M_{I_{r}^{i}}\)</span>的八邻域</li><li><span class="math inline">\(O^{i}=(I^{i}(x),I^{i}(y))\)</span></li></ul><p>上面的意思是，候选地面区域的条件是：</p><ul><li>立方体<span class="math inline">\(I^{i}\)</span>的高度要小于全局地图中xy平面上对应的高度，即<span class="math inline">\(I^i(z)&lt;G(O^i)\)</span></li><li>立方体<span class="math inline">\(I^{i}\)</span>所在的区域的八邻域不能没有地面</li></ul><p>然后，与<a href="ERASOR:%20Egocentric%20Ratio%20of%20Pseudo%20Occupancy-Based%20Dynamic%20Object%20Removal%20for%20Static%203D%20Point%20Cloud%20Map%20Building">16</a>中的区域地平面拟合(R-GPF)类似，我们在每个区域<span class="math inline">\(M_{I_{r}^{i}}\)</span> (<span class="math inline">\(I_{r}^{i} \in {}^{cgr}\mathbb{I}_r\)</span>)上执行R-GPF。对于<span class="math inline">\(M_{I_{r}^{i}}\)</span>区域中，z轴上高度小于<span class="math inline">\(M_{I_{r}^{i}}\)</span>平均高度的小立方体，我们提取其全局索引<span class="math inline">\(I_{r}^{i}\)</span>，添加到初始地面点集合 <span class="math inline">\(\mathbb{I}^{I_{r}^{i}}\)</span>中。然后我们使用主成分分析 (PCA) 来拟合地平面并更新区域<span class="math inline">\(M_{I_{r}^{i}}\)</span>的地平面参数、法向量 <span class="math inline">\(n_i\)</span> 和平面系数<span class="math inline">\(d_i=n_i\overline{I^i}\)</span>，其中<span class="math inline">\(\overline{I^i}\)</span>表示初始地面点集合<span class="math inline">\(\mathbb{I}^{I_{r}^{i}}\)</span>的平均索引。然后，<span class="math inline">\(M_{I_{r}^{i}}\)</span>区域的地面全局索引集合<span class="math inline">\({}^{gro}\mathbb{I}^{I_r^i}\)</span>可以表示如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/08/1691481291-0.png"></p><p>其中，<span class="math inline">\(r_{gro}\)</span>表示到平面的距离（应该是一个阈值?）</p><p>上面的条件大概是，利用立方体的索引计算到区域地平面的距离，如果小于阈值，那么这个立方体就是地面。</p><p>最后，我们用提取到的地面立方体集合<span class="math inline">\({}^{gro}\mathbb{I}^{I_{r}^{i}}\)</span>来更新立方体的地面属性。请注意，只有当检测到新的候选地面区域并且 R-GPE 的效果如图 4(b) 所示时，才会执行 R-GPE</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/08/1691481665-0.png"></p><h3 id="scan-to-map-removal">Scan-to-Map Removal</h3><p>一般来说，与地图相比，单次扫描的信息相对稀疏且缺乏信息。而如果没有事先对LiDAR数据进行预处理，那么基于区域的去除方法通常会导致误报(假阳性(False Positive)，错误地将静态点分类为动态点)，例如停放的汽车、墙壁或树木，如图5(b)所示的红色矩形。</p><p>而像ERASOR的R-POD<a href="ERASOR:%20Egocentric%20Ratio%20of%20Pseudo%20Occupancy-Based%20Dynamic%20Object%20Removal%20for%20Static%203D%20Point%20Cloud%20Map%20Building">16</a>这样的2D描述符可能会导致假阴性(False Negatives，无法检测到动态点)，例如位于最高点和最低点之间的动态物体。</p><p>为了解决这些问题，我们引入了兴趣区域(ROI)提取和二维和三维扫描上下文，以检测不同提取点的动态目标。</p><p>首先，与地图相比，LiDAR在LiDAR附近的视场相对有限，导致LiDAR观测与地图存在差异(见图4(a)中红色矩形)；因此，从原始LiDAR点<span class="math inline">\(P^{B}\)</span>中提取的最大线束ID <span class="math inline">\(P^B_{max}\)</span>中的点来表示LiDAR的最大FOV：</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/08/1691482128-0.png"></p><p>其中，<span class="math inline">\(P_{res}^{B}\)</span>（红色点）表示剩余的LiDAR点，那么转换到世界坐标系的ROI点为：<span class="math inline">\(P_{roi}^W=T_{B}^{W}P_{roi}^{B}=\{P_{res}^{W},P_{max}^{W}\}\)</span></p><p>为了检测扫描和地图在动态目标检测中的差异，我们引入二维区域扫描上下文<span class="math inline">\({}^{2d}S^{W}\)</span>定义如下:</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/08/1691482464-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbb{O}_{r}^{P^{W}_{roi}}\)</span>表示转换到世界坐标系的LiDAR ROI点<span class="math inline">\(P_{roi}^W\)</span>对应的2D区域集合</li><li><span class="math inline">\(Z_{max}\mathrm{~and~}Z_{min}\)</span>表示在当前帧扫描中2D区域<span class="math inline">\(O_{r}^{i}\)</span>的最高和最低点的高度信息</li></ul><p>然后，我们计算<span class="math inline">\({}^{2d}S^{W}\)</span>与地图M之间关联区域的比率<span class="math inline">\(ratio1\)</span>如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/08/08/1691483156-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\Delta H={}^{2d}S_{O_{r}^{i}}^{W}.Z_{max}-{}^{2d}S_{O_{r}^{i}}^{W}.Z_{min}\)</span></li><li><span class="math inline">\(H(O_r^i).max\)</span>和<span class="math inline">\(H(O_r^i).min\)</span>分别表示全局地图中的2D区域<span class="math inline">\(O_{r}^{i}\)</span>的最高和最低点的高度信息</li><li><span class="math inline">\(O_{r}^{p_{k}}\)</span>表示当前帧扫描的最大线束ID的激光点（已经转换到世界坐标系）<span class="math inline">\(p_{k}(p_{k}\in P_{max}^{W})\)</span>的索引所在的2D区域</li></ul><p>简单来说，这个比率1的计算就是用当前扫描的区域高度差 / 地图区域的高度差， 如果是最大线束ID的激光击中的区域，分母需要调整一下。</p><p>如果比率<span class="math inline">\(ratio_1^{O_r^i}\)</span>小于去除阈值<span class="math inline">\(\delta_1\)</span>，我们认为在LiDAR-FOV中的2D区域<span class="math inline">\(O_{r}^{i}\)</span>是动态的。 （？？？）</p><p>如上所述二维描述子的缺点，我们仍然不能完全消除FPs和FNs，如图5(c)所示。这是因为二维描述符无法准确描述“凸起”点的动态和静态状态，如图4(a)中绿色和橙色部分所示。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;rh-map-online-map-construction-framework-of-dynamic-object-removal-based-on-3d-region-wise-hash-map-structure&quot;&gt;RH-Map: Online Map Co
      
    
    </summary>
    
    
      <category term="地图结构相关" scheme="http://yoursite.com/categories/%E5%9C%B0%E5%9B%BE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>X-ICP论文阅读</title>
    <link href="http://yoursite.com/2023/06/25/X-ICP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/06/25/X-ICP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-06-25T10:00:53.000Z</published>
    <updated>2023-06-27T14:21:14.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x-icp-localizability-aware-lidar-registration-for-robust-localization-in-extreme-environments">X-ICP: Localizability-Aware LiDAR Registration for Robust Localization in Extreme Environments</h1><p><img src="https://s1.nsloop.com:58443/images/2023/06/25/1687687377-0.png"></p><h1 id="摘要">摘要</h1><p>现代机器人系统需要在具有挑战性的环境中运行，这就要求在具有挑战性的条件下进行可靠的定位。基于激光雷达的定位方法，如迭代最近点(ICP)算法，在几何信息匮乏的环境中可能会受到影响，这些环境已知会<strong>降低配准性能，并将优化推向弱约束方向的发散</strong></p><p>为了克服这个问题，本工作提出了 1)一个鲁棒的多类别(非)可定位性检测模块，以及 2)一个基于可定位性约束ICP优化模块，并以统一的方式将两者耦合在一起。所提出的可定位性检测是通过利用扫描和地图之间的对应关系来分析针对优化主方向的对准强度来实现的，作为LiDAR定位分析的一部分。</p><p>在第二部分中，这种可定位性分析紧密集成到扫描到地图的点云配准中，以沿着良好约束的方向生成无漂移的姿态更新。该方法经过了全面的评估，并在模拟和真实世界的实验中与最先进的方法进行了比较，从而在具有激光雷达挑战性的场景中获得了性能和可靠性的提升。在所有实验中，所提出的框架证明了准确和通用的定位检测和鲁棒的姿态估计，而不需要特定环境的参数调整。</p><h1 id="介绍">介绍</h1><p><strong>点云配准局限性：</strong></p><p>尽管ICP算法及其变体是迄今为止首选的注册方法之一，但在使用它时需要考虑其在实际应用中的局限性。[13]，[14]发现有四种不同的误差来源会影响ICP算法。这些问题包括：</p><ul><li>收敛到局部最小值的风险</li><li>对传感器偏差和噪声的敏感性</li><li>不准确的初始转换</li><li>以及在潜在的优化问题中缺乏几何约束</li></ul><p>虽然机器人社区开发了减少前三个来源的方法和系统，但后者仍然可能导致现代机器人系统在困难环境中部署时发生故障。在(近)自对称环境中，沿对称轴的几何约束(几乎)与噪声构成的约束难以区分。因此，优化可能收敛到以噪声主导的最优解<a href="On%20degeneracy%20of%20optimization-based%20state%20estimation%20problems">15</a>，称为退化或退化情况。隧道、开放空间、走廊和门道都可能是这种退化环境的实例[16]，参见图1中真实地下隧道示例的顶部一行。</p><p><strong>考虑可定位性：</strong></p><p>为了使机器人能够在所有场景中运行，包括退化的平面或类似隧道的环境，需要所谓的可定位性考量<code>localizability-awareness</code>[17]-[19]。</p><blockquote><p>[17]: <a href="https://github.com/leggedrobotics/L3E" target="_blank" rel="noopener">Learning-based Localizability Estimation for Robust LiDAR Localization (L3E)</a></p></blockquote><p>应对机制是双重的：</p><ul><li>首先，退化场景的检测</li><li>其次，减轻其对优化的负面影响</li></ul><p>多种方法利用信息论将优化的退化检测为退化与否(二进制形式)——而不单独考虑运动的各个轴的退化情况<a href="Predicting%20alignment%20risk%20to%20prevent%20localization%20failure">20</a>-<a href="%22A%20localizability%20estimation%20method%20for%20mobile%20robots%20based%20on%203d%20point%20cloud%20feature">23</a></p><blockquote></blockquote><p>然而，尽管具有实用性和简单，但这种分析并没有提供足够的细节，来说明优化过程中的退化方向。因此，大多数解决方案[18]-<a href="Predicting%20alignment%20risk%20to%20prevent%20localization%20failure">20</a>更倾向于丢弃整个测量的配准结果，而不是至少沿着信息良好的方向对问题进行强化。</p><p>此外，如[17]描述，现有的检测方法如<a href="On%20degeneracy%20of%20optimization-based%20state%20estimation%20problems">15</a>、<a href="Degeneracy-aware%20factors%20with%20applications%20to%20underwater%20slam">24</a>在实践中表现良好，但需要对不同的环境或传感器配置进行繁琐的参数调整。</p><blockquote></blockquote><p><strong>提出的方法：</strong></p><p>针对上述挑战，本文提出了一种鲁棒的可定位感知点云配准框架<code>X-ICP</code>，该框架使基于lidar的SLAM系统能够在无特征极端环境中运行。所提出的框架，如图 2 所示，解决了退化的检测和缓解。这两个子模块是可定位性检测模块，缩写为<code>Loc.-Module</code>，优化模块，缩写为<code>Opt.-Module</code></p><p><img src="https://s1.nsloop.com:58443/images/2023/06/25/1687690807-0.png"></p><p>Loc.-Module利用扫描与地图之间的点和表面法线对应关系来分析沿优化主方向的对齐强度。与之前的工作L3E[17]相比，这种可定位性检测用于<code>scan-to-map</code>，并且与机器人的朝向(相对于环境)无关。允许在各种环境配置中进行可靠的检测，例如地下场景，以及室外大场景，且无需在线参数调整。结果估计是细粒度的，即将当前机器人状态分为{可定位，部分可定位和不可定位}类别。</p><p>另一方面，Opt.-Module利用可定位性信息计算并整合优化约束，对点云配准进行底层优化，值得注意的是，Opt . module独立于ICP成本函数，可以与其他基于优化的系统单独结合使用。通过在迭代优化过程中直接考虑退化方向，减轻了退化方向的不利影响。这种优化的结果利用了传感中包含的信息，同时利用了沿病态条件方向的外部信息</p><p>所提出的框架在不同环境和感官条件下的多个现实世界任务中进行了广泛的测试，现实世界的实验和分析表明，该框架可以在各种环境条件下可靠地检测可定位性，而无需根据具体情况调整参数，并且在退化环境下具有较高的鲁棒性和准确性。在具有挑战性和部分退化的场景中进行的所有实验中，所提出的框架始终优于最先进的机器人方法<a href="On%20degeneracy%20of%20optimization-based%20state%20estimation%20problems">15</a>，<a href="Degeneracy-aware%20factors%20with%20applications%20to%20underwater%20slam">24</a>，参见图1中类似隧道环境的示例。</p><p>因此，本文的主要贡献为：</p><ul><li>一种多层次、鲁棒用于scan-to-map配准的可定位性检测算法的开发与集成。为了研究多级探测的效果，我们进行了详细的消融研究</li><li>开发了一种新的可定位性考量约束ICP优化模块，并与可定位性检测紧密耦合以减轻退化的影响</li><li>进行了各种实验来评估所提出的框架的有效性，并将结果与最先进的方法进行比较。此外，还提供了附加内容、数据和补充材料</li></ul><h1 id="相关工作">相关工作</h1><h2 id="退化检测">退化检测</h2><h2 id="点云建图中的约束优化">点云建图中的约束优化</h2><p>约束优化技术在文献中是众所周知的;然而，它们在点云配准中的应用最近才引起人们的关注。首先，[51]提出了一种无穿透点云配准的约束优化方法，提高了姿态估计的质量。类似地，[52]使用非线性等式约束来减少点云配准中旋转估计的线性化误差。为了提高对传感器噪声和对应异常值的鲁棒性，[53]提出通过将每个测量作为单独的约束添加，使用增广拉格朗日来解决约束优化问题。最近的一项研究<a href="CT-ICP:%20Real-time%20Elastic%20LiDAR%20Odometry%20with%20Loop%20Closure">54</a>引入了软约束作为ICP优化的成本，以确保不同扫描之间的轨迹连续性。</p><blockquote></blockquote><p>相比之下，<a href="Teaser:%20Fast%20and%20certifiable%20point%20cloud%20registration">55</a>将点云配准问题表述为约束二次规划，以提供全局最优的点云配准结果</p><blockquote></blockquote><p>这些方法提高了全局点云配准问题的鲁棒性和准确性;然而，他们没有解决约束的效用，以限制优化中的退化的影响。为了解决这一挑战，并且与所提出的方法最相关，<a href="Robust%20rank%20deficient%20SLAM">44</a>提出使用相对条件数来检测退化性，并通过在因子图公式中引入约束来惩罚沿退化方向的运动变化</p><blockquote></blockquote><p>据作者所知，这方面的研究只有<a href="Robust%20rank%20deficient%20SLAM">44</a>。然而，这项工作仅限于2D导航，并没有考虑在低级ICP优化中使用这些约束，鉴于上述讨论，使用退化分析来约束机器人在具有挑战性和退化的环境中操作的ICP注册问题仍然是一个开放的问题，本工作旨在解决这个问题。</p><h1 id="问题描述">问题描述</h1><p>受先前研究结果的启发，本工作提出了一种在几何挑战性和退化环境中进行机器人姿态估计和可靠点云配准的解决方案。仅利用LiDAR点云和外部里程计估计作为输入，并将该方案分为可定位性检测和约束点云配准两部分。所提出的组件可以在计算资源有限的机器人系统上实时运行。</p><h2 id="问题形成">问题形成</h2><p><strong>点云配准</strong></p><p>点云配准问题定义为寻找一个刚体变换<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}} \in S E(3)\)</span>，该刚体变换能够将LiDAR坐标系中<span class="math inline">\(N_p\)</span>个点<span class="math inline">\({ }_{\mathrm{L}} \boldsymbol{P} \in \mathbb{R}^{3 \times N_p}\)</span>的点云(记为L)与地图框架中<span class="math inline">\(N_q\)</span>点，<span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{Q} \in \mathbb{R}^{3 \times N_q}\)</span>的参考点云(记为M)进行最佳对齐。</p><p>刚体变换<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}} \in S E(3)\)</span>由旋转和平移组成，对于LiDAR坐标系中的每个点，地图中的参考点通常通过kd-tree进行搜索找到，这个数据关联的过程记为：<span class="math inline">\(\mathcal{M} \in \mathbb{R}^{6 \times N}=\operatorname{matching}\left({ }_{\mathrm{L}} \boldsymbol{P},{ }_{\mathrm{m}} \boldsymbol{Q}, \boldsymbol{T}_{\mathrm{LM}, \text { init }}\right)=\left.\left\{\left({ }_{\mathrm{M}} \boldsymbol{p},\left \{ { }_{\mathrm{M}} \boldsymbol{q},{ }_{\mathrm{M}} \boldsymbol{p}\right\}\right):\left({ }_{\mathrm{M}} \boldsymbol{p} \in{ }_{\mathrm{M}} \boldsymbol{P}\right),{ }_{\mathrm{M}} \boldsymbol{q} \in{ }_{\mathrm{M}} \boldsymbol{Q}\right)\right\}\)</span>，其中<span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{p}\)</span> 和 <span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{q}\)</span>是匹配点对，<span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{n} \in \mathbb{R}^3,\left\|_{\mathrm{M}} \boldsymbol{n}\right\|=1\)</span>是<span class="math inline">\(_M\boldsymbol{q}\)</span>的平面法向量。</p><p>另外，N≤Np是匹配点的个数，表示接下来的工作的问题大小。初始变换<span class="math inline">\(\boldsymbol{T}_{\text {LM,init }}\)</span>通常作为初始猜测提供，将扫描数据转换为参考坐标系，以改善匹配过程和优化收敛特性。虽然这种初始转换的准确性对于最小化的收敛至关重要[14]，但这种初始转换的质量的影响不在本工作的范围内。</p><p>定义点云对齐误差函数有多种方法;在本工作中，将使用点到平面[7]的代价函数。具有<strong>点到平面</strong>成本函数的ICP最小化问题定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/25/1687694477-0.png"></p><p>不同的求解方法，如奇异值分解(SVD)[56]、LU分解、Gauss-Newton和Levenberg-Marquardt，都可以用来求解这个最小化问题。在这项工作中，重点是直接线性代数求解器，如SVD，它直接以矩阵形式运算。</p><p>根据Pomerleau等人[57]的推导，引入标量三重积和旋转矩阵线性化，最小化(1)可以重新表述为二次代价优化问题，如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687742957-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\boldsymbol{x}=\left[\boldsymbol{r}^{\top} \boldsymbol{t}^{\top}\right]^{\top} \quad \in \mathbb{R}^6\)</span>是待优化变量</li><li><span class="math inline">\(\boldsymbol{r} \in \mathfrak{s o}(3)\)</span>是李代数SO3的旋转量</li><li><span class="math inline">\(\boldsymbol{t} \in \mathbb{R}^3\)</span></li><li><span class="math inline">\(\boldsymbol{A}^{\prime} \in \mathbb{R}^{6 \times 6}\)</span>为优化问题的Hessian矩阵</li><li><span class="math inline">\(\boldsymbol{b}^{\prime} \in \mathbb{R}^6\)</span>结合点云之间的约束</li><li>此公式(2)中的<span class="math inline">\(\boldsymbol{p}_i\)</span>应该是根据位姿初值投影到地图坐标系后的投影点坐标</li></ul><p>Hessian构成了优化的二阶矩矩阵，并定义了雅可比矩阵的局部行为。并且，式(2)是众所周知的以优化变量<span class="math inline">\(x\)</span>为变量的二次最小化形式，可以将其重新表述为正则最小二乘优化公式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687743372-0.png"></p><p>对于(半)正定矩阵<span class="math inline">\(\boldsymbol{A}^{\prime}\)</span>，求解这个最小化问题很简单。该6 × 6线性方程组的解将得到在该线性化点下的最优平移矢量<span class="math inline">\(\boldsymbol{t}\)</span>和旋转矢量<span class="math inline">\(\boldsymbol{r}\)</span>。在ICP过程中，由于非线性和由此产生的算法的迭代性质，这里描述的这些操作被重复，直到收敛。</p><p><strong>在退化环境中的操作</strong></p><p>在实际应用中，由于缺乏几何信息结构而引起的环境退化，上述点云配准可能会失败。之前的配准的解<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}}\)</span>是欠约束的，这意味着6-DoF变换的一个或多个维度(几乎)不能从观测到的correspondences中观察到。</p><p>因此，本工作试图解决的主要问题被定义为<strong>在存在环境退化的情况下找到最佳转换<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}}\)</span>，同时确定由于欠约束导致的难以估计的方向</strong>。</p><p>虽然在大多数先前的工作中忽略了这一点，但这项工作提出了一个专门针对这些情况的解决方案，以便在极端情况下运行。</p><h1 id="系统概览">系统概览</h1><p>所提出系统的概述如图2所示。提出了一种检测和减轻退化的新组件<code>Loc.-Module</code>和<code>Opt.-Module</code>，嵌入到scan-to-map配准系统<code>Pharos</code>[58]，[59]，由ANYbotics开发。但是，值得注意的是，所提出的组件可以集成到任何基于迭代优化的配准方法中。Pharos以5hz的频率运行，并与著名的点云配准库<code>libpointmatcher</code>的点对平面ICP实现紧密耦合[59]。此外，Pharos利用外部里程计姿态估计来补偿点云畸变，并作为配准先验<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}, \text { init }}\)</span>，实现scan-to-map的关联搜索。</p><h2 id="可定位性检测模块概述">可定位性检测模块概述</h2><p><code>Loc.-Module</code>的目标是近似于ICP优化的Hessian <span class="math inline">\(\boldsymbol{A}^{\prime}\)</span>的零空间。为了实现这一目标，引入了一个跨越6自由度优化问题的可定位性向量。这个局部化向量指示哪些特征向量在或应该被考虑为Hessian零空间内。可定位性向量定义为：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687744145-0.png"></p><p>其中，<span class="math inline">\(\left \{ { }_{\mathrm{L}} \boldsymbol{v}_{t_1}, \mathrm{~L}_{\mathrm{L}} \boldsymbol{v}_{t_2},{ }_{\mathrm{L}} \boldsymbol{v}_{t_3}\right\} \in \boldsymbol{V}_t\)</span>是Hessian <span class="math inline">\(\boldsymbol{A}^{\prime}\)</span>关于变量<span class="math inline">\(t\)</span>的平移特征向量（在雷达坐标系下的表示），相似的，<span class="math inline">\(\left \{ { }_{\mathrm{L}} \boldsymbol{v}_{r_1,{ }_{\mathrm{L}}} \boldsymbol{v}_{r_2, \mathrm{~L}_{\mathrm{L}}} \boldsymbol{v}_{r_3}\right \} \in \boldsymbol{V}_r\)</span>只对应于旋转向量<span class="math inline">\(\boldsymbol{r}\)</span>。</p><p>重要的是，如第II-A节所讨论的，ICP的雅可比矩阵由两个独立的元素组成，分别是平移和旋转的<span class="math inline">\(\boldsymbol{n}\)</span>和<span class="math inline">\(\boldsymbol{p} \times \boldsymbol{n}\)</span>，这是点对平面成本函数的固有属性。为了保持这一性质的有效性，<strong>在本工作中，在可定位性分析中省略了平移分量和旋转分量之间的交叉协方差</strong>。因此，只需要平移和旋转特征向量。</p><p>关于如何获得<span class="math inline">\(\boldsymbol{V}_t\)</span> 和 <span class="math inline">\(\boldsymbol{V}_r\)</span>的更多细节将在第V节的步骤V- a中解释。可定位性类别<span class="math inline">\(\Omega\)</span>以分类变量的形式表示每个特征向量的可局部化状态;这个离散的可本地化空间定义为<span class="math inline">\(\boldsymbol{\Omega}_i \in \{none, partial, full \}\)</span>，其中的类别分别对应于不可定位、部分可定位和可定位。每个类别的操作顺序将在第V节的步骤V- c中解释。</p><p><strong>考量可定位性的优化模块概述</strong></p><p>利用<code>Loc.-Module</code>模块的输出，如可定位性类别<span class="math inline">\(\Omega\)</span>，<code>Opt.-Module</code>的目标定义为构造和求解包含约束的优化问题，该问题将用于寻找优化问题(3)的最优解<span class="math inline">\(\boldsymbol{x}^*\)</span>。这一过程将在章节VI. 中详细说明。在这一部分中，<strong>使用基于拉格朗日乘子的约束优化技术</strong>来获得给定观察到的局部性的最优可能解。</p><h1 id="可定位性检测模块">可定位性检测模块</h1><p>在本节中，将详细介绍<code>Loc.-Module</code>按照图3所示的信息流进行描述。可定位性检测的目的是分析关联数据中的信息，从而正确识别约束不足的方向。如图3所示，给定关联数据关系，<strong>第一个任务是信息分析</strong>，分析Hessian与来自环境的几何信息之间的关系。<strong>第二步，“过滤</strong>”，过滤掉第一步中信息分析步骤中的冗余信息。<strong>最后，对过滤后的信息进行解释</strong>，从而实现细粒度分类。经过关联数据搜索后，将匹配的关联变换回LiDAR坐标系<span class="math inline">\(\mathrm{L}\)</span>，消除地图物理尺寸的影响，并在该帧中进行可定位性分析</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687750438-0.png"></p><h2 id="信息分析">信息分析</h2><h3 id="eigenanalysis">Eigenanalysis</h3><p>信息分析从优化问题的Hessian矩阵的特征分析开始。对于点到面ICP成本函数矩阵的推导，请参考第IV节，其中Hessian为式(3)中的<span class="math inline">\(A^{\prime}\)</span>。根据待优化的变量<span class="math inline">\(\boldsymbol{x}\)</span>的含义，Hessian可以划分为子矩阵：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687745426-0.png"></p><p>这里，<span class="math inline">\(\boldsymbol{A}_{r r}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>只包含与旋转变量相关的信息。同样，<span class="math inline">\(\boldsymbol{A}_{t t}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>只包含与平移变量相关的信息。</p><p>利用奇异值分解(SVD)对<span class="math inline">\(\boldsymbol{A}_{t t}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>和<span class="math inline">\(\boldsymbol{A}_{r r}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>进行特征分析。对于旋转和平移分量，特征分解为：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687745530-0.png"></p><p>其中<span class="math inline">\(\boldsymbol{V}_t \in S O(3)\)</span> 和 <span class="math inline">\(\boldsymbol{V}_r \in S O(3)\)</span>是矩阵形式的特征向量。<span class="math inline">\(\Sigma_t \in\left\{\operatorname{diag}(\boldsymbol{v}): \boldsymbol{v} \in \mathbb{R}^n{\geq 0}\right\}\)</span> 和 <span class="math inline">\(\Sigma_r \in\left\{\operatorname{diag}(\boldsymbol{v}): \boldsymbol{v} \in \mathbb{R}^n{\geq 0}\right\}\)</span>分别是以<span class="math inline">\(\boldsymbol{A}_{t t}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>和<span class="math inline">\(\boldsymbol{A}_{r r}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>的特征值为对角项的对角矩阵。</p><p>有趣的是，<span class="math inline">\(\Sigma_t\)</span> 和 <span class="math inline">\(\Sigma_r\)</span>中的特征值提供了与其配对的每个特征向量的信息的直接度量。然而，正如第II节所讨论的，特征值对于不同的环境和传感器可能表现不一致，<strong>因此不直接用于本工作的可定位性估计</strong>。</p><h3 id="information-pair-contribution">Information Pair Contribution</h3><p>信息分析的第二部分是制定每个数据关联对的贡献，定义为<span class="math inline">\(\left({ }_{\mathrm{L}} \boldsymbol{p},{ }_{\mathrm{L}} \boldsymbol{n}\right)\)</span>。需要在数据关联对和成本之间建立正式的关系，以评估数据关联对对成本的贡献。与其他作品[38]、[39]、[60]相似，本文选择优化的雅可比矩阵作为贡献指标。</p><p>可以直观地看到，式(2)中定义的雅可比矩阵A，根据定义度量了优化变量<span class="math inline">\(\boldsymbol{X}_i\)</span>的代价变化。</p><p><strong>Analogy to Classical Mechanics</strong></p><p>与经典力学类似，雅可比矩阵测量由每个数据关联对局部引起的影响的大小。 一个扳手系统由力和扭矩组成：在给出的应用中，可以认为这对作用力和扭矩作用于解<span class="math inline">\(\boldsymbol{x}\)</span>，在本例中，对解进行平移的力定义为表面法向量<span class="math inline">\(n\)</span>，对解进行旋转的扭矩定义为<span class="math inline">\(\boldsymbol{\tau}=\boldsymbol{p} \times \boldsymbol{n}\)</span>。虽然直观，扭矩公式不提供一个可推广的参数化在其简单的形式。点<span class="math inline">\(p\)</span>可以处于不同的距离，导致更远点的扭矩更高，这阻碍了该公式在实际应用中的推广。</p><p>Kwok和Tang[39]研究了这种尺度差异对不同归一化技术的ICP算法的影响。研究表明，最大规范归一化比平均规范归一化表现更好，如[38]或矩归一化所做的那样。</p><p>这对于可靠地解决ICP问题是正确的，其中需要点之间的空间关系。然而，对于局部化估计的逐点贡献计算，情况并非如此。考虑到这一事实以及点范数不应直接影响贡献值的要求，本工作提出使用矩归一化，将扭矩值映射到单位球(如式(5)所示)。</p><p><strong>Information Matrix</strong></p><p>为了数值稳定性，如果<span class="math inline">\(|\boldsymbol{\tau}|\)</span>接近于零(即，向量接近平行)，信息对被丢弃，(这发生在平面法向量直接指向传感器坐标系) 【此处个人感觉描述有误，这应该发生在平面法向量与关联点与世界坐标系原点的连线平行的时候，叉乘为0】。</p><p>此外，矩归一化仅适用于<span class="math inline">\(|\boldsymbol{\tau}| \geq 1\)</span>的信息对，防止转矩值在单位球内的映射，因为这可能会推动<code>Loc.-Module</code>走向乐观可定位性检测。</p><p>在转矩向量的矩归一化之后，将扳手系统堆叠为所有可用的信息对，形成如下信息矩阵：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687747900-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{F}_r \in \mathbb{R}^{N \times 3}\)</span> 和 <span class="math inline">\(\mathcal{F}_t \in \mathbb{R}^{N \times 3}\)</span>分别是旋转和平移信息矩阵</li></ul><p>信息分析的最后一个任务是从<span class="math inline">\(\mathcal{F}_r \in \mathbb{R}^{N \times 3}\)</span> 和 <span class="math inline">\(\mathcal{F}_t \in \mathbb{R}^{N \times 3}\)</span>计算可定位性贡献</p><p><strong>Localizability Contributions</strong></p><p>可定位性概念在每个特征值的特征空间中定义，因此，对于每个特征向量方向都可以得到，这确保了检测不会受到激光雷达或机器人在环境中的朝向的影响，这是实际应用中的一个关键优势。因此，等式 (5) 中定义的信息矩阵被投影到平移和旋转 Hessian 的特征空间中。为了实现这一点，特征向量矩阵<span class="math inline">\(\mathbf{V}_r\)</span> 和 <span class="math inline">\(\mathbf{V}_t\)</span>将按如下方式使用：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687748224-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{I}_r, \mathcal{I}_t \in \mathbb{R}^{N \times 3}\)</span>是所有数据关联对<span class="math inline">\(\{ \boldsymbol{p}, \boldsymbol{n} \}\)</span>的可定位性贡献，经过<span class="math inline">\(\left \{ \mathbf{V}_r, \mathbf{V}_r\right \}\)</span>中的特征向量投影</li><li><span class="math inline">\((\ldots)^{|\cdot|}\)</span>操作符表示向量的每个元素绝对值</li><li>同时，<span class="math inline">\(\mathcal{I}_r\)</span> 和 <span class="math inline">\(\mathcal{I}_t\)</span>中的标量值是某一方向可定位性贡献的直接指标</li></ul><p>如果标量值为<span class="math inline">\(\mathcal{I}(i)=1.0\)</span>，则方向的局部性贡献是完美的，如果<span class="math inline">\(\mathcal{I}(i)=0.0\)</span>，则数据关联对对这个方向的可定位性没有贡献。</p><h2 id="过滤">过滤</h2><p>给定等式 (6) 中定义的可实现性贡献<span class="math inline">\(\mathcal{I}=\left[\mathcal{I}_r, \mathcal{I}_t\right] \in \mathbb{R}^{N \times 6}\)</span>，过滤步骤的目标是删除冗余信息并使当前信息可解释。</p><p><strong>Filtering Low Contribution</strong></p><p>冗余信息示例如图 3-A 所示，其中红色突出显示的低贡献区域主导了分析，如果可定位性的贡献较小，则可能与测量噪声或特征提取噪声无法区分。此步骤通过使用二进制元素过滤来解决这个问题。过滤操作是一个重新分配操作，定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687749553-0.png"></p><p>其中，</p><ul><li>这里的索引定义为<span class="math inline">\(i \in\{1, \ldots, N\}\)</span> 和 <span class="math inline">\(j \in \{1, \ldots, 6\}\)</span>，</li><li><span class="math inline">\(\mathcal{I}_c{ }^{\prime}\)</span>是过滤后的可定位性贡献向量，它包含所有可靠的可定位性贡献值</li><li>此外，<span class="math inline">\(\kappa_f\)</span>是过滤参数，第一个用户定义的参数。由于该参数捕获不同激光雷达传感器的传感器和特征提取噪声，因此应根据传感器和特征提取进行重新调整</li></ul><p>除Ouster OS0-128外，该参数在所有实验中设置为<span class="math inline">\(\kappa_f=\cos \left(80^{\circ}\right) \approx 0.1736\)</span>，考虑到Ouster OS0-128与Velodyne VLP-16相比不同的噪声特性；Ouster LiDAR 测量受到更高的方差的影响，因此，设置为<span class="math inline">\(\kappa_f = \cos \left(60^{\circ}\right)=0.5\)</span>以实现更积极的过滤。</p><p><strong>Filtering High Contribution</strong></p><p>使用这种过滤后的可本地化贡献<span class="math inline">\(\mathcal{I}_c^{\prime}\)</span>（大于阈值<span class="math inline">\(\kappa_f\)</span> 的贡献），可以结合起来总结可用的几何信息：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687750065-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{L}_c \in \mathbb{R}^{1 \times 6}\)</span>是所有可靠数据关联对的可定位性的贡献求和后的向量。</li></ul><p>更多的对应关系表明可用的信息更高。同时，更多的对应关系还包括更多的传感器和特征提取噪声。V-B1 节的过滤步骤充当<strong>异常值拒绝步骤</strong>，并有助于减少这些影响。矩阵 <span class="math inline">\(\mathcal{I}_{\boldsymbol{c}}{ }^{\prime}\)</span> 仍然包含弱但可靠的贡献，需要保留。</p><p>然而，仍然需要衡量最强的贡献来识别可定位性更细粒度的状态，这个过滤步骤基于几何向量对齐；只有大于<span class="math inline">\(\cos \left(45^{\circ}\right) \approx 0.707\)</span>的对齐值才会被认为是强有力的贡献，通过几何关系证明。在图 3-B 中，可视化了强对齐区域和弱对齐区域与特征向量的分离。内绿色锥表示向量对齐强的区域，黄色区域表示弱区域。这种分离公式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687750410-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{L}_s \in \mathbb{R}^{1 \times 6}\)</span>是是强可定位性的贡献向量。与组合可定位性贡献<span class="math inline">\(\mathcal{L}_c(j)\)</span>类似，该表达式也受到 N 变化的影响，但是它对传感器噪声不太敏感，仅受特征提取误差的影响</li></ul><p>这些强可定位性的贡献向量<span class="math inline">\(\mathcal{L}_s\)</span>和组合可定位性贡献向量<span class="math inline">\(\mathcal{L}_c\)</span>对于下一步至关重要，其中这些向量将用于对可定位性进行分类</p><h2 id="categorization">Categorization</h2><p><code>Loc.-Module</code>的最后一步将根据上一步的信息，提供了可定位性分类</p><h3 id="可定位性参数">可定位性参数</h3><p>为了实现这一目标，引入了三个可定位性参数：</p><ul><li>参数<span class="math inline">\(\kappa_1\)</span>是定义完全可定位的下界的安全可定位阈值</li><li>参数<span class="math inline">\(\kappa_2\)</span>调节从可定位到部分可定位的转换，并表示部分可定位的阈值上限</li><li>参数<span class="math inline">\(\kappa_3\)</span>是最小信息阈值，涵盖了环境稀疏但对齐良好的信息的情况，并调节从部分可定位到不可定位的转换。</li></ul><h3 id="参数选择">参数选择</h3><p>这些阈值的定义提供了参数之间的自然界限，<span class="math inline">\(\kappa_1 \geq \kappa_2&gt;\kappa_3\)</span>。这些参数是根据所采用的ICP算法的收敛范围来设置的。</p><p>参数设置规则如下:</p><ul><li>由于<span class="math inline">\(\kappa_1\)</span>设置了可本地化和{partial-localizability, non-localizable}之间的边界，它可以设置为任意高。唯一的缺点是可定位性检测的计算成本，一个示例：<span class="math inline">\(\kappa_1 = 500\)</span>表示ICP优化运行至少500个完美的匹配对。</li><li>另一方面，设置<span class="math inline">\(\kappa_2\)</span>是一种系统特性选择。它与<span class="math inline">\(\kappa_3\)</span>共同定义了如何处理局部可定位性。它应该设置在<span class="math inline">\(\kappa_1\)</span>和<span class="math inline">\(\kappa_3\)</span>之间。</li><li>最后，<span class="math inline">\(\kappa_3\)</span>设置了部分可定位和不可定位状态的边界。值为50表明允许约束ICP优化以最少50个采样对的受控方式运行</li></ul><p>利用这些直觉，在本工作的其余部分，将第7节中所有环境和传感器的可定位性参数设置为<span class="math inline">\(\kappa_1= 250\)</span>， <span class="math inline">\(\kappa_2 = 180\)</span>和<span class="math inline">\(\kappa_3 = 35\)</span>。</p><p>### 决策树</p><p>在决策树中使用这些参数来获得如图3-C所示的可定位性类别。决策树以过滤后的可定位性贡献向量和特征向量作为输入。决策树按特征向量操作;因此，对所有6个方向重复所需的二进制比较。</p><p>首先，通过比较<span class="math inline">\(\kappa_1\)</span> 与<span class="math inline">\(\mathcal{L}_c\)</span>、<span class="math inline">\(\kappa_2\)</span> 与<span class="math inline">\(\mathcal{L}_s\)</span>，验证优化问题是否在特征向量方向上可解。如果这些比较中的任何一个表明问题是良好约束的，那么该方向是可定位的，<span class="math inline">\(\Omega_{\boldsymbol{v}_j}=\)</span> full.。</p><p>其次，假设第一步的比较表明问题没有很好的约束；在这种情况下，将<span class="math inline">\(\kappa_2\)</span>与<span class="math inline">\(\mathcal{L}_c\)</span>进行比较，将<span class="math inline">\(\kappa_3\)</span>与<span class="math inline">\(\mathcal{L}_s\)</span>进行比较，以了解优化问题中是否存在可挽救的信息。</p><p>如果这些比较中的任何一个成立，可定位性类别被分配为partial，即部分可定位， <span class="math inline">\(\Omega_{\boldsymbol{v}_j}=\)</span> partial，否则，则表示是不可定位<span class="math inline">\(\Omega_{\boldsymbol{v}_j}=\)</span> none</p><p>### Xs-ICP - Simplified X-ICP</p><p>...</p><p># 考虑可定位性的优化模块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x-icp-localizability-aware-lidar-registration-for-robust-localization-in-extreme-environments&quot;&gt;X-ICP: Localizability-Aware LiDAR Reg
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>POINT-LIO论文阅读</title>
    <link href="http://yoursite.com/2023/06/14/POINT-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/06/14/POINT-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-06-14T14:15:53.000Z</published>
    <updated>2023-06-19T12:33:40.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="point-lio-robust-high-bandwidth-light-detection-and-ranging-inertial-odometry">Point-LIO: Robust High-Bandwidth Light Detection and Ranging Inertial Odometry</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/06/14/1686752158-0.png" alt="Clipboard 2023年6月14日 22.15"><figcaption aria-hidden="true">Clipboard 2023年6月14日 22.15</figcaption></figure><h1 id="摘要">摘要</h1><p>一种鲁棒、高带宽的光探测和测距(LiDAR)惯性里程计，具有估计极激进的机器人运动的能力。Point-LIO有两个关键的新颖之处，第一个是逐点LIO框架，更新与每个LiDAR点测量对应的状态，该框架允许极高频率的里程表输出，显著增加了里程表带宽，并从根本上消除了人为的帧内运动畸变；第二个是随机过程增强的运动学模型，将IMU测量作为输出建模。这种新的建模方法即使在惯性测量单元(IMU)测量在运动中间饱和的情况下，也能对猛烈运动进行准确的定位和可靠的建图。</p><p>各种现实世界的实验进行了性能评估。总体而言，Point-LIO能够在超出IMU测量范围的剧烈振动和高角速度(75 rad/s)的剧烈运动下提供准确的高频里程计(4-8 kHz)和可靠的测绘。此外，还进行了详尽的基准比较。Point-LIO始终如一地达到相当的精度和时间消耗。最后，给出了Point-LIO的两种应用实例，一种是竞速无人机，另一种是自旋无人机，两者都具有激进的运动。</p><h1 id="介绍">介绍</h1><h2 id="现有畸变矫正方法以及局限性">现有畸变矫正方法以及局限性</h2><h1 id="系统概览">系统概览</h1><p>我们的设计理念是真实地认识到:1)LiDAR点是在各自时间按顺序采样的，而不是同时采样的帧;2)IMU数据是系统的测量数据，而不是系统的输入。一旦接收到各自的测量值(每个LiDAR点或IMU数据)，我们将这两个测量值融合在一个流形EKF框架[55]中。</p><p>我们设计的系统的概述如图1所示;顺序采样的LiDAR点和IMU数据都用于在各自的时间戳更新状态，从而导致极高速率的里程计输出，即在实践中为4-8 kHz。特别是，对于接收到的每个LiDAR点，从地图中搜索相应的平面。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/14/1686752971-0.png" alt="Clipboard 2023年6月14日 22.29"><figcaption aria-hidden="true">Clipboard 2023年6月14日 22.29</figcaption></figure><p>如果点与地图中的平面匹配，将计算残差使用流形卡尔曼滤波器来更新系统状态。优化后的姿态最终将LiDAR点注册到全局坐标系中，并合并到地图上，然后进行下一个测量(LiDAR点或IMU数据)。否则，如果点没有匹配的平面，则通过卡尔曼滤波器预测的姿态直接添加到地图中。为了在允许新配准点的同时实现快速平面对应搜索，我们使用了最初在fast - lio2中开发的增量k-d树结构ikd-Tree。[29]对于每次IMU测量，IMU的每个通道的饱和度检查是单独进行的，具有饱和值的通道不会被用于状态更新。</p><h1 id="状态估计">状态估计</h1><p>Point-LIO的状态估计是一个紧耦合的流形卡尔曼滤波器。在这里，我们简要地解释滤波器的基本公式和工作流程，并参考[55]对流形上卡尔曼滤波器进行更详细的理论解释。</p><h2 id="符号约定">符号约定</h2><p>为了便于解释，我们采用如下符号</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686760055-0.png" alt="Clipboard 2023年6月15日 00.27"><figcaption aria-hidden="true">Clipboard 2023年6月15日 00.27</figcaption></figure><h2 id="动态模型">动态模型</h2><h3 id="状态转移模型">状态转移模型</h3><p>以IMU框架(记为I)为机体系，第一帧IMU坐标系为全局坐标系(记为G)，连续运动模型为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686760787-0.png" alt="Clipboard 2023年6月15日 00.39"><figcaption aria-hidden="true">Clipboard 2023年6月15日 00.39</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\({ }^G \mathbf{R}_I,{ }^G \mathbf{p}_I\)</span>, and <span class="math inline">\({ }^G \mathbf{v}_I\)</span>分别表示imu的姿态、位置和速度在全局坐标系的表示</li><li><span class="math inline">\({ }^G \mathbf{g}\)</span>表示重力向量在全局坐标系的表示（第一帧IMU坐标系）</li><li><span class="math inline">\(b_g\)</span> and <span class="math inline">\(b_a\)</span>建模为受高斯噪声<span class="math inline">\(\mathbf{n}_{\mathrm{b}_{\mathrm{g}}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{b}_{\mathrm{g}}}\right)\)</span> and <span class="math inline">\(\mathbf{n}_{\mathrm{b}_{\mathrm{a}}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{b}_{\mathrm{a}}}\right)\)</span>影响的imu bias，具有随机游走的性质</li><li><span class="math inline">\(\lfloor\mathbf{a}\rfloor\)</span>记号表示关于向量<span class="math inline">\(a \in \mathbb{R}^3\)</span>的反对称矩阵</li><li><span class="math inline">\({ }^I \boldsymbol{\omega}\)</span> and <span class="math inline">\({ }^I \mathbf{a}\)</span>分别表示imu在body系的测量值。</li></ul><p>如文献[14]所提出的，机器人的某个运动(角速度<span class="math inline">\({ }^I \boldsymbol{\omega}\)</span>和线加速度<span class="math inline">\({ }^I \mathbf{a}\)</span>)总是可以被视为信号集合或集合的一个样本，这使我们能够通过<strong>随机过程统计</strong>地描述机器人的运动。</p><p>此外，如文献[14]所述，由于机器人系统的运动通常具有一定的平滑性(例如，由于执行器的延迟)，角速度和加速度的快速变化相对不太可能，并且n阶积分器随机过程通常足以满足实际使用。</p><p>特别地，我们选择了由高斯噪声<span class="math inline">\(\mathbf{w}_{\mathrm{g}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{g}}\right)\)</span> 和 <span class="math inline">\(\mathbf{w}_{\mathrm{a}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{a}}\right)\)</span>驱动的一阶积分器模型来分别模拟角速度<span class="math inline">\({ }^I \boldsymbol{\omega}\)</span>和线性加速度<span class="math inline">\({ }^I \mathbf{a}\)</span>。</p><p>然后将连续时间模型(2)在每个测量步骤k处离散化。表示<span class="math inline">\(\Delta t_k\)</span>为当前测量间隔，即之前测量(IMU数据或LiDAR点)与当前测量(IMU数据或LiDAR点)之间的时间差。对连续模型(2)进行离散化，假设输入在区间<span class="math inline">\(\Delta t_k\)</span>内保持恒定（加速度、角速度），得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686761972-0.png" alt="Clipboard 2023年6月15日 00.59"><figcaption aria-hidden="true">Clipboard 2023年6月15日 00.59</figcaption></figure><p>其中，流形<span class="math inline">\(\mathcal{M}\)</span>，函数<span class="math inline">\(\mathbf{f}\)</span>，状态<span class="math inline">\(\mathbf{x}\)</span>以及过程噪声<span class="math inline">\(\mathbf{w}\)</span>定义为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686762069-0.png" alt="Clipboard 2023年6月15日 01.01"><figcaption aria-hidden="true">Clipboard 2023年6月15日 01.01</figcaption></figure><p>其中，<span class="math inline">\(\mathcal{Q}=\operatorname{diag}\left(\mathcal{Q}_{\mathrm{b}_{\mathrm{g}}}, \mathcal{Q}_{\mathrm{b}_{\mathrm{a}}}, \mathcal{Q}_{\mathrm{g}}, \mathcal{Q}_{\mathrm{a}}\right)\)</span>是过程噪声<span class="math inline">\(\mathbf{w}\)</span>的协方差矩阵。</p><h3 id="测量模型">测量模型</h3><p>该系统有两个测量，一个激光雷达点或IMU数据(由角速度和加速度组成)。这两个测量通常是系统在不同时间采样和接收的，因此我们分别对它们进行建模。</p><p>假设 LiDAR 系与Body（即 IMU）系重合，或者具有预先标定的外参，一个雷达点<span class="math inline">\({ }^I \mathbf{p}_{\mathrm{m}_k}\)</span>等于局部IMU坐标系的真实位置<span class="math inline">\({ }^I \mathbf{p}_k^{\mathrm{gt}}\)</span>，但是，实际上我们并不知道对应局部IMU坐标系的点的真实位置，我们假设该值受高斯噪声<span class="math inline">\(\mathbf{n}_{\mathrm{L}_k} \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_{\mathrm{L}_k}\right)\)</span>的影响，因此有：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832451-0.png"></p><p>这个真正的点，在使用真实(但未知)IMU位姿<span class="math inline">\({ }^G \mathbf{T}_{I_k}=\left({ }^G \mathbf{R}_{I_k},{ }^G \mathbf{p}_{I_k}\right)\)</span>投影到全局坐标系后，应该恰好位于地图中的局部小平面补丁上(见图2)，即有：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832535-0.png"></p><p>其中，</p><ul><li><span class="math inline">\({ }^G \mathbf{u}_k\)</span>是关联平面的法向量</li><li><span class="math inline">\({ }^G \mathbf{q}_k\)</span>是平面上任意点</li><li>注意，<span class="math inline">\({ }^G \mathbf{T}_{I_k}\)</span>被包含在状态向量<span class="math inline">\(\mathbf{X}_k\)</span>中，式（6）对状态向量<span class="math inline">\(\mathbf{X}_k\)</span>施加隐式测量模型</li></ul><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832936-0.png"></p><p>IMU测量由角速度测量(<span class="math inline">\({ }^I \mathbf{\omega}_{\mathrm{m}}\)</span>)和加速度测量(<span class="math inline">\({ }^I \mathbf{a}_{\mathrm{m}}\)</span>)组成：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832699-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{n}_{\mathrm{g}} \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_{\mathrm{g}}\right) \quad\)</span> 和 <span class="math inline">\(\quad \mathbf{n}_{\mathrm{a}} \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_{\mathrm{a}}\right)\)</span>是高斯噪声</li><li>那么，记<span class="math inline">\(\mathbf{n}_I=\left[\begin{array}{ll}\mathbf{n}_{\mathrm{g}}^T &amp; \mathbf{n}_{\mathrm{a}}^T\end{array}\right]^T \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_I\right) = \mathcal{N}\left(\mathbf{0}, \operatorname{diag}\left(\mathscr{R}_{\mathrm{g}}, \mathscr{R}_{\mathrm{a}}\right)\right)\)</span>表示为IMU的测量噪声</li></ul><p>因此，状态方程 (2) 中分开的两个状态 <span class="math inline">\(\omega\)</span>、<span class="math inline">\(b_g\)</span>（类似地 <span class="math inline">\(a\)</span>、<span class="math inline">\(b_a\)</span>）现在在角速度测量<span class="math inline">\(\boldsymbol{\omega}_{\mathrm{m}}\)</span>（或加速度测量 <span class="math inline">\(\mathbf{a}\)</span>）中相关，综上所述，系统的测量模型可以用以下紧凑形式呈现：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832919-0.png"></p><h2 id="扩展卡尔曼滤波器">扩展卡尔曼滤波器</h2><p>紧密耦合EKF用于Point-LIO的状态估计。本节将介绍EKF的工作流程</p><h3 id="状态传播">状态传播</h3><p>假设我们已经收到了最多步骤 k 的测量，并且该时间步的更新状态是<span class="math inline">\(\overline{\mathbf{X}}_k\)</span>以及更新的协方差矩阵 <span class="math inline">\(\overline{\mathbf{P}}_k\)</span>。通过设置<span class="math inline">\(\mathbf{w}_k=\mathbf{0}\)</span>，根据公式(3)中的状态转换模型，可以得到从时间步k到下一次观测时间步k+1的状态传播，即：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686833324-0.png"></p><p>协方差传播如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686833348-0.png"></p><p>其中<span class="math inline">\(\mathcal{Q}_k\)</span>为过程噪声<span class="math inline">\(\mathbf{W}_k\)</span>的协方差，矩阵<span class="math inline">\(\mathbf{F}_{\mathbf{x}_k}, \mathbf{F}_{\mathbf{w}_k}\)</span>计算如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686833412-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{k+1}\)</span>是时间步k+1的真实状态向量</li><li><span class="math inline">\(\mathbf{F}_{11}=\operatorname{Exp}\left(-{ }^I \overline{\boldsymbol{\omega}}_k \Delta t_k\right)\)</span></li><li><span class="math inline">\(\mathbf{F}_{38}={}^G \overline{\mathbf{R}}_{I_k} \Delta t_k\)</span></li></ul><h3 id="残差计算">残差计算</h3><p><strong>激光测量</strong></p><p>利用卡尔曼滤波(9)预测的位姿<span class="math inline">\({ }^G \hat{\mathbf{T}}_{I_{k+1}}=\left({ }^G \hat{\mathbf{R}}_{I_{k+1}},{ }^G \hat{\mathbf{p}}_{I_{k+1}}\right)\)</span>，我们将测量的LiDAR点<span class="math inline">\({ }^I \mathbf{p}_{\mathrm{m}_{k+1}}\)</span>投影到全局坐标系，得到<span class="math inline">\({ }^G \hat{\mathbf{p}}_{k+1}={ }^G \hat{\mathbf{R}}_{I_{k+1}}{ }^I \mathbf{p}_{\mathrm{m}_{k+1}}+{ }^G \hat{\mathbf{p}}_{I_{k+1}}\)</span>，并在由ikd-tree构造的地图结构中搜索其最近的5个点(距离<span class="math inline">\({ }^G \hat{\mathbf{p}}_{k+1}\)</span> 5米以内)</p><p>然后使用找到的最近邻点拟合具有法向量<span class="math inline">\({ }^G \mathbf{u}_{k+1}\)</span>和质心<span class="math inline">\({ }^G \mathbf{q}_{k+1}\)</span>的局部小平面块，如测量模型所示（参见公式（6）和图 2）。</p><p>如果最近的五个点不位于拟合平面路径上(即任何点到平面的距离大于0.1 m)，则当前LiDAR点<span class="math inline">\({ }^G \hat{\mathbf{p}}_{k+1}\)</span>的测量直接合并到地图中，而不需要残差计算或状态更新。 【？？？？】</p><p>否则，如果局部平面成功拟合，则根据式(8)计算残差<span class="math inline">\(\left(\mathbf{r}_{\mathrm{L}_{k+1}}\right)\)</span>如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175048-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\delta \mathbf{x}_{k+1}=\mathbf{x}_{k+1} \boxminus \hat{\mathbf{x}}_{k+1}\)</span></li><li><span class="math inline">\(\mathbf{x}_{k+1}\)</span>是时间步K+1的真值状态向量</li></ul><p>并且，</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175169-0.png"></p><p><strong>IMU测量</strong></p><p>对于IMU测量，我们首先通过检查当前测量与额定测量范围之间的差距来评估IMU的任何通道是否饱和，如果差值太小，则IMU测量通道的测量值被丢弃而不用于更新状态。然后，收集不饱和IMU通道的加速度和角速度测量，根据式(7)计算IMU残差<span class="math inline">\(\left(\mathbf{r}_{I_{k+1}}\right)\)</span>，为了简化符号，我们在这里使用所有6个通道测量)：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175480-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\delta \mathbf{x}_{k+1}=\mathbf{x}_{k+1} \boxminus \hat{\mathbf{x}}_{k+1}\)</span></li><li><span class="math inline">\(\mathbf{x}_{k+1}\)</span>是时间步K+1的真值状态向量</li></ul><p>并且，</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175569-0.png"></p><p>综上所述，从激光雷达点测量(12)或IMU测量(14)的残差与状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>相关，通过以下关系，各自的测量噪声为：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175653-0.png"></p><p>其中，</p><p>对于激光点测量，我们有：</p><ul><li><span class="math inline">\(\mathbf{r}_{k+1}=\mathbf{r}_{L_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{H}_{k+1}=\mathbf{H}_{\mathrm{L}_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{D}_{k+1}=\mathbf{D}_{\mathrm{L}_{k+1}}\)</span></li><li><span class="math inline">\(\mathscr{R}_{k+1}=\mathscr{R}_{L_{k+1}}\)</span></li></ul><p>对于IMU测量，我们有：</p><ul><li><span class="math inline">\(\mathbf{r}_{k+1}=\mathbf{r}_{I_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{H}_{k+1}=\mathbf{H}_{\mathrm{I}_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{D}_{k+1}=\mathbf{D}_{\mathrm{I}_{k+1}}\)</span></li><li><span class="math inline">\(\mathscr{R}_{k+1}=\mathscr{R}_{I_{k+1}}\)</span></li></ul><h3 id="状态更新">状态更新</h3><p>式(9) 中的传播状态<span class="math inline">\(\hat{\mathbf{x}}_{k+1}\)</span> 和 (10) 中的协方差<span class="math inline">\(\hat{\mathbf{P}}_{k+1}\)</span> 对未知状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span> 施加先验高斯分布，如下所示：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176041-0.png"></p><blockquote><p>这里的意思是：误差状态向量服从高斯分布</p></blockquote><p>另外的，观测模型(16)给出了<span class="math inline">\(\mathbf{x}_{k+1}\)</span>的另一个高斯分布形式：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176173-0.png"></p><p>然后将(17)中的先验分布与来自(18)的测量模型相结合，得到状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>的后验分布(等价地用<span class="math inline">\(\delta \mathbf{x}_{k+1}\)</span>表示)：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176281-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\|\mathbf{x}\|_{\mathbf{A}}^2=\mathbf{x}^T \mathbf{A}^{-1} \mathbf{x}\)</span></li></ul><p>式（19）的优化问题是一个标准的二次规划，可以很容易地得到最优解<span class="math inline">\(\delta \mathbf{x}_{k+1}^0\)</span>，这本质上是卡尔曼更新[56]：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176377-0.png"></p><p>然后，更新状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176441-0.png"></p><p>更新后的状态将用于下一步传播，为此，我们还需要估计状态的协方差（上面的是误差状态的协方差），用<span class="math inline">\(\overline{\mathbf{P}}_{k+1}\)</span>表示，最优状态与状态真值之间的误差表示如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176789-0.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;point-lio-robust-high-bandwidth-light-detection-and-ranging-inertial-odometry&quot;&gt;Point-LIO: Robust High-Bandwidth Light Detection and 
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>速度坐标系转换</title>
    <link href="http://yoursite.com/2023/04/26/%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2023/04/26/%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-26T02:21:53.000Z</published>
    <updated>2023-05-15T06:15:28.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="速度坐标系转换">速度坐标系转换</h1><h2 id="问题描述">问题描述</h2><p>在做滤波器的时候，通常会遇到这样一个问题，轮速计通常安装在车辆后轴轮毂上，得到的速度通常标记为后轴中心的速度。然而IMU并不一定安装在车辆后轴中心，此时如果需要使用轮速做观测，则需要进行速度坐标系转换，即把轮速转化为IMU的速度观测。</p><h2 id="转换关系">转换关系</h2><p>假设已知后轴中心与IMU的外参关系：</p><ul><li><span class="math inline">\(R_{rear}^{imu}\)</span> 和 <span class="math inline">\(t_{rear}^{imu}\)</span>组合表示为后轴中心<code>rear</code>在IMU坐标系的位姿</li><li>即<span class="math inline">\(p_{imu} = R_{rear}^{imu} p_{rear} + t_{rear}^{imu}\)</span>把后轴中心坐标系的某个点<span class="math inline">\(p_{rear}\)</span>转换到IMU坐标系，得到点<span class="math inline">\(p_{imu}\)</span></li></ul><p>假设已知后轴中心的速度<span class="math inline">\(v_{rear}\)</span>，和后轴中心角速度<span class="math inline">\(\omega_{rear}\)</span>，那么IMU的速度<span class="math inline">\(v_{imu}\)</span>可表示为：</p><p><span class="math display">\[    v_{imu} = R_{rear}^{imu} v_{rear} - [R_{rear}^{imu} \omega_{rear}]_{\times}t_{rear}^{imu}\]</span></p><p>如果直接使用IMU的角速度<span class="math inline">\(\omega_{i}\)</span>，则可表示为：</p><p><span class="math display">\[    v_{imu} = R_{rear}^{imu} v_{rear} - [\omega_{i}]_{\times}t_{rear}^{imu}\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;速度坐标系转换&quot;&gt;速度坐标系转换&lt;/h1&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在做滤波器的时候，通常会遇到这样一个问题，轮速计通常安装在车辆后轴轮毂上，得到的速度通常标记为后轴中心的速度。然而IMU并不一定安装在车辆后轴中心，此时如果需要使用轮
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>SR-LIO论文阅读</title>
    <link href="http://yoursite.com/2023/04/20/SR-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/04/20/SR-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-04-20T10:01:53.000Z</published>
    <updated>2023-04-20T12:56:02.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sr-lio-lidar-inertial-odometry-with-sweep-reconstruction">SR-LIO: LiDAR-Inertial Odometry with Sweep Reconstruction</h1><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681988241-0.png"></p><h1 id="摘要">摘要</h1><blockquote><p>此论文所述的BA不是对激光多帧的BA，而是多传感器融合的最小二乘。</p></blockquote><p>基于改进的束平差(BA)框架，提出了一种新型激光雷达惯性里程计(LIO)，命名为SR-LIO。SR-LIO的核心是一种新的扫描重建方法，该方法对旋转激光雷达的原始输入扫描进行分割和重建，以获得更高频率的重建扫描。该方法可以有效缩短每次IMU预积分的时间间隔，减小IMU预积分误差，实现基于BA的LIO优化。为了使重建扫描期间的所有状态都能均匀优化，我们进一步提出了多段联合LIO优化，该优化允许每个扫描段的状态同时受到LiDAR和IMU的约束。在三个公共数据集上的实验结果表明，我们的SR-LIO在精度上优于所有现有的最先进的方法，通过提出的扫描重建来减少IMU预积分误差对于基于BA的LIO框架的成功非常重要。</p><h1 id="介绍">介绍</h1><p>本文提出了一种扫描重建方法，即对自旋激光雷达的原始输入扫描进行分割和重建，以获得更高频率的重建扫描。具体而言，扫描重建方法利用旋转激光雷达连续扫描的特性，将每次全扫描分割为3个扫描段，然后将每个扫描段与接下来的2个扫描段依次连接，得到重构的全扫描(如图1所示)。对每个扫描段执行上述步骤后，每个原始扫描变成3个重构的全扫描，其频率提高3倍。增加的频率缩短了两次连续扫描之间的时间间隔，从而减少了IMU预集成的误差。因此，扫描重构不仅可以提高扫描频率，还可以通过减小IMU预积分误差来提高LIO联合优化的精度。</p><p>我们在前期的研究中发现，基于BA的框架对IMU预积分误差非常敏感。为了解决这个问题，我们将提出的扫描重建方法集成到基于ba的LIO系统中，从而得到SR-LIO。所提出的SR-LIO首先对10 Hz的输入扫频进行下采样，然后进行扫频重构以获得30 Hz的重构扫频。接下来，对于每一次重构扫描，我们执行LIO联合状态优化，其中IMU预积分周期为33ms，但重构后的扫描保持完整的扫描，持续时间为100ms(如图1所示)。为了更好地保持轨迹一致性，我们提出了一种新的多段联合优化方法，该方法充分利用IMU约束和位于每100ms周期的状态变量进行优化。优化当前重构扫描的状态后，将当前重构扫描的点云添加到地图中。由于在连续重建扫描中存在重复点，因此我们以与原始输入扫描相同的频率(10 Hz)执行地图更新，以防止重复添加相同的点云。</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681988552-0.png"></p><p>总结起来，本工作的主要贡献有三个方面:</p><ul><li>提出了一种扫描重构方法，提高了LIO系统中激光雷达自旋扫描频率，降低了IMU预集成误差;</li><li>我们将所提出的扫描重建方法嵌入到新设计的基于BA的LIO系统中，实现了先进的扫描重建精度</li><li>开源</li></ul><h1 id="符号约定">符号约定</h1><h2 id="坐标系统">坐标系统</h2><p>我们记<span class="math inline">\((\cdot)^w,(\cdot)^l\)</span> and <span class="math inline">\((\cdot)^o\)</span>分别表示世界坐标系、激光雷达坐标系、IMU坐标系下的3D点。世界坐标在起始位置与<span class="math inline">\((\cdot)^o\)</span>重合。</p><p>我们记在时间<span class="math inline">\(t_i\)</span>执行激光扫描的激光坐标系为<span class="math inline">\(l_i\)</span>，那么其对应的IMU坐标为<span class="math inline">\(o_i\)</span>，那么（以外参而言）从<span class="math inline">\(l_i\)</span>到<span class="math inline">\(o_i\)</span>的转换矩阵记为<span class="math inline">\(\mathbf{T}_{l_i}^{o_i} \in S E(3)\)</span>:</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681989437-0.png"></p><p>其中，<span class="math inline">\(\mathbf{T}_{l_i}^{o_i} \in S E(3)\)</span>包含了一个旋转矩阵<span class="math inline">\(\mathbf{R}_{l_i}^{o_i} \in S O(3)\)</span>和平移向量<span class="math inline">\(\mathbf{t}_{l_i}^{o_i} \in \mathbb{R}^3\)</span>。</p><blockquote><p>外参通常离线校准一次，并在在线姿态估计期间保持不变。因此，为了简单起见，我们可以使用<span class="math inline">\(\mathbf{T}_{l}^{o}\)</span>表示<span class="math inline">\(\mathbf{T}_{l_i}^{o_i}\)</span></p></blockquote><p>在下面的语句中，为了简化符号，我们省略了表示坐标系的索引。例如，从IMU坐标到世界坐标的姿态被严格定义为<span class="math inline">\(\mathbf{T}_{o_i}^w\)</span>，但为了简单起见表示为<span class="math inline">\(T^w_i\)</span></p><p>除了位姿，我们还估计了速度v、加速度计偏置ba和陀螺仪偏置bg，它们由状态向量均匀表示:</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681989702-0.png"></p><h2 id="扫描状态表达">扫描状态表达</h2><p>受CT-ICP[6]的启发，我们表示一个扫描的状态：</p><ul><li>（1）扫描起始时刻<span class="math inline">\(t_b\)</span>的状态<span class="math inline">\(\left.S \text { (e.g., } \boldsymbol{x}_b\right)\)</span></li><li>（2）扫描结束时刻<span class="math inline">\(t_e\)</span>的状态<span class="math inline">\(S\)</span> (e.g., <span class="math inline">\(\left.\boldsymbol{x}_e\right)\)</span></li><li>因此，在<span class="math inline">\(\left[t_b, t_e\right]\)</span>时间区间内的点云，可以表示为关于<span class="math inline">\(\boldsymbol{x}_b\)</span>和<span class="math inline">\(\boldsymbol{x}_e\)</span>的函数，例如，在时间<span class="math inline">\(t_{\mathbf{p}} \in\left[t_b, t_e\right]\)</span>采集点云，那么在此时间段内的状态可以表示为：</li></ul><figure><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681994322-0.png" alt="Clipboard 2023年4月20日 20.38"><figcaption aria-hidden="true">Clipboard 2023年4月20日 20.38</figcaption></figure><p>其中，<span class="math inline">\(\operatorname{slerp}(\cdot)\)</span>表示四元数球面插值。</p><h2 id="imu测量模型">IMU测量模型</h2><p>IMU由加速度计和陀螺仪组成。IMU的原始陀螺仪和加速度计测量值<span class="math inline">\(\hat{\mathbf{a}}_t\)</span> and <span class="math inline">\(\hat{\boldsymbol{\omega}}_t\)</span>表示如下：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681994445-0.png" alt="Clipboard 2023年4月20日 20.40"><figcaption aria-hidden="true">Clipboard 2023年4月20日 20.40</figcaption></figure><p>正如在Vins-Mono[20]中提到的，加速度和陀螺仪测量中的加性噪声可以建模为高斯白噪声，<span class="math inline">\(\mathbf{n}_{\mathrm{a}} \sim N\left(\mathbf{0}, \boldsymbol{\sigma}_{\mathrm{a}}^2\right), \mathbf{n}_{\boldsymbol{\omega}} \sim N\left(\mathbf{0}, \boldsymbol{\sigma}_{\boldsymbol{\omega}}^2\right)\)</span>。加速度偏置和陀螺仪偏置建模为随机游走，其导数为高斯分布，<span class="math inline">\(\dot{\mathbf{b}}_{\mathrm{a}_t}=\mathbf{n}_{\mathbf{b}_{\mathrm{a}}} \sim N\left(\mathbf{0}, \sigma_{\mathbf{b}_{\mathrm{a}}}^2\right)\)</span>，<span class="math inline">\(\dot{\mathbf{b}}_{\omega_t}=\mathbf{n}_{\mathbf{b}_\omega} \sim N\left(\mathbf{0}, \sigma_{\mathbf{b}_\omega}^2\right)\)</span></p><h1 id="扫描重组论文核心">扫描重组（论文核心）</h1><p>扫描重组旨在从10Hz原始输入激光雷达扫描S中获得30Hz重组扫描P，图1说明了我们的核心思想</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681988552-0.png"></p><p>给定上一帧扫描<span class="math inline">\(S_j\)</span>（扫描起始时刻：<span class="math inline">\(t_{b_j}\)</span>，扫描结束：<span class="math inline">\(t_{e_j}\)</span>）以及当前帧扫描扫描<span class="math inline">\(S_{j+1}（\)</span>起始时刻：<span class="math inline">\(t_{b_{j+1}}\)</span>，扫描结束：<span class="math inline">\(t_{e_{j+1}}\)</span>）,我们假设时间段[<span class="math inline">\(t_{b_j}\)</span>, <span class="math inline">\(t_{e_j}\)</span>]和[<span class="math inline">\(t_{b_{j+1}}\)</span>, <span class="math inline">\(t_{e_{j+1}}\)</span>]的时长都是100ms。基于激光雷达在一段时间内连续采集的特点，我们可以将原始扫描数据包拆分为连续的点云数据流，然后对点云数据流进行复用重新打包，从而获得更高频率的扫描。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sr-lio-lidar-inertial-odometry-with-sweep-reconstruction&quot;&gt;SR-LIO: LiDAR-Inertial Odometry with Sweep Reconstruction&lt;/h1&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>姿态求解系列（一）An analytic solution to Wahba&#39;s problem</title>
    <link href="http://yoursite.com/2023/04/20/%E5%A7%BF%E6%80%81%E6%B1%82%E8%A7%A3%E7%B3%BB%E5%88%97(%E4%B8%80)/"/>
    <id>http://yoursite.com/2023/04/20/%E5%A7%BF%E6%80%81%E6%B1%82%E8%A7%A3%E7%B3%BB%E5%88%97(%E4%B8%80)/</id>
    <published>2023-04-20T10:01:53.000Z</published>
    <updated>2023-06-14T14:13:33.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="an-analytic-solution-to-wahbas-problem">An analytic solution to Wahba's problem</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684158134-0.png" alt="Clipboard 2023年5月15日 21.42"><figcaption aria-hidden="true">Clipboard 2023年5月15日 21.42</figcaption></figure><h1 id="摘要">摘要</h1><p>所有航天器姿态估计方法都是基于<strong>Wahba优化问题</strong>。这个问题可以简化为寻找Davenport矩阵的最大特征值和相应的特征向量。为了降低计算量，提出了<code>QUEST</code>和<code>FOMA</code>等迭代算法。但由于迭代次数不固定，求解结果理论上不准确，计算时间难以预测。最近，有人提出了一种解析解——ESOQ。解析解的优点是计算时间是固定的，在没有数值误差的情况下，理论上解是准确的。在本文中，我们对Wahba问题提出了一种不同的解析解。我们用简单且易于验证的例子表明，该方法在数值上比<code>ESOQ</code>更稳定，比<code>QUEST</code>和<code>FOMA</code>更快。我们还使用了大量的模拟测试来支持这一说法</p><h1 id="介绍">介绍</h1><p>姿态确定是每一个航天器系统成功的关键环节[1]。航天器姿态确定与估计问题是Wahba[2]在1965年提出的一个优化问题。第一种解决方案由Davenport[6]提出。Davenport证明了Wahba的问题等价于寻找所谓k矩阵的最大特征值和对应的特征向量。由于当时的计算机和相关算法还不够强大，无法将Davenport的方法应用到MAGSAT航天器的实时姿态和控制系统中[3]，因此设计了QUEST算法[3]来满足这一需求。此后，QUEST被广泛认可并应用于许多航天器姿态确定和控制系统中，同时还提出了一些其他方法，如ESOQ[4]和FOMA[5]。QUEST和FOMA使用牛顿迭代来寻找以不同方式表示的四次多项式的最大解。尽管QUEST方法的所有飞行经验都是成功的，但[8]表明，通过使用特定的例子，QUEST可能不会收敛。事实上，众所周知，牛顿的方法是不适合一般使用的，因为它可能不能收敛到一个解。即使它确实收敛，它的行为在函数非凸的区域可能是不稳定的[9]。此外，由于QUEST和FOMA的求解依赖于迭代，并且是数值求解，这意味着求解不精确，计算时间不可预测。</p><p>注意到4次多项式(四分次)允许解析解，Mortari设计了Wahba问题的闭式解[4]，其中使用四次根的一组公式代替牛顿方法（四次多项式的根有几组不同的解析公式）。在本文中，我们提出了一个由Shmakov[11]最近发现的替代解析解。Mortari的ESOQ和提出的解决方案的主要区别在于，后者的辅助立方是凹陷形式，而前者的辅助立方不是。因此，基于Shmakov公式的方法更为有效。仿真实验表明，该方法在数值上比ESOQ更稳定，与QUEST相当。</p><h1 id="wahba优化问题描述及其解法">Wahba优化问题描述及其解法</h1><h2 id="wahba的问题">Wahba的问题</h2><p>给定一组单位向量<span class="math inline">\(r_i\)</span>(表示参照系中物体的观测值)和一组单位向量<span class="math inline">\(b_i\)</span>(表示航天器体坐标系中的测量值)，航天器的姿态由满足关系的正交矩阵<span class="math inline">\(A\)</span>定义，即满足：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684159238-0.png" alt="Clipboard 2023年5月15日 22.00"><figcaption aria-hidden="true">Clipboard 2023年5月15日 22.00</figcaption></figure><p>因此，姿态确定问题是寻找使Wahba损失函数最小的正交矩阵A：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684160711-0.png" alt="Clipboard 2023年5月15日 22.25"><figcaption aria-hidden="true">Clipboard 2023年5月15日 22.25</figcaption></figure><h2 id="svd解法">SVD解法</h2><p>此处引用西北工业大学严恭敏老师的《捷联惯导算法与组合导航原理》第7章——初始对准与组合导航技术中的描述：</p><p><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684163313-0.png" alt="Clipboard 2023年5月15日 23.08"> <img src="https://s1.nsloop.com:58443/images/2023/05/15/1684163347-0.png" alt="Clipboard 2023年5月15日 23.09"> <img src="https://s1.nsloop.com:58443/images/2023/05/15/1684163385-0.png" alt="Clipboard 2023年5月15日 23.09"></p><p>参考资料：</p><ul><li>《捷联惯导算法与组合导航原理》第7章</li><li>https://ahrs.readthedocs.io/en/latest/filters/davenport.html</li></ul><h2 id="四元数解法">四元数解法</h2><p>也称<code>Davenport’s q-Method</code></p><p>根据四元数与姿态阵的关系：</p><p><span class="math display">\[\boldsymbol{C}=\left(q_0^2-\boldsymbol{q}_v^{\mathrm{T}} \boldsymbol{q}_v\right) \boldsymbol{I}+2 \boldsymbol{q}_v \boldsymbol{q}_v^{\mathrm{T}}+2 q_0\left(\boldsymbol{q}_v \times\right)\]</span></p><p>可以把上述“SVD解法”中的问题转换为关于四元数Q的目标函数：</p><p><img src="https://s1.nsloop.com:58443/images/2023/05/16/1684242822-0.png" alt="Clipboard 2023年5月16日 21.13"> <img src="https://s1.nsloop.com:58443/images/2023/05/16/1684242862-0.png" alt="Clipboard 2023年5月16日 21.14"></p><p>参考资料：</p><ul><li>《捷联惯导算法与组合导航原理》附录k</li><li>https://ahrs.readthedocs.io/en/latest/filters/davenport.html</li><li><a href="https://ntrs.nasa.gov/citations/19680021122" target="_blank" rel="noopener">Paul B. Davenport. A Vector Approach to the Algebra of Rotations with Applications. NASA Technical Note D-4696. August 1968.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;an-analytic-solution-to-wahbas-problem&quot;&gt;An analytic solution to Wahba&#39;s problem&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;https://s1.nsloop.com:58443/
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>【经典文献翻译】Fundamentals of Inertial Navigation</title>
    <link href="http://yoursite.com/2023/03/04/Fundamentals%20of%20Inertial%20Navigation%E7%BF%BB%E8%AF%91/"/>
    <id>http://yoursite.com/2023/03/04/Fundamentals%20of%20Inertial%20Navigation%E7%BF%BB%E8%AF%91/</id>
    <published>2023-03-04T02:59:30.000Z</published>
    <updated>2023-03-05T13:56:43.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fundamentals-of-inertial-navigation-satellite-based-positioning-and-their-integration">Fundamentals of Inertial Navigation, Satellite-based Positioning and their Integration</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/03/04/1677898415-0.png" alt="Clipboard 2023年3月4日 10.53"><figcaption aria-hidden="true">Clipboard 2023年3月4日 10.53</figcaption></figure><h1 id="目录">目录</h1><h2 id="章节介绍">章节介绍</h2><p><strong>第二章</strong></p><p>描述导航的数学、导航中使用的坐标框架以及在适当的坐标中计算导航解决方案所使用的转换。</p><p><strong>第三章</strong></p><p>讨论了GPS，详细介绍了GPS的各个部分、信号结构以及从伪距离和距离测量中估计位置和速度的过程。本文还讨论了在处理GPS数据时可能出现的各种误差。最后详细介绍了如何从星历表数据计算卫星的位置和速度，包括单频GPS接收机的大气校正。</p><p><strong>第四章</strong></p><p>介绍了惯性传感器及其分类、误差、标定、初始化和对准过程，然后描述了惯导系统机械化过程及其方程。</p><p><strong>第五章</strong></p><p>给出了一些基本的运动数学，并详细描述了在各种参考系下的机械化过程，给出了在最常见的导航系中导航参数的一步一步计算。</p><p><strong>第六章</strong></p><p>对惯导系统误差进行建模，并对惯导系统方程进行线性化。</p><p><strong>第七章</strong></p><p>讨论了KF的过程和测量模型、滤波算法、非线性滤波技术以及如何对系统扰动建模。</p><p><strong>第八章</strong></p><p>将所有这些想法与INS/GPS集成的详细描述以及相关的细微差别和微妙之处结合在一起。它描述了集成的类型以及它们的反馈方案。推导了INS动态误差模型方程和惯性传感器误差模型方程，讨论了线性化KF在松耦合和紧耦合INS/GPS融合中的实现。</p><p><strong>第九章</strong></p><p>讨论了轮式车辆的一种可能趋势，即通过使用速度读数来减少低成本惯性传感器的数量，并介绍了不同的约束以消除与6轴imu相关的误差，并实现类似的精度</p><p><strong>第十章</strong></p><p>给出了INS/GPS融合的实验结果。基于真实道路测试轨迹，分析了集成完整IMU(包含所有6个传感器)和简化系统(包含更少传感器)的结果。</p><h1 id="第一章">第一章</h1><h2 id="insgps组合类型">1.6 INS/GPS组合类型</h2><p>已经提出了不同形式的INS/GPS集成体系结构，以获得最大优势，这取决于使用类型和简单程度与鲁棒性。三个主要的集成体系结构是</p><ul><li>松耦合</li><li>紧耦合</li><li>超紧密的或深耦合</li></ul><h3 id="loosely-coupled-insgps-integration">Loosely Coupled INS/GPS Integration</h3><p>在这种架构中，也被称为松耦合，GPS和INS独立工作，并为位置、速度和姿态提供单独的解决方案。为了获得两个解的最佳解，这些信息通过最优估计器融合在一起，以获得第三个和大大改进的解。这种排列方式如图1.6所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/04/1677898696-0.png" alt="Clipboard 2023年3月4日 10.58"><figcaption aria-hidden="true">Clipboard 2023年3月4日 10.58</figcaption></figure><h3 id="tightly-coupled-insgps-integration">Tightly Coupled INS/GPS Integration</h3><p>在这种架构中，也称为集中式集成，GPS和INS作为基本传感器，它们的伪距离和伪距离率的原始输出以及INS的加速度和旋转速率由单个估计器混合，以实现协同解决方案(Yang 2007)。这种排列如图1.7所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/04/1677898910-0.png" alt="Clipboard 2023年3月4日 11.01"><figcaption aria-hidden="true">Clipboard 2023年3月4日 11.01</figcaption></figure><p>如第八章所述，GPS/INS集成可以通过多种方式实现，每种方式都有其优点和局限性</p><h3 id="ultra-tightly-or-deeply-coupled-integration">Ultra-Tightly or Deeply Coupled Integration</h3><p>深度耦合集成增加了INS和GPS之间的共生关系，因为集成是在跟踪环级别。这样做的主要优点是利用多普勒信息在GPS跟踪回路中对host vehicle的动态进行估计和补偿。超紧密集成存在多种构型，图1.8为一种基本构型。估计器将来自GPS的伪距离/多普勒或I(同相)和Q(正交)测量值与INS导航参数结合起来，以呈现估计的多普勒(Alban et al. 2003)。估计的多普勒是用来消除动态从GPS信号进入跟踪环，从而减少载波跟踪环带宽。虽然这种集成更加复杂，需要访问GPS硬件，但它可以提高原始测量的质量和信号的抗干扰性能(Cox Jr 1978)。</p><h1 id="第九章">第九章</h1><h3 id="轮式陆地车辆三维riss的优点">9.3.2 轮式陆地车辆三维RISS的优点</h3><p>3D RISS相对于2D车辆航迹推算解决方案的优势是基于两个加速度计的测量结果用于计算离面运动。主要体现为3个方面：</p><p>（1）第一个好处是计算正确的方位角。这是因为陀螺仪安装在车身并非严格水平，因此测量值并非完全是E-N平面的角速率。由于方位角在E-N平面，检测和修正陀螺仪倾斜的做法比忽略这一影响的二维车辆航迹推算更准确地计算出方位角。</p><p>（2）第二个好处是2D水平定位比2DRISS更精确，原因有二：</p><ul><li>从里程表测量的速度计算两个水平速度时考虑了俯仰角，提供更准确的速度来实现更好的位置估计</li><li>更精确的方位角计算可以更好地估计东向与北向速度</li></ul><p>（3）第三个好处是可以计算上升速度和高度，这是以前无法获得的数据</p><p>与完整的IMU相比，所提出的3D RISS的优点是<strong>通过加速度计而不是陀螺仪计算俯仰和横滚</strong>，并且<strong>通过里程表衍生的速度而不是加速度计计算车辆的速度</strong>。</p><p>为了证明从加速度计而不是陀螺仪来计算俯仰和横滚的优越性，假设陀螺仪中存在一个未补偿的bias，这将在俯仰或横滚中引入与积分产生的时间成正比的角度误差，从而导致INS的misalignment，从而将加速度矢量从机体框架错误地投影到局部框架。进一步的，在局部坐标系的一个水平通道中引入加速度误差，这将产生与<span class="math inline">\(t^2\)</span>成正比的<strong>速度误差</strong>和与<span class="math inline">\(t^3\)</span>成正比的<strong>位置误差</strong>。</p><p>当从加速度计计算俯仰和横摇时，第一次积分被消除，<strong>角度的误差与时间不成比例</strong>。此外，由这些角度误差引起的位置误差的部分将与<span class="math inline">\(t^2\)</span>成比例，而不是<span class="math inline">\(t^3\)</span>。</p><p>除了使用两个加速度计而不是两个陀螺仪来计算俯仰和横滚的优点之外，RISS还进一步改进了速度计算,使用里程表而不是加速度计计算速度(根据施加在陆地车辆上的非完整约束)比使用加速度计计算速度获得更好的性能。这是因为当从加速度计计算速度时，任何未补偿的bias都会在速度上引入与t成正比的误差，在位置上引入与<span class="math inline">\(t^2\)</span>成正比的误差。从里程表计算速度避免了第一次积分，从而使位置计算<strong>只需要一次积分</strong>。这意味着当使用里程表测量时，位置是在一次积分后获得的，<strong>而不是使用加速度计测量连续两次积分</strong>。在长时间的GPS停机中，使用加速度计计算的位置误差将与停机持续时间的平方成正比。</p><p>作为上述两项改进的结果，位置计算的进一步改进将随之而来。使用加速度计计算的roll和pitch误差将导致惯导系统产生misalignment，从而影响速度从body系投影到局部坐标系，使由俯仰和横滚误差引起的位置误差部分与t成正比，而不是与<span class="math inline">\(t^2\)</span>成正比，这是在消除两个陀螺仪的第一个改进中讨论的。</p><p>3D RISS中唯一剩下的主要误差来源是由于方位角陀螺仪造成的方位角误差。这个陀螺仪的未补偿的bias将导致方位角误差与时间成正比。由于这个方位误差而产生的位置误差将与车辆的（速度、积分时间和方位误差）成正比。这必须在积分滤波器内部通过模拟陀螺仪的随机漂移来解决。</p><blockquote><p>此处有一部分轨迹杜比</p></blockquote><h3 id="三维riss运动方程的推导">9.3.3 三维RISS运动方程的推导</h3><p>本节将介绍三维RISS的非线性运动模型，包括位置、速度和姿态状态</p><p>使用通用参考系。所述车辆车身框架的x轴沿横向方向，y轴沿向前纵向方向，z轴沿车辆垂直方向。局部框架是ENU框架，轴沿东、北和垂直(向上)方向。在k-1时刻从车体坐标系变换到局部坐标系的旋转矩阵为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678023702-0.png" alt="Clipboard 2023年3月5日 21.41"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.41</figcaption></figure><p>为了描述运动模型，我们首先需要控制输入。陀螺仪、两个加速度计和里程表提供的传感器测量表示为矢量：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678023792-0.png" alt="Clipboard 2023年3月5日 21.43"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.43</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(v_k^{o d}\)</span>表示轮式里程计计算得到的速度</li><li><span class="math inline">\(a_k^{o d}\)</span>表示轮式里程计推导计算得到的加速度</li><li><span class="math inline">\(f_k^x\)</span>表示横向加速度计的测量</li><li><span class="math inline">\(f_k^y\)</span>表示前向加速度计的测量</li><li><span class="math inline">\(\omega_k^z\)</span>表示方位角陀螺仪测量得到的角速度</li><li>在本讨论中，带有k后缀的控制输入表示那些导致系统状态在时间epoch k-1到k之间发生变化的输入</li></ul><p>在推导运动方程之前，定义系统的导航状态是很重要的。一个可能的状态向量是：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678023960-0.png" alt="Clipboard 2023年3月5日 21.46"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.46</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(\varphi_k\)</span>是纬度</li><li><span class="math inline">\(\lambda_k\)</span>经度</li><li><span class="math inline">\(h_k\)</span>高度</li><li><span class="math inline">\(v_k^f\)</span>前向速度</li><li><span class="math inline">\(p_k\)</span>pintch角</li><li><span class="math inline">\(r_k\)</span>roll角</li><li><span class="math inline">\(A_k\)</span>方位角</li></ul><p><strong>pitch和roll的计算</strong></p><p>对于陆地车辆，俯仰角是它相对于水平地面所作的角度(即围绕横向轴旋转)，滚转角是其围绕纵向轴旋转，如图9.5所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678024115-0.png" alt="Clipboard 2023年3月5日 21.48"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.48</figcaption></figure><p>当车辆移动时，向前加速度计测量向前车辆加速度以及重力分量，并且为了计算俯仰角，从里程表测量中得到的车辆加速度，并且从向前加速度计测量中去除，如下：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678024205-0.png" alt="Clipboard 2023年3月5日 21.50"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.50</figcaption></figure><p>类似地，横向加速度计测量车辆加速度的法向分量以及重力分量，为了计算滚转角度，横向加速度计的测量必须补偿加速度的法向分量，也就是说，考虑车发生俯仰角的时候，重力分量不完全是g，而是<span class="math inline">\(g \cos p_k\)</span>:</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678024597-0.png" alt="Clipboard 2023年3月5日 21.56"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.56</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fundamentals-of-inertial-navigation-satellite-based-positioning-and-their-integration&quot;&gt;Fundamentals of Inertial Navigation, Satellit
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【经典文献翻译】IMU Error Modeling Tutorial</title>
    <link href="http://yoursite.com/2023/03/04/IMU%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2023/03/04/IMU%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-03-04T02:59:30.000Z</published>
    <updated>2023-03-12T02:36:08.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="imu-error-modeling-tutorial-ins-state-estimation-with-real-time-sensor-calibration">IMU Error Modeling Tutorial (INS state estimation with real-time sensor calibration)</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678500899-0.png" alt="Clipboard 2023年3月11日 10.14"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.14</figcaption></figure><h1 id="介绍">介绍</h1><p>自动驾驶汽车技术正在快速发展。关键的使能因素是计算和传感系统能力的提高和成本的降低，这些系统使传感融合能够感知车辆的状态和环境。出于控制目的，必须以足够高的采样率和足够高的带宽准确、可靠地估计车辆状态。对于具有高带宽的系统，这些要求通常通过辅助惯性导航系统（INS）[1]、[2]、[3]、[4]、[5]、[6]来实现。</p><p>NS通过IMU高采样率的运动学模型集成来自惯性测量单元(IMU)的6个数据，以计算状态估计。辅助INS使用从辅助传感器(如视觉、激光雷达、雷达和全局导航卫星系统(GNSS))数据纠正这一状态估计。传感器融合状态估计可以通过以下任何一种方法来完成:卡尔曼滤波器(KF)[7]，[8]，[9]，[10]，[11]，扩展卡尔曼滤波器(EKF)[12]，[13]，[14]，[15]，无迹卡尔曼滤波器(UKF)[16]，[17]，[18]，粒子滤波(PF)[19]，[20]，[21]，12和最大后验(MAP)优化[22]，[23]，[24]，[25]，[26]，[27]。</p><p>如果将IMU和辅助传感器数据结合在状态空间形式中，则结合IMU和辅助传感器数据的数据融合系统将能够通过实时校准实现更好的性能。IMU制造商提供了一个描述预期IMU性能的数据表。根据规范标准[28]、[29]、[30]，这种性能通常用艾伦方差(AV)来表示。</p><p>然而，目前还不清楚如何将这些数据表中的AV信息转换成合适的状态空间模型。多种模型已经被知晓并使用了几十年[31]，[32]，[33]，[34]，[35]，20[36]，[37]，[38]，[39]，[40]。尽管它们很重要，但现有文献中没有对潜在思想、问题和权衡进行清晰的教程阐述。本文的目的是提供这样一个指导性的讨论。“辅助INS历史”中讨论了这些想法的悠久历史以及与成功应用相关的问题。</p><p>本教程讨论与示例导航系统设计方法相关的问题和权衡：</p><ul><li>(1)使用AV信息来指定IMU状态空间随机误差模型的连续时间参数(例如，<span class="math inline">\(p, n_z, A_z, B_z, C_z, S_z\)</span>, and <span class="math inline">\(S_\eta\)</span>)；</li><li>(2)将该连续时间模型转换为实现状态估计器所需的离散时间、状态空间误差模型参数(<span class="math inline">\(\Phi, Q_{z_d}, H, Q_{\eta_d}\)</span>)</li><li>(3)相对于Allan信息验证IMU模型。以前的一些文章讨论了上述专题中的一些[32]、[34]、[36]、[39]、[43]、[44]、[46]、[47]。</li><li>本文的目标是以教程的方式清楚而全面地介绍背景和主要思想，使用符合仪器规范标准[28]、[29]的符号和术语。为了澄清问题，通篇都包括了一些例子。</li></ul><h1 id="应用简介">应用简介</h1><p>INS设计是基于车辆运动学模型：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678501669-0.png" alt="Clipboard 2023年3月11日 10.27"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.27</figcaption></figure><p>其中，<span class="math inline">\(\vec{x}_v\)</span>表示车辆的状态<span class="math inline">\(\vec{u} \in \Re^6\)</span>表示系统输入(即比力和角速度向量)。典型的车辆状态向量可能包括位置、速度和姿态的子向量。导航系统基于信号<span class="math inline">\(\vec{u}(t)\)</span>的测量来求解(1)：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678501803-0.png" alt="Clipboard 2023年3月11日 10.30"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.30</figcaption></figure><p>其中 <span class="math inline">\(\hat{\vec{u}}(t)\)</span>是使用实时估计的校准因子（从IMU 测量<span class="math inline">\(\tilde{\vec{u}}(t)\)</span>计算出来的）。“"Simplified INS Example.”中介绍了简化的二维惯性导航示例。</p><p>对于标量信号，将传感器测量̃<span class="math inline">\(\tilde{u}(t)\)</span>与期望真值信号<span class="math inline">\(u(t)\)</span>相关联的模型是(参见[28]、[29]）：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678501958-0.png" alt="Clipboard 2023年3月11日 10.32"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.32</figcaption></figure><p>期望信号<span class="math inline">\(u(t)\)</span>的测量<span class="math inline">\(\tilde{u}(t)\)</span>被确定性误差<span class="math inline">\(d(\vec{u}(t))\)</span>和累积随机误差<span class="math inline">\(z(t)\)</span>破坏。确定性误差是具有未知确定性系数的分析模型足够的传感器缺陷。其中一些系数在仪器的生命周期内仅表现出微小的变化。</p><p>这些可以在工厂校准过程中估计和补偿。其他确定性错误，如启动偏差，可以通过状态增广来实时估计。确定性错误的形式可能包括比例因子误差、非线性、对陀螺的 g 敏感性、非正交轴和交叉耦合的轴[5]。请参阅“问题和权衡讨论”中的“确定性错误”小节。</p><p>本文的重点是由<span class="math inline">\(z(t)\)</span>表示的随机误差，这些误差可能来自各种物理现象（参见“背景”部分）。每次仪器打开时，随机误差是不同的，随时间变化的函数，不能根据传感器测量<span class="math inline">\(\tilde{u}(t)\)</span>进行预测。</p><p>为清楚起见和简单性，本教程的大部分将<span class="math inline">\(z(t)\)</span>视为标量信号。基本思想适用于六自由度IMU随机误差模型。</p><h1 id="state-estimation-error-model">State Estimation Error Model</h1><p>当导航系统通过积分式(2)的非线性模型来传播车辆状态向量时，误差表示为<span class="math inline">\(\delta \vec{x}_v(t)=\vec{x}_v(t)-\hat{\vec{x}}_v(t)\)</span>，无论选择哪种姿态表示法(例如方向余弦矩阵或四元数)，姿态误差都可以由具有三个分量的向量来表示。因此，车辆误差状态包含位置、速度和姿态误差的子矢量，每个是具有三个分量的矢量，即<span class="math inline">\(\delta \vec{x}_v(t) \in \Re^{n_v}, n_v=9\)</span>。</p><p>车辆状态误差向量可以使用辅助传感器[10]、[13]、[12]、[31]、[43]、[44]的测量结果实时估计。估计算法包含误差状态的线性化状态空间模型：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678502779-0.png" alt="Clipboard 2023年3月11日 10.46"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.46</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(F(t)=\left.\frac{\partial f(\vec{x}, \vec{u})}{\partial \vec{x}}\right|_{\hat{\vec{x}}(t), \hat{\vec{u}}(t)}\)</span></li><li><span class="math inline">\(G(t)=\left.\frac{\partial f(\vec{x}, \vec{u})}{\partial \vec{u}}\right|_{\hat{\vec{x}}(t), \hat{\vec{u}}(t)}\)</span></li><li><span class="math inline">\(\delta \vec{u}(t)=\vec{u}(t)-\hat{\vec{u}}(t)\)</span></li><li>参见“Simplified INS Example.”中的示例F(t)和G(t)矩阵</li></ul><p>这个状态空间模型并不完整，除非指定<span class="math inline">\(\delta \vec{u}(t)\)</span>的IMU误差模型。对于状态估计，确定状态空间形式的IMU误差模型。</p><p>实时状态估计过程用于估计增广的状态向量：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678502968-0.png" alt="Clipboard 2023年3月11日 10.49"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.49</figcaption></figure><p>由车辆误差状态向量<span class="math inline">\(\delta \vec{x}_v(t) \in \Re^{n_v}\)</span>组成，其中，</p><ul><li><span class="math inline">\(\vec{x}_d(t) \in \Re^{n_d}\)</span>表示imu确定性误差</li><li><span class="math inline">\(\vec{x}_z(t) \in \Re^{n_z}\)</span>表示imu随机误差</li><li>错误状态的总维度<span class="math inline">\(n_x=n_v+n_d+n_2\)</span></li></ul><p>状态增广的过程，在“State Augmentation”中进行了讨论。这里的介绍将完全集中在随机IMU误差上<span class="math inline">\(z(t)\)</span>，其在式(3)中的累积用<span class="math inline">\(\vec{z}(t)\)</span>表示。</p><p>标量<span class="math inline">\(z(t)\)</span>的状态空间模型：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678503236-0.png" alt="Clipboard 2023年3月11日 10.53"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.53</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(A_z \in \Re^{n_z \times n_z}, B_z \in \Re^{n_z \times p}\)</span>, and <span class="math inline">\(C_z \in \Re^{1 \times n_z}\)</span></li><li>参数p表示IMU误差模型的微分方程式部分中不同的独立的噪声过程的数目</li><li>参数<span class="math inline">\(n_z\)</span>表示IMU随机误差模型中的状态数</li></ul><p>随机信号<span class="math inline">\(\vec{\omega}_z(t)\)</span> and <span class="math inline">\(\eta_z(t)\)</span>式相互独立的具有功率谱密度<span class="math inline">\((S_{\omega_z} \in \Re^{p \times p}\)</span> and <span class="math inline">\(S_{\eta_z} \in \Re)\)</span>的高斯白噪声过程。假设<span class="math inline">\(\vec{\omega}_z(t)\)</span>的元素是相互独立的，因此得到<span class="math inline">\(S_{\omega_z}\)</span>是对角线的。</p><blockquote><p>设计者在选择模型结构(特别是<span class="math inline">\(n_z\)</span>和<span class="math inline">\(P\)</span>)时必须谨慎，因为整个模型将有6<span class="math inline">\(n_z\)</span>状态和6<span class="math inline">\(P\)</span>个独立噪声源。</p></blockquote><h1 id="线性状态空间系统的功率谱密度">线性状态空间系统的功率谱密度</h1><p>对应于(6)-(7)中的状态空间模型，频域模型为</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504350-0.png" alt="Clipboard 2023年3月11日 11.12"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.12</figcaption></figure><p>其中，S是拉普拉斯变量。从<span class="math inline">\(\omega_z(t)\)</span>到<span class="math inline">\(z(t)\)</span>的传递函数模型为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504410-0.png" alt="Clipboard 2023年3月11日 11.13"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.13</figcaption></figure><p>它有1行和p列，符号<span class="math inline">\(Z(s), \Omega_z(s)\)</span>, and <span class="math inline">\(\eta_z(s)\)</span>分别表示为信号<span class="math inline">\(z(t), \omega_z(t)\)</span>, and <span class="math inline">\(\eta_z(t)\)</span>的拉普拉斯变换，因此，对应于信号<span class="math inline">\(z(t)\)</span>的功率谱密度（PSD）：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504552-0.png" alt="Clipboard 2023年3月11日 11.15"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.15</figcaption></figure><p>假设驱动噪声向量<span class="math inline">\(\omega_z(t)\)</span>和输出噪声<span class="math inline">\(\eta_z(t)\)</span>的所有元素是相互独立的并且是白的，这简化为</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504605-0.png" alt="Clipboard 2023年3月11日 11.16"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.16</figcaption></figure><p>其中，</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504625-0.png" alt="Clipboard 2023年3月11日 11.17"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.17</figcaption></figure><p><span class="math inline">\(T_i(s)\)</span>是<span class="math inline">\(\vec{\omega}_z(t)\)</span>的第i个元素到<span class="math inline">\(z(t)\)</span>的(标量)传递函数，<span class="math inline">\(B_{z_i} \in \Re^{n_z \times 1}\)</span>是<span class="math inline">\(B_z\)</span>的第i列。每个<span class="math inline">\(T_i(s)\)</span>是<span class="math inline">\(s\)</span>中分子与分母之比，<span class="math inline">\(S_z\)</span>是<span class="math inline">\(\omega\)</span>的正实函数。因此，每个<span class="math inline">\(T_i(j \omega) T_i(-j \omega)\)</span>和<span class="math inline">\(S_z(\omega)\)</span>将始终是拉普拉斯变量<span class="math inline">\(s\)</span>的偶次幂的多项式函数的比率。证明这一事实的例子在《Finite Dimensional Linear StateSpace Systems have Even Power Spectra.》中给出</p><p><span class="math inline">\(S_z\)</span>是正实函数的事实导致了IMU误差建模方法中的主要挑战之一，因为一些IMU随机误差分量的PSD不能用式(10)的总和中的项精确地拟合。因此，设计者必须在近似状态空间模型中做出明智的选择，以达到满意的折衷。这个问题将在"Modeling via Independent Noise Sources”一节中进一步讨论。</p><h1 id="available-error-specification-information">Available Error Specification Information</h1><p>为了表征IMU的质量(根据IEEE规范[28]、[29]、[30])，制造商提供了AV曲线图、Allan标准偏差(ASD)曲线图或从中提取的参数。ASD图表既可以帮助仪器设计者理解和改进他们的传感器，也可以将预期性能传达给预期的用户。在本文的上下文中，主要主题是INS设计人员如何使用来自ASD图的信息来指定式(6)-(7)中的状态空间模型的参数。</p><p>图1和图2显示了示例ASD曲线图。图1显示了Crossbow μNav IMU陀螺仪的ASD曲线图[45]。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678505281-0.png" alt="Clipboard 2023年3月11日 11.28"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.28</figcaption></figure><p>这些ASD是根据[36]的作者提供的数据计算得出的。蓝色、黑色和绿色星号(‘*’)标记ASD数据点。</p><p>图2中的ASD10绘图是根据制造商提供的数据计算得出的，该数据来自安装在隔振系统顶部的大大理石平板上的IMU。图2中的每个蓝色‘x’标记一个ASD数据点。每个ASD图的水平轴是集群时间(或大小)，符号τ以秒为单位。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678505302-0.png" alt="Clipboard 2023年3月11日 11.28"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.28</figcaption></figure><p>请注意，这两张图中的ASD图既有相似之处，也有不同之处。对于较小的集群大小，两者都以-1/2的特征斜率减小，如每个图中的红色虚线切线所示。然后，在虚线青色切线所指示的值处，两者都变平到零的斜率。</p><p>对于较大的集群大小，图2中的ASD以1/2的斜率增加，如用黑色虚线绘制的切线所示。对于像τ=1000这样大的集群时间，图1中的ASD曲线图并没有(强烈地)表现出斜率为1/2的这种增加。</p><p>这些τ的值和发生变化的ASD值对于每个仪器都是不同的。它们指定了某些参数，这些参数对于比较惯性仪器的性能和评估权衡构建IMU随机误差模型都很有用。</p><h1 id="问题描述">问题描述</h1><p>本文的目的是讨论与开发模型相关的方法、问题和权衡，该模型将IMU误差的随机部分的性质定量地传达给状态估计算法。该误差模型的输入将是随机信号。</p><p>制造商提供的可用于模型开发的信息是AV或ASD特性。设计者无法获得产生这些特性的IMU真值输出数据；因此，系统辨识方法不适用。</p><p>由于误差状态估计算法是状态空间形式的，所以IMU误差模型也是状态空间形式的。输入被建模为独立的高斯白噪声过程。挑战在于构建这些模型，使它们具有与IMU相同的输出统计特性(即，AV方差)。</p><p>请注意，这种随机状态空间模型并不是唯一的。事实上，本文并不打算提出一个特定的模型；尽管本文讨论了一个特定的ASD情节，并给出了一个模型作为教程示例。相反，本文的目标是清楚地展示各种文章、书籍[9]和标准16[30]、[28]、[29]中使用或暗示的方法(使用各种特定模型)。作者认为，这种方法的许多方面都是行业标准的。不幸的是，大多数描述这种方法的出版物都不公开。</p><p>从高层次上，该方法的概要如下：</p><ul><li>(1)利用来自AV/ASD图的信息构建连续时间状态空间模型。</li><li>(2)将连续时间为IMU的随机模型转化为等价的离散时间模型。</li><li>(3)在模拟中使用离散时间模型产生数据，计算ASD图与仪器的ASD图进行比较。</li><li>(4)当设计者对IMU误差模型满意时，将其附加到车辆状态误差模型中，并用于INS误差状态估值器的设计。</li></ul><h1 id="allan-variance">Allan Variance</h1><p>AV是一种众所周知的时域分析技术，最初开发该技术是为了表征和研究振荡器的频率稳定性[48]、[49]、[50]。由于其相对简单，已被成功地用于传递IMU性能规范和来表征它们的随机误差[28]、[29]、[32]、[34]、[36]、[39]、[43]、[44]、[46]、[47]</p><p>给定一组数据，计算AV的过程如下。设<span class="math inline">\(D=\left\{\tilde{u}_i\right\}_{i=1}^L\)</span>是一组(去趋势的)比力(或角速率)数据（由静止的IMU以恒定采样间隔T测量）。对于每个<span class="math inline">\(n \in[1, L / 2]\)</span>，以<span class="math inline">\(\tau=n T\)</span>为变量，以<span class="math inline">\(\tau\)</span>的范围为从T到LT/2的簇时间的值分别计算方差。</p><p>对于给定的n，在每个时刻<span class="math inline">\(t_i \in[T, 2 T, \ldots,(L-n) T]\)</span>，一组n个连续的数据点(从<span class="math inline">\(t_i\)</span>开始)形成一个数据集<span class="math inline">\(\left\{\tilde{u}_j\right\}_{j=i}^{i+n-1}\)</span>，为每个这样的n点聚类计算平均值<span class="math inline">\(\bar{u}_i(\tau)=\frac{1}{n} \sum_{j=0}^{n-1} \tilde{u}_{i+j}\)</span>。然后，以<span class="math inline">\((L-2 n)\)</span>平方簇差[28]、[49]的平均值来计算持续时间τ的AV：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678523821-0.png" alt="Clipboard 2023年3月11日 16.37"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.37</figcaption></figure><p>由于一些IMU(尤其是那些高级IMU)提供比力(或角速率)的积分，表示为<span class="math inline">\(\tilde{\theta}_i\)</span>，因此<span class="math inline">\(\bar{u}_i(\tau)\)</span>可替换为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678523919-0.png" alt="Clipboard 2023年3月11日 16.38"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.38</figcaption></figure><p>将式(13)带入式(12)得到</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678524037-0.png" alt="Clipboard 2023年3月11日 16.40"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.40</figcaption></figure><p>这是计算AV的另一种公式[28]。</p><p>对于图形分析，AV的平方根<span class="math inline">\(\hat{\sigma}_u(\tau)\)</span>，称为ASD，被称为ASD，通常以对数-对数比例绘制，由于数据集D的长度有限，每组数据簇的数据量会随着<span class="math inline">\(\tau\)</span>的增加而减少；因此，ASD的标准差（注意，不是ASD本身）计算为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678524537-0.png" alt="Clipboard 2023年3月11日 16.48"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.48</figcaption></figure><p>其中，<span class="math inline">\(\kappa\)</span>是经验常数，对于imu分析，通常取<span class="math inline">\(\kappa \approx 1 / \sqrt{2}\)</span>，[53], [28], [29], [34], [54].</p><h1 id="power-spectral-density-and-allan-variance">Power Spectral Density and Allan Variance</h1><p>AV通过以下方式与双边PSD相关：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678524966-0.png" alt="Clipboard 2023年3月11日 16.56"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.56</figcaption></figure><p>IEEE标准952-1997[28]中(C.1)后面的文字将此等式解释为，当通过传递函数时，Allan Variance与信号<span class="math inline">\(u\)</span>中的总噪声功率成比例，该传递函数由用于创建和操作簇的方法确定。式(16)的推导可以在[55]第79页找到，(16)没有求逆公式(见[53])。在这个表达式中，<span class="math inline">\(S_u(f)=\left.S_u(s)\right|_{s=j 2 \pi f}\)</span>，其中<span class="math inline">\(s \in \mathbb{C}\)</span>是拉普拉斯变量，<span class="math inline">\(j=\sqrt{-1}\)</span>是复数、<span class="math inline">\(f \in \Re\)</span>的单位是hz。</p><h1 id="modeling-via-independent-noise-sources">Modeling via Independent Noise Sources</h1><p>当功率谱表示为频率f的幂函数级数时，它的形式为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678525335-0.png" alt="Clipboard 2023年3月11日 17.02"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.02</figcaption></figure><p>这种形式的PSD很方便。根据叠加原理，它与信号的功率谱相对应：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678525367-0.png" alt="Clipboard 2023年3月11日 17.02"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.02</figcaption></figure><p>其中，信号<span class="math inline">\(z_N(t), z_B(t)\)</span>, and <span class="math inline">\(z_K(t)\)</span>是相互独立的零均值噪声过程。</p><p>在此假设下，对式(16)到(17)应用，将产生具有以下形式的AV：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678525455-0.png" alt="Clipboard 2023年3月11日 17.04"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.04</figcaption></figure><p>其中每个AV项的具体功能形式可以计算，并可在各种来源中获得[28]、[29]、[30]、[34]、[55]。每个AV项的函数形式很容易与ASD图的一部分相关联。</p><p>“Continuous-Time State-Space Models”一节描述了建立这种关联并为每个术语定义连续时间状态空间模型的方法。每项的状态空间模型由它自己的独立的高斯白驱动噪声驱动，从而导致每个信号<span class="math inline">\(z_N(t), z_B(t)\)</span>, and <span class="math inline">\(z_K(t)\)</span>相互独立。</p><ul><li>这些状态空间模型对于对应于式(17)中f的偶函数的项（如<span class="math inline">\(\frac{K^2}{(2 \pi f)^2}\)</span>）可以是精确的</li><li>然而(如前所述并在侧栏中举例说明)是频率f的奇函数的功率谱项（如<span class="math inline">\(\frac{B^2}{2 \pi f}\)</span>）不能由任何有限维、线性、状态空间模型精确建模，因此，必须对这些术语进行近似建模，仔细权衡。</li></ul><p>在式(17)的幂级数表示中可以包括任意数量的项。这导致式(18)的信号模型和式(19)的AV模型中的项的数量相同。每个项代表来自独立来源的不同类型的噪声。ASD图的典型形状如图3所示，有五个独立的噪声源(另见[28]中的图C.8)</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678526032-0.png" alt="Clipboard 2023年3月11日 17.13"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.13</figcaption></figure><p>在ASD图中，每种噪声类型都与一个特征斜率相关联，该特征斜率有助于识别该噪声类型及其模型参数。并不是所有的噪声类型在每个设备都很明显。当存在时，噪声项占主导地位的<span class="math inline">\(\tau\)</span>的模型参数和范围对于每个仪器可能是不同的。</p><p>在商业级IMU中，N、B和K项通常占主导地位(例如，参见图1和图2)。对于较小的<span class="math inline">\(\tau\)</span>，仪器设计的选择(例如量化方法和10个采样周期)会导致随机误差表现为白噪声。这种白噪声在随机游走噪声项中被考虑（也就是N）。然而，随机误差并不是完全真正的白噪声。随着集群时间<span class="math inline">\(\tau\)</span>的增加，ASD曲线图可能表现出偏置不稳定(B)、速率随机游动(K)和其他噪声类型。要使ASD曲线图显示这些其他噪声类型，用于生成ASD曲线图的IMU数据集必须非常长。</p><p>ASD图绘制到几分钟（例如，几百秒），对于在观测不可用的间隔期间分析性能是有意义的。然而，对于非常大的<span class="math inline">\(\tau\)</span>，ASD曲线的具体形状通常是不确定的，并不重要。</p><p>表1的第1列和第2列包括了陀螺仪和加速度计的 N、B 和 K 个噪声项的具体名称。第3列和第4列总结了这些噪声类型的AV和PSD之间的关系，[28]、[34]</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678526752-0.png" alt="Clipboard 2023年3月11日 17.25"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.25</figcaption></figure><p>其中，N、B 和 K 项将是“"Continuous-Time State-Space Models”部分讨论的焦点。</p><h1 id="continuous-time-state-space-models">Continuous-Time State-Space Models</h1><p>本节考虑开发近似再现ASD图和式(17)PSD的连续时间状态空间模型。使用图2中的示例ASD来说明整个思路。图1将仅在参考B和K幂级数项时才讨论。整体模型将具有以下形式：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527004-0.png" alt="Clipboard 2023年3月11日 17.30"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.30</figcaption></figure><p>其中， <span class="math inline">\(z_N(t), z_B(t)\)</span>, and <span class="math inline">\(z_K(t)\)</span>分别是与系数N、B和K相关的IMU随机误差信号。</p><h2 id="随机游走误差z_nt角速度和速度">随机游走误差<span class="math inline">\(z_N(t)\)</span>:角速度和速度</h2><p>式(17)中的PSD项<span class="math inline">\(N^2\)</span>相对于频率f是恒定的，这对应于白噪声的功率谱[56]。因此，</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527127-0.png" alt="Clipboard 2023年3月11日 17.32"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.32</figcaption></figure><p>其中，<span class="math inline">\(\omega_N(t)\)</span>是PSD为<span class="math inline">\(S_N=N^2\)</span>的高斯白噪声。</p><blockquote><p>在文献中和制造商规范中，这种类型的误差称为<strong>陀螺角速度随机游走误差</strong>和<strong>加速度计的速度随机游走误差</strong>。</p></blockquote><p>将式(16)中的变换应用于<span class="math inline">\(S_{z_N}(f)=N^2\)</span>，将得到[28]，如表1中所示：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527260-0.png" alt="Clipboard 2023年3月11日 17.34"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.34</figcaption></figure><p>这表明，在ASD图上，角/速度随机游走将用斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的直线表示，如图4所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527392-0.png" alt="Clipboard 2023年3月11日 17.36"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.36</figcaption></figure><p>随机游走参数N的值可以从提供ASD绘图的制造商中近似确定,这是通过识别ASD图上斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的<span class="math inline">\(\tau\)</span>范围，并绘制其切线来得到的。</p><p>在图2中，在<span class="math inline">\(\tau \in[0.01,30]\)</span>范围内绘制了红色虚线切线。从式(23)可以看出<span class="math inline">\(\left.\sigma_{z_N}(\tau)\right|_{\tau=1}=N\)</span>，因此，可以从ASD图中（<span class="math inline">\(\tau=1 \mathrm{~s}\)</span>，斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的切线）提取N的值，对于图2，结果是<span class="math inline">\(N \approx 0.0033 \mathrm{~m} /\mathrm{s}/ \mathrm{s}^{1 / 2}\)</span></p><h2 id="随机游走误差z_kt速率和加速度">随机游走误差<span class="math inline">\(z_K(t)\)</span>：速率和加速度</h2><p>式（17）中的项<span class="math inline">\(\frac{K^2}{(2 \pi f)^2}=\left.\frac{K}{s} \frac{K}{s^*}\right|_{s=j 2 \pi f}\)</span>对应于具有传递函数为<span class="math inline">\(T(s)=\frac{1}{s}\)</span>的线性系统，因此，其状态空间模型为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528144-0.png" alt="Clipboard 2023年3月11日 17.49"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.49</figcaption></figure><p>其中<span class="math inline">\(z_K(t)\)</span>是输出，输入<span class="math inline">\(\omega_K(t)\)</span>是带有PSD为<span class="math inline">\(S_K=K^2\)</span>的高斯白噪声。</p><blockquote><p>在文献中和制造商规范中，这种类型的误差称为陀螺的速率随机游走误差和加速度计的加速随机游走误差.</p></blockquote><p>给定式（24）和（25），<span class="math inline">\(z_K(t)\)</span>的PSD是：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528628-0.png" alt="Clipboard 2023年3月11日 17.57"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.57</figcaption></figure><p>其所需形式对应于式（17）中的第三个项。使用式（16）代换<span class="math inline">\(S_{z_K}(f)\)</span>，得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528710-0.png" alt="Clipboard 2023年3月11日 17.58"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.58</figcaption></figure><p>总结在表1的相应行中，等式 (27) 显示，在ASD图上，速率/加速随机游走误差将由斜率为<span class="math inline">\(+\frac{1}{2}\)</span>的线表示，如图5所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528824-0.png" alt="Clipboard 2023年3月11日 18.00"><figcaption aria-hidden="true">Clipboard 2023年3月11日 18.00</figcaption></figure><p>速率/加速度随机游走参数K可以从制造商提供的ASD图中近似确定。</p><p>第一步是识别ASD图上斜率为<span class="math inline">\(+\frac{1}{2}\)</span>的<span class="math inline">\(\tau\)</span>范围（如果存在），并绘制与其切线。在图2中，绘制的虚线黑线为<span class="math inline">\(\tau \in[3,500]\)</span>秒，斜率为<span class="math inline">\(+\frac{1}{2}\)</span>，在<span class="math inline">\(\tau \geq 100\)</span>秒时与ASD曲线大致相切。因为<span class="math inline">\(\tau\)</span>很大，这部分ASD通常具有更高程度的不确定性[如相对于 式(15) 所讨论的那样]。</p><p>第二步使用切线来估计K。从式(27)可以看出<span class="math inline">\(\left.\sigma_{z_K}(\tau)\right|_{\tau=3}=K\)</span>，因此，从ASD图中估计K值的简单方法是在<span class="math inline">\(\tau = 3 s\)</span>时找到直线近似的值，在图2的例子中，<span class="math inline">\(K \approx 0.00014 \mathrm{~m} / \mathrm{s}^2 / \mathrm{s}^{1 / 2}\)</span></p><p>基于图1中的ASD图，μNav单元中的陀螺可能不需要包含角速率随机游走噪声，即使聚类时间可达1000秒。</p><h2 id="累积误差模型nk">累积误差模型：N，K</h2><p>由于角随机游走和速率随机游走误差(或速度随机游走和加速度随机游走误差)都具有功率谱，因此可以直接建立状态空间模型来再现功率谱中相应的项，以及它们的ASD图部分。</p><p>基于前面的两个部分，状态空间模型将是：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678529391-0.png" alt="Clipboard 2023年3月11日 18.09"><figcaption aria-hidden="true">Clipboard 2023年3月11日 18.09</figcaption></figure><p>其中，<span class="math inline">\(z_N(t)=\omega_N(t)\)</span>是PSD为<span class="math inline">\(N^2\)</span>的白噪声，<span class="math inline">\(\omega_K(t)\)</span>是PSD为<span class="math inline">\(K^2\)</span>的白噪声。</p><p>随机信号<span class="math inline">\(\omega_N(t)\)</span>和<span class="math inline">\(\omega_K(t)\)</span>是独立的，因此，<span class="math inline">\(z_N(t)\)</span>和<span class="math inline">\(z_K(t)\)</span>也是独立的。</p><p>该模型的ASD为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678529561-0.png" alt="Clipboard 2023年3月11日 18.12"><figcaption aria-hidden="true">Clipboard 2023年3月11日 18.12</figcaption></figure><p>该模型的ASD图使用值<span class="math inline">\(N \approx 0.0033 \mathrm{~m} /\mathrm{s}/ \mathrm{s}^{1 / 2}\)</span>和<span class="math inline">\(K \approx 0.00014 \mathrm{~m} / \mathrm{s}^2 / \mathrm{s}^{1 / 2}\)</span>，如图2所示的绿色实线。</p><h2 id="偏差不稳定性z_bt">偏差不稳定性<span class="math inline">\(z_B(t)\)</span></h2><p>一些ASD图(如图1中的图)没有表现出与<span class="math inline">\(z_K(t)\)</span>相关的<span class="math inline">\(+\frac{1}{2}\)</span>斜率，但对于较大的<span class="math inline">\(\tau\)</span>值，确实有一个较宽的平坦区域。该平面区域不能由N或K值项来很好地建模。在这种情况下，式(30)中的NK模型的AV（和 ASD）图中，<span class="math inline">\(\tau\)</span>在N和K这个中间范围内太小。在任何一种情况下，都有足够的偏差不稳定性，这样可以通过在模型中考虑其性能来改进。</p><p>与<span class="math inline">\(S_{z_B}(f)=\frac{B^2}{2 \pi f}\)</span>对应的误差项<span class="math inline">\(z_B(t)\)</span>通常被称为偏差不稳定性（或闪烁噪声）[28], [29], [34], [44], [39].</p><p>将 式(16) 应用于<span class="math inline">\(S_{z_B}(f)=\frac{B^2}{2 \pi f}\)</span> for <span class="math inline">\(f \leq f_0\)</span>（并且排除0的情况），将会得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678547385-0.png" alt="Clipboard 2023年3月11日 23.09"><figcaption aria-hidden="true">Clipboard 2023年3月11日 23.09</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(x=\pi f_0 \tau\)</span></li><li><span class="math inline">\(C i\)</span>是[56]的cosine积分函数</li><li>参数<span class="math inline">\(f_0\)</span>是截断频率[28]</li></ul><p>偏差不稳定性ASD图如图6所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678585362-0.png" alt="Clipboard 2023年3月12日 09.42"><figcaption aria-hidden="true">Clipboard 2023年3月12日 09.42</figcaption></figure><p>该图显示，对于小<span class="math inline">\(\tau\)</span>，<span class="math inline">\(\sigma_{z_B}(\tau)\)</span>增长，直到<span class="math inline">\(\tau&gt;\frac{1}{f_0}\)</span>的平台阶段。因此，<span class="math inline">\(\tau \approx \frac{1}{f_0}\)</span>的值定义了偏差不稳定性（或闪烁噪声）对其最大值贡献的部分。在该区域内，可以证明式(31)中的正弦项和余弦项接近于零，因此在平坦区域，有：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678585637-0.png" alt="Clipboard 2023年3月12日 09.47"><figcaption aria-hidden="true">Clipboard 2023年3月12日 09.47</figcaption></figure><p>这些方程提供了一种从ASD图中提取B近似值的简单方法。在这种方法中（例如，参见[35]中的p.6,[44]中的p.21, [54]中的p.10和[55] 中的p.114），可以从[28]中的B.4.5 节中推断，ASD图平坦的部分所对应的<span class="math inline">\(\sigma_z^2(\tau)\)</span>和<span class="math inline">\(\frac{2 B^2 \ln (2)}{\pi}\)</span>近似，来推断参数B的值。</p><p>对于图1中的ASD图，青色水平线近似于9.5e-3和1.40e-2deg/s的最小ASD值，对应的B的值为1.43e-2和2.11e-2 deg/s (9.5e-3/0.664, 1.40e-2/0.664)，对于图2中的ASD图，<span class="math inline">\(7.4 e-4 \mathrm{~m} / \mathrm{s}^2\)</span>的最小ASD值对应于<span class="math inline">\(B=1.11 e-3 \mathrm{~m} / \mathrm{s}^2\)</span>。</p><p>因为偏差不稳定性项的功率谱项（即<span class="math inline">\(\frac{B^2}{2 \pi f}\)</span>）不是<span class="math inline">\(s=j 2 \pi f\)</span>的偶数幂，所以没有完全拟合它的有限阶线性状态空间模型。因此，导航系统设计者必须选择一个状态空间模型来逼近偏差不稳定性误差效应。</p><p>人们提出了各种方法来近似地解释偏置不稳定性。其中包括一阶高斯-马尔科夫[4]，[32]，[36]，[39]，[44]，[58]和高阶自回归模型[43]，[46]，[47]。一个重要的权衡是，随着状态空间模型维数的增加，近似值的保真度可能会增加，但状态估计算法所需的实时计算负载也会增加。此外，更精细的模型可能对未建模的动力学和非线性不鲁棒，特别是当一些添加的状态是弱可观的。这些主题将在“Discussion of Issues and Tradeoffs”一节中进一步分析。</p><p>为了举例说明这个想法，下一节将考虑一阶高斯-马尔可夫模型，该模型使用指数相关噪声来模拟偏差不稳定性误差。</p><h2 id="gauss-markov-error-model">Gauss-Markov Error Model</h2><p>一阶连续时间高斯-马尔可夫模型为[9]，[56]：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586568-0.png" alt="Clipboard 2023年3月12日 10.02"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.02</figcaption></figure><p>且：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586591-0.png" alt="Clipboard 2023年3月12日 10.03"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.03</figcaption></figure><p>其中，</p><ul><li>符号<span class="math inline">\(T_B\)</span>表示进程的相关时间。</li><li>符号<span class="math inline">\(\omega_B(t)\)</span>表示带有PSD为<span class="math inline">\(S_B\)</span>的白色驱动噪声</li></ul><p>式(33)对应的传递函数为:</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586684-0.png" alt="Clipboard 2023年3月12日 10.04"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.04</figcaption></figure><p>产生的PSD为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586716-0.png" alt="Clipboard 2023年3月12日 10.05"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.05</figcaption></figure><p>将式(16)应用于<span class="math inline">\(S_{z_G}(s)\)</span>将得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586829-0.png" alt="Clipboard 2023年3月12日 10.07"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.07</figcaption></figure><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678588393-0.png" alt="Clipboard 2023年3月12日 10.33"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.33</figcaption></figure><p><span class="math inline">\(\sigma_{z_G}(\tau)\)</span>的曲线如图7所示。一些特殊情况值得注意：</p><p><strong>(1) 对于较小的集群时间（<span class="math inline">\(\tau&lt;&lt;T_B\)</span>）</strong></p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587018-0.png" alt="Clipboard 2023年3月12日 10.10"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.10</figcaption></figure><p>使ASD图对于小的<span class="math inline">\(\tau\)</span>阶段的斜率为<span class="math inline">\(+\frac{1}{2}\)</span>。</p><p><strong>(2) 当<span class="math inline">\(\tau=1.89 T_B\)</span>，曲线平滑且：</strong></p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587140-0.png" alt="Clipboard 2023年3月12日 10.12"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.12</figcaption></figure><p>或<span class="math inline">\(\sigma_{z_G}\left(1.89 T_B\right)=0.4365 \sqrt{S_B T_B}\)</span></p><blockquote><p>此处公式要注意，<span class="math inline">\(\sigma_{z_G}\left(1.89 T_B\right)\)</span>是一个值，不是两个值相乘，所以<span class="math inline">\(\sigma_{z_G}^2\left(1.89 T_B\right)\)</span>应该看作<span class="math inline">\(\sigma_{z_G}^2(\tau)\)</span></p></blockquote><p><strong>(1) 对于较大的集群时间（<span class="math inline">\(\tau&gt;&gt;T_B\)</span>）</strong></p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587284-0.png" alt="Clipboard 2023年3月12日 10.14"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.14</figcaption></figure><p>使ASD图对于大的<span class="math inline">\(\tau\)</span>阶段的斜率为<span class="math inline">\(-\frac{1}{2}\)</span>。</p><p>一阶标量高斯-马尔可夫过程可用于(近似地)对ASD图的平坦部分(即偏置不稳定性)建模。</p><blockquote><p>为什么长这样，与直觉相反？因为为了产生平坦区域，前面部分斜率为<span class="math inline">\(+\frac{1}{2}\)</span>刚好可以跟角度/速度随机游走N的斜率<span class="math inline">\(-\frac{1}{2}\)</span>抵消。后面部分也同样道理，但是这样就需要有截断的频率。</p></blockquote><p>如果制造商只提供了<span class="math inline">\(B\)</span>和<span class="math inline">\(T_B\)</span>的值，那么<span class="math inline">\(\mu_B\)</span>的值可以用(34)计算。通过使式(32)中的<span class="math inline">\(\sigma_{z_B}^2\)</span>等于式(37)中的<span class="math inline">\(\sigma_{z_G}^2\)</span>，可以求解<span class="math inline">\(S_B\)</span>：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587506-0.png" alt="Clipboard 2023年3月12日 10.18"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.18</figcaption></figure><p>当<span class="math inline">\(\mu_B\)</span>和<span class="math inline">\(S_B\)</span>已知时，式(33)的状态空间模型完全指定。</p><p>相反，如果制造商提供ASD图，并且偏差不稳定性足够大，足以保证包含在模型中，那么可以首先根据<span class="math inline">\(1.89T_B\)</span>靠近ASD图的平坦部分来得到<span class="math inline">\(T_B\)</span>参数，然后使式(37)中定义的<span class="math inline">\(\sigma_{z_G}\left(1.89 T_B\right)\)</span>的值接近ASD图平坦区域的值，从而得到<span class="math inline">\(S_B\)</span>。</p><p>对于图2中的ASD图，在<span class="math inline">\(\tau = 60 s\)</span>时，最小值为<span class="math inline">\(7.4 e-4 \mathrm{~m} / \mathrm{s}^2\)</span>。对应<span class="math inline">\(T_B= 60/1.89 = 31.7\)</span>, <span class="math inline">\(S_B=9.0 e-8 \mathrm{~m}^2 / \mathrm{s}^5\)</span>, <span class="math inline">\(B=1.11 e-3 \mathrm{~m} / \mathrm{s}^2\)</span></p><h2 id="cumulative-error-model-n-b-k">Cumulative Error Model: N , B, K</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;imu-error-modeling-tutorial-ins-state-estimation-with-real-time-sensor-calibration&quot;&gt;IMU Error Modeling Tutorial (INS state estimatio
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IKFOM代码解析</title>
    <link href="http://yoursite.com/2023/02/20/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2023/02/20/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-20T01:22:58.000Z</published>
    <updated>2023-02-22T05:59:44.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kalman-filters-on-differentiable-manifolds">Kalman Filters on Differentiable Manifolds</h1><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227202357.png"></p><h1 id="ikfom在fast-lio2中的应用">IkFoM在Fast-LIO2中的应用</h1><p>Fast-LIO2中，主要使用了IkFoM作为状态，其中，在<code>use-ikfom.hpp</code>声明了关于各种状态、数据的宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IKFoM_toolkit/esekfom/esekfom.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">3</span>, <span class="keyword">double</span>&gt; vect3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::SO3&lt;<span class="keyword">double</span>&gt; SO3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::S2&lt;<span class="keyword">double</span>, <span class="number">98090</span>, <span class="number">10000</span>, <span class="number">1</span>&gt; S2; </span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">1</span>, <span class="keyword">double</span>&gt; vect1;</span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">2</span>, <span class="keyword">double</span>&gt; vect2;</span><br><span class="line"></span><br><span class="line">MTK_BUILD_MANIFOLD(state_ikfom,</span><br><span class="line">((vect3, pos))</span><br><span class="line">((SO3, rot))</span><br><span class="line">((SO3, offset_R_L_I))</span><br><span class="line">((vect3, offset_T_L_I))</span><br><span class="line">((vect3, vel))</span><br><span class="line">((vect3, bg))</span><br><span class="line">((vect3, ba))</span><br><span class="line">((S2, grav))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">MTK_BUILD_MANIFOLD(input_ikfom,</span><br><span class="line">((vect3, acc))</span><br><span class="line">((vect3, gyro))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">MTK_BUILD_MANIFOLD(process_noise_ikfom,</span><br><span class="line">((vect3, ng))</span><br><span class="line">((vect3, na))</span><br><span class="line">((vect3, nbg))</span><br><span class="line">((vect3, nba))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，<code>MTK_BUILD_MANIFOLD</code>宏定义是引用自<code>build_manifold.hpp</code>文件，即<code>mtk</code>文件夹内的内容，<code>mtk</code>文件夹原版是来自(OpenSLAM-MTK)[https://github.com/OpenSLAM-org/openslam_MTK]，并且经过了一定的修改和适配。</p><h2 id="mtk_build_manifold干了啥">MTK_BUILD_MANIFOLD干了啥</h2><p><code>MTK_BUILD_MANIFOLD</code>是由BOOST宏模板编程技术写的宏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MTK_AUTOCONSTRUCT_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_AUTOCONSTRUCT_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/preprocessor/seq.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/preprocessor/cat.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"src/SubManifold.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"startIdx.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PARSED_BY_DOXYGEN</span></span><br><span class="line"><span class="comment">//////// internals //////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_APPLY_MACRO_ON_TUPLE(r, macro, tuple) macro tuple</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_TRANSFORM_COMMA(macro, entries) BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM_S(1, MTK_APPLY_MACRO_ON_TUPLE, macro, entries))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_TRANSFORM(macro, entries) BOOST_PP_SEQ_FOR_EACH_R(1, MTK_APPLY_MACRO_ON_TUPLE, macro, entries)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_CONSTRUCTOR_ARG(  type, id) const type&amp; id = type()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_CONSTRUCTOR_COPY( type, id) id(id)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_BOXPLUS(          type, id) id.boxplus(MTK::subvector(__vec, &amp;self::id), __scale);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_OPLUS(               type, id) id.oplus(MTK::subvector_(__vec, &amp;self::id), __scale);</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><code>#ifndef PARSED_BY_DOXYGEN</code> 表示接下来的代码，将不是由 DOXYGEN 工具来解析，而是由C++预处理来处理</li><li><code>build_manifold.hpp</code>文件使用了大量的Boost库的预处理(PP: preprocessor)模板元库技术，直接看代码比较复杂，所以这里反过来看，即直接对宏展开，然后往回看。</li></ul><h3 id="方法一使用ide展开宏定义">【方法一】使用IDE展开宏定义</h3><p>以<code>input_ikfom</code>的定义代码块为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MTK_BUILD_MANIFOLD(input_ikfom,</span><br><span class="line">((vect3, acc))</span><br><span class="line">((vect3, gyro))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>直接使用CLion展开是最快的，把鼠标移到附近，等待解析完成，显示如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/02/20/1676881479.png"></p><p>展开结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> input_ikfom self;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; S2_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; SO3_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; vect_state;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> vect3::scalar scalar;</span><br><span class="line">    input_ikfom(<span class="keyword">const</span> vect3 &amp;acc = vect3(), <span class="keyword">const</span> vect3 &amp;gyro = vect3()) : acc(acc), gyro(gyro) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.boxplus(MTK::subvector(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.boxplus(MTK::subvector(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.oplus(MTK::subvector_(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.oplus(MTK::subvector_(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar, DOF&gt; __res, <span class="keyword">const</span> input_ikfom &amp;__oth)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        acc.boxminus(MTK::subvector(__res, &amp;self::acc), __oth.acc);</span><br><span class="line">        gyro.boxminus(MTK::subvector(__res, &amp;self::gyro), __oth.gyro);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;__os, <span class="keyword">const</span> input_ikfom &amp;__var) &#123;</span><br><span class="line">        <span class="keyword">return</span> __os &lt;&lt; __var.acc &lt;&lt; <span class="string">" "</span> &lt;&lt; __var.gyro &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">0</span>) &#123;</span><br><span class="line">            (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM), vect3::DOF));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">0</span>) &#123; (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM), vect3::DOF)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_hat(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_hat(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_Nx_yy(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Nx_yy(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123;</span><br><span class="line">            acc.S2_Mx(res, dx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Mx(res, dx); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp;<span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp;__is, input_ikfom &amp;__var) &#123; <span class="keyword">return</span> __is &gt;&gt; __var.acc &gt;&gt; __var.gyro; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二编写代码展开宏定义并打印">【方法二】编写代码展开宏定义并打印</h3><p>新建<code>test</code>文件夹，添加<code>test_ikfom.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../include/IKFoM_toolkit/esekfom/esekfom.hpp"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">3</span>, <span class="keyword">double</span>&gt; vect3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::SO3&lt;<span class="keyword">double</span>&gt; SO3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::S2&lt;<span class="keyword">double</span>, <span class="number">98090</span>, <span class="number">10000</span>, <span class="number">1</span>&gt; S2;</span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">1</span>, <span class="keyword">double</span>&gt; vect1;</span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">2</span>, <span class="keyword">double</span>&gt; vect2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(...) STR_(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_(...) #__VA_ARGS__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> message <span class="meta-string">"Marco is : "</span> \</span></span><br><span class="line">    STR(MTK_BUILD_MANIFOLD(input_ikfom, \</span><br><span class="line">                            ((vect3, acc))  \</span><br><span class="line">                            ((vect3, gyro))  \</span><br><span class="line">                           )\</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,</span><br><span class="line">           STR(MTK_BUILD_MANIFOLD(input_ikfom, \</span><br><span class="line">                            ((vect3, acc))  \</span><br><span class="line">                            ((vect3, gyro))  \</span><br><span class="line">                           )\</span><br><span class="line">           )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>__VA_ARGS__</code>是可变参数宏标识符，<code>#define STR(...)</code>里面的<code>(...)</code>表示可以传递多个参数。</p><p>需要注意的是：</p><ul><li>​​#运算符​​ 把参数字符串化，功能就是转为字符串</li></ul><p>为什么需要用两个STR宏，是因为：</p><ul><li><code>STR(...)</code>将<code>MTK_BUILD_MANIFOLD(xxxx)</code>这一串字符传递给<code>__VA_ARGS__</code>变量，如果此时就调用<code>#__VA_ARGS__</code>进行打印，那么输出的仍然是<code>MTK_BUILD_MANIFOLD(xxxx)</code>，为了展开，需要将<code>__VA_ARGS__</code>的值（也就是<code>MTK_BUILD_MANIFOLD(xxxx)</code>的值）进行传递，所以有了<code>STR_(...)</code>，此时<code>MTK_BUILD_MANIFOLD(xxxx)</code>的具体值就会传递给<code>STR_(...)</code>的<code>__VA_ARGS__</code>，这个时候再打印，就是完整的宏定义展开了。</li></ul><p>运行此CPP，得到输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span> <span class="keyword">typedef</span> input_ikfom self; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state; MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc; MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro; <span class="keyword">enum</span> &#123;DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF&#125;; <span class="keyword">enum</span> &#123;DIM = vect3::DIM+<span class="number">0</span> + vect3::DIM&#125;; <span class="keyword">typedef</span> vect3::scalar scalar; input_ikfom ( <span class="keyword">const</span> vect3&amp; acc = vect3(), <span class="keyword">const</span> vect3&amp; gyro = vect3() ) : acc(acc), gyro(gyro) &#123;&#125; <span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125; <span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; acc.boxplus(MTK::subvector(__vec, &amp;self::acc), __scale); gyro.boxplus(MTK::subvector(__vec, &amp;self::gyro), __scale); &#125; <span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; acc.oplus(MTK::subvector_(__vec, &amp;self::acc), __scale); gyro.oplus(MTK::subvector_(__vec, &amp;self::gyro), __scale); &#125; <span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar,DOF&gt; __res, <span class="keyword">const</span> input_ikfom&amp; __oth)</span> <span class="keyword">const</span> </span>&#123; acc.boxminus(MTK::subvector(__res, &amp;self::acc), __oth.acc); gyro.boxminus(MTK::subvector(__res, &amp;self::gyro), __oth.gyro); &#125; <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; __os, <span class="keyword">const</span> input_ikfom&amp; __var)&#123; <span class="keyword">return</span> __os &lt;&lt; __var.acc &lt;&lt; <span class="string">" "</span> &lt;&lt; __var.gyro &lt;&lt; <span class="string">" "</span> ; &#125; <span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span></span>&#123; <span class="keyword">if</span>(acc.TYP == <span class="number">1</span>)&#123;S2_state.push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM));&#125; <span class="keyword">if</span>(gyro.TYP == <span class="number">1</span>)&#123;S2_state.push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM));&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span></span>&#123; <span class="keyword">if</span>(acc.TYP == <span class="number">0</span>)&#123;(vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM), vect3::DOF));&#125; <span class="keyword">if</span>(gyro.TYP == <span class="number">0</span>)&#123;(vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM), vect3::DOF));&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span></span>&#123; <span class="keyword">if</span>(acc.TYP == <span class="number">2</span>)&#123;(SO3_state).push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM));&#125; <span class="keyword">if</span>(gyro.TYP == <span class="number">2</span>)&#123;(SO3_state).push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM));&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123; <span class="keyword">if</span>(acc.IDX == idx)&#123;acc.S2_hat(res);&#125; <span class="keyword">if</span>(gyro.IDX == idx)&#123;gyro.S2_hat(res);&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123; <span class="keyword">if</span>(acc.IDX == idx)&#123;acc.S2_Nx_yy(res);&#125; <span class="keyword">if</span>(gyro.IDX == idx)&#123;gyro.S2_Nx_yy(res);&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123; <span class="keyword">if</span>(acc.IDX == idx)&#123;acc.S2_Mx(res, dx);&#125; <span class="keyword">if</span>(gyro.IDX == idx)&#123;gyro.S2_Mx(res, dx);&#125; &#125; <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; __is, input_ikfom&amp; __var)&#123; <span class="keyword">return</span> __is &gt;&gt; __var.acc &gt;&gt; __var.gyro ; &#125; &#125;;</span><br></pre></td></tr></table></figure><p>重新格式化后，得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> input_ikfom self;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> vect3::scalar scalar;</span><br><span class="line">    input_ikfom(<span class="keyword">const</span> vect3 &amp;acc = vect3(), <span class="keyword">const</span> vect3 &amp;gyro = vect3()) : acc(acc), gyro(gyro) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.boxplus(MTK::subvector(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.boxplus(MTK::subvector(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.oplus(MTK::subvector_(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.oplus(MTK::subvector_(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar, DOF&gt; __res, <span class="keyword">const</span> input_ikfom &amp;__oth)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        acc.boxminus(MTK::subvector(__res, &amp;self::acc), __oth.acc);</span><br><span class="line">        gyro.boxminus(MTK::subvector(__res, &amp;self::gyro), __oth.gyro);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;__os, <span class="keyword">const</span> input_ikfom &amp;__var) &#123;</span><br><span class="line">        <span class="keyword">return</span> __os &lt;&lt; __var.acc &lt;&lt; <span class="string">" "</span> &lt;&lt; __var.gyro &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">0</span>) &#123;</span><br><span class="line">            (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM), vect3::DOF));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">0</span>) &#123; (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM), vect3::DOF)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_hat(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_hat(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_Nx_yy(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Nx_yy(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123;</span><br><span class="line">            acc.S2_Mx(res, dx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Mx(res, dx); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp;<span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp;__is, input_ikfom &amp;__var) &#123; <span class="keyword">return</span> __is &gt;&gt; __var.acc &gt;&gt; __var.gyro; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>两种方法得到的结果，是一致的</strong>。</p><h2 id="mtk_build_manifold细读">MTK_BUILD_MANIFOLD细读</h2><p>有了输入、输出，这个时候结合<code>MTK_BUILD_MANIFOLD</code>的代码来分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_BUILD_MANIFOLD(name, entries) \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span> \</span><br><span class="line"><span class="keyword">typedef</span> name self; \</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;\</span><br><span class="line">MTK_SUBVARLIST(entries, S2_state, SO3_state) \</span><br><span class="line">name ( \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_ARG, entries) \</span><br><span class="line">) : \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_COPY, entries) &#123;&#125;\</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_OPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar,DOF&gt; __res, <span class="keyword">const</span> name&amp; __oth)</span> <span class="keyword">const</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXMINUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; __os, <span class="keyword">const</span> name&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __os MTK_TRANSFORM(MTK_OSTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_vect_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_SO3_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_hat, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Nx_yy, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Mx, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; __is, name&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __is MTK_TRANSFORM(MTK_ISTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把<code>name = input_ikfom</code>代入上面，得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_BUILD_MANIFOLD(name, entries) \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span> \</span><br><span class="line"><span class="keyword">typedef</span> input_ikfom self; \</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;\</span><br><span class="line">MTK_SUBVARLIST(entries, S2_state, SO3_state) \</span><br><span class="line">input_ikfom ( \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_ARG, entries) \</span><br><span class="line">) : \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_COPY, entries) &#123;&#125;\</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_OPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar,DOF&gt; __res, <span class="keyword">const</span> input_ikfom&amp; __oth)</span> <span class="keyword">const</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXMINUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; __os, <span class="keyword">const</span> input_ikfom&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __os MTK_TRANSFORM(MTK_OSTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_vect_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_SO3_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_hat, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Nx_yy, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Mx, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; __is, input_ikfom&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __is MTK_TRANSFORM(MTK_ISTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，还有</p><ul><li><code>MTK_SUBVARLIST</code>,</li><li><code>MTK_TRANSFORM_COMMA</code>,</li><li><code>MTK_TRANSFORM</code>,</li><li><code>MTK_CONSTRUCTOR_ARG</code>,</li><li><code>MTK_CONSTRUCTOR_COPY</code>,</li><li><code>MTK_BOXPLUS</code>,</li><li><code>MTK_OSTREAM</code>,</li><li><code>MTK_S2_state</code>,</li><li><code>MTK_vect_state</code>,</li><li><code>MTK_SO3_state</code>,</li><li><code>MTK_S2_hat</code>,</li><li><code>MTK_S2_Nx_yy</code>,</li><li><code>MTK_S2_Mx</code>,</li><li><code>MTK_ISTREAM</code>,</li><li><code>MTK::vectview</code></li></ul><p>需要展开。</p><h3 id="mtk_subvarlist">MTK_SUBVARLIST</h3><p><code>MTK_SUBVARLIST</code>的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_SUBVARLIST(seq, S2state, SO3state) \</span></span><br><span class="line">BOOST_PP_FOR_1( \</span><br><span class="line">( \</span><br><span class="line">BOOST_PP_SEQ_SIZE(seq), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq) (~), \</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state ),\</span><br><span class="line">MTK_ENTRIES_TEST, MTK_ENTRIES_NEXT, MTK_ENTRIES_OUTPUT)</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;</span><br><span class="line">MTK_SUBVARLIST(((vect3, acc)) ((vect3, gyro)) , S2_state, SO3_state) \</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;</span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vect3::scalar scalar;</span><br></pre></td></tr></table></figure><p>此处用了<code>BOOST_PP_FOR_1</code>，根据附录，BOOST_PP_FOR(state, pred, op, macro) 宏用于执行一定数量的宏展开操作</p><p>在这里，</p><ul><li>循环变量的初始状态state为</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">BOOST_PP_SEQ_SIZE(seq), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq) (~), \</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state )</span><br></pre></td></tr></table></figure><ul><li>结束循环的条件pred为<code>MTK_ENTRIES_TEST</code></li><li>产生新状态的操作op为<code>MTK_ENTRIES_NEXT</code></li><li>具体输出操作macro为<code>MTK_ENTRIES_OUTPUT</code></li></ul><hr><p>============= 第一轮循环 ============</p><p><strong>初始状态</strong></p><p>原始输入:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq =     ((vect3, acc))  \</span><br><span class="line">               ((vect3, gyro))  \</span><br></pre></td></tr></table></figure><p>输入初始状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">BOOST_PP_SEQ_SIZE(seq), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq) (~), \</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state )</span><br></pre></td></tr></table></figure><ul><li>BOOST_PP_SEQ_SIZE(seq) = 2</li><li>BOOST_PP_SEQ_HEAD(seq) = (vect3, acc)</li><li>BOOST_PP_SEQ_TAIL(seq) (~) = ((vect3, gyro))</li></ul><p>即初始状态为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">    <span class="number">2</span>, \</span><br><span class="line">    (vect3, acc), \</span><br><span class="line">    ((vect3, gyro)), \</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    S2state,\</span><br><span class="line">    SO3state\</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_TEST</strong></p><p>取state第0个元素，非0则继续循环，为0则结束循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! this used to be BOOST_PP_TUPLE_ELEM_4_0:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_TUPLE_ELEM_4_0(a,b,c,d,e,f, g) a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取state第0个元素</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_TEST(r, state) MTK_TUPLE_ELEM_4_0 state</span></span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_OUTPUT</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_APPLY_MACRO_ON_TUPLE(r, macro, tuple) macro tuple</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PUT_TYPE(type, id, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK::SubManifold&lt;type, dof, dim&gt; id; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PUT_TYPE_AND_ENUM(type, id, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK_PUT_TYPE(type, id, dof, dim, S2state, SO3state) \</span><br><span class="line"><span class="keyword">enum</span> &#123;DOF = type::DOF + dof&#125;; \</span><br><span class="line"><span class="keyword">enum</span> &#123;DIM = type::DIM+dim&#125;; \</span><br><span class="line"><span class="keyword">typedef</span> type::scalar scalar; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_OUTPUT_I(s, head, seq, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK_APPLY_MACRO_ON_TUPLE(~, \</span><br><span class="line">BOOST_PP_IF(BOOST_PP_DEC(s), MTK_PUT_TYPE, MTK_PUT_TYPE_AND_ENUM), \</span><br><span class="line">( BOOST_PP_TUPLE_REM_2 head, dof, dim, S2state, SO3state)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要调用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_OUTPUT(r, state) MTK_ENTRIES_OUTPUT_I state</span></span><br></pre></td></tr></table></figure><p>初始状态为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">    <span class="number">2</span>, \</span><br><span class="line">    (vect3, acc), \</span><br><span class="line">    ((vect3, gyro)), \</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    S2state,\</span><br><span class="line">    SO3state\</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MTK_ENTRIES_OUTPUT_I (s = <span class="number">2</span>, head = (vect3, acc), seq = ((vect3, gyro)), dof = <span class="number">0</span>, dim = <span class="number">0</span>, S2state = S2state, SO3state = SO3state)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MTK_ENTRIES_OUTPUT_I的内部流程为：</span></span><br><span class="line"><span class="comment">// 如果 s-1 &gt; 0 :</span></span><br><span class="line"><span class="comment">// 那么，以(head[0], head[1], dof, dim, S2state, SO3state)为参数，调用MTK_PUT_TYPE宏</span></span><br><span class="line"><span class="comment">// 如果 s-1 &lt;=0:</span></span><br><span class="line"><span class="comment">// 那么，以(head[0], head[1], dof, dim, S2state, SO3state)为参数，调用MTK_PUT_TYPE_AND_ENUM宏</span></span><br></pre></td></tr></table></figure><p>此处，s - 1=2 - 1 &gt; 0，所以会调用<code>MTK_PUT_TYPE</code>宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PUT_TYPE(type, id, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK::SubManifold&lt;type, dof, dim&gt; id;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_NEXT</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_NEXT(r, state) MTK_ENTRIES_NEXT_I state</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_NEXT_I(len, head, seq, dof, dim, S2state, SO3state) ( \</span></span><br><span class="line">BOOST_PP_DEC(len), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq), \</span><br><span class="line">dof + BOOST_PP_TUPLE_ELEM_2_0 head::DOF,\</span><br><span class="line">dim + BOOST_PP_TUPLE_ELEM_2_0 head::DIM,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state)</span><br></pre></td></tr></table></figure><p>初始状态为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">    <span class="number">2</span>, \</span><br><span class="line">    (vect3, acc), \</span><br><span class="line">    ((vect3, gyro)), \</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    S2state,\</span><br><span class="line">    SO3state\</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTK_ENTRIES_NEXT_I(len = <span class="number">2</span>, head = (vect3, acc), seq = ((vect3, gyro)), <span class="number">0</span>, <span class="number">0</span>, S2state, SO3state)</span><br></pre></td></tr></table></figure><p>经过op操作（MTK_ENTRIES_NEXT）之后，得到新的state：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, \</span><br><span class="line">(vect3, gyro), \</span><br><span class="line">, \</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DOF,\</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DIM,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state\</span><br></pre></td></tr></table></figure><p>============= 第二轮循环 ============</p><p>当前状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, \</span><br><span class="line">(vect3, gyro), \</span><br><span class="line">, \</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DOF,\</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DIM,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state\</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_TEST</strong></p><p>第0个元素为1，继续执行</p><p><strong>MTK_ENTRIES_OUTPUT</strong></p><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vect3::scalar scalar;</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_NEXT</strong></p><p>op操作，得到下一个状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,BOOST_PP_SEQ_ELEM_III,BOOST_PP_SEQ_TAIL_I,<span class="number">0</span>+vect3::DOF+vect3::DOF,<span class="number">0</span>+vect3::DIM+vect3::DIM,S2state,SO3state)</span><br></pre></td></tr></table></figure><p>============= 结束循环 ============</p><p>最终，<code>MTK_SUBVARLIST</code>得到结果如下：</p><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一轮循环输出的</span></span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二轮循环输出的</span></span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vect3::scalar scalar;</span><br></pre></td></tr></table></figure><h1 id="附录">附录</h1><h2 id="boost_pp_for">BOOST_PP_FOR</h2><p>BOOST_PP_FOR 是 Boost Preprocessor 库中的一个宏，用于实现基于循环的元编程。BOOST_PP_FOR(state, pred, op, macro) 表示泛化的for水平重复结构，它接受四个参数：</p><ul><li>state : 初始状态</li><li>pred : 判断是否继续展开，形如 pred(r, state) 的二元谓词。该宏必须展开为一个位于 0 到 BOOST_PP_LIMIT_MAG 间的整数。当该谓词返回非零时，BOOST_PP_FOR 重复展开 macro</li><li>op : 操作生成新的状态，形如 op(r, state) 的二元操作; 该宏被重复应用于 state, <strong>每次产生一个新的 state</strong>, 直至 pred 返回 0.</li><li>macro: 利用state生成做后的输出，形如 macro(r, state) 的二元宏;该宏被 BOOST_PP_FOR 重复调用，直至 pred 返回 0</li></ul><p>简单来说，使用<code>BOOST_PP_FOR</code>，大概会展开成这个模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">macro(r, state) macro(r, op(r, state)) … macro(r, op(r, … op(r, state) … ))</span><br><span class="line">&#96;&#96;</span><br><span class="line"></span><br><span class="line">常用的pred大概长这样:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line"> &#x2F;&#x2F; 当state的首元素不等于state第二元素+1时，返回1，否则返回0</span><br><span class="line">#define PRED(r, state) \</span><br><span class="line">   BOOST_PP_NOT_EQUAL( \</span><br><span class="line">      BOOST_PP_TUPLE_ELEM(2, 0, state), \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(2, 1, state)) \</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; BOOST_PP_NOT_EQUAL ， BOOST_PP_INC 可以看下面的BOOST_PP运算部分</span><br><span class="line">&#x2F;&#x2F; BOOST_PP_TUPLE_ELEM表示从state中取第0个元素</span><br></pre></td></tr></table></figure><p>一个op操作举例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP(r, state) \</span></span><br><span class="line">   ( \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">0</span>, state)), \ <span class="comment">// 递增首元素</span></span><br><span class="line">      BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">1</span>, state) \ <span class="comment">// 取出第二元素 ，组合成新的元组（state）</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 输入: (5, 10) 则state = (5, 10)</span></span><br><span class="line"> <span class="comment">// 输出: (6, 10)</span></span><br></pre></td></tr></table></figure><p>一个macro操作举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACRO(r, state) BOOST_PP_TUPLE_ELEM(2, 0, state) <span class="comment">// 取元组的首元素</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入: (5, 10)</span></span><br><span class="line"><span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入: (6, 10)</span></span><br><span class="line"><span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure><p>对上面的操作进行组合，形成一个<code>BOOST_PP_FOR</code>操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 当state的首元素不等于state第二元素+1时，返回1，否则返回0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRED(r, state) \</span></span><br><span class="line">   BOOST_PP_NOT_EQUAL( \</span><br><span class="line">      BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">0</span>, state), \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">1</span>, state)) \</span><br><span class="line">   )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP(r, state) \</span></span><br><span class="line">   ( \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">0</span>, state)), \ <span class="comment">// 递增首元素</span></span><br><span class="line">      BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">1</span>, state) \ <span class="comment">// 取出第二元素 ，组合成新的元组（state）</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取元组的首元素  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACRO(r, state) BOOST_PP_TUPLE_ELEM(2, 0, state)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开为 5 6 7 8 9 10（当状态为（11，10）停止，不输出）</span></span><br><span class="line">BOOST_PP_FOR((<span class="number">5</span>, <span class="number">10</span>), PRED, OP, MACRO)</span><br></pre></td></tr></table></figure><h2 id="boost_pp运算">BOOST_PP运算</h2><p>算术运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_ADD(x,y)          x + y</span><br><span class="line">BOOST_PP_DEC(x)            x - <span class="number">1</span></span><br><span class="line">BOOST_PP_DIV(x,y)          x / y</span><br><span class="line">BOOST_PP_INC(x)              x + <span class="number">1</span></span><br><span class="line">BOOST_PP_MOD(x,y)          x % y</span><br><span class="line">BOOST_PP_MUL(x,y)         x * y</span><br><span class="line">BOOST_PP_SUB(x,y)          x – y</span><br></pre></td></tr></table></figure><p>整型逻辑运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_AND(x,y)          x &amp;&amp; y</span><br><span class="line">BOOST_PP_NOR(x,y)          !(x || y)</span><br><span class="line">BOOST_PP_OR(x,y)            x || y</span><br><span class="line">BOOST_PP_XOR(x,y)          (<span class="keyword">bool</span>)x != (<span class="keyword">bool</span>)y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_NOT(x)            x ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">BOOST_PP_BOOL(x)          x ? <span class="number">1</span> : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>位逻辑运算（单个位操作的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_BITAND(x,y) x &amp;&amp; y</span><br><span class="line">BOOST_PP_BITNOR(x,y)          !(x || y)</span><br><span class="line">BOOST_PP_BITOR(x,y)                x || y</span><br><span class="line">BOOST_PP_BITXOR(x,y)          (<span class="keyword">bool</span>)x != (<span class="keyword">bool</span>)y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_COMPL(x)                x ? <span class="number">0</span> : <span class="number">1</span></span><br></pre></td></tr></table></figure><p>比较运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_EQUAL(x,y)                               x == y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_NOT_EQUAL(x,y)            x != y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_LESS(x,y)                                    x &lt; y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_LESS_EQUAL(x,y)                    x &lt;= y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_GREATER(x,y)                           x &gt; y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_GREATER_EQUAL(x,y)          x &gt;= y ? <span class="number">1</span> : <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="boost_pp序列">BOOST_PP序列</h2><p>序列 (简称为 seq)是一组相邻的带括号的元素。例如, (a)(b)©(d) seq 不能为空。因此，一个 “空的” seq 被认为是一种特殊情况，必须由C++单独处理。 对于序列的处理效率是非常高的，可以认为是随机访问的。</p><p>BOOST_PP_SEQ_HEAD(seq) 展开为一个 seq 的第一个元素。 BOOST_PP_SEQ_TAIL(seq) 展开为一个 seq 中除了第一个元素以外的其它元素。(还是一个序列)</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/preprocessor/seq/seq.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEQ (a)(b)(c)</span></span><br><span class="line"></span><br><span class="line">BOOST_PP_SEQ_HEAD(SEQ) <span class="comment">// expands to a</span></span><br><span class="line">BOOST_PP_SEQ_TAIL(SEQ) <span class="comment">// expands to (b)(c)</span></span><br><span class="line">BOOST_PP_SEQ_CAT(SEQ) <span class="comment">// expands to abc</span></span><br></pre></td></tr></table></figure><h2 id="boost_pp_ifcond-t-f">BOOST_PP_IF(cond, t, f)</h2><p>类似三元运算符 cond ? t : f ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kalman-filters-on-differentiable-manifolds&quot;&gt;Kalman Filters on Differentiable Manifolds&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.nsloop.com:58443
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/12/18/M_LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/12/18/M_LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-12-18T08:25:38.825Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="robust-odometry-and-mapping-for-multi-lidar-systems-with-online-extrinsic-calibration">Robust Odometry and Mapping for Multi-LiDAR Systems with Online Extrinsic Calibration</h1><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002092755.png"></p><h1 id="摘要">摘要</h1><p>组合多个LIDARS使机器人能够最大化其对环境的感知意识，并获得足够的测量。本文提出了一种实现鲁棒和同步的外参标定，里程计和多个LIDAR的建图系统。</p><p>我们的方法从测量预处理开始，从原始测量中提取边缘和平面特征，在运动和外参初始化过程之后，基于滑动窗口的多激光雷达里程计将板载运行，以估计具有在线标定和收敛性检测的位姿。</p><p>我们进一步开发了一种建图算法来构造全局地图，并优化具有足够特征的Pose以及捕获和减少数据不确定性的方法。</p><h1 id="介绍">介绍</h1><p>如果没有手动干预，我们的系统可以从多个未知外参的激光雷达开始，自动校准其外参，并提供准确的姿势以及全局一致的地图。先前的工作（LIOM），启发了本文，我们尝试解决多激光雷达融合问题的地方。此外，我们介绍了一种基于运动的方法[4]以初始化外参的方法，并使用[19]中的工具来表示不确定性。 本文贡献如下：</p><ul><li>自动初始化，计算所有关键状态，包括连续帧之间的运动以及后续阶段的外参。它可以在任意位置开始，而无需任何先前的机械配置或校准对象知识(Section VI)</li><li>使用常规收敛准则的在线自标定与里程计同时执行，它具有以完全无监督的方式监控收敛性和触发终止的能力(Section VII-B)</li><li>基于滑动窗口的里程计，充分利用来自多个 LiDAR 的信息，该实现可以解释为小规模的帧到地图注册表，这进一步减少了连续帧到帧的帧累积的漂移(Section VII-C)</li><li>使用二阶段方法进行建图，捕获传感器噪声并传播不确定性，来消除姿势估计和外参估计的外部扰动，这种方法使建图过程能够了解不确定性，并有助于我们保持全局地图的一致性以及提高系统的鲁棒性以进行长期导航任务。</li></ul><p>据我们所知，M-LOAM是第一个对多激光雷达外参标定和SLAM的完整解决方案，该系统在手持设备和自动驾驶汽车上进行了广泛的实验评估，从室内办事处到户外城市道路的各种情景，优于基于Sota Lidar的方法。关于各种平台上的校准，我们的方法实现了外参上的平移的厘米级精度和旋转的分数。对于不同尺度的SLAM，已成功应用M-LOAM以提供准确的姿势和地图结果。 图1可视化每个阶段的M-Loam的输出。</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002095249.png"></p><h1 id="相关工作">相关工作</h1><h2 id="lidar-based-slam">LiDAR-Based SLAM</h2><h2 id="multi-sensor-calibration">Multi-Sensor Calibration</h2><p>Kummerle等 [52]开创了一个超图优化框架，用于校准带轮式编码器的车载激光扫描仪，Teichman等人[53] 同时，提出了一种迭代的SLAM-Fitting Pipline，以解决两个RGB-D相机的畸变，为了恢复多摄像时系统的空间偏移，恒等人[54]将问题转换为为<code>Bundle Adjustment</code>，而欧阳展鹏等[55]采用<code>Ackermann</code>转向模型来限制外参。</p><p>如[47]所示，[56] - [58]，传感器之间的时间偏移的在线估计对IMU的系统至关重要。 Qin等 [56]利用QIU等人的视觉特征的重新注入误差制定时间校准问题。 [58]提出了一种通过分析传感器的运动相关来校准异质传感器的更一般的方法。</p><p>本文隐含地同步了基于硬件的外部时钟的多个激光雷达的时间系统，并明确关注外参标定。 我们的方法包括在线程序，以实现灵活的多激光雷达外参标定。 要监控估计的外部的融合，我们提出了一般标准。 此外，我们对外部扰动进行建模，以减少其对长期导航任务的负面影响。</p><h1 id="问题描述">问题描述</h1><p>我们根据最大似然估计（Maximum Like- lihood Estimation， MLE）制定M-LOAM，MLE导致非线性优化问题，其中，高斯协方差的逆对残差函数进行加权。</p><p>在深入研究 M-LOAM 的细节之前，我们先介绍一些基本概念：</p><ul><li>第 III-A 节介绍了符号</li><li>第 III-B 节介绍了 MLE</li><li>第 III-C 节描述了合适的模型来表示 <span class="math inline">\(\mathbb{R}^{3}\)</span>中的不确定测量和 SE(3) 中的变换。</li><li>最后，第 III-D 节简要介绍了 MLE 在 M-LOAM 中具有近似高斯噪声的实现</li></ul><h2 id="符号约定">符号约定</h2><p>命名法如表I所示</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002103027.png"></p><p>我们考虑一个由一个主要激光雷达和多个辅助灵敏器组成的系统，主激光雷达作为<code>base_frame</code>，我们使用()<span class="math inline">\(^{l^{1}} /()^{b}\)</span>来表示，对于其他辅助雷达，使用()<span class="math inline">\(^{l^{i, i&gt;1}}\)</span>来表示。</p><p>我们记<span class="math inline">\(\mathcal{F}\)</span>为从原始激光雷达提取的有效特征，每个特征都表示为3D空间中的一个点：<span class="math inline">\(\mathbf{p}=[x, y, z]^{\top}\)</span>。</p><p>状态向量，由平移和旋转部件组成，记为<span class="math inline">\(\mathbf{x}=[\mathbf{t}, \mathbf{q}]\)</span>，其中<span class="math inline">\(\mathbf{t}\)</span>是3x1向量，<span class="math inline">\(\mathbf{q}\)</span>是汉密尔顿四元数，但在我们需要旋转向量的情况下，我们在SO(3)中使用3×3旋转矩阵<span class="math inline">\(\mathbf{R}\)</span>.</p><p>第VIII节将不确定性与矢量空间上的构成相关联，我们使用SE（3）中的4×4变换矩阵T表示Pose:</p><p><span class="math display">\[\mathbf{T}=\left[\begin{array}{cc}\mathbf{R} &amp; \mathbf{p} \\\mathbf{0}^{\top} &amp; 1\end{array}\right]\]</span></p><h2 id="最大似然估计">最大似然估计</h2><p>我们为MLE问题制定了多激光雷达系统的姿势和外参估计[60] 式（1）：</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \max } p\left(\mathcal{F}_{k} \mid \mathbf{x}_{k}\right)=\underset{\mathbf{x}_{k}}{\arg \min } f\left(\mathbf{x}_{\mathbf{k}}, \mathcal{F}_{k}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{F}_{k}\)</span>表示第k帧的有效特征</li><li><span class="math inline">\(\mathbf{x}_{k}\)</span>表示待优化的状态</li><li><span class="math inline">\(f(\cdot)\)</span>表示目标函数</li></ul><p>假设观测模型使用高斯噪声[3]来替换，那么式（1）变成非线性最小二乘(NLS)问题:</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \min } \sum_{i=1}^{m} \rho\left(\left\|\mathbf{r}\left(\mathbf{x}_{k}, \mathbf{p}_{k i}\right)\right\|_{\mathbf{\Sigma}_{i}}^{2}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\rho(\cdot)\)</span>表示鲁棒性Huber损失[61]，用于处理outlier</li><li><span class="math inline">\(\mathbf{r}(\cdot)\)</span>表示残差函数</li><li><span class="math inline">\(\Sigma_i\)</span>表示协方差矩阵</li></ul><p>迭代方法如高斯牛顿、LM等方法常用于解决NLS问题，这些方法通过计算目标函数相对于状态向量<span class="math inline">\(\mathbf{x}_k\)</span>的<code>Jacobian</code>来进行局部线性化，即<span class="math inline">\(\mathbf{J}=\partial f / \partial \mathbf{x}_{k}\)</span>。通过给定初始值，<span class="math inline">\(\mathbf{x}_k\)</span>通过使用<span class="math inline">\(\mathbf{J}\)</span>进行迭代优化，直到收敛到局部最优。</p><p>在最终的迭代中，状态的最小二乘协方差计算为<span class="math inline">\(\boldsymbol{\Xi}=\boldsymbol{\Lambda}^{-1}\)</span>[62]，其中，<span class="math inline">\(\boldsymbol{\Lambda}=\mathbf{J}^{\top} \mathbf{J}\)</span>称为<code>信息矩阵</code>。</p><h2 id="不确定性表示">不确定性表示</h2><p>我们使用[19]中的工具来表示数据不确定性，首先，考虑噪声的激光点如下，式（3）：</p><p><span class="math display">\[\mathbf{p}=\overline{\mathbf{p}}+\boldsymbol{\zeta}, \quad \boldsymbol{\zeta} \sim \mathcal{N}(\mathbf{0}, \mathbf{Z})\]</span></p><p>其中,</p><ul><li><span class="math inline">\(\bar{\mathbf{p}}\)</span>表示不含噪声的点</li><li><span class="math inline">\(\zeta \in \mathbb{R}^{3}\)</span>是零均值的高斯扰动变量，<span class="math inline">\(\mathbf{Z}\)</span>是激光测量的噪声协方差</li><li>为了使得式（3）与转换矩阵(i.e., <span class="math inline">\(\left.\mathbf{p}_{h}^{\prime}=\mathbf{T} \mathbf{p}_{h}\right)\)</span>更加紧凑，我们使用齐次坐标系来表示：</li></ul><p><span class="math display">\[\mathbf{p}_{h}=\left[\begin{array}{l}\overline{\mathbf{p}} \\1\end{array}\right]+\mathbf{D} \boldsymbol{\zeta}=\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}, \quad \boldsymbol{\zeta} \sim \mathcal{N}(\mathbf{0}, \mathbf{Z})\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{D}\)</span>是将3x1向量转换为齐次坐标的矩阵</li></ul><p>如[63]中的研究，LIDARS深度测量误差（也称为传感器噪声）主要受目标距离的影响，矩阵<span class="math inline">\(\mathbf{Z}\)</span>被简单的设置为常值矩阵。</p><blockquote><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002114842.png"></p></blockquote><p>然后，我们定义SE(3)中受小扰动的随机变量：</p><p><span class="math display">\[\mathbf{T}=\exp \left(\boldsymbol{\xi}^{\wedge}\right) \overline{\mathbf{T}}, \quad \boldsymbol{\xi} \sim \mathcal{N}(\mathbf{0}, \boldsymbol{\Xi})\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\overline{\mathbf{T}}\)</span>是不含噪声的变换矩阵</li><li><span class="math inline">\(\xi \in \mathbb{R}^{6}\)</span>是协方差为<span class="math inline">\(\Xi\)</span>的小扰动变量</li></ul><p>这种表示允许我们在状态空间中储存变换的均值作为<span class="math inline">\(\overline{\mathbf{T}}\)</span>，并使用<span class="math inline">\(\xi\)</span>作为扰动。</p><blockquote><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002114918.png"></p></blockquote><p>我们考虑<span class="math inline">\(\Xi\)</span>包含两个部分的来源：</p><ul><li>Degenerate Pose Estimatio，来自案例，例如在受限制的环境中缺乏几何结构[34]，它通常在其退化方向上不确定姿势[62]，[64]，现有工程诉诸基于模型和基于学习的[65]方法来估算ICP的背景下的姿势协方差。</li><li>Extrinsic Perturbation，该项始终存在，由于外参误差的存在[12]。这种扰动不利于多传感器系统的测量精度 [66]、[67] 但很难测量。</li></ul><p>特别的，<span class="math inline">\(\Xi\)</span>的详细计算在Section VIII</p><h2 id="m-loam中的mle问题">M-LOAM中的MLE问题</h2><p>我们扩展了 MLE 以设计多个 M-LOAM 估计器，以从粗到细的方式解决机器人姿态和外参。最重要的步骤是将高斯噪声协方差<span class="math inline">\(\Sigma\)</span>近似于现实的测量模型。</p><p>根据第 III-C 节中的（上述）讨论，我们确定了三个可能使地标不确定的误差源：传感器噪声、退化姿态估计和外参扰动。</p><p>帧到帧运动估计（部分VI-A）归结于传感器噪声，紧耦合的里程计（第VII-C部分）建立了局部地图用于位姿优化，因此我们应该<code>传播位姿的不确定性到每一个地图点</code>。尽管如此，如果涉及更多的雷达和滑动窗口，这种操作通常是耗时的（大约10ms-20ms）。为了保证里程计的实时性，我们不在此处计算的位姿不确定性。</p><p>因此，我们简单地设置<span class="math inline">\(\Sigma=\mathbf{Z}\)</span>作为残差的协方差。在建图部分，我们有足够的时间来获得准确的姿势和全局地图，因此，我们考虑所有不确定性来源。 第VIII部分解释了姿势不确定性如何影响建图精度和<span class="math inline">\(\Sigma\)</span>的传播。</p><h1 id="系统概览">系统概览</h1><p>我们制作三个假设来简化系统设计</p><ul><li>Lidars是同步的，这意味着不同雷达之间的时间延迟几乎为零</li><li>该平台在校准初始化期间经历了足够的旋转和平移运动</li><li>主激光雷达的局部地图应与辅助LIDAR共享重叠的FOV，用于在改进中匹配以缩短校准阶段，这可以通过移动机器人来实现</li></ul><p>图 2 展示了 M-LOAM 的流水线。 系统从测量预处理（第 V 部分）开始，即从去噪点云中提取和跟踪边缘和平面特征</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002195854.png"></p><p>初始化模块（第VI部分）提供了所有必要的值，包括姿势和外参，用于启动后续的非线性优的M-LO。M-LO融合多激光雷达测量在滑动窗口内优化里程计和外参，如果外参已经收敛，我们跳过外参初始化以及细化步骤，然后进入纯里程计和建图阶段。</p><p>概率建图模块（第VIII节）构造了一种具有足够特征的全局地图，以消除里程计累计漂移。 里程计和建图模块分别运行在隔离的线程上。</p><h1 id="测量预处理">测量预处理</h1><p>我们实施三个顺序步骤来处理LiDARS'raw测量，我们首先将点云分割成许多簇以去除嘈杂的对象，然后提取边缘和平面特征。 为了将连续帧之间的特征关联起来，我们匹配了一系列的对应关系。 <code>在本节中，每个 LiDAR 都是独立处理的</code>。</p><h2 id="噪声去除分割">噪声去除分割</h2><p>通过了解LIDAR的垂直扫描角度，我们可以将原始点云投影到没有数据丢失的范围图像上,在图像中，每个有效点由像素表示。像素值记录了该点到原点的欧几里德距离。我们将[68]中提出的分割方法应用于将像素分组到多个集群中。</p><p>我们假设，如果两个相邻点的连接线大致垂直于（大于60度）激光束，则认为这两个相邻点属于相同的对象。我们采用广度第一搜索算法来遍历所有像素，确保恒定的时间复杂度，特别的，我们丢弃小集群，因为它们可能会在优化中提供不可靠的约束。</p><h2 id="特征提取和匹配">特征提取和匹配</h2><p>我们有兴趣提取一般边缘和平面特征，我们遵循[16]选择根据其曲率从测量中选择一组特征点。该组提取的特征<span class="math inline">\(\mathcal{F}\)</span>由两个子集组成：边缘子集（高曲率）<span class="math inline">\(\mathcal{E}\)</span>和平面子集（低曲率）<span class="math inline">\(\mathcal{H}\)</span>。我们进一步从<span class="math inline">\(\mathcal{E}\)</span>收集曲率最高边缘点，从平面<span class="math inline">\(\mathcal{H}\)</span>收集曲率最低的平面点，得到另外两组点<span class="math inline">\(\hat{\mathcal{E}},\hat{\mathcal{H}}\)</span>。</p><p>下一步是确定两个连续帧之间的特征对应关系，()<span class="math inline">\(^{l_{k-1}^{i}} \rightarrow()^{l_{k}^{i}}\)</span>，以构造几何约束：</p><ul><li>对于边缘点集合<span class="math inline">\(\hat{\mathcal{E}}^{l_{k}^{i}}\)</span>中的点，将从前一帧的边缘点集合<span class="math inline">\(\mathcal{E}^{l_{k-1}^{i}}\)</span>中查找两个最近邻的边缘点以形成边缘线关联。</li><li>对于平面点集合<span class="math inline">\(\hat{\mathcal{H}}^{l_{k}^{i}}\)</span>中的点，则从上一帧的边缘点集合<span class="math inline">\(\mathcal{H}^{l_{k-1}^{i}}\)</span>中查找3个最近邻点作为平面关联。</li></ul><p><img src="https://s1.nsloop.com:58443/images/2021/10/03/20211003174638.png"></p><h1 id="初始化">初始化</h1><p>优化多个LIDARS的状态是高度非线性的，需要给出初始估计值。本节介绍了我们的运动和外在初始化方法，不需要任何先前的传感器套件的机械配置。 它还不涉及任何手动努力，使其对自主机器人特别有用。</p><h2 id="scan-based-motion-estimation">Scan-Based Motion Estimation</h2><p>在每个LIDAR的两个连续帧之间找到了相应的对应关系，我们通过最小化所有功能的残差误差来估计帧到帧变换。如图3所示，残差由边缘和平面对应关系制定，设<span class="math inline">\(\mathbf{x}_k\)</span>为第k帧的相对变换，对于平面特征，对于平面点<span class="math inline">\(\mathbf{p} \in \hat{\mathcal{H}}^{l_{k}^{i}}\)</span>，如果<span class="math inline">\(\Pi\)</span>是关联的平面，那么该平面点对应的残差如下计算，式（6）：</p><p><span class="math display">\[\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi\right)=a \mathbf{w}, \quad a=\mathbf{w}^{\top}\left(\mathbf{R}_{k} \mathbf{p}+\mathbf{t}_{k}\right)+d\]</span></p><p>其中，</p><ul><li><span class="math inline">\(a\)</span>是点到平面的距离</li><li><span class="math inline">\([\mathbf{w}, d]\)</span>是平面的参数</li></ul><p>对于边缘线特征点<span class="math inline">\(\mathbf{p} \in \hat{\mathcal{E}}^{l_{k}^{i}}\)</span>，如果<span class="math inline">\(L\)</span>是与之关联的边缘线，那么我们使用如式（6）的两个平面特征的组合来表示点与边缘线的残差：</p><p><span class="math display">\[\mathbf{r}_{\mathcal{E}}\left(\mathbf{x}_{k}, \mathbf{p}, L\right)=\left[\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi_{1}\right), \mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi_{2}\right)\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\left[\mathbf{w}_{1}, d_{1}\right]\)</span>,<span class="math inline">\(\left[\mathbf{w}_{2}, d_{2}\right]\)</span>分别是平面<span class="math inline">\(\Pi_{1}\)</span>、<span class="math inline">\(\Pi_{2}\)</span>的系数</li><li><span class="math inline">\(\mathbf{w}_{1}\)</span>恰好与点<span class="math inline">\(\mathbf{p}\)</span>到直线<span class="math inline">\(L\)</span>的投影方向一致</li><li>并且平面<span class="math inline">\(\Pi_{2}\)</span>垂直于<span class="math inline">\(\Pi_{1}\)</span>，满足s.t. <span class="math inline">\(\mathbf{w}_{2} \perp \mathbf{w}_{1}\)</span>, and <span class="math inline">\(\mathbf{w}_{2} \perp L\)</span></li><li>上述定义与<code>LOAM</code>[16]有所不同，其中有两个好处，一是边缘残差为状态量提供了额外的约束，其次，残差可以使用向量表示，这允许我们乘以3x3的协方差矩阵</li></ul><p>我们最小化所有残差项的总和以获得MLE：</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \min } \sum_{\mathbf{p} \in \hat{\mathcal{F}}^{i \atop k}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\]</span></p><p><span class="math display">\[\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{k}, \mathbf{p}\right)=\left\{\begin{array}{ll}\mathbf{r}_{\mathcal{E}}\left(\mathbf{x}_{k}, \mathbf{p}, L\right) &amp; \text { if } \mathbf{p} \in \hat{\mathcal{E}}^{i_{k}^{i}} \\\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi\right) &amp; \text { if } \mathbf{p} \in \hat{\mathcal{H}}^{i_{k}^{i}}\end{array}\right.\]</span></p><p>特别的，关于<span class="math inline">\(\mathbf{r}_{\mathcal{F}}(\cdot)\)</span>的雅克比在Appendix A进行详细讨论。</p><p>在实践中，在带滚动快门扫描的LiDars运动后，点存在一些倾斜畸变，在求出增量运动<span class="math inline">\(\mathbf{x}_k\)</span>后，我们将这些点转换到前一帧扫描的最后时刻（即第k帧扫描的起始）以矫正畸变。</p><p>令<span class="math inline">\(t_{k-1},t_{k}\)</span>表示激光扫描的起始和结束，对于每一个扫描点<span class="math inline">\(\mathbf{p}\)</span>，都可以进行转换如下：</p><p><span class="math display">\[\mathbf{p}^{l_{k-1}^{i}}=\mathbf{R}_{k}^{\tau} \mathbf{p}+\mathbf{t}_{k}^{\tau}, \quad \tau=\frac{t-t_{k-1}}{t_{k}-t_{k-1}}\]</span></p><p>其中，旋转和平移部分使用se(3)进行插值？参考文献[5]</p><p><span class="math display">\[\mathbf{R}_{k}^{\tau}=\exp \left(\boldsymbol{\phi}_{k}^{\wedge}\right)^{\tau}=\exp \left(\tau \boldsymbol{\phi}_{k}^{\wedge}\right), \quad \mathbf{t}_{k}^{\tau}=\tau \mathbf{t}_{k}\]</span></p><h2 id="calibration-of-multi-lidar-system">Calibration of Multi-LiDAR System</h2><p>通过对准两个传感器的运动序列来获得初始外参，即这被称为手眼标定问题<span class="math inline">\(\mathbf{A X}=\mathbf{X B}\)</span>，其中<span class="math inline">\(\mathbf{A},\mathbf{B}\)</span>是两个传感器的位姿增量，<span class="math inline">\(\mathbf{B}\)</span>是他们的外参。</p><p>当机器人移动时，第i个激光雷达的第k帧时刻，有：</p><p>式（11）：</p><p><span class="math display">\[\mathbf{R}_{l_{k}^{i}}^{l_{k-1}^{i}} \mathbf{R}_{l^{i}}^{b}=\mathbf{R}_{l^{i}}^{b} \mathbf{R}_{b_{k}}^{b_{k-1}}\]</span></p><p>式（12）：</p><p><span class="math display">\[\left(\mathbf{R}_{l_{k}^{i}}^{l_{k-1}^{i}}-\mathbf{I}_{3}\right) \mathbf{t}_{l^{i}}^{b}=\mathbf{R}_{l^{i}}^{b} \mathbf{t}_{b_{k}}^{b_{k-1}}-\mathbf{t}_{l_{k}^{i}}^{l_{k-1}^{i}}\]</span></p><p>上面两式实际上是根据[14]，将情况下原始问题<span class="math inline">\(\mathbf{A X}=\mathbf{X B}\)</span>分解为旋转和平移部分。我们实现了此方法可在线初始化外参。</p><h3 id="旋转初始化">旋转初始化</h3><p>通过使用四元数，可以将式（11）重写成如下式（13）：</p><p><span class="math display">\[\begin{aligned}&amp; \mathbf{q}_{l_{k}^{i}}^{l_{k-1}} \otimes \mathbf{q}_{l^{i}}^{b}=\mathbf{q}_{l^{i}}^{b} \otimes \mathbf{q}_{b_{k}}^{b_{k-1}} \\\Rightarrow &amp;\left[\mathbf{Q}_{1}\left(\mathbf{q}_{l_{k-1}^{i}}^{l_{k}}\right)-\mathbf{Q}_{2}\left(\mathbf{q}_{b_{k}}^{b_{k-1}}\right)\right] \mathbf{q}_{l^{i}}^{b}=\mathbf{Q}_{k}^{k-1} \mathbf{q}_{l^{i}}^{b} = 0\end{aligned}\]</span></p><p>其中，<span class="math inline">\(\otimes\)</span>表示四元数乘法，<span class="math inline">\(\mathbf{Q}_{1}(\cdot)，\mathbf{Q}_{1}(\cdot)\)</span>表示四元数的左乘、右乘等价矩阵[59]。</p><p>通过多次时间间隔，可以将式（13）就行堆叠，形成超定线性方程组：</p><p>式（14）：</p><p><span class="math display">\[\left[\begin{array}{c}w_{1}^{0} \cdot \mathbf{Q}_{1}^{0} \\\vdots \\w_{K}^{K-1} \cdot \mathbf{Q}_{K}^{K-1}\end{array}\right]_{4 K \times 4} \mathbf{q}_{l^{i}}^{b}=\mathbf{Q}_{K} \mathbf{q}_{l^{i}}^{b}=\mathbf{0}_{4 K \times 4}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(K\)</span>表示约束的数量</li><li><span class="math inline">\(w_{k}^{k-1}\)</span>是鲁棒性权重，定义为残差四元素的角度轴表示中的角度？</li></ul><p><span class="math display">\[w_{k}^{k-1}=\rho^{\prime}(\phi), \quad \phi=2 \arctan \left(\left\|\mathbf{q}_{x y z}\right\|, q_{w}\right)\]</span></p><p><span class="math display">\[\mathbf{q}=\left(\check{\mathbf{q}}_{l^{i}}^{b}{ }\right)^{*}\otimes\left(\mathbf{q}_{l_{k}^{i}}^{l_{k-1}^{i}}\right)^{*} \otimes \check{\mathbf{q}}_{l^{i}}^{b} \otimes \mathbf{q}_{b_{k}}^{b_{k-1}}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\rho^{\prime}(\cdot)\)</span>是Huber loss的微分</li><li><span class="math inline">\(\check{\mathbf{q}}_{l^{i}}^{b}\)</span>是当前估计的旋转外参</li><li><span class="math inline">\(\mathbf{q}^{*}\)</span>是<span class="math inline">\(\mathbf{q}\)</span>的逆</li></ul><p>令<span class="math inline">\(\| \mathbf{q}_{l^{\prime}}^{b}\|=1\)</span>，我们可以使用<code>SVD</code>来获取式（14）的<code>close form</code>解。</p><p>对于3-DOF旋转的全部可观察性，需要足够的运动激励，在足够的约束下，<span class="math inline">\(Q_k\)</span>的零空间的秩应为1，也就是说，我们只有1个零奇异值（4个变量，3个维度，剩下一个为0）。</p><p>否则，由于在一个轴或多个轴上的运动退化会导致<span class="math inline">\(Q_k\)</span>的零空间&gt;1。因此，我们需要确保第二小的奇异值<span class="math inline">\(\sigma_{min2}\)</span>足够大以确保条件满足。我们设置了阈值<span class="math inline">\(\sigma_{\mathbf{R}}\)</span>，<code>and terminate the rotation calibration if σmin2&gt; σR.</code> ???</p><p>越来越多的数据会使得<span class="math inline">\(Q_k\)</span>行数迅速增长，为了维持计算时间，我们使用优先级队列[69]，长度k = 300逐渐存储历史约束，并删除小旋转的约束。</p><h3 id="平移初始化">平移初始化</h3><p>一旦旋转校准完成，我们通过式（12）将所有可用数据结合，构造一个线性系统：</p><p>式（16）：</p><p><span class="math display">\[\left[\begin{array}{c}\mathbf{R}_{l_{1}^{i}}^{l_{0}}-\mathbf{I}_{3} \\\vdots \\\mathbf{R}_{l_{K}^{i}}^{l_{K-1}^{i}}-\mathbf{I}_{3}\end{array}\right]_{3 K \times 3} \mathbf{\mathbf { t }}_{l^{i}}^{b}=\left[\begin{array}{c}\hat{\mathbf{R}}_{l^{i}}^{b} \mathbf{t}_{b_{1}}^{b_{0}}-\mathbf{t}_{l_{1}^{i}}^{l_{0}^{i}} \\\vdots \\\hat{\mathbf{R}}_{l^i}^{b} \mathbf{t}_{b_{K}}^{b_{K-1}}-\mathbf{t}_{l_{K}^{i}}^{l^{i}_{K-1}}\end{array}\right]_{3 K \times 1}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{t}_{l^{i}}^{b}\)</span>通过使用最小二乘法获取</li></ul><p>然而，如果机器人只在平面上运动，z轴方向上的平移是不可观的，在这种情况下，我们设置<span class="math inline">\(t_z=0\)</span>然后重写式（16）以移除<span class="math inline">\(\mathbf{t}_{l^{i}}^{b}\)</span>中的Z轴分量。</p><p>不像文献[4]，我们的方法不能通过地面来初始化<span class="math inline">\(t_z\)</span>，因此需要在后续的<code>refinement</code>阶段来恢复<span class="math inline">\(t_z\)</span>.(Section VII-B)</p><h1 id="具备传感器外参细化的紧耦合多激光雷达里程计">具备传感器外参细化的紧耦合多激光雷达里程计</h1><p>将最初的猜测作为输入，我们提出了一个紧密耦合的M-LO，以优化滑动窗口内的所有状态，该过程的灵感来自多传感器系统的<code>BA</code>，<code>Graph-Based</code>和<code>marginalization</code>的启发[5],[15],[70].</p><h2 id="问题构造">问题构造</h2><p>滑动窗口中的全部状态向量如下定义：</p>$$<span class="math display">\[\begin{aligned}\mathcal{X} &amp;=[\mathcal{X}_{f},\qquad \mathcal{X}_{v},  \qquad  \qquad \qquad \mathcal{X}_{e}] \\&amp;=[\mathbf{x}_{1}, \cdots, \mathbf{x}_{p}, \mathbf{x}_{p+1}, \cdots, \mathbf{x}_{N+1}, \mathbf{x}_{l^{2}}^{b}, \cdots, \mathbf{x}_{l^{l}}^{b}]\end{aligned}\]</span><p>$$</p><p><span class="math display">\[\begin{aligned}\mathbf{x}_{k} &amp;=\left[\mathbf{t}_{b_{k}}^{w}, \mathbf{q}_{b_{k}}^{w}\right], \quad k \in[1, N+1] \\\mathbf{x}_{l^{i}}^{b} &amp;=\left[\mathbf{t}_{l^{i}}^{b}, \mathbf{q}_{l^{i}}^{b}\right], \quad i \in[1, I],\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_k\)</span>是主激光雷达在世界坐标系下不同时间戳的状态</li><li><span class="math inline">\(\mathbf{x}_{l^{i}}^{b}\)</span>表示主激光雷达到第i辅助激光雷达的外参</li><li><span class="math inline">\(N+1\)</span>是滑动窗口中的状态数量</li></ul><p>为了建立这些状态之间的数据关联，我们建立了局部地图</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/04/20211004171829.png"></p><p>图4对<code>Graph-base</code>的构造进行了可视化，我们使用<span class="math inline">\(p\)</span>来索引滑动窗口中的枢轴状态，并设置<span class="math inline">\(\mathbf{x}_p\)</span>作为局部地图的原点（起始）。</p><p>利用从枢轴帧到其他帧的相对变换，通过连接前N帧（如<span class="math inline">\(\mathcal{F}^{l_{k}^{i}}, k \in[1, N]\)</span>）的特征点来构造局部地图。第i个激光雷达的局部特征地图由局部边缘地图和局部平面地图组成，记为<span class="math inline">\(\mathcal{M}^{l^{i}}\)</span>。</p><p>我们分割全状态向量<span class="math inline">\(\mathcal{X}\)</span>为3个部分：<span class="math inline">\(\mathcal{X}_{f},\mathcal{X}_{v},\mathcal{X}_e\)</span>：</p><ul><li><span class="math inline">\(\mathcal{X}_{f}=[\mathbf{x}_1,\dots,\mathbf{x}_p]\)</span>是由已经固定的准确状态组成</li><li><span class="math inline">\(\mathcal{X}_{v}=\left[\mathbf{x}_{p+1}, \cdots, \mathbf{x}_{N+1}\right]\)</span>被考虑作为在优化过程中迭代更新的变量</li><li><span class="math inline">\(\mathcal{X}_{e}=\left[\mathbf{x}_{l^{2}}^{b}, \cdots, \mathbf{x}_{l^I}^{b}\right]\)</span>是外参向量，它们的设置取决于在线校准的收敛性。</li><li></li><li>我们最小化滑动窗口内所有残差的总和以获得 MAP 估计为：</li></ul><p><span class="math display">\[\hat{\mathcal{X}}=\underset{\mathcal{X}}{\arg \min }\left\{\left\|\mathbf{r}_{p r i}(\mathcal{X})\right\|^{2}+f_{\mathcal{M}}(\mathcal{X})\right\}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{r}_{p r i}(\mathcal{X})\)</span>是VII-E节中定义的边缘化状态的先验项</li><li><span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>是基于地图的残差的总和，其式（18）的雅克比矩阵推导见Appendix A</li></ul><p>本文呈现的滑动窗口估计器与帧到帧估计不同，该估计器联合优化了窗口中的所有状态。这种方法，输出更准确的结果，因为局部地图提供了密集和可靠的对应关系。如果传感器精确标定，还使用来自其他雷达的约束。根据标定的收敛性，我们将问题分为两个子任务：</p><ul><li>在线标定online calibration (variable <span class="math inline">\(\mathcal{X}_e\)</span>)</li><li>纯里程计pure odometry (fixed <span class="math inline">\(\mathcal{X}_e\)</span>)</li></ul><p>在每个任务中，<span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>的定义是不同的，我们在第 VII-B 和 VII-C 节中介绍了详细信息</p><h2 id="考虑在线标定的优化">考虑在线标定的优化</h2><p>我们利用基于地图的测量来改进粗略初始化结果，在这里，我们将标定问题视为配准问题，<span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>分为两个函数，分别相对于<span class="math inline">\(\mathcal{X}_{v}\)</span>和<span class="math inline">\(\mathcal{X}_{e}\)</span>。</p><p><strong>对于<span class="math inline">\(\mathcal{X}_{v}\)</span>中的状态</strong>，这些约束由主传感器的最新帧的特征如<span class="math inline">\(\mathcal{F}^{b_{k}}, k \in[p+1, N+1]\)</span>，与主激光雷达的局部地图<span class="math inline">\(\mathcal{M}^{b}\)</span>之间的关联构成。</p><p><strong>对于<span class="math inline">\(\mathcal{X}_{e}\)</span>中的状态</strong>，这些约束由第i辅助激光雷达的第p帧的特征<span class="math inline">\(\mathcal{F}^{l_{p}^{i}}\)</span>与局部地图<span class="math inline">\(\mathcal{M}^{b}\)</span>的特征关联构成。</p><p><span class="math inline">\(\mathcal{F}^{b_{k}}\)</span>与局部特征地图<span class="math inline">\(\mathcal{M}^{b}\)</span>的关联使用[16]中的方法进行寻找，其中特征地图<span class="math inline">\(\mathcal{M}^{b}\)</span>使用了KD-TREE进行索引。</p><ol type="1"><li><p>对于边缘点，我们在局部边缘地图中的指定范围查找与之最近邻的点集合，记为<span class="math inline">\(\mathcal{S}\)</span>，然后计算点集的方差。点集的最大特征值对应的特征向量表示了与该边缘点所关联的直线的方向。通过计算点集的均值，即可确定边缘点对应的边缘线。</p></li><li><p>对于平面点，通过求解线性系统<span class="math inline">\(\mathbf{w s}+d=0, \forall \mathbf{s} \in \mathcal{S}\)</span>，可以得到在局部平面点云地图中与之关联的平面的系数，同样的，我们寻找<span class="math inline">\(\mathcal{F}^{l_{p}^{i}}\)</span>和<span class="math inline">\(\mathcal{M}^{b}\)</span>的关联。</p></li></ol><p>最后，我们将目标定义为在线标定的所有测量残差的总和，式（19）：</p><p><span class="math display">\[\begin{aligned}f_{\mathcal{M}}(\mathcal{X}) &amp;=f_{\mathcal{M}}\left(\mathcal{X}_{v}\right)+f_{\mathcal{M}}\left(\mathcal{X}_{e}\right) \\&amp;=\sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{b_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\Sigma_{\mathrm{p}}}^{2}\right)+\sum_{i=2}^{I} \sum_{\mathbf{p} \in \mathcal{F}^{l_{p}^{i}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}\)</span>表示从中枢坐标系到第k帧的变换</li><li><span class="math inline">\(\mathbf{x}_{p}\)</span>作为局部地图的起点状态</li></ul><h2 id="纯里程计的优化">纯里程计的优化</h2><p>一旦我们通过满足收敛标准完成在线校准（VII-D部分），然后就可以在给定准确外参的情况下进行纯里程计的优化。在这种情况下，我们没有优化外参，并利用基于地图的测量来改善单激光的里程计。</p><p>我们将所有 LiDAR 和局部地图的特征之间的约束合并到成本函数中：</p><p><span class="math display">\[\begin{aligned}f_{\mathcal{M}}(\mathcal{X}) &amp;=f_{\mathcal{M}}\left(\mathcal{X}_{v}\right) \\&amp;=\sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{b_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\Sigma_{\mathbf{p}}}^{2}\right) \\&amp;+\sum_{i=2}^{I} \sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{l^{i}_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k} \mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{p}^{-1} \mathbf{x}_{k} \mathbf{x}_{l^{i}}^{b}\)</span>表示第k帧下，从主激光雷达的局部地图坐标系（pivot frame）到辅助激光雷达坐标系的变换。</li></ul><h2 id="外参标定收敛性管理">外参标定收敛性管理</h2><p>在以无人监督的方式工作在线标定时，判断标定是否收敛是有意义的，收敛后，我们就可以固定外参。这对我们的系统有益，因为里程计和建图都是从辅助雷达获得更多几何约束，以便更准确地进行位姿估计。</p><p>如[34]中得出，作为信息矩阵的最小特征值的退化因子λ揭示了基于优化的状态估计问题的条件。通过这项工作的影响，我们使用λ表示是否包含足够的约束来获取准确的外参。</p><p>更新外参和收敛性监视器的详细流水线总结如算法1所示：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/04/20211004233254.png"></p><p>算法采用式（19）定义的函数<span class="math inline">\(f_{\mathcal{M}}(\cdot)\)</span>，以及使用当前的外参作为输入，并返回优化后的外参。</p><ul><li>在第4行，我们从<code>cost function</code>的信息矩阵中计算<span class="math inline">\(\lambda\)</span>，</li><li>在5-7行，如果<span class="math inline">\(\lambda\)</span>大于阈值，则对外参进行更新。</li><li>在第8行，我们使用的外参候选值来检查收敛性。</li><li>在第9-10行，收敛性判断条件满足，因此触发停止标定。然后计算<span class="math inline">\(\mathcal{L}\)</span>的采样均值，作为输出的外参结果，并且采样协方差作为标定的协方差。</li></ul><h2 id="边缘化">边缘化</h2><p>我们应用边缘化技术来删除滑动窗口中的最旧变量状态，边缘化是将历史约束作为目标融合的过程，这是维持里程计和标定结果一致性的重要步骤。</p><p>在我们的系统中，<span class="math inline">\(\mathbf{x}_{p}\)</span>是在每次优化后被边缘化的唯一的状态，通过应用<code>Schur Complement</code>，我们得到关于保留状态的信息矩阵<span class="math inline">\(\mathbf{A}_{rr}^{*}\)</span>和残差<span class="math inline">\(\mathbf{g}_{r}^{*}\)</span>。因此，由边缘化得到的先验残差项可写成：<span class="math inline">\(\left\|\mathbf{r}_{p r i}\right\|^{2}=\mathbf{g}_{r}^{* \top} \boldsymbol{\Lambda}_{r r}^{*-1} \mathbf{g}_{r}^{*}\)</span>，<code>Appendix B</code>会给出更加详细的数学推导。</p><h1 id="考虑不确定性的多激光雷达建图">考虑不确定性的多激光雷达建图</h1><p>我们首先回顾了典型 LiDAR SLAM 系统的建图模块的管道 [16]-[18]，以里程计先验作为输入，算法构建全局地图并使用足够的约束来对pose关键帧进行精细化调整。这通过最小化所有基于地图的残差项之和来实现，式（21）：</p><p><span class="math display">\[\hat{\mathbf{x}}_{b_{k}}^{w}=\underset{\mathbf{x}_{b_{k}}^{w}}{\arg \min } \sum_{i=1}^{I}\sum_{\mathbf{p} \in \mathcal{F}_{k}^{l^{i}_{k}}}\rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{b_{k}}^{w} \mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\]</span></p><p>其中,</p><ul><li><span class="math inline">\(\mathcal{F}^{l_{k}^{i}}\)</span>是第k帧点云的特征点</li><li><span class="math inline">\(\mathcal{G}_{\mathcal{F}}^{w_{k}}\)</span>是全局地图</li><li><span class="math inline">\(\mathbf{x}_{b_{k}}^{w} \mathbf{x}_{l^{i}}^{b}\)</span>表示第k帧时刻第i个激光雷达的状态</li></ul><p>我们使用Section VII-B中的方法查找<span class="math inline">\(\mathcal{F}^{l_{k}^{i}}\)</span>和<span class="math inline">\(\mathcal{G}_{\mathcal{F}}^{w_{k}}\)</span>之前的特征关联。在求解式（21）之后，求解的位姿将用于将特征点转换到世界坐标系，然后添加到全局地图上。为了降低计算和内存复杂性，地图也使用体素滤波器[71]进行降采样。但是，优化的精度取决于地图质量。图5展示了使用不确定的pose得到的带有噪声的地图点。我们认为，三个不确定性来源使地图点嘈杂：传感器噪声，退化姿态估计和外参扰动。</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/05/20211005104501.png"></p><p>在下一节中，我们将激光测量点和位姿求解的不确定性传播到地图点上。结果，每个地图点都被建模为高斯变量。 然后，我们提出了一种考虑不确定性的方法来提高多激光雷达建图算法的鲁棒性和准确性。</p><h2 id="不确定性传播">不确定性传播</h2><p>继续在第III-C节中描述，我们现在计算协方差<span class="math inline">\(\Xi\)</span>，mapping的位姿通过求解式（21）的NLS问题得到，我们直接计算信息矩阵的逆，即<span class="math inline">\(\mathbf{\Xi}_{\mathbf{x}_{b_{k}}^{w}}=\boldsymbol{\Lambda}^{-1}\)</span>作为协方差。</p><p>外参协方差的设置取决于特定的情况，我们通用的把外参协方差定义如下：</p><p><span class="math display">\[\boldsymbol{\Xi}_{\mathbf{x}_{l^{i}}^{b}}=\alpha \cdot \boldsymbol{\Xi}_{\text {calib }}, \quad \boldsymbol{\xi}_{l^{i}}^{b} \sim \mathcal{N}\left(\mathbf{0}, \boldsymbol{\Xi}_{\mathbf{x}_{l^{i}}^{b}}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\boldsymbol{\xi}_{l^{i}}^{b}\)</span>是外参的扰动变量</li><li><span class="math inline">\(\boldsymbol{\Xi}_{\text {calib }}\)</span>是通过算法1计算得到的标定协方差</li><li><span class="math inline">\(\alpha\)</span>是缩放系数，用于控制协方差的量级</li></ul><p>如果多激光雷达系统最近被标定过，我们设置<span class="math inline">\(\alpha=1\)</span>，如果系统使用了很长时间且没有进行重新标定，激光雷达之间的外参会存在小的偏差，<span class="math inline">\(\alpha\)</span>将被设置为更大的值。它具有与时间和外部影响的隐含关系，以及温度漂移。</p><p>给定主激光雷达的pose均值以及外参的均值和协方差，然后计算其他雷达pose的均值和协方差，如<span class="math inline">\(\left\{\mathbf{T}_{l_{k}^{i}}^{w}, \boldsymbol{\Xi}_{l_{k}^{i}}^{w}\right\}\)</span>，这是一个关于两个含有噪声的复合pose的问题，我们遵循[19]中的4阶近似来计算他们。</p><p>然后，我们需要通过一个包含噪声的位姿变换来传播高斯不确定性，以产生新的地图点（landmark），如<span class="math inline">\(\mathbf{y} \in \mathcal{G}_{\mathcal{F}}^{w_{k+1}}\)</span>，其均值和方差为<span class="math inline">\(\{\overline{\mathbf{y}}, \boldsymbol{\Sigma}\}\)</span>，利用将点进行坐标变换的公式，可得：</p><p><span class="math display">\[\begin{aligned}\mathbf{y} \triangleq \mathbf{T}_{l_{k}^{i}}^{w} \mathbf{p}_{h} &amp;=\exp \left(\boldsymbol{\xi}_{e l_{k}^{i}}^{w^{\wedge}}\right) \overline{\mathbf{T}}_{l_{k}^{i}}^{w}\left(\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}\right) \\&amp; \approx\left(\mathbf{I}+\boldsymbol{\xi}_{l_{k}^{i}}^{w^{\wedge}}\right) \mathbf{\mathbf { T }}_{l_{k}^{i}}^{w}\left(\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}\right)\end{aligned}\]</span></p><p>其中，我们只保留指数映射<span class="math inline">\(\exp(\cdot)\)</span>的一阶近似。</p><p>进一步的，如果我们展开等式，并仅保留一阶项，我们有：</p><p><span class="math display">\[\mathbf{y} \approx \mathbf{h}+\mathbf{H} \boldsymbol{\theta}\]</span></p><p>其中，</p><p><span class="math display">\[\mathbf{h}=\overline{\mathbf{T}}_{l_{k}^{i}}^{w} \overline{\mathbf{p}}_{h}, \quad \mathbf{H}=\left[\left(\overline{\mathbf{T}}_{l_{k}^{i}}^{w} \overline{\mathbf{p}}_{h}\right)^{\odot} \quad \overline{\mathbf{T}}_{l_{k}^{i}}^{w} \mathbf{D}\right]\]</span></p><p><span class="math display">\[\boldsymbol{\theta}=\left[\boldsymbol{\xi}_{l_{k}^{i}}^{w \top}, \boldsymbol{\zeta}^{\top}\right]^{\top}, \quad \boldsymbol{\theta} \sim \mathcal{N}(\mathbf{0}, \boldsymbol{\Theta}), \quad \boldsymbol{\Theta}=\operatorname{diag}\left(\boldsymbol{\Xi}_{l_{k}^{i}}^{w}, \mathbf{Z}\right)\]</span></p><p>特别的，操作符<span class="math inline">\(\odot\)</span>表示将4x1的向量转换为4x6的矩阵：</p><p><span class="math display">\[\left[\begin{array}{l}\varepsilon \\\eta\end{array}\right]^{\odot}=\left[\begin{array}{cc}\eta \mathbf{I} &amp; -\boldsymbol{\varepsilon}^{\wedge} \\\mathbf{0}^{\top} &amp; \mathbf{0}^{\top}\end{array}\right], \quad \boldsymbol{\varepsilon} \in \mathbb{R}^{3}, \quad \eta=1\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;robust-odometry-and-mapping-for-multi-lidar-systems-with-online-extrinsic-calibration&quot;&gt;Robust Odometry and Mapping for Multi-LiDAR S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/12/18/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_6/"/>
    <id>http://yoursite.com/2022/12/18/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_6/</id>
    <published>2022-12-18T08:25:38.748Z</published>
    <updated>2022-06-26T21:28:37.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
      <category term="传感器标定" scheme="http://yoursite.com/categories/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>基于层次BA的高一致性大规模激光建图</title>
    <link href="http://yoursite.com/2022/11/12/HBA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/11/12/HBA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-11-12T12:16:30.000Z</published>
    <updated>2023-06-27T14:35:24.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="large-scale-lidar-consistent-mapping-using-hierarchical-lidar-bundle-adjustment">Large-Scale LiDAR Consistent Mapping using Hierarchical LiDAR Bundle Adjustment</h1><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343283-0.png"></p><h1 id="摘要">摘要</h1><p>重建精确一致的大规模激光雷达点云图对机器人应用至关重要。现有的位姿图优化方法虽然效率高，但不能直接优化建图一致性。激光雷达束调整(BA)最近被提出来解决这个问题;然而，这在大尺度地图上太耗时了。为了解决这一问题，本文提出了一种适用于大尺度地图的全局一致且高效的制图方法。</p><p>我们提出的工作包括自底向上的层次BA和自顶向下的姿态图优化，结合了两种方法的优点。通过分层设计，我们用比原始BA小得多的Hessian矩阵大小解决了多个BA问题;通过姿态图优化，实现了激光雷达姿态的平稳高效更新。</p><p>我们提出的方法的有效性和鲁棒性已在多个空间和及时的大规模公共旋转LiDAR数据集上得到验证，如KITTI、MulRan和Newer College，以及结构化和非结构化场景下自收集的固态LiDAR数据集。通过适当的设置，我们证明了我们的工作可以在大约12%的序列时间内生成全局一致的建图。</p><h1 id="介绍">介绍</h1><p>激光雷达束调整(LiDAR bundle adjustment, BA)方法[5,6]通过最小化总体点面距离直接优化了建图一致性，这通常会带来高的建图质量，这是建图应用所必需的。在<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>中，首先解析求解平面参数，这样最终的优化问题只与LiDAR姿态有关。在<a href="LiDAR%20SLAM%20With%20Plane%20Adjustment%20for%20Indoor%20Environment">6</a>中，与visual BA[7,8]一样，通过Schur补技巧在每次优化迭代中消除平面参数。无论哪种方式，得到的优化结果(至少)是LiDAR位姿数N的维数，需要O(n3)时间来求解<a href="Efficient%20and%20Consistent%20Bundle%20Adjustment%20on%20Lidar%20Point%20Clouds(BALM2)">9</a>。由于计算时间的三次增长，对于具有较大位姿数的大比例尺地图，无法进行束调整。</p><blockquote></blockquote><p>针对上述问题，我们提出了一种分层LiDAR BA方法，在保持时间效率的前提下全局优化建图一致性。该方法构建框架位姿的金字塔结构(如图1)，并进行自底向上的层次BA调整和自顶向下的位姿图优化(如图2)。自底向上过程在从底层(局部BA)到顶层帧(全局BA)的局部窗口内进行层次BA调整。这样的设计大大提高了计算时间，每层局部BA的处理适合并行处理，而且由于涉及的位姿较少，每个局部BA的时间复杂度相对较低。自底向上过程中的一个问题是它忽略了在不同的局部窗口中共同可见的特征，这可能会降低精度。为了缓解这个问题，自顶向下的过程构造一个从上到下的位姿图，并通过位姿图优化分配错误。这两个过程迭代直到收敛。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343687-0.png"></p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343704-0.png"></p><p>通过分层BA调整设计，既可以直接优化点云内平面的一致性，又可以避免求解大维的代价函数。通过位姿图优化，我们以快速可靠的方式对整个激光雷达位姿进行适当的收敛更新。为了保持每两个相邻关键帧之间的平滑性，我们通过设置步幅大小小于窗口大小来保持它们之间的重叠区域。为了进一步提高优化速度，我们在构建金字塔时使用了滤波器去除异常点，并实现了基于cpu的并行处理。综上所述，我们的贡献如下:</p><ul><li>提出了一种分层束调整方法，以全局优化激光雷达建图一致性和里程测量精度。在给定良好的初始位姿轨迹(例如，从位姿图优化)的情况下，我们提出的方法提高了建图质量，甚至在初始位姿轨迹有较大漂移时缩小间隙</li><li>我们提出的工作的有效性已经在多个公共机械旋转激光雷达数据集和我们自己收集的固态激光雷达数据集上进行了结构化和非结构化场景的验证</li></ul><h1 id="相关工作">相关工作</h1><p>文献中讨论了多种提高建图质量的方法，主要分为两类:基于位姿图优化的方法和基于平面(束)调整的方法。在位姿图优化中，两帧之间的相对变换(位姿约束)由ICP[10]或其变体估计[11,12]。这个相对位姿误差然后由信息矩阵加权，通常是对应的Hessian<a href="Real-time%20loop%20closure%20in%202D%20LIDAR%20SLAM">13</a>的逆矩阵或简单的常数矩阵[14]。当总和相对位姿误差最小时，对位姿图进行优化。尽管姿态图优化的计算效率很高，但它的一个重要问题是<strong>不能直接优化点云的一致性</strong>。由于相对位姿约束的不正确估计或不精确建模，位姿图可能收敛到局部最小值，点云内仍可能存在较大的发散<a href="MULLS,">3,15</a>。</p><p>平面调整方法通过最小化点到平面的总和距离，直接优化点云的一致性。在平面调整中，每个平面特征用两个参数表示，即平面到原点的距离和平面法向量<a href="LiDAR%20SLAM%20With%20Plane%20Adjustment%20for%20Indoor%20Environment">6</a>，在[16]中，作者同时优化了激光雷达姿态和几何平面特征。该方法在优化过程中需要对所有特征的参数进行维护和更新，而随着地图规模的扩大，特征的总数会迅速增长，导致代价函数的维数很大。虽然使用舒尔补法可以将优化变量简化为激光雷达位姿，但在实际操作中，该方法在优化过程中容易产生位姿估计故障。</p><p>BA调整方法改进了平面调整技术，通过在优化前消除特征估计参数，使用一个封闭形式的解<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>，在<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>中，作者将点云分割为多个体素，每个体素包含一个平面特征。将原来的点到面最小化问题转化为每个体素中点协方差特征值的最小化问题。这种方法需要遍历每个特征内的每个点来推导Hessian矩阵，而Hessian矩阵的时间复杂度是点数的平方，计算量很大。该问题在后续工作<a href="**Efficient%20and%20Consistent%20Bundle%20Adjustment%20on%20Lidar%20Point%20Clouds**">9</a>中得到解决，该工作将同一姿态观察到的特征的所有点进行了聚合，从根本上消除了时间复杂度对点数的依赖。</p><p>尽管如此，在上述所有的平面和束调整方法中，计算复杂度仍然是位姿数量的三次方，对于大比例尺地图来说并不实用。此外，当地图中的散度大于或接近最大体素大小时，这些方法可能具有较慢的收敛速度。</p><p>我们提出的分层束调整方法同时利用了BA和姿态图优化。我们使用BA直接最小化点到面距离和位姿图优化来平滑有效地更新激光雷达的位姿，以避免位姿估计中的故障。通过分层设计，我们可以用比原来的<a href="BALM">5</a>小得多的Hessian矩阵大小并行解决多个BA问题。此外，我们可以根据初始姿态轨迹的质量灵活地设置从底层到顶层的BA参数。</p><h1 id="方法">方法</h1><h2 id="概览">概览</h2><p>所提方法的系统工作流程如图2所示。输入是来自每次激光雷达扫描的原始点或去畸变点云，以及它们在全局坐标系中相应姿态的初始估计，这可以从一般激光雷达里程计或同步运动和建图(SLAM)算法中获得。该方法由两个过程组成，自底向上(见第III-B节)和自顶向下(见第III-C节)，迭代直到收敛。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343704-0.png"></p><p>在自底向上的过程中，对较小的局部窗口内的LiDAR帧进行局部BA，构建从第一层到第二层的关键帧(如图1)。这个过程是分层执行的，直到满足最优层数，并在顶层关键帧上执行全局BA。然后利用各优化层和相邻层之间的因子构建位姿图(如图1所示)。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343687-0.png"></p><p>如图1所示，<code>first layer</code>(在上文中的bottom layer)描述了初始LiDAR帧和姿态的集合。类似地，<code>second layer</code>表示使用局部BA从<code>first layer</code>创建的LiDAR关键帧和姿态的集合。<code>top layer</code>是指最后剩下的LiDAR关键帧的集合(在图1中，顶层指第三层)。</p><p>核心思想：</p><ul><li>从底层到顶层分层创建LiDAR关键帧的过程称为自底向上过程。</li><li>通过姿态图优化来更新底层激光雷达姿态的过程称为自顶向下过程。</li></ul><h2 id="自底向上的ba-bottom-up-hierarchical-ba">自底向上的BA （Bottom-Up Hierarchical BA）</h2><ul><li>记<span class="math inline">\(\mathbb{F}_j^i\)</span>为第i层的第j帧雷达，以及<span class="math inline">\(\mathbf{x}_j^i \triangleq \mathbf{T}_j^i=(\mathbf{R}, \mathbf{t}) \in \operatorname{SE}(3)\)</span>为对应的位姿。</li><li>记<span class="math inline">\(\mathbf{T}_{j, k}^i\)</span>为<span class="math inline">\(\mathbf{T}_j^i\)</span>和<span class="math inline">\(\mathbf{T}_k^i\)</span>的相对位姿，即<span class="math inline">\(\mathbf{T}_{j, k}^i=\left(\mathbf{T}_j^i\right)^{-1} \cdot \mathbf{T}_k^i\)</span></li><li>需要注意的是，<span class="math inline">\(\mathbb{F}_j^i\)</span>是在雷达坐标系的点云，而位姿T是全局坐标系下的</li><li>此外，记<span class="math inline">\(w\)</span>为局部窗口大小，<span class="math inline">\(S\)</span>为自底向上构造LiDAR关键帧时的步幅大小，如图1所示。</li></ul><p>假设我们有<span class="math inline">\(N_i\)</span>帧点云（在第i层），在自底向上的过程中，利用所提供的初始姿态轨迹在每个局部窗口中进行局部BA，并优化<strong>每帧与该窗口第一帧之间的相对姿态</strong>。特别的，各局部窗口BA导出的Hessian矩阵H会被记录，并将其作为后续自顶向下的姿态图构造的信息矩阵。</p><p>给定一个在第i层，含有w帧点云的局部窗口<span class="math inline">\(\left\{\mathbb{F}_{s j+k}^i \mid j=0, \cdots,\left\lfloor\frac{N_i-w}{s}\right\rfloor ; k=0, \cdots, w-1\right\}\)</span>及其优化之后的所有相对位姿<span class="math inline">\(\mathbf{T}_{j, k}^{i *}\)</span>，我们将这些帧聚合成第(i+1)层的<strong>一个关键帧</strong>。即每一帧中的所有点都转换到局部窗口的第一帧，新的关键帧的位姿<span class="math inline">\(\mathbf{T}_j^{i+1}\)</span>，其初值被设置为前一次局部窗口优化后的第一帧的pose。即有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/08/1670507170-0.png"></p><p>这一过程可以从下层到上层重复进行，直到达到最优层数<span class="math inline">\(l\)</span>。值得注意的是，新的关键帧(局部BA)的构造不依赖于局部窗口外的帧，这使得可以同一层中的多个局部窗口并行处理。假设我们总共有N帧雷达点云，如<span class="math inline">\(N_1=N\)</span>，在每个时间，我们选择<span class="math inline">\(w\)</span>帧以<span class="math inline">\(s\)</span>为步长从低层到高层，设n为可用于并行处理的线程数。由于BA的计算时间为<span class="math inline">\(O\left(M^3\right)\)</span>， <span class="math inline">\(M\)</span>为涉及的姿态数，我们可以推导出第<span class="math inline">\(l\)</span>层金字塔的总时间消耗<span class="math inline">\(O\left(T_l\right)\)</span></p><p>第l层金字塔的总时间消耗包括每层局部BA消耗的时间和顶层全局BA消耗的时间。对于第l层金字塔，第i层的局部窗口数(i &lt; l)为<span class="math inline">\(\frac{N}{s^i}\)</span>，每个局部窗口消耗<span class="math inline">\(O\left(w^3\right)\)</span>个时间。当有n个并行线程时，本地BA的总时间消耗为各层本地BA的总和，即<span class="math inline">\(w^3 \cdot\left(\sum_{i=1}^{l-1} \frac{N}{s^i} \cdot \frac{1}{n}\right)\)</span>，以及第l层的全局BA花费时间为：<span class="math inline">\(O\left(\left(\frac{N}{s^{l-1}}\right)^3\right)\)</span>。因此，第l层的时间复杂度总结如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/11/1670766549-0.png"></p><p>我们把<span class="math inline">\(T_l\)</span>看作l的函数，通过让<span class="math inline">\(T_l\)</span>的导数等于零来计算最优<span class="math inline">\(l^*\)</span>，这就得到：</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/11/1670766625-0.png"></p><p>图3给出了不同帧数N时，计算时间<span class="math inline">\(T_l\)</span>随层数l的变化示例，可以看出，随着层数从l=1(原始BA)增加到<span class="math inline">\(l^*\)</span>，计算时间大大减少，这表明了所提出的分层BA的有效性。当<span class="math inline">\(l &gt; l^*\)</span>时，计算时间不会增加太多，几乎保持不变，这表明任何大于<span class="math inline">\(l^*\)</span>的层数都同样有效。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/11/1670766690-0_1.png"></p><p>对于自底向上的分层BA中各层的特征提取和关联，我们使用<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>（BALM）中提出的自适应体素化方法，提取适合不同结构环境的不同大小的平面特征。为了提取这些<strong>不同尺寸的平面特征</strong>，整个点云在使用初始姿态轨迹转换为相同的全局坐标系后，被分割成大小为V的多个体素，每一个都通过平面测试，检查所含点的最小(V1)和最大特征值(V3)之比小于阈值，如<span class="math inline">\(\frac{\lambda_1}{\lambda_3}&lt;\theta\)</span>，如果平面测试通过，体素中的点将被视为位于同一平面上并在BA中使用，否则，体素将被递归分割，直到包含的点形成一个平面。</p><p>上述自适应体素化过程在点数非常大的情况下非常耗时。为了缓解这个问题，我们注意到<strong>在低层中不被认为是平面特征的点在上层中也不会形成平面</strong>。因此，在自底向上的过程中，我们<strong>只使用局部BA中每个体素的平面特征点来构造上层的关键帧</strong>。该方法进一步节省了下一层自适应体素图构建的时间，提高了局部BA的计算精度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;large-scale-lidar-consistent-mapping-using-hierarchical-lidar-bundle-adjustment&quot;&gt;Large-Scale LiDAR Consistent Mapping using Hierarch
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ICP协方差分析 On the Covariance of ICP-based Scan-matching Techniques</title>
    <link href="http://yoursite.com/2022/11/12/ICP%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2022/11/12/ICP%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/</id>
    <published>2022-11-12T12:16:30.000Z</published>
    <updated>2023-06-27T14:17:57.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="on-the-covariance-of-icp-based-scan-matching-techniques">On the Covariance of ICP-based Scan-matching Techniques</h1><p><img src="https://s1.nsloop.com:58443/images/2022/11/12/1668261534-0.png"></p><h1 id="摘要">摘要</h1><p>本文研究迭代最近点(ICP)算法计算旋转平移的协方差估计问题。这个问题与移动机器人和装备了深度传感相机(如Kinect)或激光雷达(如Velodyne)的车辆的定位问题有关。以往文献中提出的封闭形式的协方差公式通常建立在ICP的解是通过最小化线性最小二乘问题得到的这一事实之上。在本文中，我们表明这种方法需要谨慎，因为算法的重新匹配步骤没有显式解释，并将其应用于点到点版本的ICP导致完全错误的协方差。然后，我们给出了一个形式化的数学证明，证明了该方法在点到平面的ICP版本中是有效的，从而验证了从业者的直觉和实验结果。</p><h1 id="介绍">介绍</h1><p>相对旋转-平移估计的协方差不仅取决于传感器噪声特性，还取决于环境的几何形状。实际上，当使用ICP进行扫描匹配时，有几个误差来源会起作用：</p><ul><li>在一次扫描中没有在后续扫描中观察到几何图形的存在，也就是说，缺乏重叠</li><li>点的不匹配，也就是说，如果扫描开始时彼此距离很远，则ICP可能会降到局部(而不是全局)最小值，从而产生错误的旋转平移估计</li><li>即使1)和2)没有发生，由于传感器噪声和可能的欠约束环境(如长而无特征的走廊)，计算出的估计仍然具有不确定性</li></ul><p>在实践中，第一个问题可以通过拒绝具有过多距离度量或位于扫描边界[11]附近的点对来解决，第二个问题可以通过使用航迹估计预对齐扫描或使用足够快的采样率来解决。因此，我们将把重点放在<strong>第三个</strong>误差来源上。</p><p>通过扫描匹配算法(如ICP)得到的估计的协方差可以从文献[12]，[13]得到。</p><p>要估计的变换<span class="math inline">\(\hat{x}\)</span>由代价函数J(x, z)的局部argmin得到，其中<span class="math inline">\(z\)</span>为当前扫描到的点云。</p><p>结果，我们期望得到<span class="math inline">\(\frac{\partial}{\partial x} J(\hat{x}, z)=0\)</span>，根据隐函数定理，此时x是数据z在这个函数最小值附近。</p><p>因此，如果此时观测数据z(点云)有一个小的扰动<span class="math inline">\(\delta z\)</span>，意味着<span class="math inline">\(\delta x\)</span>也有小的变化<span class="math inline">\(\frac{\partial^2 J}{\partial x^2} \delta x+\frac{\partial^2 J}{\partial z \partial x} \delta z=0\)</span>，即有：</p><p><span class="math display">\[\delta x=-\left(\frac{\partial^2 J}{\partial x^2}\right)^{-1} \frac{\partial^2 J}{\partial z \partial x} \delta z\]</span></p><p>因此，如果<span class="math inline">\(\delta z\)</span>表示由于传感器噪声造成的测量(随机)差异，则估计中相应的可变性<span class="math inline">\(\delta x=\hat{x}-x\)</span>，其中方差为：</p><p><span class="math display">\[\mathbb{E}\left(\delta x \delta x^T\right)=\operatorname{cov}(\hat{x})\]</span></p><p><img src="https://s1.nsloop.com:58443/images/2022/11/12/1668263744-0.png"></p><p>我们的目标是指出这个公式在ICP协方差计算方面的<strong>潜在有效性不足</strong>，但也要描述它可以安全使用的情况。具体来说，几何配准(1)的问题在于它依赖于<span class="math inline">\(\delta x=-\left(\frac{\partial^2 J}{\partial x^2}\right)^{-1} \frac{\partial^2 J}{\partial z \partial x} \delta z\)</span>，这是基于局部隐函数定理的，它只适用于无穷小的变化<span class="math inline">\(\delta x, \delta z\)</span>。在ICP的情况下，无穷小意味着亚像素位移，的确，在匹配扫描时，ICP执行的重新匹配步骤使代价函数远不是平滑的，因此对代价函数进行泰勒展开有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/11/12/1668263773-0.png"></p><p>这在极限∆x→0中是正确的，但当位移∆x大于几个像素时，结果可能完全错误。这方面的一个例子将在Section II-A.2. 中给出。另一方面，如果将配准误差投影到参考曲面上，如点到面ICP[2]，则式(1)将给出有效结果。这将在第三节中得到正式证明。</p><p>我们的论文是[13]和[14]结果的推广和严格证明。我们的主要贡献是指出盲目应用(1)的潜在缺点。然后基于第三节中的几何论证，为(1)点到面ICP的有效性提供形式化的数学证明。最后，我们将在第四节中用一个简单的3D示例说明结果。</p><h1 id="数学框架">数学框架</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;on-the-covariance-of-icp-based-scan-matching-techniques&quot;&gt;On the Covariance of ICP-based Scan-matching Techniques&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ROLI激光雷达IMU初始化及标定</title>
    <link href="http://yoursite.com/2022/03/06/Fast-LIO%E7%B3%BB%E5%88%97/ROLI%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEIMU%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%A0%87%E5%AE%9A/"/>
    <id>http://yoursite.com/2022/03/06/Fast-LIO%E7%B3%BB%E5%88%97/ROLI%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEIMU%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%A0%87%E5%AE%9A/</id>
    <published>2022-03-06T04:02:22.000Z</published>
    <updated>2023-11-09T08:20:39.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="robust-and-online-lidar-inertial-initialization">Robust and Online LiDAR-inertial Initialization</h1><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306201811.png"></p><h1 id="介绍">介绍</h1><p>摘要：对于大多数LiDAR惯性里程计来说，精确的初始状态，包括时间偏差和LiDAR与6轴IMU之间的外参，起着重要的作用，通常被认为是前提条件。然而，在定制的激光雷达惯性系统中，这样的信息并不总是可用的，本文提出了一种完全在线的激光雷达惯性系统初始化过程，该过程通过校准激光雷达和IMU之间的时间偏差和外参，并通过将激光雷达测量的状态估计值与IMU测量的状态值对齐来校正重力矢量和IMU偏差。我们将所提出的方法实现为一个初始化模块，如果启用该模块，它将自动检测采集数据的激发程度，同时校准时间偏移量、外参偏移量、重力矢量和惯性测量单元偏差，然后将其用作在线激光雷达惯性里程仪系统的高质量初始状态值。对不同类型的激光雷达和激光雷达-惯性组合进行的实验表明了该初始化方法的鲁棒性、适应性和有效性。</p><p>我们的LiDAR-惯性初始化法的主要目的之一是在<strong>没有任何初始估计</strong>的情况下校准LiDAR和IMU之间的外特性。现有的一些外部标定方法是基于批量优化的，数据关联性很强，耗时较大。例如，Lveal。[14]提出了一种基于连续时间批优化的标定方法。B样条的使用使得需要估计的参数较多，计算量也较大。[15]使用扩展卡尔曼过滤估计运动补偿复杂的外域变换，收敛速度有限。与这些方法相比，我们的方法更轻量级，能够快速运行，同时仍然可以获得足够精确的外部校准，以便后续的在线估计(例如，通过[1])。我们的方法还校准了[14，15]中没有考虑的时间偏移。此外，文献[14，15]所采用的基于NDT的扫描-扫描匹配通常不适用于具有非重复扫描模式的激光雷达。相比之下，我们的方法采用了扫描到地图的匹配策略，可以很容易地应用重复扫描和非重复扫描的LiDAR。</p><h1 id="方法">方法</h1><h2 id="系统框架">系统框架</h2><p>由于IMU只有在运动时才被激发[15]，所以我们的初始化过程是基于运动的方法，这意味着充分的激励是必要的。我们工作流程的概述如图2所示，一些重要符号如表一所示。我们建议的LiDAR里程计(参见第III-B节)由FAST-LIO2[1]改进而来，采用恒定(角和线)速度(CV)模型来预测LiDAR运动并进行畸变矫正。</p><p>为了缓解恒速模型与传感器实际运动之间的失配，通过将输入帧分割成几个子帧来提高LiDAR里程计速率。</p><p>如果LiDAR里程计没有失效(例如，退化)，并且估计的LiDAR角速度和线速度满足我们建议的评估标准(参见第III-C5节)，则认为激励是足够的，并且LiDAR里程计输出和相应的IMU数据都被馈送到初始化模块(参见第III-C节)</p><p>在初始化中，首先通过移动IMU测量值来校准时间偏移，以与LiDAR里程计对准，然后进行优化处理，进一步细化时间偏移，校准外参，估计IMU偏差和重力矢量。通过融合后续的LiDAR和IMU数据，可以将初始化的状态附加到紧耦合的LiDAR惯性里程计(例如，[1])，用于在线状态估计。</p><h2 id="激光里程计">激光里程计</h2><p>我们的LiDAR里程计是建立在恒速(CV)运动模型上的，该模型假设在tk和tk+1接收到的两个连续扫描之间的角速度和线速度是恒定的，即，在tk和tk+1接收到的两个连续扫描之间，有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306215022.png"></p><p>其中<span class="math inline">\(\Delta t\)</span>是两帧扫描的时间间隔，状态向量<span class="math inline">\(\mathbf{x}\)</span>、噪声<span class="math inline">\(\mathbf{w}\)</span>和离散的状态转移函数<span class="math inline">\(\mathbf{f}\)</span>定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306215311.png"></p><p>其中：</p><ul><li><span class="math inline">\({ }^{G} \mathbf{R}_{L} \in S O(3)\)</span>和<span class="math inline">\({ }^{G} \mathbf{p}_{L}\)</span>分别表示激光雷达在全局坐标系（此处为第0帧激光坐标系）的姿态的位置</li><li><span class="math inline">\({ }^{G} \mathbf{v}_{L}\)</span>是激光雷达在全局坐标系的速度表示</li><li><span class="math inline">\(\omega_{L}\)</span>是激光雷达线速度（在激光雷达坐标系）</li><li>上述两个速度被分别被建模为由高斯噪声<span class="math inline">\(\mathbf{n}_{\mathbf{v}}\)</span>和<span class="math inline">\(\mathbf{n}_{\omega}\)</span>驱动的随机游走过程。</li></ul><p>在对于公式（1），使用文献[22]的记号<span class="math inline">\(\boxplus / \boxminus\)</span>紧凑地表示状态流形上的“+”。具体地说，对于公式(2)中的状态流形<span class="math inline">\(S O(3) \times \mathbb{R}^{n}\)</span>，运算及其逆定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306220010.png"></p><p>其中：</p><ul><li><span class="math inline">\(\mathbf{R}, \mathbf{R}_{1}, \mathbf{R}_{2} \in S O(3)\)</span>，</li><li><span class="math inline">\(\mathbf{r}, \mathbf{a}, \mathbf{b} \in \mathbb{R}^{n}\)</span></li><li><span class="math inline">\(\operatorname{Exp}(\cdot): \mathbb{R}^{3} \mapsto S O(3)\)</span> 表示指数映射</li><li><span class="math inline">\(\log (\cdot): S O(3) \mapsto \mathbb{R}^{3}\)</span>是指数映射的逆，即对数映射</li></ul><p>在实践中，传感器的运动可能不具有恒定速度。<strong>为了减轻这种模型误差的影响，我们可以将输入的LiDAR扫描分割成多个持续时间较短的子帧</strong>，在这些子帧上传感器的运动更符合CV模型。</p><h3 id="误差迭代卡尔曼">误差迭代卡尔曼</h3><p>基于流形上的系统表示(1)，我们使用误差状态迭代卡尔曼过滤(ESIKF)[23]来估计其状态，ESIKF的预测步骤由状态预测和协方差传播组成，如下所示：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306220634.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{P}\)</span>表示状态估计的协方差</li><li><span class="math inline">\(\mathbf{Q}\)</span>表示过程噪声<span class="math inline">\(\mathbf{w}\)</span>对应的协方差</li></ul><p><span class="math inline">\(\mathbf{F}_{\tilde{\mathbf{x}}}\)</span> 和 <span class="math inline">\(\mathbf{F}_{\mathbf{w}}\)</span>定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306220815.png"></p><blockquote><p>由误差状态微分方程可导出（上述Fx Fw是离散时间下的）</p></blockquote><h3 id="运动补偿">运动补偿</h3><p>在我们考虑的问题中，<strong>IMU和LiDAR是不同步的</strong>，因此文献[14，15]所采用的IMU辅助运动补偿方法是不可行的。</p><p>在时间戳<span class="math inline">\(t_{k+1}\)</span>处接收到新的激光雷达扫描之后，为了补偿运动失真，我们将在时间戳<span class="math inline">\(\rho_{j} \in\left(t_{k}, t_{k+1}\right)\)</span>处采样的每个包含点<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{j}\)</span>投影到扫描端激光雷达帧<span class="math inline">\(L_{k+1}\)</span>中，也就是将激光矫正<strong>到扫描结束时刻</strong>。</p><p>在恒速模型下，我们有<span class="math inline">\({}^G \widehat{\mathbf{v}}_{L_{k+1}}={}^G{\overline{\mathbf{v}}}_{L_{k}}, \widehat{\boldsymbol{\omega}}_{L_{k+1}}=\overline{\boldsymbol{\omega}}_{L_{k}}\)</span>，因此，可以导出<span class="math inline">\({}^{L_{k+1}} \check{\mathbf{T}}_{L_{j}}=\left({ }^{L_{k+1}} \check{\mathbf{R}}_{L_{j}},{ }^{L_{k+1}} \check{\mathbf{p}}_{L_{j}}\right)\)</span>的计算如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306221754.png"></p><p>然后，在时间段<span class="math inline">\(\rho_{j} \in\left(t_{k}, t_{k+1}\right)\)</span>内的测量<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{j}\)</span>可以被投影到扫描结束时刻，即：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306222001.png"></p><p>矫正之后的激光扫描<span class="math inline">\(\left\{ {}^{L_{k+1}} \mathbf{p}_{j}\right\}\)</span>用于提供未知状态<span class="math inline">\({}^G \mathbf{T}_{L_{k+1}}\)</span>的隐式测量，表示为点到面距离残差，在此基础上，在迭代卡尔曼滤波器框架中迭代估计完整状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>，直到收敛。这种迭代估计的细节可以参考FAST-LIO2[1]或[23]，以便更一般地处理流形约束。</p><p>收敛后的状态估计记为<span class="math inline">\(\overline{\mathbf{x}}_{k+1}\)</span>，将用于传播后续IMU测量，如第III-B1节所述。</p><p>图3中示出了使用有运动补偿和无运动补偿的扫描的映射结果比较。</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306222357.png"></p><h3 id="激光-惯性初始化">激光-惯性初始化</h3><p>第III-B节中的激光雷达里程计在每个扫描结束时间<span class="math inline">\(t_{k}\)</span>输出激光雷达的角速度<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>和线速度<span class="math inline">\({ }^{G} \mathbf{V}_{L_{k}}\)</span>。同时，惯性测量单元提供了原始测量，包括时间戳<span class="math inline">\(\tau_{i}\)</span>的body系角速度<span class="math inline">\(\omega_{m}\)</span>和线加速度<span class="math inline">\(\mathbf{a}_{m_{i}}\)</span>。这些数据按照第III-C5节所示的激励标准进行累积和重复评估。</p><p>一旦收集到足够激励的数据，就调用初始化模块，然后输出如下信息：</p><ul><li>时间偏移<span class="math inline">\({ }^{I} t_{L} \in \mathbb{R}\)</span></li><li>外参<span class="math inline">\({ }^{I} \mathbf{T}_{L}=\left({ }^{I} \mathbf{R}_{L},{ }^{I} \mathbf{p}_{L}\right) \in SE(3)\)</span></li><li>IMU Bias<span class="math inline">\(\mathbf{b}_{\omega}, \mathbf{b}_{\mathbf{a}} \in \mathbb{R}^{3}\)</span></li><li>以及全局坐标系下的重力向量<span class="math inline">\({ }^{G} \mathbf{g} \in \mathbb{R}^{3}\)</span></li></ul><ol type="1"><li>数据处理</li></ol><p>IMU原始测量数据收到噪声<span class="math inline">\(\mathbf{n}_{\omega_{i}}\)</span> 和 <span class="math inline">\(\mathbf{n}_{\mathbf{a}}\)</span>的影响，因此IMU测量模型如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306223946.png"></p><p>其中，</p><ul><li><span class="math inline">\(\omega_{i}^{\mathrm{gt}}, \mathbf{a}_{i}^{\mathrm{gt}}\)</span>是测量真值</li><li>同时，从激光里程计估计出来的<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},{ }^{G} \mathbf{v}_{L_{k}}\)</span>也包含了噪声</li></ul><p>为了消除这些通常是高频的噪声，使用了非因果零阶低通滤波器[24]来过滤噪声，而不会引入任何过滤延迟。<strong>零相位过滤是通过巴特沃斯低通滤波器的前向和后向运行来实现</strong>的[24]，得到噪声衰减（去除噪声影响的测量）的IMU测量<span class="math inline">\(\boldsymbol{\omega}_{I_{i}}=\boldsymbol{\omega}_{i}^{\mathrm{gt}}+\mathbf{b}_{\omega}, \mathbf{a}_{I_{i}}=\mathbf{a}_{i}^{\mathrm{gt}}+\mathbf{b}_{\mathbf{a}}\)</span>为表示简单起见，噪声衰减的激光里程计速度估计值仍然表示为<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},{ }^{G} \mathbf{v}_{L_{k}}\)</span>。</p><p>从激光雷达里程计得到的<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},^{G} \mathbf{v}_{L_{k}}\)</span>，通过非因果中心差分[25]得到激光雷达角加速度和线加速度<span class="math inline">\(\boldsymbol{\Omega}_{L_{k}},{ }^{G} \mathbf{a}_{L_{k}}\)</span>，因此，根据激光里程计得到的数据记为：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306233851.png"></p><p>类似地，我们从噪声衰减的陀螺测量<span class="math inline">\(\omega_{I}\)</span>得到角加速度<span class="math inline">\(\boldsymbol{\Omega}_{I_{i}}\)</span>，因此有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306234056.png"></p><p>由于IMU频率通常高于LiDAR odometer的频率，因此两个序列<span class="math inline">\(\mathcal{I}_{i}\)</span>和<span class="math inline">\(\mathcal{L}_{k}\)</span>的长度并不相同。为了解决这一问题，我们提取在同一时间段内接收的LiDAR和IMU数据，并通过在每个LiDAR里程计时间<span class="math inline">\(t_{k}\)</span>对<span class="math inline">\(\mathcal{I}_{i}\)</span>进行线性插值来实现下采样(参见图4)。</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306234448.png"></p><p>降采样的IMU数据记为<span class="math inline">\(\mathcal{I}_{k}\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306234533.png"></p><p>其中，<span class="math inline">\(\mathcal{I}_{k}\)</span>具有与<span class="math inline">\(\mathcal{L}_{k}\)</span>相同的时间戳<span class="math inline">\(t_{k}\)</span>(但是数据实际上被已知的时间常数<span class="math inline">\({ }^{I} t_{L}\)</span>延迟)。</p><ol start="2" type="1"><li>用互相关法进行时间初始化(Temporal Initialization by Cross-Correlation)</li></ol><p>在大多数情况下，由于LiDAR惯性里程计模块受到接收数据之前不可避免的传输和处理延迟，在LiDAR <span class="math inline">\(\mathcal{L}_{k}\)</span>和IMU <span class="math inline">\(\mathcal{I}_{k}\)</span>之间将存在未知但恒定的偏移<span class="math inline">\({ }^{I} t_{L}\)</span>（例如IMU数据，全部向前推进<span class="math inline">\({ }^{I} t_{L}\)</span>，则与激光雷达数据对齐）。</p><p>由于激光雷达数据公式(9)和IMU数据公式(11)处于离散时间<span class="math inline">\(t_{k}\)</span>，因此IMU数据的推进实质上是以离散时间步<span class="math inline">\(d={ }^{I} t_{L} / \Delta t\)</span>进行的，其中<span class="math inline">\(\Delta t\)</span>是两次激光雷达扫描之间的时间间隔。具体地说，对于角速度，我们有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306235340.png"></p><p>忽略通常很小的陀螺偏置bω，我们发现<span class="math inline">\(\boldsymbol{\omega}_{I_{k+d}}\)</span>和<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>的大小(模长)应该是相同的，而与外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>无关。受[16]的启发，我们使用互相关来量化它们之间的相似度。然后，偏移量<span class="math inline">\(d\)</span>可以从下面的优化问题中求解：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306235549.png"> 通过枚举<span class="math inline">\(\mathcal{L}_{k}\)</span>的索引范围内的偏移量<span class="math inline">\(d\)</span>。</p><blockquote><p>这里是通过对IMU数据逐个前挪来实现对齐，所以<span class="math inline">\(d\)</span>的理解是：IMU前移1个数据，即前移了<span class="math inline">\(\Delta t\)</span>时间，所以<span class="math inline">\({ }^{I} t_{L}= d * \Delta t\)</span></p></blockquote><ol type="1"><li>统一的旋转外参和时间校准</li></ol><p>(2)中的互相关法对噪声和小尺度陀螺偏差具有较强的鲁棒性。但其的一个明显缺陷是，时间偏移的校准分辨率只能达到激光雷达里程计的一个采样间隔<span class="math inline">\(\Delta t\)</span>，不能识别任何小于<span class="math inline">\(\Delta t\)</span>的剩余偏移δt。</p><p>设<span class="math inline">\({ }^{I} t_{L}\)</span>为激光雷达里程计ωL与IMU数据ωi之间的总偏移量，则<span class="math inline">\({ }^{I_{t}} t_{L}=d^{*} \Delta t+\delta t\)</span>。与公式(12)类似，如果IMU测量<span class="math inline">\(\boldsymbol{\omega}_{I}\)</span>提前时间<span class="math inline">\({ }^{I} t_{L}\)</span>，则通过下式将与激光雷达里程计<span class="math inline">\(\omega_{L}\)</span>对齐：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308094706.png"></p><p>由于公式(9)中的实际激光雷达里程计<span class="math inline">\(\boldsymbol{\omega}_{L}\)</span>仅在时间戳<span class="math inline">\(t_{k}\)</span>处可用，用<span class="math inline">\(t=t_{k}\)</span>和<span class="math inline">\({ }^{I} t_{L}=d^{*} \Delta t+\delta t\)</span>代入到公式(14)，并注意到<span class="math inline">\(\boldsymbol{\omega}_{L}\left(t_{k}\right)=\boldsymbol{\omega}_{L_{k}}\)</span>，我们有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308094924.png"></p><p>注意到，<span class="math inline">\(\boldsymbol{\omega}_{I}\left(t_{k}+d^{*} \Delta t+\delta t\right)\)</span>是在时间戳为<span class="math inline">\(t_{k}+d^{*} \Delta t\)</span>之后紧跟的IMU角速度，而时间戳为<span class="math inline">\(t_{k}+d^{*} \Delta t\)</span>对应的角速度和角加速度分别为<span class="math inline">\(\omega_{I}\left(t_{k}+d^{*} \Delta t\right)=\omega_{I_{k^{\prime}}}\)</span>和<span class="math inline">\(\boldsymbol{\Omega}_{I}\left(t_{k}+d^{*} \Delta t\right)=\boldsymbol{\Omega}_{I_{k^{\prime}}}\)</span>，假设角加速度在小量<span class="math inline">\(\delta t\)</span>上恒定，我们可以插值得到<span class="math inline">\(\boldsymbol{\omega}_{I}\left(t_{k}+d^{*} \Delta t+\delta t\right)\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308095413.png"></p><p>将上式（16）代入公式（16），可以获得：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308095500.png"></p><p>最后，基于公式(17)中的约束，统一的时空优化问题可以表述为：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308095721.png"></p><p>上述问题可通过<code>Ceres</code>迭代求解(由于非线性约束<span class="math inline">\({ }^{I} \mathbf{R}_{L} \in S O(3)\)</span>)，并且给定初始值为<span class="math inline">\(\left({ }^{I} \mathbf{R}_{L}, \mathbf{b}_{\omega}, \delta t\right)=\left(\mathbf{I}_{3 \times 3}, \mathbf{0}_{3 \times 1}, 0\right)\)</span></p><ol start="4" type="1"><li>平移外参与重力向量初始化</li></ol><p>在第III-C3节中，我们得到了外旋转<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>、陀螺偏置<span class="math inline">\(\mathbf{b}_{\omega}\)</span>和时间偏移量<span class="math inline">\({ }^{I} t_{L}\)</span>。在这一部分中，我们将固定这些值，然后进行平移外参、重力矢量和加速度偏差的校准。</p><p>首先，我们使用之前得到的偏移<span class="math inline">\(d^{*}\)</span>和<span class="math inline">\(\delta t\)</span>来对齐IMU数据<span class="math inline">\(\mathcal{I}_{k}\)</span>和雷达数据<span class="math inline">\(\mathcal{L}_{k}\)</span>。对齐的IMU数据表示为̄<span class="math inline">\(\overline{\mathcal{I}}_{k}\)</span>，现在认为它与<span class="math inline">\(\mathcal{L}_{k}\)</span>完全对齐，没有时间偏移。</p><p>具体地，在时间<span class="math inline">\(t_{k}\)</span>对应于LiDAR角速度̄<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>的IMU角速度<span class="math inline">\(\bar{\omega}_{I_{k}}\)</span>为（其实就是公式（15））：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309230908.png"></p><p>相似的，与时刻<span class="math inline">\(t_{k}\)</span>的LiDAR加速度<span class="math inline">\({ }^{G} \mathbf{a}_{L_{k}}\)</span>对应的IMU加速度̄<span class="math inline">\(\overline{\mathbf{a}}_{I_{k}}\)</span>为：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309231105.png"></p><p>与公式（14）类似，我们可以找到IMU和LiDAR之间的加速度约束。如文献[26]所述，具有固定外参的两个坐标系A、B的加速度具有以下关系：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309231254.png"></p><p>其中，</p><ul><li><span class="math inline">\({ }^{A} \mathbf{R}_{B},{ }^{A} \mathbf{p}_{B}\)</span>表示从B系到A系的外参变换</li><li><span class="math inline">\(\mathbf{a}_{A}, \mathbf{a}_{B}\)</span>分别是加速度在两个坐标系的表示</li></ul><blockquote><p>上面公式（21）怎么来的，为啥不是 <span class="math inline">\({ }^{A} \mathbf{R}_{B} \mathbf{a}_{B}=\mathbf{a}_{A}\)</span></p></blockquote><p>对于LiDAR-惯性系统，我们有两种选择：A用于IMU，B用于LiDAR，或者相反的情况。值得注意的是，在第一种情况下，<span class="math inline">\(\boldsymbol{\omega}_{A}=\overline{\boldsymbol{\omega}}_{I_{k}}-\mathbf{b}_{\omega}\)</span>的精度受到陀螺仪偏差估计的影响，并且<span class="math inline">\(\boldsymbol{\Omega}_{A}\)</span>的误差会因角速度测量中的噪声而被放大。</p><p>为了避免这一问题，增加外源平移校准的鲁棒性，我们将LiDAR设置为A，将IMU设置为B，由于LiDAR的加速度<span class="math inline">\({ }^{G} \mathbf{a}_{L_{k}}\)</span>是在全局坐标系中（即第0帧激光坐标系）描述的，所以我们需要将这个加速度转换到激光雷达坐标系下，记为<span class="math inline">\(\mathbf{a}_{L_{k}}\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309232853.png"></p><p>其中，<span class="math inline">\({ }^{G} \mathbf{R}_{L}\)</span>是LiDAR在激光里程计全局坐标系的姿态，由第III-B节中的LiDAR里程计获得。</p><p>最后，平移外参、加速度计偏置和重力矢量可以从以下优化问题中联合估计：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309233109.png"></p><p>上述问题可以由<code>ceres</code>求解器迭代求解(由于约束<span class="math inline">\({ }^{G} \mathbf{g} \in \mathrm{S}_{2}\)</span>)，并且指定初始值<span class="math inline">\(\left({ }^{I} \mathbf{p}_{L}, \mathbf{b}_{\mathbf{a}},{ }^{G} \mathbf{g}\right)= \left(\mathbf{0}_{3 \times 1}, \mathbf{0}_{3 \times 1}, 9.81 \mathbf{e}_{3}\right)\)</span>。</p><p>在估计<span class="math inline">\({ }^{L} \mathbf{p}_{I}\)</span>之后，从激光雷达到IMU的转换计算如下：<span class="math inline">\({ }^{I} \mathbf{p}_{L}=-{ }^{I} \mathbf{R}_{L}^{L} \mathbf{p}_{I}\)</span></p><ol start="5" type="1"><li>数据累积评估</li></ol><p>提出的初始化方法依赖于LiDAR惯性器件的充分激励(充分运动)。因此，系统应该能够自行评估激励是否足以执行初始化。</p><p>理想情况下，可以通过公式（18）关于<span class="math inline">\(\left({ }^{I} \mathbf{R}_{L}, \mathbf{b}_{\omega}, \delta t\right)\)</span>和公式（23）关于<span class="math inline">\(\left({ }^{I} \mathbf{p}_{L}, \mathbf{b}_{\mathbf{a}},{ }^{G} \mathbf{g}\right)\)</span>的的全雅可比矩阵的秩来评估激励。</p><p>在实际中，我们发现，使用关于外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>和<span class="math inline">\({ }^{I} \mathbf{p}_{L}\)</span>的雅可比来评估运动就足够了，因为对外参的激发通常需要复杂的运动，这也会激发其他状态。因此，记<span class="math inline">\(\mathbf{J}_{r}\)</span>为公式（18）对旋转外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>的雅可比，<span class="math inline">\(\mathbf{J}_{t}\)</span>为公式（23）对平移外参<span class="math inline">\({ }^{I} \mathbf{p}_{L}\)</span>的雅可比，如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/10/20220310094624.png"></p><p>那么，激励可以通过对以下矩阵的秩来进行评估：</p><ul><li><span class="math inline">\(\mathbf{J}_{r}^{T} \mathbf{J}_{r}=\sum\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor{ }_{\wedge}^{T}\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor \wedge\)</span></li><li><span class="math inline">\(\mathbf{J}_{t}^{T} \mathbf{J}_{t}=\sum\left(\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor_{\wedge}^{2}+ \left\lfloor\boldsymbol{\Omega}_{\left.L_{k}\right\rfloor}\right\rfloor_{\wedge}\right)^{T}\left(\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor_{\Lambda}^{2}+\left\lfloor\boldsymbol{\Omega}_{L_{k}}\right\rfloor \wedge\right)\)</span></li></ul><p>更定量地，用<span class="math inline">\(\mathbf{J}_{r}^{T} \mathbf{J}_{r}\)</span>和<span class="math inline">\(\mathbf{J}_{t}^{T} \mathbf{J}_{t}\)</span>的奇异值来表示激发的程度。<strong>根据这一原理，我们开发了一个评估程序，可以指导用户如何移动他们的设备以获得足够的激励</strong>。我们根据雅可比矩阵的奇异值来量化激励，并用来评估激励是否充分。</p><h1 id="参考">参考</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;robust-and-online-lidar-inertial-initialization&quot;&gt;Robust and Online LiDAR-inertial Initialization&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.nsloop
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>IEKF迭代扩展卡尔曼滤波器</title>
    <link href="http://yoursite.com/2022/02/28/Fast-LIO%E7%B3%BB%E5%88%97/IEKF%E8%BF%AD%E4%BB%A3%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>http://yoursite.com/2022/02/28/Fast-LIO%E7%B3%BB%E5%88%97/IEKF%E8%BF%AD%E4%BB%A3%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/</id>
    <published>2022-02-28T14:02:22.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="performance-evaluation-of-iterated-extended-kalman-filterwith-variable-step-length">Performance evaluation of iterated extended Kalman filterwith variable step-length</h1><h1 id="介绍">介绍</h1><p>优化方法主要基于最小化均方误差准则，对于线性高斯系统，导致了著名的卡尔曼滤波。与提供状态的条件PDF的贝叶斯方法不同，最优化方法提供状态的点估计和估计误差的相应协方差矩阵(CM)。与贝叶斯方法一样，基于最优化方法的状态估计问题只能在少数特殊情况下得到解析解。对于其他情况，估计方法通常遵循卡尔曼滤波框架，并利用非线性函数的线性化等逼近技术，例如，扩展(EKF)和二阶扩展卡尔曼滤波器[6]、[1]分别通过围绕当前估计到一阶或二阶的泰勒级数展开来逼近非线性函数，当线性化误差的影响往往会扰乱过滤的性能或其收敛性时，在更新状态附近重新线性化测量方程可能会减轻困难。</p><p>这种方法被称为迭代扩展卡尔曼过滤(IEKF)[6]。</p><p>IEKF计算状态估计不是作为近似条件平均值(就像EKF那样)，而是作为最大后验(MAP)估计[7]。文献[8]证明了IEKF量测更新是高斯-牛顿(GN)方法的应用，而EKF是仅用一次GN方法迭代的IEKF的特例。</p><p>第二节简要介绍了EKF和IEKF的非线性状态估计及其求解方法。第三节简要介绍了IEKF的最新发展。第四节介绍了分析中使用的各种性能度量。接下来，在第五节中，通过两个数值例子对两种滤波器进行了比较，并在第六节中对本文进行了总结。</p><h1 id="nonlinear-state-estimation-by-ekf-and-iekf">Nonlinear state estimation by EKF and IEKF</h1><h2 id="系统描述">系统描述</h2><p>离散时间非线性随机系统的状态空间形式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228191455.png"></p><p>其中，</p><ul><li><p>向量<span class="math inline">\(\mathbf{x}_{k} \in \mathbb{R}^{n_{x}}\)</span>和<span class="math inline">\(\mathbf{z}_{k} \in \mathbb{R}^{n_{z}}\)</span>分别表示在时间k下，系统的状态和观测。</p></li><li><p><span class="math inline">\(\mathbf{f}_{k}: \mathbb{R}^{n_{x}} \rightarrow \mathbb{R}^{n_{x}}\)</span> and <span class="math inline">\(\mathbf{h}_{k}: \mathbb{R}^{n_{x}} \rightarrow \mathbb{R}^{n_{z}}\)</span>是已知的向量函数。</p></li><li><p><span class="math inline">\(\mathbf{w}_{k} \in \mathbb{R}^{n_{x}}\)</span>和<span class="math inline">\(\mathbf{v}_{k} \in \mathbb{R}^{n_{z}}\)</span>是相互独立的状态白噪声和测量白噪声。</p></li></ul><p>噪声的概率密度函数是零均值且已知协方差矩阵<span class="math inline">\(\Sigma_{k}^{\mathbf{w}}\)</span> and <span class="math inline">\(\Sigma_{k}^{\mathbf{v}}\)</span>的高斯分布，即有<span class="math inline">\(p\left(\mathbf{w}_{k}\right)=\mathcal{N}\left\{\mathbf{w}_{k} ; \mathbf{0}_{n_{x} \times 1}, \Sigma_{k}^{\mathbf{w}}\right\} *\)</span>和<span class="math inline">\(p\left(\mathbf{v}_{k}\right)=\mathcal{N}\left\{\mathbf{v}_{k} ; \mathbf{0}_{n_{z} \times 1}, \Sigma_{k}^{\mathbf{v}}\right\}\)</span>。初始态的概率密度函数是高斯的，也是已知的，即<span class="math inline">\(p\left(\mathbf{x}_{0}\right)=\mathcal{N}\left\{\mathbf{x}_{0} ; \hat{\mathbf{x}}_{0}, \mathbf{P}_{0}\right\}\)</span>。初始状态与噪声无关</p><h2 id="扩展卡尔曼">扩展卡尔曼</h2><p>最初，卡尔曼过滤是在1960年利用正交性原理[13]推导出来的。给出了具有线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>的系统(1)和(2)的最小均方误差估计。</p><p>对于非线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>，必须使用近似，例如在EKF中使用的近似。EKF基于一阶泰勒级数展开(TE1)。在假设状态预测平均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k-1}=\mathrm{E}\left[\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right]\)</span>(定义线性化点)已知的条件下，函数<span class="math inline">\(\mathbf{h}_{k}\)</span>的泰勒一阶展开由下式给出：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228192900.png"></p><p>其中，矩阵<span class="math inline">\(\mathbf{H}_{k}=\left.\frac{\partial \mathbf{h}\left(\mathbf{x}_{k}\right)}{\partial \mathbf{x}_{k}}\right|_{\mathbf{x}_{k}=\hat{\mathbf{x}}_{k \mid k-1}}\)</span>是测量函数<span class="math inline">\(\mathbf{h}_{k}(\cdot)\)</span>关于<span class="math inline">\(\mathbf{X}_{k}\)</span>在线性化点<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>的雅可比。</p><p>预测更新步骤的TE1近似的使用是类似的。在已知滤波均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}=\mathrm{E}\left[\mathbf{x}_{k} \mid \mathbf{z}^{k}\right]\)</span>的假设下，(1)中的<span class="math inline">\(\mathbf{f}_{k}\)</span>的TE1具有如下形式：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193333.png"></p><p>其中，<span class="math inline">\(\mathbf{F}_{k}=\left.\frac{\partial \mathbf{f}\left(\mathbf{x}_{k}\right)}{\partial \mathbf{x}_{k}}\right|_{\mathbf{x}_{k}=\hat{\mathbf{x}}_{k \mid k}}\)</span>是系统矩阵<span class="math inline">\(\mathbf{f}_{k}(\cdot)\)</span>关于关于<span class="math inline">\(\mathbf{X}_{k}\)</span>在线性化点<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k}\)</span>的雅可比。</p><p>扩展卡尔曼算法如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193529.png"></p><blockquote><p>对于具有轻度非线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>的系统，扩展卡尔曼滤波性能良好，但是如果测量方程(2)是强非线性的(例如在纯方位跟踪问题中)，滤波器的性能就会恶化。在这种情况下，IEKF往往比EKF提供更准确的估计。</p></blockquote><h2 id="迭代扩展卡尔曼">迭代扩展卡尔曼</h2><p>IEKF[6]的想法是在存在显著非线性的情况下改进参考轨迹，从而改进估计。这些改进是通过EKF测量更新的局部迭代实现的(参见算法2)。迭代通常在连续迭代中没有显著变化或满足其他标准(如最大迭代次数)时停止。算法如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193907.png"></p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228200156.png"></p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193927.png"></p><p>翻译一下，就是以下步骤:</p><ol type="1"><li><p>初始化：设置迭代次数<span class="math inline">\(i=0\)</span>，此时有<span class="math inline">\(\hat{\mathbf{x}}_{k}^{0}=\hat{\mathbf{x}}_{k \mid k-1}\)</span>，表示在第k次观测的第0次迭代的状态<span class="math inline">\(\mathbf{x}_{k}^{0}\)</span>等于利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span></p></li><li><p>测量更新：计算测量函数在迭代状态<span class="math inline">\(\mathbf{x}_{k}^{i}\)</span>处的雅可比<span class="math inline">\(\mathbf{H}_{k}^{i}\)</span>，更新第i次迭代的卡尔曼增益<span class="math inline">\(\mathbf{K}_{k}^{i}\)</span>，更新第i次迭代后的状态<span class="math inline">\(\hat{\mathbf{x}}_{k}^{i+1}\)</span>,如下：</p></li></ol><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228200516.png"></p><p>其中，</p><ul><li><p><span class="math inline">\(\mathbf{H}_{k}^{i}\)</span>是测量函数在迭代状态<span class="math inline">\(\mathbf{x}_{k}^{i}\)</span>处</p></li><li><p><span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>是利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的协方差，即第0次迭代前的协方差</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k \mid k-1}\)</span>是利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态，即第0次迭代前的状态</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k}^{i}\)</span>是第k观测下，迭代i次后的状态</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k}^{i+1}\)</span>是第k观测下，迭代i+1次后的状态</p></li></ul><ol start="3" type="1"><li>迭代完成后，需要更新（保存）状态和协方差：</li></ol><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228201345.png"></p><p>即协方差是在迭代结束后再更新的，迭代过中一直使用的是<span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>，即上一次更新完后又预测到k时刻的协方差。</p><p>值得一提的是，即使在IEKF算法中发生的重新线性化也不能保证滤波器的收敛性，IEKF也不总是比扩展卡尔曼滤波性能好。不过，IEKF测量更新有两个非常有趣的属性：</p><ul><li><p>它可以看作是高斯-牛顿法的一种应用</p></li><li><p>它生成最大后验（MAP）估计：<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}^{\mathrm{MAP}}=\underset{\mathbf{x}_{k}}{\arg \max } p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span></p></li></ul><h2 id="对迭代扩展卡尔曼过滤算法的改进">对迭代扩展卡尔曼过滤算法的改进</h2><p>如上所述，IEKF可以看作是求解非线性最小二乘问题的GN方法的一种应用。因此，在IEKF中可以使用对GN方法的改进来提高方法的性能和收敛性，以提高估计的质量。改变步长是常用的改进措施之一。首先，介绍了IEKF最小化的MAP准则。</p><h3 id="map-criterion">MAP criterion</h3><p>如果使用系统(1)和(2)的概率描述，则使用先验的概率密度函数<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>来求后验PDF<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span>。</p><p>先验的概率分布<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的均值<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>和协方差<span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>在算法1的时间更新步骤中计算。其假设为高斯，并且在算法2的测量更新中计算后验PDF<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}\)</span>和方差<span class="math inline">\(\mathbf{P}_{k \mid k}\)</span>。</p><p>后验概率<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span>与似然<span class="math inline">\(p\left(\mathbf{z}_{k} \mid \mathbf{x}_{k}\right)=p_{\mathbf{v}_{k}}\left(\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right)\)</span>与先验<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的乘积成正比，即有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202344.png"></p><p>其中，为方便起见，不依赖于<span class="math inline">\(\mathbf{X}_{k}\)</span>的项已被删除。然后由下式给出MAP估计：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202535.png"></p><p>现在，有了MAP模型，可以使用GN方法来找到<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}\)</span>，以达到最小化函数。理想情况下，每次GN方法迭代(即IEKF测量更新迭代)都应该减小准则<span class="math inline">\(\mathbf{V}_{k}\)</span>。</p><p>IEKF测量更新(16)可以用隐式方式被重写：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202910.png"></p><p>本次迭代更新偏移量<span class="math inline">\(\Delta_{k}^{i}\)</span>如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202946.png"></p><p>其中，<span class="math inline">\(\hat{\mathbf{x}}_{k}^{0}=\hat{\mathbf{x}}_{k \mid k-1}\)</span>，即在第k次观测的第0次迭代的状态<span class="math inline">\(\mathbf{x}_{k}^{0}\)</span>等于利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>（先验）</p><p><strong>对于高斯牛顿方法</strong>，也可以求出更新偏移量<span class="math inline">\(\Delta_{k}^{i}\)</span>的另一种表达形式：</p><p>高斯牛顿法就是将<span class="math inline">\(f(\mathbf{x})\)</span>进行一届泰勒展开（注意这里的<span class="math inline">\(f(\mathbf{x})\)</span>不是目标函数，而是原函数，即<span class="math inline">\(f(\mathbf{x}) = z-h(\mathbf{x})\)</span></p><p>因此，有：</p><p><span class="math display">\[    f(\mathbf{x}+\Delta{\mathbf{x}}) \approx f(\mathbf{x}) + \mathbf{J}(\mathbf{x})\Delta{\mathbf{x}}\]</span></p><p>其中，<span class="math inline">\(\mathbf{J}(\mathbf{x})\)</span>为<span class="math inline">\(f(\mathbf{x})\)</span>关于<span class="math inline">\(\mathbf{x}\)</span>的雅克比。</p><p>经过系列变换，最终可以得到正规方程：</p><p><span class="math display">\[    \mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x}) \Delta{\mathbf{x}} = -\mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \]</span></p><p>因此有：</p><p><span class="math display">\[    \Delta{\mathbf{x}} = - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \]</span></p><p>对于式（17）（18）所展示的MAP问题，可以进一步建模为：</p><p><span class="math display">\[\begin{aligned}\hat{\mathbf{x}}_{k \mid k} &amp;=\underset{\mathbf{x}_{k}}{\arg \min } \frac{1}{2}\left(\left[\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right]^{T}\left(\Sigma_{k}^{v}\right)^{-1}\left[\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right]+\left[\hat{\mathbf{x}}_{k \mid k-1}-\mathbf{x}_{k}\right]^{T} \mathbf{P}_{k \mid k-1}^{-1}\left[\hat{\mathbf{x}}_{k \mid k-1}-\mathbf{x}_{k}\right]\right) \\&amp;=\underset{\mathbf{x}_{k}}{\arg \min } \frac{1}{2} r(\mathbf{X})^{T}r(\mathbf{X})\end{aligned}\]</span></p><p>其中，</p><p><span class="math display">\[r(\mathbf{X})=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_k-h(\mathbf{x}_k)) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k \right)\end{array}\right]\]</span></p><p>雅克比<span class="math inline">\(J(\mathbf{X})\)</span>如下：</p><p><span class="math display">\[\mathbf{J}_{k}=-\left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]\]</span></p><p><span class="math display">\[\mathbf{H}_{k}=\left.\frac{\partial h(s)}{\partial s}\right|_{s=\mathbf{x}_{k}}\]</span></p><p>将信息回代到高斯牛顿正规方程，可以得到增量<span class="math inline">\(\Delta{\mathbf{x}}\)</span>如下：</p><p><span class="math display">\[ \begin{aligned}    \Delta{\mathbf{x}} &amp;= - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \\    &amp;=     \left(        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]^{T}        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]    \right)^{-1}        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]^{T}        \left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_k-h(\mathbf{x}_k)) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k \right)\end{array}\right]\\    &amp;=     \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        (\mathbf{z}_k-h(\mathbf{x}_k))    +    \mathbf{P}_k^{-1}(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    \right)    \\    &amp;=    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \{    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        (\mathbf{z}_k-h(\mathbf{x}_k) - \mathbf{H}_k (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k))    +    \\    &amp;  \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k    (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    +    \mathbf{P}_k^{-1}(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    \}    \\    &amp;=    \hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k +    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}    \left (        \mathbf{z}_k-h(\mathbf{x}_k) - \mathbf{H}_k (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)        \right)\end{aligned} \]</span></p><p>此时，如果令<span class="math inline">\(\mathbf{K}_{k}\)</span>满足:</p><p><span class="math display">\[\mathbf{K}_{k} = \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}\]</span></p><p>定睛一看，这货不就是公式（20）由IEKF的增量吗？</p><p>所以，<strong>IEKF实际上是高斯牛顿的一种应用</strong>，如果多个观测放在一起来求解，就是最小二乘，如果迭代的求解，就成了IEKF。</p><h1 id="iekf在fast-lio系列的应用">IEKF在Fast-LIO系列的应用</h1><p>回顾Fast-LIO1论文，公式(17)，要优化的目标函数是：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312105428.png"></p><p>其中，包含了先验项和观测项</p><h2 id="先验项">先验项</h2><ol type="1"><li>第一项<span class="math inline">\(\left\|\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\right\|_{\widehat{\mathbf{P}}_{k}^{-1}}^{2}\)</span>是先验项，其表述有点奇怪</li></ol><hr><p>原文描述如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312105720.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{X}_{k}\)</span>表示状态真值</li><li><span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>表示k时刻预测值</li><li><span class="math inline">\(\mathbf{J}^{\kappa}\)</span>表示<span class="math inline">\(\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxplus \widetilde{\mathbf{x}}_{k}^{\kappa}\right) \boxminus \widehat{\mathbf{x}}_{k}\)</span>关于误差状态<span class="math inline">\(\tilde{\mathbf{x}}_{k}^{\kappa}\)</span>的雅克比</li></ul><p>按照原文的意思是，<span class="math inline">\(\left\|\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\right\|_{\widehat{\mathbf{P}}_{k}^{-1}}^{2}\)</span>用于约束预测值<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>不应该离状态真值太远，即误差状态应尽可能小（这个先验看起来跟平时的形式不一样，<strong>难以理解</strong>）。</p><hr><p>下面，按照我们通用的理解去描述：</p><p>先验一般约束着迭代状态值<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa}\)</span>不应该离预测值<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>太远，因此，先验对应的残差项可以写为：</p><p><span class="math display">\[\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\]</span></p><blockquote><p>因此，个人认为，原文公式（17）第一项不应该为<span class="math inline">\(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\)</span>，替换为<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\)</span>更合理</p></blockquote><h2 id="观测项">观测项</h2><ol start="2" type="1"><li>第二项<span class="math inline">\(\left\|\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>在原文中的表述比较牵强：</li></ol><hr><p>原文公式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312174507.png"> <img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312173821.png"></p><p>上面<span class="math inline">\(\mathbf{h}_{j}\left(\mathbf{x}_{k},{ }^{L_{j}} \mathbf{n}_{f_{j}}\right)\)</span>的意思是，给定状态真值<span class="math inline">\(\mathbf{x}_{k}\)</span>和测量噪声<span class="math inline">\({ }^{L_{j}} \mathbf{n}_{f_{j}}\)</span>，那么理论上得到的观测值（即点到平面的距离）为0。</p><p>然而，由于无法得知状态真值，因此使用一阶近似得到的公式（14）。此处使用的<span class="math inline">\(\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\)</span>让人容易混淆，还是看下文的另外一种描述。</p><hr><p>前面提到，实际的观测值其实不用去观测，因为点就在平面上，所以实际的观测值为0，即<span class="math inline">\(\mathbf{z_{true}} = 0\)</span>。</p><p>为了衡量当前估计的状态是否足够接近真值，我们利用迭代的状态去计算点-面距离，<strong>这一个操作称为观测预测</strong>，<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\)</span>为观测预测模型，即通过给定状态来计算在该状态下得到的观测值，此处为计算得到的点-面距离。</p><p>因此，残差项可以写为：</p><p><span class="math display">\[    \mathbf{z_{true}} -\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\]</span></p><p>其中，已知<span class="math inline">\(\mathbf{z_{true}} = 0\)</span>，因此，残差项就是利用迭代的状态计算得到的点-面距离<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}\right)\)</span>。</p><blockquote><p>因此，个人认为，原文描述的第二项不应该为<span class="math inline">\(\left\|\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>，替换为<span class="math inline">\(\left\| \mathbf{z_{true}} -\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\right\|_{\mathbf{R}_{j}^{-1}}^{2} = \left\|\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>更为合适。</p></blockquote><h2 id="推导">推导</h2><p>综上，我们继续使用上面的方法再一次推导：</p><p>假设目标函数<span class="math inline">\(r(\mathbf{X})\)</span>如下:</p><p><span class="math display">\[r(\mathbf{X})=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}\left ( \mathbf{z_{true}} -\mathbf{h}_{j}(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}) \right) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k} \right)\end{array}\right] = \left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}\left ( \mathbf{h}_{j}(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}) \right) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k} \right)\end{array}\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\)</span>是观测模型，对其进行泰勒一阶展开，可得：<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}\boxplus\tilde{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right) \approx \mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \tilde{\mathbf{x}}_{k}^{\kappa}\)</span>，其中<span class="math inline">\(\mathbf{z}_{j}^{\kappa}\)</span>就是利用状态<span class="math inline">\(\widehat{\mathbf{X}}_{k}^{\kappa}\)</span>计算得到的点到平面距离</li><li><span class="math inline">\(j\)</span>表示第j个激光点</li></ul><p>根据高斯牛顿的思想，对残差函数进行一阶泰勒展开如下：</p><p><span class="math display">\[\begin{aligned}r(\mathbf{X^{\kappa} +\Delta \mathbf{x}}) = r(\mathbf{X^{\kappa} +\tilde{\mathbf{x}}_{k}^{\kappa}}) &amp;=r(\mathbf{X^{\kappa}})+ J(\mathbf{X}^{\kappa})\tilde{\mathbf{x}}_{k}^{\kappa}\\&amp;=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \tilde{\mathbf{x}}_{k}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}+\mathbf{J}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right)\end{array}\right]\\&amp;=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)\end{array}\right]+\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{H}_{j}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{J}^{\kappa} \right)\end{array}\right]\widetilde{\mathbf{x}}_{k}^{\kappa}\end{aligned}\]</span></p><p>其中</p><ul><li><span class="math inline">\(\mathbf{H}^{\kappa}_{j}\)</span>是激光投影点到地图上最近的平面的距离关于误差状态的雅克比，其推导可从<a href="https://readpaper.com/paper/3131967444" target="_blank" rel="noopener">R2LIVE</a>中找到。</li><li><span class="math inline">\(\mathbf{J}^{\kappa}\)</span>表示<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\)</span>关于误差状态<span class="math inline">\(\tilde{\mathbf{x}}_{k}^{\kappa}\)</span>的雅克比</li></ul><p>雅克比<span class="math inline">\(J(\mathbf{X}^{\kappa})\)</span>如下：</p><p><span class="math display">\[\mathbf{J}_{k}^{\kappa} =\left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\\mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa} \end{array}\right]\]</span></p><p><span class="math display">\[\mathbf{H}_{k}^{\kappa} =\left.\frac{\partial h(s)}{\partial s}\right|_{s=\mathbf{x}_{k}^{\kappa} }\]</span></p><p><span class="math display">\[\mathbf{J}^{\kappa}=\left[\begin{array}{cc}\mathbf{A}\left({ }^{G} \widehat{\mathbf{R}}_{I_{k}}^{\kappa} \boxminus^{G} \widehat{\mathbf{R}}_{I_{k}}\right)^{-T} &amp; \mathbf{0}_{3 \times 15} \\\mathbf{0}_{15 \times 3} &amp; \mathbf{I}_{15 \times 15}\end{array}\right]\]</span></p><p>这里注意区分<span class="math inline">\(\mathbf{J}_{k}\)</span>和<span class="math inline">\(\mathbf{J}^{\kappa}\)</span>。</p><p>将<span class="math inline">\(r(\mathbf{X^{\kappa}})\)</span>以及雅克比<span class="math inline">\(J(\mathbf{X}^{\kappa})\)</span>回代到高斯牛顿正规方程，可以得到增量<span class="math inline">\(\Delta{\mathbf{x}}\)</span>如下：</p><p><span class="math display">\[\begin{aligned}    \Delta{\mathbf{x}} &amp;= - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x})     \\    &amp;= -    \left(        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]^{T}        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]    \right)^{-1}        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]^{T}    \left[\begin{array}{c}    \left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}) \\    \mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \end{array}\right]    \\    &amp;= -    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    \left \{        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        \mathbf{z}_k^{\kappa} +        (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right \}    \\    &amp;= -    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    \{        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        \mathbf{z}_k^{\kappa} +        (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \\    &amp;+ \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k (\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) - \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k (\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \}    \\    &amp;= -(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) -     \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    (\mathbf{H}_k^{T} \mathbf{R}_k^{-1})    \left (        \mathbf{z}_k^{\kappa} +        \mathbf{H}_k(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right )    \\    &amp;= -(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) -      \mathbf{K}_{k}^{\kappa}    \left (        \mathbf{z}_k^{\kappa} +        \mathbf{H}_k(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right )    \\    &amp;=    -\mathbf{K} \mathbf{z}_{k}^{\kappa}-(\mathbf{I}-\mathbf{K} \mathbf{H})\left(\mathbf{J}^{\kappa}\right)^{-1}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)\end{aligned}\]</span></p><p>按照上述推导，即可得到与论文公式（18）一致的结果。</p><h1 id="参考">参考</h1><p><a href="https://zhuanlan.zhihu.com/p/141018958" target="_blank" rel="noopener">知乎：迭代扩展卡尔曼滤波(IEKF)</a></p><p><a href="https://readpaper.com/pdf-annotate/note?noteId=658232918830911488&amp;pdfId=658232843626635264" target="_blank" rel="noopener">论文：Performance evaluation of iterated extended Kalman filter with variable step-length</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;performance-evaluation-of-iterated-extended-kalman-filterwith-variable-step-length&quot;&gt;Performance evaluation of iterated extended Kalm
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>IKFOM论文阅读</title>
    <link href="http://yoursite.com/2022/02/27/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/02/27/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-02-27T12:22:58.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kalman-filters-on-differentiable-manifolds">Kalman Filters on Differentiable Manifolds</h1><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227202357.png"></p><h1 id="摘要">摘要</h1><p>卡尔曼滤波是现代控制系统中最重要和应用最广泛的滤波技术之一。然而，几乎所有当前的卡尔曼滤波器的变体都是在欧几里得空间Rn中制定的，而许多现实世界的系统(例如，机器人系统)实际上是在流形上进化的。</p><p>在本文中，我们提出了一种为这类流形上系统设计卡尔曼滤波器的方法。利用运算<span class="math inline">\(\boxplus \backslash \boxminus\)</span>，并进一步定义了相应流形上的⊕运算，给出了流形上系统的规范表示。这种非正则形式使我们能够在卡尔曼过滤的每一步中将多种约束从系统行为中分离出来，最终产生一个在流形上自然演化的通用的和象征性的卡尔曼过滤框架。</p><p>此外，这种流形上的卡尔曼滤波器集成了C++包实现，它使用户能够实现集成卡尔曼滤波器，就像在<span class="math inline">\(\mathbb{R}^{n}\)</span>空间中的普通卡尔曼过滤一样：用户只需要提供系统特定的描述，然后调用各自的过滤步骤(例如，预测、更新)，而不需要处理任何流形约束。</p><h1 id="preliminaries-of-differentiable-manifolds">PRELIMINARIES OF DIFFERENTIABLE MANIFOLDS</h1><h2 id="可微分流形differentiable-manifolds">可微分流形（Differentiable manifolds）</h2><p>如文[34]所示，维数为n的流形是局部同胚于<span class="math inline">\(\mathbb{R}^{n}\)</span>的集合M(称为homeomorphicspace)。、</p><p>也就是说，对于任意一个点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>以及一个包含该点的开子集<span class="math inline">\(U \subset \mathcal{M}\)</span>，存在一个双射函数(称为homeomorphism)φ，它将<span class="math inline">\(U\)</span>中的点映射到<span class="math inline">\(\mathbb{R}^{n}\)</span>的开子集。该对<span class="math inline">\((\phi, U)\)</span>称为局部坐标图，如果任何两个图<span class="math inline">\((\phi, U)\)</span>和<span class="math inline">\((\psi, V)\)</span>共享重叠的合成映射<span class="math inline">\(\phi \circ \psi^{-1}\)</span>是可微的，则该流形称为可微流形。</p><h2 id="boxplus-backslash-boxminus操作"><span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作</h2><p>流形M中任意点周围<code>homeomorphisms</code>的存在使我们能够封装两个算子<span class="math inline">\(\boxplus_{\mathcal{M}}\)</span>(“boxplus”)和<span class="math inline">\(\boxminus_{\mathcal{M}}\)</span>(“boxminus”)到流形[25]：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227204348.png"></p><p>其中，<span class="math inline">\(\mathcal{M}_{\varphi_{\mathrm{x}}}\)</span>是点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>的一个<code>homeomorphism</code>.</p><p><span class="math inline">\(\mathbf{y}=\mathbf{x} \boxplus_{\mathcal{M}} \mathbf{u}\)</span>的物理含义是向点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>添加一个扰动<span class="math inline">\(\mathbf{u}\)</span>，然后产生了流形上的<span class="math inline">\(\mathbf{y} \in \mathcal{M}\)</span>， 如图2所示。</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227204921.png"></p><p>其中，逆操作<span class="math inline">\(\mathbf{u}=\mathbf{y} \boxminus_{\mathcal{M}} \mathbf{x}\)</span>可以确定扰动量<span class="math inline">\(\mathbf{u}\)</span>，该扰动量<span class="math inline">\(\mathbf{u}\)</span>就是产生<span class="math inline">\(\mathbf{y} \in \mathcal{M}\)</span>时，对点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>进行<span class="math inline">\(\boxplus_{\mathcal{M}^{-}}\)</span>操作所添加的扰动。</p><p>这两个操作符创建了一个局部的、矢量化视角，对应于流形上复杂的全局结构。</p><p>对于李群来说，当<span class="math inline">\(\mathcal{M}\)</span>是Lie group (e.g., <span class="math inline">\(\left.\mathbb{R}^{n}, S O(3), S E(3)\right)\)</span>，正切空间具有表示为m的李代数结构和指数映射<span class="math inline">\(\exp : \mathfrak{m} \mapsto \mathcal{M}\)</span>。</p><p>令<span class="math inline">\(\mathfrak{f}: \mathbb{R}^{n} \mapsto \mathfrak{m}\)</span>作为从最小参数化空间到李代数、指数映射<span class="math inline">\(\operatorname{Exp}=\exp \circ f\)</span>以及其逆操作<span class="math inline">\(\log\)</span>的的映射，那么<span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作的定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227210416.png"></p><p>其中·是M上的二元运算，使得<span class="math inline">\((\mathcal{M}, \cdot)\)</span>形成李群，<span class="math inline">\(\mathbf{x}^{-1}\)</span>是<span class="math inline">\(\mathbf{X}\)</span>的逆，对于李群上的元素，它总是存在。</p><p>当流形M不是李群时，找出流形与其切空间参数化之间的同胚没有一般准则。例如，2球面流形<span class="math inline">\(\mathbb{S}^{2}(r) \triangleq\{\mathbf{x} \in \left.\mathbb{R}^{3} \mid\|\mathbf{x}\|=r, r&gt;0\right\}\)</span>在点x处的切线空间就是在点<span class="math inline">\(\mathbf{X}\)</span>的简单正切平面，如图3所示。</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227211039.png"><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227211039.png"><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227211039.png"></p><p>对于点<span class="math inline">\(\mathbf{x} \in \mathbb{S}^{2}(r)\)</span>，扰动可以通过沿着正切平面上的向量旋转来实现，结果仍将保留在<span class="math inline">\(\mathbb{S}^{2}(r)\)</span>上。</p><p>正切平面中的旋转向量被<span class="math inline">\(\mathbf{u} \in \mathbb{R}^{2}\)</span>最小参数化表达，其中，所在的空间为由两个bias向量<span class="math inline">\(\mathbf{b}_{1}, \mathbf{b}_{2} \in \mathbb{R}^{3}\)</span>所展开的正切平面。也就是说：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227212601.png"></p><p>其中，<span class="math inline">\(\mathbf{R}(\mathbf{w})=\operatorname{Exp}(\mathbf{w}) \in S O(3)\)</span>记为关于由向量<span class="math inline">\(\mathbf{w} \in \mathbb{R}^{3}\)</span>所表示的轴-角旋转。特别的，<span class="math inline">\(\mathbf{b}_{1}, \mathbf{b}_{2}\)</span>的选择不是唯一的，只要它们是正交的并且都垂直于x。</p><blockquote><p><span class="math inline">\(\mathbb{S}^{2}\)</span>常用于重力的表示，如VINS-Mono就用这个来表示并进一步refine重力向量。</p></blockquote><h2 id="oplus操作符"><span class="math inline">\(\oplus\)</span>操作符</h2><p>现实世界的系统通常是由一些外在的输入驱动的。为了模拟这一现象，除了描述流形本身所在的状态之外，还需要一个额外的操作来描述流形上的状态是如何在无限小的时间周期内由恒定的外生速度驱动的。</p><p>尽管速度对状态的影响增加了对流形上其原始位置的扰动，这在流形上有很好的描述运算符<span class="math inline">\(\boxplus\)</span>，则外部速度不一定在相同的homeomorphic空间(即，切线空间)中，该空间定义操作，因此需要表示为<span class="math inline">\(\oplus_{\mathcal{M}}\)</span>的新操作。</p><p>假设外部速度的维度是l，那么新的操作为：<span class="math inline">\(\oplus_{\mathcal{M}}: \mathcal{M} \times \mathbb{R}^{l} \mapsto \mathcal{M}\)</span></p><p>具体地说，当<span class="math inline">\(\mathcal{M}\)</span>是李群时，外生速度通常位于正切空间，同时也定义了公式(2)中的<span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作，因此操作⊕与<span class="math inline">\(\boxplus\)</span>重合，即：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214214.png"></p><p>。。。</p><h2 id="差分">差分</h2><p><span class="math inline">\((((\mathbf{x} \boxplus \mathbf{u}) \oplus \mathbf{v}) \boxminus \mathbf{y})\)</span>相对于<span class="math inline">\(\mathbf{u}\)</span>和<span class="math inline">\(\mathbf{V}\)</span>的差分将会在后面的卡尔曼滤波器中用到，其中，<span class="math inline">\(\mathbf{x}, \mathbf{y} \in \mathcal{M}, \mathbf{u} \in \mathbb{R}^{n}\)</span>，<span class="math inline">\(\mathbf{v} \in \mathbb{R}^{l}\)</span>。</p><p>由链式法则，可得：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214416.png"></p><p>对于某些流形(例如，SO(3))，计算微分通常更为方便，而不用使用链式法则展开。</p><h2 id="复合可微流形">复合可微流形</h2><p>基于流形的笛卡儿积原理，给出了流形的定义由两个子流形(归纳为任意个子流形)组成的复合流形上的<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>操作定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214841.png"></p><p>因此复合流形上的偏微分满足(见引理)：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214913.png"></p><p><span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>运算及其在复合流形上的偏微分非常有用，使用户能够定义<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>运算及其导数(例如，<span class="math inline">\(\mathbb{R}^{n}, S O(3), \mathbb{S}^{2}(r)\)</span>)，然后将这些定义推广到更复杂的复合流形。</p><p>例如，根据前面讨论<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>的定义，总结了几个重要流形，包括<span class="math inline">\(\mathbb{R}^{n}, S O(3), \mathbb{S}^{2}(r)\)</span>的运算，并在表中总结了它们的局部微分，其中：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227215246.png"></p><p>其中，<span class="math inline">\(\lfloor\mathbf{u}\rfloor\)</span>记为反对称矩阵，并且有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227215356.png"></p><p>总结表如下： （详细推导见附录B）</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227215458.png"></p><h2 id="流形系统的规范表示">流形系统的规范表示</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kalman-filters-on-differentiable-manifolds&quot;&gt;Kalman Filters on Differentiable Manifolds&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.nsloop.com:58443
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>Cyber-RT系列之协程Croutine</title>
    <link href="http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%8F%E7%A8%8BCroutine/"/>
    <id>http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%8F%E7%A8%8BCroutine/</id>
    <published>2021-11-28T15:10:29.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>协程是Cyber-RT的实现任务轮转的最小单位，是处理数据回调的运行模块。协程可以理解为“可以暂停”的函数，相比于线程，其具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即可达到类似线程的效果。</p><p>为什么选用协程，因为基于协程的特性再加上Cyber中枢调度<code>Scheduler</code>的线程调度，可以避免回调时由于阻塞导致其他回调不能被执行的情况；此外，协程是在用户态来完成上下文切换的，所以切换耗时只有区区100ns多一些，比进程切换要高30倍。</p><h1 id="cybercroutine目录">Cyber/croutine目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── BUILD</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── croutine.cc</span><br><span class="line">├── croutine.h</span><br><span class="line">├── detail</span><br><span class="line">│   ├── routine_context.cc</span><br><span class="line">│   ├── routine_context.h</span><br><span class="line">│   ├── swap_aarch64.S</span><br><span class="line">│   └── swap_x86_64.S</span><br><span class="line">└── routine_factory.h</span><br></pre></td></tr></table></figure><h1 id="croutine类图">Croutine类图</h1><p>...</p><h1 id="结构图">结构图</h1><h1 id="协程的创建">协程的创建</h1><p>Cyber-RT中有两个地方创建了协程：</p><ul><li><code>Component</code>的初始化</li><li><code>Reader</code>的初始化</li></ul><p>两处地方的创建大同小异，这里给出<code>Component&lt;M0, NullType, NullType, NullType&gt;::Initialize</code>函数中关于创建协程的代码片段:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0&gt;</span><br><span class="line"><span class="keyword">bool</span> Component&lt;M0, NullType, NullType, NullType&gt;::Initialize(</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// lambda函数 （这个后面作为）</span></span><br><span class="line">  <span class="keyword">auto</span> func = [self](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;M0&gt;&amp; msg) &#123;</span><br><span class="line">    <span class="comment">// 处理msg</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造 data::DataVisitor</span></span><br><span class="line">  <span class="keyword">auto</span> dv = <span class="built_in">std</span>::make_shared&lt;data::DataVisitor&lt;M0&gt;&gt;(conf);</span><br><span class="line">  <span class="comment">// 创建协程工厂</span></span><br><span class="line">  croutine::RoutineFactory factory =</span><br><span class="line">      croutine::CreateRoutineFactory&lt;M0&gt;(func, dv);</span><br><span class="line">  <span class="keyword">auto</span> sched = scheduler::Instance();</span><br><span class="line">  <span class="keyword">return</span> sched-&gt;CreateTask(factory, node_-&gt;Name());</span><br></pre></td></tr></table></figure><p>其流程大概是这样:</p><ol type="1"><li>写出一个lambda函数，内部进行msg的回调处理</li><li>构造一个<code>DataVistor</code></li><li>将lambda函数和创建的<code>DataVistor</code>一并作为参数，用于创建协程工厂croutine::RoutineFactory</li><li>将协程工厂作为参数，调用中枢调度Scheduler::CreateTask(...)函数</li></ol><h2 id="why-routinefactory">Why RoutineFactory?</h2><p>看到上面的代码片段可能会觉得奇怪，为什么需要协程工厂这一层，直接创建一个协程不好吗？</p><p>这其实是一种封装，假设我们直接创建一个协程，那么需要传入一个回调函数，用于处理msg，然而Cyber-RT一共考虑了1-4种msg的情况，那么创建协程时传入的回调函数的参数就有4种情况，这使得接口不能统一。使用协程工厂就是为了对4种情况进行封装，并统一接口，即创建协程时只需要把协程工厂传入作为参数即可。</p><h2 id="what-is-routinefactory">What is RoutineFactory?</h2><h1 id="重要过程时序流图">重要过程时序流图</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;协程是Cyber-RT的实现任务轮转的最小单位，是处理数据回调的运行模块。协程可以理解为“可以暂停”的函数，相比于线程，其具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即
      
    
    </summary>
    
    
    
      <category term="Cyber_RT" scheme="http://yoursite.com/tags/Cyber-RT/"/>
    
  </entry>
  
</feed>
