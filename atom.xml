<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EpsilonJohn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-06-27T14:21:14.956Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EpsilonJohn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>X-ICP论文阅读</title>
    <link href="http://yoursite.com/2023/06/25/X-ICP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/06/25/X-ICP%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-06-25T10:00:53.000Z</published>
    <updated>2023-06-27T14:21:14.956Z</updated>
    
    <content type="html"><![CDATA[<h1 id="x-icp-localizability-aware-lidar-registration-for-robust-localization-in-extreme-environments">X-ICP: Localizability-Aware LiDAR Registration for Robust Localization in Extreme Environments</h1><p><img src="https://s1.nsloop.com:58443/images/2023/06/25/1687687377-0.png"></p><h1 id="摘要">摘要</h1><p>现代机器人系统需要在具有挑战性的环境中运行，这就要求在具有挑战性的条件下进行可靠的定位。基于激光雷达的定位方法，如迭代最近点(ICP)算法，在几何信息匮乏的环境中可能会受到影响，这些环境已知会<strong>降低配准性能，并将优化推向弱约束方向的发散</strong></p><p>为了克服这个问题，本工作提出了 1)一个鲁棒的多类别(非)可定位性检测模块，以及 2)一个基于可定位性约束ICP优化模块，并以统一的方式将两者耦合在一起。所提出的可定位性检测是通过利用扫描和地图之间的对应关系来分析针对优化主方向的对准强度来实现的，作为LiDAR定位分析的一部分。</p><p>在第二部分中，这种可定位性分析紧密集成到扫描到地图的点云配准中，以沿着良好约束的方向生成无漂移的姿态更新。该方法经过了全面的评估，并在模拟和真实世界的实验中与最先进的方法进行了比较，从而在具有激光雷达挑战性的场景中获得了性能和可靠性的提升。在所有实验中，所提出的框架证明了准确和通用的定位检测和鲁棒的姿态估计，而不需要特定环境的参数调整。</p><h1 id="介绍">介绍</h1><p><strong>点云配准局限性：</strong></p><p>尽管ICP算法及其变体是迄今为止首选的注册方法之一，但在使用它时需要考虑其在实际应用中的局限性。[13]，[14]发现有四种不同的误差来源会影响ICP算法。这些问题包括：</p><ul><li>收敛到局部最小值的风险</li><li>对传感器偏差和噪声的敏感性</li><li>不准确的初始转换</li><li>以及在潜在的优化问题中缺乏几何约束</li></ul><p>虽然机器人社区开发了减少前三个来源的方法和系统，但后者仍然可能导致现代机器人系统在困难环境中部署时发生故障。在(近)自对称环境中，沿对称轴的几何约束(几乎)与噪声构成的约束难以区分。因此，优化可能收敛到以噪声主导的最优解<a href="On%20degeneracy%20of%20optimization-based%20state%20estimation%20problems">15</a>，称为退化或退化情况。隧道、开放空间、走廊和门道都可能是这种退化环境的实例[16]，参见图1中真实地下隧道示例的顶部一行。</p><p><strong>考虑可定位性：</strong></p><p>为了使机器人能够在所有场景中运行，包括退化的平面或类似隧道的环境，需要所谓的可定位性考量<code>localizability-awareness</code>[17]-[19]。</p><blockquote><p>[17]: <a href="https://github.com/leggedrobotics/L3E" target="_blank" rel="noopener">Learning-based Localizability Estimation for Robust LiDAR Localization (L3E)</a></p></blockquote><p>应对机制是双重的：</p><ul><li>首先，退化场景的检测</li><li>其次，减轻其对优化的负面影响</li></ul><p>多种方法利用信息论将优化的退化检测为退化与否(二进制形式)——而不单独考虑运动的各个轴的退化情况<a href="Predicting%20alignment%20risk%20to%20prevent%20localization%20failure">20</a>-<a href="%22A%20localizability%20estimation%20method%20for%20mobile%20robots%20based%20on%203d%20point%20cloud%20feature">23</a></p><blockquote></blockquote><p>然而，尽管具有实用性和简单，但这种分析并没有提供足够的细节，来说明优化过程中的退化方向。因此，大多数解决方案[18]-<a href="Predicting%20alignment%20risk%20to%20prevent%20localization%20failure">20</a>更倾向于丢弃整个测量的配准结果，而不是至少沿着信息良好的方向对问题进行强化。</p><p>此外，如[17]描述，现有的检测方法如<a href="On%20degeneracy%20of%20optimization-based%20state%20estimation%20problems">15</a>、<a href="Degeneracy-aware%20factors%20with%20applications%20to%20underwater%20slam">24</a>在实践中表现良好，但需要对不同的环境或传感器配置进行繁琐的参数调整。</p><blockquote></blockquote><p><strong>提出的方法：</strong></p><p>针对上述挑战，本文提出了一种鲁棒的可定位感知点云配准框架<code>X-ICP</code>，该框架使基于lidar的SLAM系统能够在无特征极端环境中运行。所提出的框架，如图 2 所示，解决了退化的检测和缓解。这两个子模块是可定位性检测模块，缩写为<code>Loc.-Module</code>，优化模块，缩写为<code>Opt.-Module</code></p><p><img src="https://s1.nsloop.com:58443/images/2023/06/25/1687690807-0.png"></p><p>Loc.-Module利用扫描与地图之间的点和表面法线对应关系来分析沿优化主方向的对齐强度。与之前的工作L3E[17]相比，这种可定位性检测用于<code>scan-to-map</code>，并且与机器人的朝向(相对于环境)无关。允许在各种环境配置中进行可靠的检测，例如地下场景，以及室外大场景，且无需在线参数调整。结果估计是细粒度的，即将当前机器人状态分为{可定位，部分可定位和不可定位}类别。</p><p>另一方面，Opt.-Module利用可定位性信息计算并整合优化约束，对点云配准进行底层优化，值得注意的是，Opt . module独立于ICP成本函数，可以与其他基于优化的系统单独结合使用。通过在迭代优化过程中直接考虑退化方向，减轻了退化方向的不利影响。这种优化的结果利用了传感中包含的信息，同时利用了沿病态条件方向的外部信息</p><p>所提出的框架在不同环境和感官条件下的多个现实世界任务中进行了广泛的测试，现实世界的实验和分析表明，该框架可以在各种环境条件下可靠地检测可定位性，而无需根据具体情况调整参数，并且在退化环境下具有较高的鲁棒性和准确性。在具有挑战性和部分退化的场景中进行的所有实验中，所提出的框架始终优于最先进的机器人方法<a href="On%20degeneracy%20of%20optimization-based%20state%20estimation%20problems">15</a>，<a href="Degeneracy-aware%20factors%20with%20applications%20to%20underwater%20slam">24</a>，参见图1中类似隧道环境的示例。</p><p>因此，本文的主要贡献为：</p><ul><li>一种多层次、鲁棒用于scan-to-map配准的可定位性检测算法的开发与集成。为了研究多级探测的效果，我们进行了详细的消融研究</li><li>开发了一种新的可定位性考量约束ICP优化模块，并与可定位性检测紧密耦合以减轻退化的影响</li><li>进行了各种实验来评估所提出的框架的有效性，并将结果与最先进的方法进行比较。此外，还提供了附加内容、数据和补充材料</li></ul><h1 id="相关工作">相关工作</h1><h2 id="退化检测">退化检测</h2><h2 id="点云建图中的约束优化">点云建图中的约束优化</h2><p>约束优化技术在文献中是众所周知的;然而，它们在点云配准中的应用最近才引起人们的关注。首先，[51]提出了一种无穿透点云配准的约束优化方法，提高了姿态估计的质量。类似地，[52]使用非线性等式约束来减少点云配准中旋转估计的线性化误差。为了提高对传感器噪声和对应异常值的鲁棒性，[53]提出通过将每个测量作为单独的约束添加，使用增广拉格朗日来解决约束优化问题。最近的一项研究<a href="CT-ICP:%20Real-time%20Elastic%20LiDAR%20Odometry%20with%20Loop%20Closure">54</a>引入了软约束作为ICP优化的成本，以确保不同扫描之间的轨迹连续性。</p><blockquote></blockquote><p>相比之下，<a href="Teaser:%20Fast%20and%20certifiable%20point%20cloud%20registration">55</a>将点云配准问题表述为约束二次规划，以提供全局最优的点云配准结果</p><blockquote></blockquote><p>这些方法提高了全局点云配准问题的鲁棒性和准确性;然而，他们没有解决约束的效用，以限制优化中的退化的影响。为了解决这一挑战，并且与所提出的方法最相关，<a href="Robust%20rank%20deficient%20SLAM">44</a>提出使用相对条件数来检测退化性，并通过在因子图公式中引入约束来惩罚沿退化方向的运动变化</p><blockquote></blockquote><p>据作者所知，这方面的研究只有<a href="Robust%20rank%20deficient%20SLAM">44</a>。然而，这项工作仅限于2D导航，并没有考虑在低级ICP优化中使用这些约束，鉴于上述讨论，使用退化分析来约束机器人在具有挑战性和退化的环境中操作的ICP注册问题仍然是一个开放的问题，本工作旨在解决这个问题。</p><h1 id="问题描述">问题描述</h1><p>受先前研究结果的启发，本工作提出了一种在几何挑战性和退化环境中进行机器人姿态估计和可靠点云配准的解决方案。仅利用LiDAR点云和外部里程计估计作为输入，并将该方案分为可定位性检测和约束点云配准两部分。所提出的组件可以在计算资源有限的机器人系统上实时运行。</p><h2 id="问题形成">问题形成</h2><p><strong>点云配准</strong></p><p>点云配准问题定义为寻找一个刚体变换<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}} \in S E(3)\)</span>，该刚体变换能够将LiDAR坐标系中<span class="math inline">\(N_p\)</span>个点<span class="math inline">\({ }_{\mathrm{L}} \boldsymbol{P} \in \mathbb{R}^{3 \times N_p}\)</span>的点云(记为L)与地图框架中<span class="math inline">\(N_q\)</span>点，<span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{Q} \in \mathbb{R}^{3 \times N_q}\)</span>的参考点云(记为M)进行最佳对齐。</p><p>刚体变换<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}} \in S E(3)\)</span>由旋转和平移组成，对于LiDAR坐标系中的每个点，地图中的参考点通常通过kd-tree进行搜索找到，这个数据关联的过程记为：<span class="math inline">\(\mathcal{M} \in \mathbb{R}^{6 \times N}=\operatorname{matching}\left({ }_{\mathrm{L}} \boldsymbol{P},{ }_{\mathrm{m}} \boldsymbol{Q}, \boldsymbol{T}_{\mathrm{LM}, \text { init }}\right)=\left.\left\{\left({ }_{\mathrm{M}} \boldsymbol{p},\left \{ { }_{\mathrm{M}} \boldsymbol{q},{ }_{\mathrm{M}} \boldsymbol{p}\right\}\right):\left({ }_{\mathrm{M}} \boldsymbol{p} \in{ }_{\mathrm{M}} \boldsymbol{P}\right),{ }_{\mathrm{M}} \boldsymbol{q} \in{ }_{\mathrm{M}} \boldsymbol{Q}\right)\right\}\)</span>，其中<span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{p}\)</span> 和 <span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{q}\)</span>是匹配点对，<span class="math inline">\({ }_{\mathrm{M}} \boldsymbol{n} \in \mathbb{R}^3,\left\|_{\mathrm{M}} \boldsymbol{n}\right\|=1\)</span>是<span class="math inline">\(_M\boldsymbol{q}\)</span>的平面法向量。</p><p>另外，N≤Np是匹配点的个数，表示接下来的工作的问题大小。初始变换<span class="math inline">\(\boldsymbol{T}_{\text {LM,init }}\)</span>通常作为初始猜测提供，将扫描数据转换为参考坐标系，以改善匹配过程和优化收敛特性。虽然这种初始转换的准确性对于最小化的收敛至关重要[14]，但这种初始转换的质量的影响不在本工作的范围内。</p><p>定义点云对齐误差函数有多种方法;在本工作中，将使用点到平面[7]的代价函数。具有<strong>点到平面</strong>成本函数的ICP最小化问题定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/25/1687694477-0.png"></p><p>不同的求解方法，如奇异值分解(SVD)[56]、LU分解、Gauss-Newton和Levenberg-Marquardt，都可以用来求解这个最小化问题。在这项工作中，重点是直接线性代数求解器，如SVD，它直接以矩阵形式运算。</p><p>根据Pomerleau等人[57]的推导，引入标量三重积和旋转矩阵线性化，最小化(1)可以重新表述为二次代价优化问题，如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687742957-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\boldsymbol{x}=\left[\boldsymbol{r}^{\top} \boldsymbol{t}^{\top}\right]^{\top} \quad \in \mathbb{R}^6\)</span>是待优化变量</li><li><span class="math inline">\(\boldsymbol{r} \in \mathfrak{s o}(3)\)</span>是李代数SO3的旋转量</li><li><span class="math inline">\(\boldsymbol{t} \in \mathbb{R}^3\)</span></li><li><span class="math inline">\(\boldsymbol{A}^{\prime} \in \mathbb{R}^{6 \times 6}\)</span>为优化问题的Hessian矩阵</li><li><span class="math inline">\(\boldsymbol{b}^{\prime} \in \mathbb{R}^6\)</span>结合点云之间的约束</li><li>此公式(2)中的<span class="math inline">\(\boldsymbol{p}_i\)</span>应该是根据位姿初值投影到地图坐标系后的投影点坐标</li></ul><p>Hessian构成了优化的二阶矩矩阵，并定义了雅可比矩阵的局部行为。并且，式(2)是众所周知的以优化变量<span class="math inline">\(x\)</span>为变量的二次最小化形式，可以将其重新表述为正则最小二乘优化公式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687743372-0.png"></p><p>对于(半)正定矩阵<span class="math inline">\(\boldsymbol{A}^{\prime}\)</span>，求解这个最小化问题很简单。该6 × 6线性方程组的解将得到在该线性化点下的最优平移矢量<span class="math inline">\(\boldsymbol{t}\)</span>和旋转矢量<span class="math inline">\(\boldsymbol{r}\)</span>。在ICP过程中，由于非线性和由此产生的算法的迭代性质，这里描述的这些操作被重复，直到收敛。</p><p><strong>在退化环境中的操作</strong></p><p>在实际应用中，由于缺乏几何信息结构而引起的环境退化，上述点云配准可能会失败。之前的配准的解<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}}\)</span>是欠约束的，这意味着6-DoF变换的一个或多个维度(几乎)不能从观测到的correspondences中观察到。</p><p>因此，本工作试图解决的主要问题被定义为<strong>在存在环境退化的情况下找到最佳转换<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}}\)</span>，同时确定由于欠约束导致的难以估计的方向</strong>。</p><p>虽然在大多数先前的工作中忽略了这一点，但这项工作提出了一个专门针对这些情况的解决方案，以便在极端情况下运行。</p><h1 id="系统概览">系统概览</h1><p>所提出系统的概述如图2所示。提出了一种检测和减轻退化的新组件<code>Loc.-Module</code>和<code>Opt.-Module</code>，嵌入到scan-to-map配准系统<code>Pharos</code>[58]，[59]，由ANYbotics开发。但是，值得注意的是，所提出的组件可以集成到任何基于迭代优化的配准方法中。Pharos以5hz的频率运行，并与著名的点云配准库<code>libpointmatcher</code>的点对平面ICP实现紧密耦合[59]。此外，Pharos利用外部里程计姿态估计来补偿点云畸变，并作为配准先验<span class="math inline">\(\boldsymbol{T}_{\mathrm{ML}, \text { init }}\)</span>，实现scan-to-map的关联搜索。</p><h2 id="可定位性检测模块概述">可定位性检测模块概述</h2><p><code>Loc.-Module</code>的目标是近似于ICP优化的Hessian <span class="math inline">\(\boldsymbol{A}^{\prime}\)</span>的零空间。为了实现这一目标，引入了一个跨越6自由度优化问题的可定位性向量。这个局部化向量指示哪些特征向量在或应该被考虑为Hessian零空间内。可定位性向量定义为：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687744145-0.png"></p><p>其中，<span class="math inline">\(\left \{ { }_{\mathrm{L}} \boldsymbol{v}_{t_1}, \mathrm{~L}_{\mathrm{L}} \boldsymbol{v}_{t_2},{ }_{\mathrm{L}} \boldsymbol{v}_{t_3}\right\} \in \boldsymbol{V}_t\)</span>是Hessian <span class="math inline">\(\boldsymbol{A}^{\prime}\)</span>关于变量<span class="math inline">\(t\)</span>的平移特征向量（在雷达坐标系下的表示），相似的，<span class="math inline">\(\left \{ { }_{\mathrm{L}} \boldsymbol{v}_{r_1,{ }_{\mathrm{L}}} \boldsymbol{v}_{r_2, \mathrm{~L}_{\mathrm{L}}} \boldsymbol{v}_{r_3}\right \} \in \boldsymbol{V}_r\)</span>只对应于旋转向量<span class="math inline">\(\boldsymbol{r}\)</span>。</p><p>重要的是，如第II-A节所讨论的，ICP的雅可比矩阵由两个独立的元素组成，分别是平移和旋转的<span class="math inline">\(\boldsymbol{n}\)</span>和<span class="math inline">\(\boldsymbol{p} \times \boldsymbol{n}\)</span>，这是点对平面成本函数的固有属性。为了保持这一性质的有效性，<strong>在本工作中，在可定位性分析中省略了平移分量和旋转分量之间的交叉协方差</strong>。因此，只需要平移和旋转特征向量。</p><p>关于如何获得<span class="math inline">\(\boldsymbol{V}_t\)</span> 和 <span class="math inline">\(\boldsymbol{V}_r\)</span>的更多细节将在第V节的步骤V- a中解释。可定位性类别<span class="math inline">\(\Omega\)</span>以分类变量的形式表示每个特征向量的可局部化状态;这个离散的可本地化空间定义为<span class="math inline">\(\boldsymbol{\Omega}_i \in \{none, partial, full \}\)</span>，其中的类别分别对应于不可定位、部分可定位和可定位。每个类别的操作顺序将在第V节的步骤V- c中解释。</p><p><strong>考量可定位性的优化模块概述</strong></p><p>利用<code>Loc.-Module</code>模块的输出，如可定位性类别<span class="math inline">\(\Omega\)</span>，<code>Opt.-Module</code>的目标定义为构造和求解包含约束的优化问题，该问题将用于寻找优化问题(3)的最优解<span class="math inline">\(\boldsymbol{x}^*\)</span>。这一过程将在章节VI. 中详细说明。在这一部分中，<strong>使用基于拉格朗日乘子的约束优化技术</strong>来获得给定观察到的局部性的最优可能解。</p><h1 id="可定位性检测模块">可定位性检测模块</h1><p>在本节中，将详细介绍<code>Loc.-Module</code>按照图3所示的信息流进行描述。可定位性检测的目的是分析关联数据中的信息，从而正确识别约束不足的方向。如图3所示，给定关联数据关系，<strong>第一个任务是信息分析</strong>，分析Hessian与来自环境的几何信息之间的关系。<strong>第二步，“过滤</strong>”，过滤掉第一步中信息分析步骤中的冗余信息。<strong>最后，对过滤后的信息进行解释</strong>，从而实现细粒度分类。经过关联数据搜索后，将匹配的关联变换回LiDAR坐标系<span class="math inline">\(\mathrm{L}\)</span>，消除地图物理尺寸的影响，并在该帧中进行可定位性分析</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687750438-0.png"></p><h2 id="信息分析">信息分析</h2><h3 id="eigenanalysis">Eigenanalysis</h3><p>信息分析从优化问题的Hessian矩阵的特征分析开始。对于点到面ICP成本函数矩阵的推导，请参考第IV节，其中Hessian为式(3)中的<span class="math inline">\(A^{\prime}\)</span>。根据待优化的变量<span class="math inline">\(\boldsymbol{x}\)</span>的含义，Hessian可以划分为子矩阵：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687745426-0.png"></p><p>这里，<span class="math inline">\(\boldsymbol{A}_{r r}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>只包含与旋转变量相关的信息。同样，<span class="math inline">\(\boldsymbol{A}_{t t}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>只包含与平移变量相关的信息。</p><p>利用奇异值分解(SVD)对<span class="math inline">\(\boldsymbol{A}_{t t}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>和<span class="math inline">\(\boldsymbol{A}_{r r}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>进行特征分析。对于旋转和平移分量，特征分解为：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687745530-0.png"></p><p>其中<span class="math inline">\(\boldsymbol{V}_t \in S O(3)\)</span> 和 <span class="math inline">\(\boldsymbol{V}_r \in S O(3)\)</span>是矩阵形式的特征向量。<span class="math inline">\(\Sigma_t \in\left\{\operatorname{diag}(\boldsymbol{v}): \boldsymbol{v} \in \mathbb{R}^n{\geq 0}\right\}\)</span> 和 <span class="math inline">\(\Sigma_r \in\left\{\operatorname{diag}(\boldsymbol{v}): \boldsymbol{v} \in \mathbb{R}^n{\geq 0}\right\}\)</span>分别是以<span class="math inline">\(\boldsymbol{A}_{t t}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>和<span class="math inline">\(\boldsymbol{A}_{r r}^{\prime} \in \mathbb{R}^{3 \times 3}\)</span>的特征值为对角项的对角矩阵。</p><p>有趣的是，<span class="math inline">\(\Sigma_t\)</span> 和 <span class="math inline">\(\Sigma_r\)</span>中的特征值提供了与其配对的每个特征向量的信息的直接度量。然而，正如第II节所讨论的，特征值对于不同的环境和传感器可能表现不一致，<strong>因此不直接用于本工作的可定位性估计</strong>。</p><h3 id="information-pair-contribution">Information Pair Contribution</h3><p>信息分析的第二部分是制定每个数据关联对的贡献，定义为<span class="math inline">\(\left({ }_{\mathrm{L}} \boldsymbol{p},{ }_{\mathrm{L}} \boldsymbol{n}\right)\)</span>。需要在数据关联对和成本之间建立正式的关系，以评估数据关联对对成本的贡献。与其他作品[38]、[39]、[60]相似，本文选择优化的雅可比矩阵作为贡献指标。</p><p>可以直观地看到，式(2)中定义的雅可比矩阵A，根据定义度量了优化变量<span class="math inline">\(\boldsymbol{X}_i\)</span>的代价变化。</p><p><strong>Analogy to Classical Mechanics</strong></p><p>与经典力学类似，雅可比矩阵测量由每个数据关联对局部引起的影响的大小。 一个扳手系统由力和扭矩组成：在给出的应用中，可以认为这对作用力和扭矩作用于解<span class="math inline">\(\boldsymbol{x}\)</span>，在本例中，对解进行平移的力定义为表面法向量<span class="math inline">\(n\)</span>，对解进行旋转的扭矩定义为<span class="math inline">\(\boldsymbol{\tau}=\boldsymbol{p} \times \boldsymbol{n}\)</span>。虽然直观，扭矩公式不提供一个可推广的参数化在其简单的形式。点<span class="math inline">\(p\)</span>可以处于不同的距离，导致更远点的扭矩更高，这阻碍了该公式在实际应用中的推广。</p><p>Kwok和Tang[39]研究了这种尺度差异对不同归一化技术的ICP算法的影响。研究表明，最大规范归一化比平均规范归一化表现更好，如[38]或矩归一化所做的那样。</p><p>这对于可靠地解决ICP问题是正确的，其中需要点之间的空间关系。然而，对于局部化估计的逐点贡献计算，情况并非如此。考虑到这一事实以及点范数不应直接影响贡献值的要求，本工作提出使用矩归一化，将扭矩值映射到单位球(如式(5)所示)。</p><p><strong>Information Matrix</strong></p><p>为了数值稳定性，如果<span class="math inline">\(|\boldsymbol{\tau}|\)</span>接近于零(即，向量接近平行)，信息对被丢弃，(这发生在平面法向量直接指向传感器坐标系) 【此处个人感觉描述有误，这应该发生在平面法向量与关联点与世界坐标系原点的连线平行的时候，叉乘为0】。</p><p>此外，矩归一化仅适用于<span class="math inline">\(|\boldsymbol{\tau}| \geq 1\)</span>的信息对，防止转矩值在单位球内的映射，因为这可能会推动<code>Loc.-Module</code>走向乐观可定位性检测。</p><p>在转矩向量的矩归一化之后，将扳手系统堆叠为所有可用的信息对，形成如下信息矩阵：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687747900-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{F}_r \in \mathbb{R}^{N \times 3}\)</span> 和 <span class="math inline">\(\mathcal{F}_t \in \mathbb{R}^{N \times 3}\)</span>分别是旋转和平移信息矩阵</li></ul><p>信息分析的最后一个任务是从<span class="math inline">\(\mathcal{F}_r \in \mathbb{R}^{N \times 3}\)</span> 和 <span class="math inline">\(\mathcal{F}_t \in \mathbb{R}^{N \times 3}\)</span>计算可定位性贡献</p><p><strong>Localizability Contributions</strong></p><p>可定位性概念在每个特征值的特征空间中定义，因此，对于每个特征向量方向都可以得到，这确保了检测不会受到激光雷达或机器人在环境中的朝向的影响，这是实际应用中的一个关键优势。因此，等式 (5) 中定义的信息矩阵被投影到平移和旋转 Hessian 的特征空间中。为了实现这一点，特征向量矩阵<span class="math inline">\(\mathbf{V}_r\)</span> 和 <span class="math inline">\(\mathbf{V}_t\)</span>将按如下方式使用：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687748224-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{I}_r, \mathcal{I}_t \in \mathbb{R}^{N \times 3}\)</span>是所有数据关联对<span class="math inline">\(\{ \boldsymbol{p}, \boldsymbol{n} \}\)</span>的可定位性贡献，经过<span class="math inline">\(\left \{ \mathbf{V}_r, \mathbf{V}_r\right \}\)</span>中的特征向量投影</li><li><span class="math inline">\((\ldots)^{|\cdot|}\)</span>操作符表示向量的每个元素绝对值</li><li>同时，<span class="math inline">\(\mathcal{I}_r\)</span> 和 <span class="math inline">\(\mathcal{I}_t\)</span>中的标量值是某一方向可定位性贡献的直接指标</li></ul><p>如果标量值为<span class="math inline">\(\mathcal{I}(i)=1.0\)</span>，则方向的局部性贡献是完美的，如果<span class="math inline">\(\mathcal{I}(i)=0.0\)</span>，则数据关联对对这个方向的可定位性没有贡献。</p><h2 id="过滤">过滤</h2><p>给定等式 (6) 中定义的可实现性贡献<span class="math inline">\(\mathcal{I}=\left[\mathcal{I}_r, \mathcal{I}_t\right] \in \mathbb{R}^{N \times 6}\)</span>，过滤步骤的目标是删除冗余信息并使当前信息可解释。</p><p><strong>Filtering Low Contribution</strong></p><p>冗余信息示例如图 3-A 所示，其中红色突出显示的低贡献区域主导了分析，如果可定位性的贡献较小，则可能与测量噪声或特征提取噪声无法区分。此步骤通过使用二进制元素过滤来解决这个问题。过滤操作是一个重新分配操作，定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687749553-0.png"></p><p>其中，</p><ul><li>这里的索引定义为<span class="math inline">\(i \in\{1, \ldots, N\}\)</span> 和 <span class="math inline">\(j \in \{1, \ldots, 6\}\)</span>，</li><li><span class="math inline">\(\mathcal{I}_c{ }^{\prime}\)</span>是过滤后的可定位性贡献向量，它包含所有可靠的可定位性贡献值</li><li>此外，<span class="math inline">\(\kappa_f\)</span>是过滤参数，第一个用户定义的参数。由于该参数捕获不同激光雷达传感器的传感器和特征提取噪声，因此应根据传感器和特征提取进行重新调整</li></ul><p>除Ouster OS0-128外，该参数在所有实验中设置为<span class="math inline">\(\kappa_f=\cos \left(80^{\circ}\right) \approx 0.1736\)</span>，考虑到Ouster OS0-128与Velodyne VLP-16相比不同的噪声特性；Ouster LiDAR 测量受到更高的方差的影响，因此，设置为<span class="math inline">\(\kappa_f = \cos \left(60^{\circ}\right)=0.5\)</span>以实现更积极的过滤。</p><p><strong>Filtering High Contribution</strong></p><p>使用这种过滤后的可本地化贡献<span class="math inline">\(\mathcal{I}_c^{\prime}\)</span>（大于阈值<span class="math inline">\(\kappa_f\)</span> 的贡献），可以结合起来总结可用的几何信息：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687750065-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{L}_c \in \mathbb{R}^{1 \times 6}\)</span>是所有可靠数据关联对的可定位性的贡献求和后的向量。</li></ul><p>更多的对应关系表明可用的信息更高。同时，更多的对应关系还包括更多的传感器和特征提取噪声。V-B1 节的过滤步骤充当<strong>异常值拒绝步骤</strong>，并有助于减少这些影响。矩阵 <span class="math inline">\(\mathcal{I}_{\boldsymbol{c}}{ }^{\prime}\)</span> 仍然包含弱但可靠的贡献，需要保留。</p><p>然而，仍然需要衡量最强的贡献来识别可定位性更细粒度的状态，这个过滤步骤基于几何向量对齐；只有大于<span class="math inline">\(\cos \left(45^{\circ}\right) \approx 0.707\)</span>的对齐值才会被认为是强有力的贡献，通过几何关系证明。在图 3-B 中，可视化了强对齐区域和弱对齐区域与特征向量的分离。内绿色锥表示向量对齐强的区域，黄色区域表示弱区域。这种分离公式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/26/1687750410-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{L}_s \in \mathbb{R}^{1 \times 6}\)</span>是是强可定位性的贡献向量。与组合可定位性贡献<span class="math inline">\(\mathcal{L}_c(j)\)</span>类似，该表达式也受到 N 变化的影响，但是它对传感器噪声不太敏感，仅受特征提取误差的影响</li></ul><p>这些强可定位性的贡献向量<span class="math inline">\(\mathcal{L}_s\)</span>和组合可定位性贡献向量<span class="math inline">\(\mathcal{L}_c\)</span>对于下一步至关重要，其中这些向量将用于对可定位性进行分类</p><h2 id="categorization">Categorization</h2><p><code>Loc.-Module</code>的最后一步将根据上一步的信息，提供了可定位性分类</p><h3 id="可定位性参数">可定位性参数</h3><p>为了实现这一目标，引入了三个可定位性参数：</p><ul><li>参数<span class="math inline">\(\kappa_1\)</span>是定义完全可定位的下界的安全可定位阈值</li><li>参数<span class="math inline">\(\kappa_2\)</span>调节从可定位到部分可定位的转换，并表示部分可定位的阈值上限</li><li>参数<span class="math inline">\(\kappa_3\)</span>是最小信息阈值，涵盖了环境稀疏但对齐良好的信息的情况，并调节从部分可定位到不可定位的转换。</li></ul><h3 id="参数选择">参数选择</h3><p>这些阈值的定义提供了参数之间的自然界限，<span class="math inline">\(\kappa_1 \geq \kappa_2&gt;\kappa_3\)</span>。这些参数是根据所采用的ICP算法的收敛范围来设置的。</p><p>参数设置规则如下:</p><ul><li>由于<span class="math inline">\(\kappa_1\)</span>设置了可本地化和{partial-localizability, non-localizable}之间的边界，它可以设置为任意高。唯一的缺点是可定位性检测的计算成本，一个示例：<span class="math inline">\(\kappa_1 = 500\)</span>表示ICP优化运行至少500个完美的匹配对。</li><li>另一方面，设置<span class="math inline">\(\kappa_2\)</span>是一种系统特性选择。它与<span class="math inline">\(\kappa_3\)</span>共同定义了如何处理局部可定位性。它应该设置在<span class="math inline">\(\kappa_1\)</span>和<span class="math inline">\(\kappa_3\)</span>之间。</li><li>最后，<span class="math inline">\(\kappa_3\)</span>设置了部分可定位和不可定位状态的边界。值为50表明允许约束ICP优化以最少50个采样对的受控方式运行</li></ul><p>利用这些直觉，在本工作的其余部分，将第7节中所有环境和传感器的可定位性参数设置为<span class="math inline">\(\kappa_1= 250\)</span>， <span class="math inline">\(\kappa_2 = 180\)</span>和<span class="math inline">\(\kappa_3 = 35\)</span>。</p><p>### 决策树</p><p>在决策树中使用这些参数来获得如图3-C所示的可定位性类别。决策树以过滤后的可定位性贡献向量和特征向量作为输入。决策树按特征向量操作;因此，对所有6个方向重复所需的二进制比较。</p><p>首先，通过比较<span class="math inline">\(\kappa_1\)</span> 与<span class="math inline">\(\mathcal{L}_c\)</span>、<span class="math inline">\(\kappa_2\)</span> 与<span class="math inline">\(\mathcal{L}_s\)</span>，验证优化问题是否在特征向量方向上可解。如果这些比较中的任何一个表明问题是良好约束的，那么该方向是可定位的，<span class="math inline">\(\Omega_{\boldsymbol{v}_j}=\)</span> full.。</p><p>其次，假设第一步的比较表明问题没有很好的约束；在这种情况下，将<span class="math inline">\(\kappa_2\)</span>与<span class="math inline">\(\mathcal{L}_c\)</span>进行比较，将<span class="math inline">\(\kappa_3\)</span>与<span class="math inline">\(\mathcal{L}_s\)</span>进行比较，以了解优化问题中是否存在可挽救的信息。</p><p>如果这些比较中的任何一个成立，可定位性类别被分配为partial，即部分可定位， <span class="math inline">\(\Omega_{\boldsymbol{v}_j}=\)</span> partial，否则，则表示是不可定位<span class="math inline">\(\Omega_{\boldsymbol{v}_j}=\)</span> none</p><p>### Xs-ICP - Simplified X-ICP</p><p>...</p><p># 考虑可定位性的优化模块</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;x-icp-localizability-aware-lidar-registration-for-robust-localization-in-extreme-environments&quot;&gt;X-ICP: Localizability-Aware LiDAR Reg
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>POINT-LIO论文阅读</title>
    <link href="http://yoursite.com/2023/06/14/POINT-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/06/14/POINT-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-06-14T14:15:53.000Z</published>
    <updated>2023-06-19T12:33:40.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="point-lio-robust-high-bandwidth-light-detection-and-ranging-inertial-odometry">Point-LIO: Robust High-Bandwidth Light Detection and Ranging Inertial Odometry</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/06/14/1686752158-0.png" alt="Clipboard 2023年6月14日 22.15"><figcaption aria-hidden="true">Clipboard 2023年6月14日 22.15</figcaption></figure><h1 id="摘要">摘要</h1><p>一种鲁棒、高带宽的光探测和测距(LiDAR)惯性里程计，具有估计极激进的机器人运动的能力。Point-LIO有两个关键的新颖之处，第一个是逐点LIO框架，更新与每个LiDAR点测量对应的状态，该框架允许极高频率的里程表输出，显著增加了里程表带宽，并从根本上消除了人为的帧内运动畸变；第二个是随机过程增强的运动学模型，将IMU测量作为输出建模。这种新的建模方法即使在惯性测量单元(IMU)测量在运动中间饱和的情况下，也能对猛烈运动进行准确的定位和可靠的建图。</p><p>各种现实世界的实验进行了性能评估。总体而言，Point-LIO能够在超出IMU测量范围的剧烈振动和高角速度(75 rad/s)的剧烈运动下提供准确的高频里程计(4-8 kHz)和可靠的测绘。此外，还进行了详尽的基准比较。Point-LIO始终如一地达到相当的精度和时间消耗。最后，给出了Point-LIO的两种应用实例，一种是竞速无人机，另一种是自旋无人机，两者都具有激进的运动。</p><h1 id="介绍">介绍</h1><h2 id="现有畸变矫正方法以及局限性">现有畸变矫正方法以及局限性</h2><h1 id="系统概览">系统概览</h1><p>我们的设计理念是真实地认识到:1)LiDAR点是在各自时间按顺序采样的，而不是同时采样的帧;2)IMU数据是系统的测量数据，而不是系统的输入。一旦接收到各自的测量值(每个LiDAR点或IMU数据)，我们将这两个测量值融合在一个流形EKF框架[55]中。</p><p>我们设计的系统的概述如图1所示;顺序采样的LiDAR点和IMU数据都用于在各自的时间戳更新状态，从而导致极高速率的里程计输出，即在实践中为4-8 kHz。特别是，对于接收到的每个LiDAR点，从地图中搜索相应的平面。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/14/1686752971-0.png" alt="Clipboard 2023年6月14日 22.29"><figcaption aria-hidden="true">Clipboard 2023年6月14日 22.29</figcaption></figure><p>如果点与地图中的平面匹配，将计算残差使用流形卡尔曼滤波器来更新系统状态。优化后的姿态最终将LiDAR点注册到全局坐标系中，并合并到地图上，然后进行下一个测量(LiDAR点或IMU数据)。否则，如果点没有匹配的平面，则通过卡尔曼滤波器预测的姿态直接添加到地图中。为了在允许新配准点的同时实现快速平面对应搜索，我们使用了最初在fast - lio2中开发的增量k-d树结构ikd-Tree。[29]对于每次IMU测量，IMU的每个通道的饱和度检查是单独进行的，具有饱和值的通道不会被用于状态更新。</p><h1 id="状态估计">状态估计</h1><p>Point-LIO的状态估计是一个紧耦合的流形卡尔曼滤波器。在这里，我们简要地解释滤波器的基本公式和工作流程，并参考[55]对流形上卡尔曼滤波器进行更详细的理论解释。</p><h2 id="符号约定">符号约定</h2><p>为了便于解释，我们采用如下符号</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686760055-0.png" alt="Clipboard 2023年6月15日 00.27"><figcaption aria-hidden="true">Clipboard 2023年6月15日 00.27</figcaption></figure><h2 id="动态模型">动态模型</h2><h3 id="状态转移模型">状态转移模型</h3><p>以IMU框架(记为I)为机体系，第一帧IMU坐标系为全局坐标系(记为G)，连续运动模型为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686760787-0.png" alt="Clipboard 2023年6月15日 00.39"><figcaption aria-hidden="true">Clipboard 2023年6月15日 00.39</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\({ }^G \mathbf{R}_I,{ }^G \mathbf{p}_I\)</span>, and <span class="math inline">\({ }^G \mathbf{v}_I\)</span>分别表示imu的姿态、位置和速度在全局坐标系的表示</li><li><span class="math inline">\({ }^G \mathbf{g}\)</span>表示重力向量在全局坐标系的表示（第一帧IMU坐标系）</li><li><span class="math inline">\(b_g\)</span> and <span class="math inline">\(b_a\)</span>建模为受高斯噪声<span class="math inline">\(\mathbf{n}_{\mathrm{b}_{\mathrm{g}}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{b}_{\mathrm{g}}}\right)\)</span> and <span class="math inline">\(\mathbf{n}_{\mathrm{b}_{\mathrm{a}}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{b}_{\mathrm{a}}}\right)\)</span>影响的imu bias，具有随机游走的性质</li><li><span class="math inline">\(\lfloor\mathbf{a}\rfloor\)</span>记号表示关于向量<span class="math inline">\(a \in \mathbb{R}^3\)</span>的反对称矩阵</li><li><span class="math inline">\({ }^I \boldsymbol{\omega}\)</span> and <span class="math inline">\({ }^I \mathbf{a}\)</span>分别表示imu在body系的测量值。</li></ul><p>如文献[14]所提出的，机器人的某个运动(角速度<span class="math inline">\({ }^I \boldsymbol{\omega}\)</span>和线加速度<span class="math inline">\({ }^I \mathbf{a}\)</span>)总是可以被视为信号集合或集合的一个样本，这使我们能够通过<strong>随机过程统计</strong>地描述机器人的运动。</p><p>此外，如文献[14]所述，由于机器人系统的运动通常具有一定的平滑性(例如，由于执行器的延迟)，角速度和加速度的快速变化相对不太可能，并且n阶积分器随机过程通常足以满足实际使用。</p><p>特别地，我们选择了由高斯噪声<span class="math inline">\(\mathbf{w}_{\mathrm{g}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{g}}\right)\)</span> 和 <span class="math inline">\(\mathbf{w}_{\mathrm{a}} \approx \mathcal{N}\left(\mathbf{0}, \mathcal{Q}_{\mathrm{a}}\right)\)</span>驱动的一阶积分器模型来分别模拟角速度<span class="math inline">\({ }^I \boldsymbol{\omega}\)</span>和线性加速度<span class="math inline">\({ }^I \mathbf{a}\)</span>。</p><p>然后将连续时间模型(2)在每个测量步骤k处离散化。表示<span class="math inline">\(\Delta t_k\)</span>为当前测量间隔，即之前测量(IMU数据或LiDAR点)与当前测量(IMU数据或LiDAR点)之间的时间差。对连续模型(2)进行离散化，假设输入在区间<span class="math inline">\(\Delta t_k\)</span>内保持恒定（加速度、角速度），得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686761972-0.png" alt="Clipboard 2023年6月15日 00.59"><figcaption aria-hidden="true">Clipboard 2023年6月15日 00.59</figcaption></figure><p>其中，流形<span class="math inline">\(\mathcal{M}\)</span>，函数<span class="math inline">\(\mathbf{f}\)</span>，状态<span class="math inline">\(\mathbf{x}\)</span>以及过程噪声<span class="math inline">\(\mathbf{w}\)</span>定义为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686762069-0.png" alt="Clipboard 2023年6月15日 01.01"><figcaption aria-hidden="true">Clipboard 2023年6月15日 01.01</figcaption></figure><p>其中，<span class="math inline">\(\mathcal{Q}=\operatorname{diag}\left(\mathcal{Q}_{\mathrm{b}_{\mathrm{g}}}, \mathcal{Q}_{\mathrm{b}_{\mathrm{a}}}, \mathcal{Q}_{\mathrm{g}}, \mathcal{Q}_{\mathrm{a}}\right)\)</span>是过程噪声<span class="math inline">\(\mathbf{w}\)</span>的协方差矩阵。</p><h3 id="测量模型">测量模型</h3><p>该系统有两个测量，一个激光雷达点或IMU数据(由角速度和加速度组成)。这两个测量通常是系统在不同时间采样和接收的，因此我们分别对它们进行建模。</p><p>假设 LiDAR 系与Body（即 IMU）系重合，或者具有预先标定的外参，一个雷达点<span class="math inline">\({ }^I \mathbf{p}_{\mathrm{m}_k}\)</span>等于局部IMU坐标系的真实位置<span class="math inline">\({ }^I \mathbf{p}_k^{\mathrm{gt}}\)</span>，但是，实际上我们并不知道对应局部IMU坐标系的点的真实位置，我们假设该值受高斯噪声<span class="math inline">\(\mathbf{n}_{\mathrm{L}_k} \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_{\mathrm{L}_k}\right)\)</span>的影响，因此有：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832451-0.png"></p><p>这个真正的点，在使用真实(但未知)IMU位姿<span class="math inline">\({ }^G \mathbf{T}_{I_k}=\left({ }^G \mathbf{R}_{I_k},{ }^G \mathbf{p}_{I_k}\right)\)</span>投影到全局坐标系后，应该恰好位于地图中的局部小平面补丁上(见图2)，即有：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832535-0.png"></p><p>其中，</p><ul><li><span class="math inline">\({ }^G \mathbf{u}_k\)</span>是关联平面的法向量</li><li><span class="math inline">\({ }^G \mathbf{q}_k\)</span>是平面上任意点</li><li>注意，<span class="math inline">\({ }^G \mathbf{T}_{I_k}\)</span>被包含在状态向量<span class="math inline">\(\mathbf{X}_k\)</span>中，式（6）对状态向量<span class="math inline">\(\mathbf{X}_k\)</span>施加隐式测量模型</li></ul><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832936-0.png"></p><p>IMU测量由角速度测量(<span class="math inline">\({ }^I \mathbf{\omega}_{\mathrm{m}}\)</span>)和加速度测量(<span class="math inline">\({ }^I \mathbf{a}_{\mathrm{m}}\)</span>)组成：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832699-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{n}_{\mathrm{g}} \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_{\mathrm{g}}\right) \quad\)</span> 和 <span class="math inline">\(\quad \mathbf{n}_{\mathrm{a}} \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_{\mathrm{a}}\right)\)</span>是高斯噪声</li><li>那么，记<span class="math inline">\(\mathbf{n}_I=\left[\begin{array}{ll}\mathbf{n}_{\mathrm{g}}^T &amp; \mathbf{n}_{\mathrm{a}}^T\end{array}\right]^T \approx \mathcal{N}\left(\mathbf{0}, \mathscr{R}_I\right) = \mathcal{N}\left(\mathbf{0}, \operatorname{diag}\left(\mathscr{R}_{\mathrm{g}}, \mathscr{R}_{\mathrm{a}}\right)\right)\)</span>表示为IMU的测量噪声</li></ul><p>因此，状态方程 (2) 中分开的两个状态 <span class="math inline">\(\omega\)</span>、<span class="math inline">\(b_g\)</span>（类似地 <span class="math inline">\(a\)</span>、<span class="math inline">\(b_a\)</span>）现在在角速度测量<span class="math inline">\(\boldsymbol{\omega}_{\mathrm{m}}\)</span>（或加速度测量 <span class="math inline">\(\mathbf{a}\)</span>）中相关，综上所述，系统的测量模型可以用以下紧凑形式呈现：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686832919-0.png"></p><h2 id="扩展卡尔曼滤波器">扩展卡尔曼滤波器</h2><p>紧密耦合EKF用于Point-LIO的状态估计。本节将介绍EKF的工作流程</p><h3 id="状态传播">状态传播</h3><p>假设我们已经收到了最多步骤 k 的测量，并且该时间步的更新状态是<span class="math inline">\(\overline{\mathbf{X}}_k\)</span>以及更新的协方差矩阵 <span class="math inline">\(\overline{\mathbf{P}}_k\)</span>。通过设置<span class="math inline">\(\mathbf{w}_k=\mathbf{0}\)</span>，根据公式(3)中的状态转换模型，可以得到从时间步k到下一次观测时间步k+1的状态传播，即：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686833324-0.png"></p><p>协方差传播如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686833348-0.png"></p><p>其中<span class="math inline">\(\mathcal{Q}_k\)</span>为过程噪声<span class="math inline">\(\mathbf{W}_k\)</span>的协方差，矩阵<span class="math inline">\(\mathbf{F}_{\mathbf{x}_k}, \mathbf{F}_{\mathbf{w}_k}\)</span>计算如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/15/1686833412-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{k+1}\)</span>是时间步k+1的真实状态向量</li><li><span class="math inline">\(\mathbf{F}_{11}=\operatorname{Exp}\left(-{ }^I \overline{\boldsymbol{\omega}}_k \Delta t_k\right)\)</span></li><li><span class="math inline">\(\mathbf{F}_{38}={}^G \overline{\mathbf{R}}_{I_k} \Delta t_k\)</span></li></ul><h3 id="残差计算">残差计算</h3><p><strong>激光测量</strong></p><p>利用卡尔曼滤波(9)预测的位姿<span class="math inline">\({ }^G \hat{\mathbf{T}}_{I_{k+1}}=\left({ }^G \hat{\mathbf{R}}_{I_{k+1}},{ }^G \hat{\mathbf{p}}_{I_{k+1}}\right)\)</span>，我们将测量的LiDAR点<span class="math inline">\({ }^I \mathbf{p}_{\mathrm{m}_{k+1}}\)</span>投影到全局坐标系，得到<span class="math inline">\({ }^G \hat{\mathbf{p}}_{k+1}={ }^G \hat{\mathbf{R}}_{I_{k+1}}{ }^I \mathbf{p}_{\mathrm{m}_{k+1}}+{ }^G \hat{\mathbf{p}}_{I_{k+1}}\)</span>，并在由ikd-tree构造的地图结构中搜索其最近的5个点(距离<span class="math inline">\({ }^G \hat{\mathbf{p}}_{k+1}\)</span> 5米以内)</p><p>然后使用找到的最近邻点拟合具有法向量<span class="math inline">\({ }^G \mathbf{u}_{k+1}\)</span>和质心<span class="math inline">\({ }^G \mathbf{q}_{k+1}\)</span>的局部小平面块，如测量模型所示（参见公式（6）和图 2）。</p><p>如果最近的五个点不位于拟合平面路径上(即任何点到平面的距离大于0.1 m)，则当前LiDAR点<span class="math inline">\({ }^G \hat{\mathbf{p}}_{k+1}\)</span>的测量直接合并到地图中，而不需要残差计算或状态更新。 【？？？？】</p><p>否则，如果局部平面成功拟合，则根据式(8)计算残差<span class="math inline">\(\left(\mathbf{r}_{\mathrm{L}_{k+1}}\right)\)</span>如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175048-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\delta \mathbf{x}_{k+1}=\mathbf{x}_{k+1} \boxminus \hat{\mathbf{x}}_{k+1}\)</span></li><li><span class="math inline">\(\mathbf{x}_{k+1}\)</span>是时间步K+1的真值状态向量</li></ul><p>并且，</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175169-0.png"></p><p><strong>IMU测量</strong></p><p>对于IMU测量，我们首先通过检查当前测量与额定测量范围之间的差距来评估IMU的任何通道是否饱和，如果差值太小，则IMU测量通道的测量值被丢弃而不用于更新状态。然后，收集不饱和IMU通道的加速度和角速度测量，根据式(7)计算IMU残差<span class="math inline">\(\left(\mathbf{r}_{I_{k+1}}\right)\)</span>，为了简化符号，我们在这里使用所有6个通道测量)：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175480-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\delta \mathbf{x}_{k+1}=\mathbf{x}_{k+1} \boxminus \hat{\mathbf{x}}_{k+1}\)</span></li><li><span class="math inline">\(\mathbf{x}_{k+1}\)</span>是时间步K+1的真值状态向量</li></ul><p>并且，</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175569-0.png"></p><p>综上所述，从激光雷达点测量(12)或IMU测量(14)的残差与状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>相关，通过以下关系，各自的测量噪声为：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687175653-0.png"></p><p>其中，</p><p>对于激光点测量，我们有：</p><ul><li><span class="math inline">\(\mathbf{r}_{k+1}=\mathbf{r}_{L_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{H}_{k+1}=\mathbf{H}_{\mathrm{L}_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{D}_{k+1}=\mathbf{D}_{\mathrm{L}_{k+1}}\)</span></li><li><span class="math inline">\(\mathscr{R}_{k+1}=\mathscr{R}_{L_{k+1}}\)</span></li></ul><p>对于IMU测量，我们有：</p><ul><li><span class="math inline">\(\mathbf{r}_{k+1}=\mathbf{r}_{I_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{H}_{k+1}=\mathbf{H}_{\mathrm{I}_{k+1}}\)</span></li><li><span class="math inline">\(\mathbf{D}_{k+1}=\mathbf{D}_{\mathrm{I}_{k+1}}\)</span></li><li><span class="math inline">\(\mathscr{R}_{k+1}=\mathscr{R}_{I_{k+1}}\)</span></li></ul><h3 id="状态更新">状态更新</h3><p>式(9) 中的传播状态<span class="math inline">\(\hat{\mathbf{x}}_{k+1}\)</span> 和 (10) 中的协方差<span class="math inline">\(\hat{\mathbf{P}}_{k+1}\)</span> 对未知状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span> 施加先验高斯分布，如下所示：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176041-0.png"></p><blockquote><p>这里的意思是：误差状态向量服从高斯分布</p></blockquote><p>另外的，观测模型(16)给出了<span class="math inline">\(\mathbf{x}_{k+1}\)</span>的另一个高斯分布形式：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176173-0.png"></p><p>然后将(17)中的先验分布与来自(18)的测量模型相结合，得到状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>的后验分布(等价地用<span class="math inline">\(\delta \mathbf{x}_{k+1}\)</span>表示)：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176281-0.png"></p><p>其中，</p><ul><li><span class="math inline">\(\|\mathbf{x}\|_{\mathbf{A}}^2=\mathbf{x}^T \mathbf{A}^{-1} \mathbf{x}\)</span></li></ul><p>式（19）的优化问题是一个标准的二次规划，可以很容易地得到最优解<span class="math inline">\(\delta \mathbf{x}_{k+1}^0\)</span>，这本质上是卡尔曼更新[56]：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176377-0.png"></p><p>然后，更新状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176441-0.png"></p><p>更新后的状态将用于下一步传播，为此，我们还需要估计状态的协方差（上面的是误差状态的协方差），用<span class="math inline">\(\overline{\mathbf{P}}_{k+1}\)</span>表示，最优状态与状态真值之间的误差表示如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/06/19/1687176789-0.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;point-lio-robust-high-bandwidth-light-detection-and-ranging-inertial-odometry&quot;&gt;Point-LIO: Robust High-Bandwidth Light Detection and 
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>速度坐标系转换</title>
    <link href="http://yoursite.com/2023/04/26/%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2023/04/26/%E5%85%B3%E4%BA%8E%E9%80%9F%E5%BA%A6%E5%9D%90%E6%A0%87%E7%B3%BB%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-04-26T02:21:53.000Z</published>
    <updated>2023-05-15T06:15:28.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="速度坐标系转换">速度坐标系转换</h1><h2 id="问题描述">问题描述</h2><p>在做滤波器的时候，通常会遇到这样一个问题，轮速计通常安装在车辆后轴轮毂上，得到的速度通常标记为后轴中心的速度。然而IMU并不一定安装在车辆后轴中心，此时如果需要使用轮速做观测，则需要进行速度坐标系转换，即把轮速转化为IMU的速度观测。</p><h2 id="转换关系">转换关系</h2><p>假设已知后轴中心与IMU的外参关系：</p><ul><li><span class="math inline">\(R_{rear}^{imu}\)</span> 和 <span class="math inline">\(t_{rear}^{imu}\)</span>组合表示为后轴中心<code>rear</code>在IMU坐标系的位姿</li><li>即<span class="math inline">\(p_{imu} = R_{rear}^{imu} p_{rear} + t_{rear}^{imu}\)</span>把后轴中心坐标系的某个点<span class="math inline">\(p_{rear}\)</span>转换到IMU坐标系，得到点<span class="math inline">\(p_{imu}\)</span></li></ul><p>假设已知后轴中心的速度<span class="math inline">\(v_{rear}\)</span>，和后轴中心角速度<span class="math inline">\(\omega_{rear}\)</span>，那么IMU的速度<span class="math inline">\(v_{imu}\)</span>可表示为：</p><p><span class="math display">\[    v_{imu} = R_{rear}^{imu} v_{rear} - [R_{rear}^{imu} \omega_{rear}]_{\times}t_{rear}^{imu}\]</span></p><p>如果直接使用IMU的角速度<span class="math inline">\(\omega_{i}\)</span>，则可表示为：</p><p><span class="math display">\[    v_{imu} = R_{rear}^{imu} v_{rear} - [\omega_{i}]_{\times}t_{rear}^{imu}\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;速度坐标系转换&quot;&gt;速度坐标系转换&lt;/h1&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;在做滤波器的时候，通常会遇到这样一个问题，轮速计通常安装在车辆后轴轮毂上，得到的速度通常标记为后轴中心的速度。然而IMU并不一定安装在车辆后轴中心，此时如果需要使用轮
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>SR-LIO论文阅读</title>
    <link href="http://yoursite.com/2023/04/20/SR-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2023/04/20/SR-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2023-04-20T10:01:53.000Z</published>
    <updated>2023-04-20T12:56:02.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sr-lio-lidar-inertial-odometry-with-sweep-reconstruction">SR-LIO: LiDAR-Inertial Odometry with Sweep Reconstruction</h1><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681988241-0.png"></p><h1 id="摘要">摘要</h1><blockquote><p>此论文所述的BA不是对激光多帧的BA，而是多传感器融合的最小二乘。</p></blockquote><p>基于改进的束平差(BA)框架，提出了一种新型激光雷达惯性里程计(LIO)，命名为SR-LIO。SR-LIO的核心是一种新的扫描重建方法，该方法对旋转激光雷达的原始输入扫描进行分割和重建，以获得更高频率的重建扫描。该方法可以有效缩短每次IMU预积分的时间间隔，减小IMU预积分误差，实现基于BA的LIO优化。为了使重建扫描期间的所有状态都能均匀优化，我们进一步提出了多段联合LIO优化，该优化允许每个扫描段的状态同时受到LiDAR和IMU的约束。在三个公共数据集上的实验结果表明，我们的SR-LIO在精度上优于所有现有的最先进的方法，通过提出的扫描重建来减少IMU预积分误差对于基于BA的LIO框架的成功非常重要。</p><h1 id="介绍">介绍</h1><p>本文提出了一种扫描重建方法，即对自旋激光雷达的原始输入扫描进行分割和重建，以获得更高频率的重建扫描。具体而言，扫描重建方法利用旋转激光雷达连续扫描的特性，将每次全扫描分割为3个扫描段，然后将每个扫描段与接下来的2个扫描段依次连接，得到重构的全扫描(如图1所示)。对每个扫描段执行上述步骤后，每个原始扫描变成3个重构的全扫描，其频率提高3倍。增加的频率缩短了两次连续扫描之间的时间间隔，从而减少了IMU预集成的误差。因此，扫描重构不仅可以提高扫描频率，还可以通过减小IMU预积分误差来提高LIO联合优化的精度。</p><p>我们在前期的研究中发现，基于BA的框架对IMU预积分误差非常敏感。为了解决这个问题，我们将提出的扫描重建方法集成到基于ba的LIO系统中，从而得到SR-LIO。所提出的SR-LIO首先对10 Hz的输入扫频进行下采样，然后进行扫频重构以获得30 Hz的重构扫频。接下来，对于每一次重构扫描，我们执行LIO联合状态优化，其中IMU预积分周期为33ms，但重构后的扫描保持完整的扫描，持续时间为100ms(如图1所示)。为了更好地保持轨迹一致性，我们提出了一种新的多段联合优化方法，该方法充分利用IMU约束和位于每100ms周期的状态变量进行优化。优化当前重构扫描的状态后，将当前重构扫描的点云添加到地图中。由于在连续重建扫描中存在重复点，因此我们以与原始输入扫描相同的频率(10 Hz)执行地图更新，以防止重复添加相同的点云。</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681988552-0.png"></p><p>总结起来，本工作的主要贡献有三个方面:</p><ul><li>提出了一种扫描重构方法，提高了LIO系统中激光雷达自旋扫描频率，降低了IMU预集成误差;</li><li>我们将所提出的扫描重建方法嵌入到新设计的基于BA的LIO系统中，实现了先进的扫描重建精度</li><li>开源</li></ul><h1 id="符号约定">符号约定</h1><h2 id="坐标系统">坐标系统</h2><p>我们记<span class="math inline">\((\cdot)^w,(\cdot)^l\)</span> and <span class="math inline">\((\cdot)^o\)</span>分别表示世界坐标系、激光雷达坐标系、IMU坐标系下的3D点。世界坐标在起始位置与<span class="math inline">\((\cdot)^o\)</span>重合。</p><p>我们记在时间<span class="math inline">\(t_i\)</span>执行激光扫描的激光坐标系为<span class="math inline">\(l_i\)</span>，那么其对应的IMU坐标为<span class="math inline">\(o_i\)</span>，那么（以外参而言）从<span class="math inline">\(l_i\)</span>到<span class="math inline">\(o_i\)</span>的转换矩阵记为<span class="math inline">\(\mathbf{T}_{l_i}^{o_i} \in S E(3)\)</span>:</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681989437-0.png"></p><p>其中，<span class="math inline">\(\mathbf{T}_{l_i}^{o_i} \in S E(3)\)</span>包含了一个旋转矩阵<span class="math inline">\(\mathbf{R}_{l_i}^{o_i} \in S O(3)\)</span>和平移向量<span class="math inline">\(\mathbf{t}_{l_i}^{o_i} \in \mathbb{R}^3\)</span>。</p><blockquote><p>外参通常离线校准一次，并在在线姿态估计期间保持不变。因此，为了简单起见，我们可以使用<span class="math inline">\(\mathbf{T}_{l}^{o}\)</span>表示<span class="math inline">\(\mathbf{T}_{l_i}^{o_i}\)</span></p></blockquote><p>在下面的语句中，为了简化符号，我们省略了表示坐标系的索引。例如，从IMU坐标到世界坐标的姿态被严格定义为<span class="math inline">\(\mathbf{T}_{o_i}^w\)</span>，但为了简单起见表示为<span class="math inline">\(T^w_i\)</span></p><p>除了位姿，我们还估计了速度v、加速度计偏置ba和陀螺仪偏置bg，它们由状态向量均匀表示:</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681989702-0.png"></p><h2 id="扫描状态表达">扫描状态表达</h2><p>受CT-ICP[6]的启发，我们表示一个扫描的状态：</p><ul><li>（1）扫描起始时刻<span class="math inline">\(t_b\)</span>的状态<span class="math inline">\(\left.S \text { (e.g., } \boldsymbol{x}_b\right)\)</span></li><li>（2）扫描结束时刻<span class="math inline">\(t_e\)</span>的状态<span class="math inline">\(S\)</span> (e.g., <span class="math inline">\(\left.\boldsymbol{x}_e\right)\)</span></li><li>因此，在<span class="math inline">\(\left[t_b, t_e\right]\)</span>时间区间内的点云，可以表示为关于<span class="math inline">\(\boldsymbol{x}_b\)</span>和<span class="math inline">\(\boldsymbol{x}_e\)</span>的函数，例如，在时间<span class="math inline">\(t_{\mathbf{p}} \in\left[t_b, t_e\right]\)</span>采集点云，那么在此时间段内的状态可以表示为：</li></ul><figure><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681994322-0.png" alt="Clipboard 2023年4月20日 20.38"><figcaption aria-hidden="true">Clipboard 2023年4月20日 20.38</figcaption></figure><p>其中，<span class="math inline">\(\operatorname{slerp}(\cdot)\)</span>表示四元数球面插值。</p><h2 id="imu测量模型">IMU测量模型</h2><p>IMU由加速度计和陀螺仪组成。IMU的原始陀螺仪和加速度计测量值<span class="math inline">\(\hat{\mathbf{a}}_t\)</span> and <span class="math inline">\(\hat{\boldsymbol{\omega}}_t\)</span>表示如下：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681994445-0.png" alt="Clipboard 2023年4月20日 20.40"><figcaption aria-hidden="true">Clipboard 2023年4月20日 20.40</figcaption></figure><p>正如在Vins-Mono[20]中提到的，加速度和陀螺仪测量中的加性噪声可以建模为高斯白噪声，<span class="math inline">\(\mathbf{n}_{\mathrm{a}} \sim N\left(\mathbf{0}, \boldsymbol{\sigma}_{\mathrm{a}}^2\right), \mathbf{n}_{\boldsymbol{\omega}} \sim N\left(\mathbf{0}, \boldsymbol{\sigma}_{\boldsymbol{\omega}}^2\right)\)</span>。加速度偏置和陀螺仪偏置建模为随机游走，其导数为高斯分布，<span class="math inline">\(\dot{\mathbf{b}}_{\mathrm{a}_t}=\mathbf{n}_{\mathbf{b}_{\mathrm{a}}} \sim N\left(\mathbf{0}, \sigma_{\mathbf{b}_{\mathrm{a}}}^2\right)\)</span>，<span class="math inline">\(\dot{\mathbf{b}}_{\omega_t}=\mathbf{n}_{\mathbf{b}_\omega} \sim N\left(\mathbf{0}, \sigma_{\mathbf{b}_\omega}^2\right)\)</span></p><h1 id="扫描重组论文核心">扫描重组（论文核心）</h1><p>扫描重组旨在从10Hz原始输入激光雷达扫描S中获得30Hz重组扫描P，图1说明了我们的核心思想</p><p><img src="https://s1.nsloop.com:58443/images/2023/04/20/1681988552-0.png"></p><p>给定上一帧扫描<span class="math inline">\(S_j\)</span>（扫描起始时刻：<span class="math inline">\(t_{b_j}\)</span>，扫描结束：<span class="math inline">\(t_{e_j}\)</span>）以及当前帧扫描扫描<span class="math inline">\(S_{j+1}（\)</span>起始时刻：<span class="math inline">\(t_{b_{j+1}}\)</span>，扫描结束：<span class="math inline">\(t_{e_{j+1}}\)</span>）,我们假设时间段[<span class="math inline">\(t_{b_j}\)</span>, <span class="math inline">\(t_{e_j}\)</span>]和[<span class="math inline">\(t_{b_{j+1}}\)</span>, <span class="math inline">\(t_{e_{j+1}}\)</span>]的时长都是100ms。基于激光雷达在一段时间内连续采集的特点，我们可以将原始扫描数据包拆分为连续的点云数据流，然后对点云数据流进行复用重新打包，从而获得更高频率的扫描。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sr-lio-lidar-inertial-odometry-with-sweep-reconstruction&quot;&gt;SR-LIO: LiDAR-Inertial Odometry with Sweep Reconstruction&lt;/h1&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>姿态求解系列（一）An analytic solution to Wahba&#39;s problem</title>
    <link href="http://yoursite.com/2023/04/20/%E5%A7%BF%E6%80%81%E6%B1%82%E8%A7%A3%E7%B3%BB%E5%88%97(%E4%B8%80)/"/>
    <id>http://yoursite.com/2023/04/20/%E5%A7%BF%E6%80%81%E6%B1%82%E8%A7%A3%E7%B3%BB%E5%88%97(%E4%B8%80)/</id>
    <published>2023-04-20T10:01:53.000Z</published>
    <updated>2023-06-14T14:13:33.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="an-analytic-solution-to-wahbas-problem">An analytic solution to Wahba's problem</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684158134-0.png" alt="Clipboard 2023年5月15日 21.42"><figcaption aria-hidden="true">Clipboard 2023年5月15日 21.42</figcaption></figure><h1 id="摘要">摘要</h1><p>所有航天器姿态估计方法都是基于<strong>Wahba优化问题</strong>。这个问题可以简化为寻找Davenport矩阵的最大特征值和相应的特征向量。为了降低计算量，提出了<code>QUEST</code>和<code>FOMA</code>等迭代算法。但由于迭代次数不固定，求解结果理论上不准确，计算时间难以预测。最近，有人提出了一种解析解——ESOQ。解析解的优点是计算时间是固定的，在没有数值误差的情况下，理论上解是准确的。在本文中，我们对Wahba问题提出了一种不同的解析解。我们用简单且易于验证的例子表明，该方法在数值上比<code>ESOQ</code>更稳定，比<code>QUEST</code>和<code>FOMA</code>更快。我们还使用了大量的模拟测试来支持这一说法</p><h1 id="介绍">介绍</h1><p>姿态确定是每一个航天器系统成功的关键环节[1]。航天器姿态确定与估计问题是Wahba[2]在1965年提出的一个优化问题。第一种解决方案由Davenport[6]提出。Davenport证明了Wahba的问题等价于寻找所谓k矩阵的最大特征值和对应的特征向量。由于当时的计算机和相关算法还不够强大，无法将Davenport的方法应用到MAGSAT航天器的实时姿态和控制系统中[3]，因此设计了QUEST算法[3]来满足这一需求。此后，QUEST被广泛认可并应用于许多航天器姿态确定和控制系统中，同时还提出了一些其他方法，如ESOQ[4]和FOMA[5]。QUEST和FOMA使用牛顿迭代来寻找以不同方式表示的四次多项式的最大解。尽管QUEST方法的所有飞行经验都是成功的，但[8]表明，通过使用特定的例子，QUEST可能不会收敛。事实上，众所周知，牛顿的方法是不适合一般使用的，因为它可能不能收敛到一个解。即使它确实收敛，它的行为在函数非凸的区域可能是不稳定的[9]。此外，由于QUEST和FOMA的求解依赖于迭代，并且是数值求解，这意味着求解不精确，计算时间不可预测。</p><p>注意到4次多项式(四分次)允许解析解，Mortari设计了Wahba问题的闭式解[4]，其中使用四次根的一组公式代替牛顿方法（四次多项式的根有几组不同的解析公式）。在本文中，我们提出了一个由Shmakov[11]最近发现的替代解析解。Mortari的ESOQ和提出的解决方案的主要区别在于，后者的辅助立方是凹陷形式，而前者的辅助立方不是。因此，基于Shmakov公式的方法更为有效。仿真实验表明，该方法在数值上比ESOQ更稳定，与QUEST相当。</p><h1 id="wahba优化问题描述及其解法">Wahba优化问题描述及其解法</h1><h2 id="wahba的问题">Wahba的问题</h2><p>给定一组单位向量<span class="math inline">\(r_i\)</span>(表示参照系中物体的观测值)和一组单位向量<span class="math inline">\(b_i\)</span>(表示航天器体坐标系中的测量值)，航天器的姿态由满足关系的正交矩阵<span class="math inline">\(A\)</span>定义，即满足：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684159238-0.png" alt="Clipboard 2023年5月15日 22.00"><figcaption aria-hidden="true">Clipboard 2023年5月15日 22.00</figcaption></figure><p>因此，姿态确定问题是寻找使Wahba损失函数最小的正交矩阵A：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684160711-0.png" alt="Clipboard 2023年5月15日 22.25"><figcaption aria-hidden="true">Clipboard 2023年5月15日 22.25</figcaption></figure><h2 id="svd解法">SVD解法</h2><p>此处引用西北工业大学严恭敏老师的《捷联惯导算法与组合导航原理》第7章——初始对准与组合导航技术中的描述：</p><p><img src="https://s1.nsloop.com:58443/images/2023/05/15/1684163313-0.png" alt="Clipboard 2023年5月15日 23.08"> <img src="https://s1.nsloop.com:58443/images/2023/05/15/1684163347-0.png" alt="Clipboard 2023年5月15日 23.09"> <img src="https://s1.nsloop.com:58443/images/2023/05/15/1684163385-0.png" alt="Clipboard 2023年5月15日 23.09"></p><p>参考资料：</p><ul><li>《捷联惯导算法与组合导航原理》第7章</li><li>https://ahrs.readthedocs.io/en/latest/filters/davenport.html</li></ul><h2 id="四元数解法">四元数解法</h2><p>也称<code>Davenport’s q-Method</code></p><p>根据四元数与姿态阵的关系：</p><p><span class="math display">\[\boldsymbol{C}=\left(q_0^2-\boldsymbol{q}_v^{\mathrm{T}} \boldsymbol{q}_v\right) \boldsymbol{I}+2 \boldsymbol{q}_v \boldsymbol{q}_v^{\mathrm{T}}+2 q_0\left(\boldsymbol{q}_v \times\right)\]</span></p><p>可以把上述“SVD解法”中的问题转换为关于四元数Q的目标函数：</p><p><img src="https://s1.nsloop.com:58443/images/2023/05/16/1684242822-0.png" alt="Clipboard 2023年5月16日 21.13"> <img src="https://s1.nsloop.com:58443/images/2023/05/16/1684242862-0.png" alt="Clipboard 2023年5月16日 21.14"></p><p>参考资料：</p><ul><li>《捷联惯导算法与组合导航原理》附录k</li><li>https://ahrs.readthedocs.io/en/latest/filters/davenport.html</li><li><a href="https://ntrs.nasa.gov/citations/19680021122" target="_blank" rel="noopener">Paul B. Davenport. A Vector Approach to the Algebra of Rotations with Applications. NASA Technical Note D-4696. August 1968.</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;an-analytic-solution-to-wahbas-problem&quot;&gt;An analytic solution to Wahba&#39;s problem&lt;/h1&gt;
&lt;figure&gt;
&lt;img src=&quot;https://s1.nsloop.com:58443/
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>【经典文献翻译】Fundamentals of Inertial Navigation</title>
    <link href="http://yoursite.com/2023/03/04/Fundamentals%20of%20Inertial%20Navigation%E7%BF%BB%E8%AF%91/"/>
    <id>http://yoursite.com/2023/03/04/Fundamentals%20of%20Inertial%20Navigation%E7%BF%BB%E8%AF%91/</id>
    <published>2023-03-04T02:59:30.000Z</published>
    <updated>2023-03-05T13:56:43.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fundamentals-of-inertial-navigation-satellite-based-positioning-and-their-integration">Fundamentals of Inertial Navigation, Satellite-based Positioning and their Integration</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/03/04/1677898415-0.png" alt="Clipboard 2023年3月4日 10.53"><figcaption aria-hidden="true">Clipboard 2023年3月4日 10.53</figcaption></figure><h1 id="目录">目录</h1><h2 id="章节介绍">章节介绍</h2><p><strong>第二章</strong></p><p>描述导航的数学、导航中使用的坐标框架以及在适当的坐标中计算导航解决方案所使用的转换。</p><p><strong>第三章</strong></p><p>讨论了GPS，详细介绍了GPS的各个部分、信号结构以及从伪距离和距离测量中估计位置和速度的过程。本文还讨论了在处理GPS数据时可能出现的各种误差。最后详细介绍了如何从星历表数据计算卫星的位置和速度，包括单频GPS接收机的大气校正。</p><p><strong>第四章</strong></p><p>介绍了惯性传感器及其分类、误差、标定、初始化和对准过程，然后描述了惯导系统机械化过程及其方程。</p><p><strong>第五章</strong></p><p>给出了一些基本的运动数学，并详细描述了在各种参考系下的机械化过程，给出了在最常见的导航系中导航参数的一步一步计算。</p><p><strong>第六章</strong></p><p>对惯导系统误差进行建模，并对惯导系统方程进行线性化。</p><p><strong>第七章</strong></p><p>讨论了KF的过程和测量模型、滤波算法、非线性滤波技术以及如何对系统扰动建模。</p><p><strong>第八章</strong></p><p>将所有这些想法与INS/GPS集成的详细描述以及相关的细微差别和微妙之处结合在一起。它描述了集成的类型以及它们的反馈方案。推导了INS动态误差模型方程和惯性传感器误差模型方程，讨论了线性化KF在松耦合和紧耦合INS/GPS融合中的实现。</p><p><strong>第九章</strong></p><p>讨论了轮式车辆的一种可能趋势，即通过使用速度读数来减少低成本惯性传感器的数量，并介绍了不同的约束以消除与6轴imu相关的误差，并实现类似的精度</p><p><strong>第十章</strong></p><p>给出了INS/GPS融合的实验结果。基于真实道路测试轨迹，分析了集成完整IMU(包含所有6个传感器)和简化系统(包含更少传感器)的结果。</p><h1 id="第一章">第一章</h1><h2 id="insgps组合类型">1.6 INS/GPS组合类型</h2><p>已经提出了不同形式的INS/GPS集成体系结构，以获得最大优势，这取决于使用类型和简单程度与鲁棒性。三个主要的集成体系结构是</p><ul><li>松耦合</li><li>紧耦合</li><li>超紧密的或深耦合</li></ul><h3 id="loosely-coupled-insgps-integration">Loosely Coupled INS/GPS Integration</h3><p>在这种架构中，也被称为松耦合，GPS和INS独立工作，并为位置、速度和姿态提供单独的解决方案。为了获得两个解的最佳解，这些信息通过最优估计器融合在一起，以获得第三个和大大改进的解。这种排列方式如图1.6所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/04/1677898696-0.png" alt="Clipboard 2023年3月4日 10.58"><figcaption aria-hidden="true">Clipboard 2023年3月4日 10.58</figcaption></figure><h3 id="tightly-coupled-insgps-integration">Tightly Coupled INS/GPS Integration</h3><p>在这种架构中，也称为集中式集成，GPS和INS作为基本传感器，它们的伪距离和伪距离率的原始输出以及INS的加速度和旋转速率由单个估计器混合，以实现协同解决方案(Yang 2007)。这种排列如图1.7所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/04/1677898910-0.png" alt="Clipboard 2023年3月4日 11.01"><figcaption aria-hidden="true">Clipboard 2023年3月4日 11.01</figcaption></figure><p>如第八章所述，GPS/INS集成可以通过多种方式实现，每种方式都有其优点和局限性</p><h3 id="ultra-tightly-or-deeply-coupled-integration">Ultra-Tightly or Deeply Coupled Integration</h3><p>深度耦合集成增加了INS和GPS之间的共生关系，因为集成是在跟踪环级别。这样做的主要优点是利用多普勒信息在GPS跟踪回路中对host vehicle的动态进行估计和补偿。超紧密集成存在多种构型，图1.8为一种基本构型。估计器将来自GPS的伪距离/多普勒或I(同相)和Q(正交)测量值与INS导航参数结合起来，以呈现估计的多普勒(Alban et al. 2003)。估计的多普勒是用来消除动态从GPS信号进入跟踪环，从而减少载波跟踪环带宽。虽然这种集成更加复杂，需要访问GPS硬件，但它可以提高原始测量的质量和信号的抗干扰性能(Cox Jr 1978)。</p><h1 id="第九章">第九章</h1><h3 id="轮式陆地车辆三维riss的优点">9.3.2 轮式陆地车辆三维RISS的优点</h3><p>3D RISS相对于2D车辆航迹推算解决方案的优势是基于两个加速度计的测量结果用于计算离面运动。主要体现为3个方面：</p><p>（1）第一个好处是计算正确的方位角。这是因为陀螺仪安装在车身并非严格水平，因此测量值并非完全是E-N平面的角速率。由于方位角在E-N平面，检测和修正陀螺仪倾斜的做法比忽略这一影响的二维车辆航迹推算更准确地计算出方位角。</p><p>（2）第二个好处是2D水平定位比2DRISS更精确，原因有二：</p><ul><li>从里程表测量的速度计算两个水平速度时考虑了俯仰角，提供更准确的速度来实现更好的位置估计</li><li>更精确的方位角计算可以更好地估计东向与北向速度</li></ul><p>（3）第三个好处是可以计算上升速度和高度，这是以前无法获得的数据</p><p>与完整的IMU相比，所提出的3D RISS的优点是<strong>通过加速度计而不是陀螺仪计算俯仰和横滚</strong>，并且<strong>通过里程表衍生的速度而不是加速度计计算车辆的速度</strong>。</p><p>为了证明从加速度计而不是陀螺仪来计算俯仰和横滚的优越性，假设陀螺仪中存在一个未补偿的bias，这将在俯仰或横滚中引入与积分产生的时间成正比的角度误差，从而导致INS的misalignment，从而将加速度矢量从机体框架错误地投影到局部框架。进一步的，在局部坐标系的一个水平通道中引入加速度误差，这将产生与<span class="math inline">\(t^2\)</span>成正比的<strong>速度误差</strong>和与<span class="math inline">\(t^3\)</span>成正比的<strong>位置误差</strong>。</p><p>当从加速度计计算俯仰和横摇时，第一次积分被消除，<strong>角度的误差与时间不成比例</strong>。此外，由这些角度误差引起的位置误差的部分将与<span class="math inline">\(t^2\)</span>成比例，而不是<span class="math inline">\(t^3\)</span>。</p><p>除了使用两个加速度计而不是两个陀螺仪来计算俯仰和横滚的优点之外，RISS还进一步改进了速度计算,使用里程表而不是加速度计计算速度(根据施加在陆地车辆上的非完整约束)比使用加速度计计算速度获得更好的性能。这是因为当从加速度计计算速度时，任何未补偿的bias都会在速度上引入与t成正比的误差，在位置上引入与<span class="math inline">\(t^2\)</span>成正比的误差。从里程表计算速度避免了第一次积分，从而使位置计算<strong>只需要一次积分</strong>。这意味着当使用里程表测量时，位置是在一次积分后获得的，<strong>而不是使用加速度计测量连续两次积分</strong>。在长时间的GPS停机中，使用加速度计计算的位置误差将与停机持续时间的平方成正比。</p><p>作为上述两项改进的结果，位置计算的进一步改进将随之而来。使用加速度计计算的roll和pitch误差将导致惯导系统产生misalignment，从而影响速度从body系投影到局部坐标系，使由俯仰和横滚误差引起的位置误差部分与t成正比，而不是与<span class="math inline">\(t^2\)</span>成正比，这是在消除两个陀螺仪的第一个改进中讨论的。</p><p>3D RISS中唯一剩下的主要误差来源是由于方位角陀螺仪造成的方位角误差。这个陀螺仪的未补偿的bias将导致方位角误差与时间成正比。由于这个方位误差而产生的位置误差将与车辆的（速度、积分时间和方位误差）成正比。这必须在积分滤波器内部通过模拟陀螺仪的随机漂移来解决。</p><blockquote><p>此处有一部分轨迹杜比</p></blockquote><h3 id="三维riss运动方程的推导">9.3.3 三维RISS运动方程的推导</h3><p>本节将介绍三维RISS的非线性运动模型，包括位置、速度和姿态状态</p><p>使用通用参考系。所述车辆车身框架的x轴沿横向方向，y轴沿向前纵向方向，z轴沿车辆垂直方向。局部框架是ENU框架，轴沿东、北和垂直(向上)方向。在k-1时刻从车体坐标系变换到局部坐标系的旋转矩阵为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678023702-0.png" alt="Clipboard 2023年3月5日 21.41"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.41</figcaption></figure><p>为了描述运动模型，我们首先需要控制输入。陀螺仪、两个加速度计和里程表提供的传感器测量表示为矢量：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678023792-0.png" alt="Clipboard 2023年3月5日 21.43"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.43</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(v_k^{o d}\)</span>表示轮式里程计计算得到的速度</li><li><span class="math inline">\(a_k^{o d}\)</span>表示轮式里程计推导计算得到的加速度</li><li><span class="math inline">\(f_k^x\)</span>表示横向加速度计的测量</li><li><span class="math inline">\(f_k^y\)</span>表示前向加速度计的测量</li><li><span class="math inline">\(\omega_k^z\)</span>表示方位角陀螺仪测量得到的角速度</li><li>在本讨论中，带有k后缀的控制输入表示那些导致系统状态在时间epoch k-1到k之间发生变化的输入</li></ul><p>在推导运动方程之前，定义系统的导航状态是很重要的。一个可能的状态向量是：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678023960-0.png" alt="Clipboard 2023年3月5日 21.46"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.46</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(\varphi_k\)</span>是纬度</li><li><span class="math inline">\(\lambda_k\)</span>经度</li><li><span class="math inline">\(h_k\)</span>高度</li><li><span class="math inline">\(v_k^f\)</span>前向速度</li><li><span class="math inline">\(p_k\)</span>pintch角</li><li><span class="math inline">\(r_k\)</span>roll角</li><li><span class="math inline">\(A_k\)</span>方位角</li></ul><p><strong>pitch和roll的计算</strong></p><p>对于陆地车辆，俯仰角是它相对于水平地面所作的角度(即围绕横向轴旋转)，滚转角是其围绕纵向轴旋转，如图9.5所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678024115-0.png" alt="Clipboard 2023年3月5日 21.48"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.48</figcaption></figure><p>当车辆移动时，向前加速度计测量向前车辆加速度以及重力分量，并且为了计算俯仰角，从里程表测量中得到的车辆加速度，并且从向前加速度计测量中去除，如下：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678024205-0.png" alt="Clipboard 2023年3月5日 21.50"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.50</figcaption></figure><p>类似地，横向加速度计测量车辆加速度的法向分量以及重力分量，为了计算滚转角度，横向加速度计的测量必须补偿加速度的法向分量，也就是说，考虑车发生俯仰角的时候，重力分量不完全是g，而是<span class="math inline">\(g \cos p_k\)</span>:</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/05/1678024597-0.png" alt="Clipboard 2023年3月5日 21.56"><figcaption aria-hidden="true">Clipboard 2023年3月5日 21.56</figcaption></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fundamentals-of-inertial-navigation-satellite-based-positioning-and-their-integration&quot;&gt;Fundamentals of Inertial Navigation, Satellit
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【经典文献翻译】IMU Error Modeling Tutorial</title>
    <link href="http://yoursite.com/2023/03/04/IMU%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2023/03/04/IMU%E8%AF%AF%E5%B7%AE%E6%A8%A1%E5%9E%8B/</id>
    <published>2023-03-04T02:59:30.000Z</published>
    <updated>2023-03-12T02:36:08.696Z</updated>
    
    <content type="html"><![CDATA[<h1 id="imu-error-modeling-tutorial-ins-state-estimation-with-real-time-sensor-calibration">IMU Error Modeling Tutorial (INS state estimation with real-time sensor calibration)</h1><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678500899-0.png" alt="Clipboard 2023年3月11日 10.14"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.14</figcaption></figure><h1 id="介绍">介绍</h1><p>自动驾驶汽车技术正在快速发展。关键的使能因素是计算和传感系统能力的提高和成本的降低，这些系统使传感融合能够感知车辆的状态和环境。出于控制目的，必须以足够高的采样率和足够高的带宽准确、可靠地估计车辆状态。对于具有高带宽的系统，这些要求通常通过辅助惯性导航系统（INS）[1]、[2]、[3]、[4]、[5]、[6]来实现。</p><p>NS通过IMU高采样率的运动学模型集成来自惯性测量单元(IMU)的6个数据，以计算状态估计。辅助INS使用从辅助传感器(如视觉、激光雷达、雷达和全局导航卫星系统(GNSS))数据纠正这一状态估计。传感器融合状态估计可以通过以下任何一种方法来完成:卡尔曼滤波器(KF)[7]，[8]，[9]，[10]，[11]，扩展卡尔曼滤波器(EKF)[12]，[13]，[14]，[15]，无迹卡尔曼滤波器(UKF)[16]，[17]，[18]，粒子滤波(PF)[19]，[20]，[21]，12和最大后验(MAP)优化[22]，[23]，[24]，[25]，[26]，[27]。</p><p>如果将IMU和辅助传感器数据结合在状态空间形式中，则结合IMU和辅助传感器数据的数据融合系统将能够通过实时校准实现更好的性能。IMU制造商提供了一个描述预期IMU性能的数据表。根据规范标准[28]、[29]、[30]，这种性能通常用艾伦方差(AV)来表示。</p><p>然而，目前还不清楚如何将这些数据表中的AV信息转换成合适的状态空间模型。多种模型已经被知晓并使用了几十年[31]，[32]，[33]，[34]，[35]，20[36]，[37]，[38]，[39]，[40]。尽管它们很重要，但现有文献中没有对潜在思想、问题和权衡进行清晰的教程阐述。本文的目的是提供这样一个指导性的讨论。“辅助INS历史”中讨论了这些想法的悠久历史以及与成功应用相关的问题。</p><p>本教程讨论与示例导航系统设计方法相关的问题和权衡：</p><ul><li>(1)使用AV信息来指定IMU状态空间随机误差模型的连续时间参数(例如，<span class="math inline">\(p, n_z, A_z, B_z, C_z, S_z\)</span>, and <span class="math inline">\(S_\eta\)</span>)；</li><li>(2)将该连续时间模型转换为实现状态估计器所需的离散时间、状态空间误差模型参数(<span class="math inline">\(\Phi, Q_{z_d}, H, Q_{\eta_d}\)</span>)</li><li>(3)相对于Allan信息验证IMU模型。以前的一些文章讨论了上述专题中的一些[32]、[34]、[36]、[39]、[43]、[44]、[46]、[47]。</li><li>本文的目标是以教程的方式清楚而全面地介绍背景和主要思想，使用符合仪器规范标准[28]、[29]的符号和术语。为了澄清问题，通篇都包括了一些例子。</li></ul><h1 id="应用简介">应用简介</h1><p>INS设计是基于车辆运动学模型：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678501669-0.png" alt="Clipboard 2023年3月11日 10.27"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.27</figcaption></figure><p>其中，<span class="math inline">\(\vec{x}_v\)</span>表示车辆的状态<span class="math inline">\(\vec{u} \in \Re^6\)</span>表示系统输入(即比力和角速度向量)。典型的车辆状态向量可能包括位置、速度和姿态的子向量。导航系统基于信号<span class="math inline">\(\vec{u}(t)\)</span>的测量来求解(1)：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678501803-0.png" alt="Clipboard 2023年3月11日 10.30"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.30</figcaption></figure><p>其中 <span class="math inline">\(\hat{\vec{u}}(t)\)</span>是使用实时估计的校准因子（从IMU 测量<span class="math inline">\(\tilde{\vec{u}}(t)\)</span>计算出来的）。“"Simplified INS Example.”中介绍了简化的二维惯性导航示例。</p><p>对于标量信号，将传感器测量̃<span class="math inline">\(\tilde{u}(t)\)</span>与期望真值信号<span class="math inline">\(u(t)\)</span>相关联的模型是(参见[28]、[29]）：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678501958-0.png" alt="Clipboard 2023年3月11日 10.32"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.32</figcaption></figure><p>期望信号<span class="math inline">\(u(t)\)</span>的测量<span class="math inline">\(\tilde{u}(t)\)</span>被确定性误差<span class="math inline">\(d(\vec{u}(t))\)</span>和累积随机误差<span class="math inline">\(z(t)\)</span>破坏。确定性误差是具有未知确定性系数的分析模型足够的传感器缺陷。其中一些系数在仪器的生命周期内仅表现出微小的变化。</p><p>这些可以在工厂校准过程中估计和补偿。其他确定性错误，如启动偏差，可以通过状态增广来实时估计。确定性错误的形式可能包括比例因子误差、非线性、对陀螺的 g 敏感性、非正交轴和交叉耦合的轴[5]。请参阅“问题和权衡讨论”中的“确定性错误”小节。</p><p>本文的重点是由<span class="math inline">\(z(t)\)</span>表示的随机误差，这些误差可能来自各种物理现象（参见“背景”部分）。每次仪器打开时，随机误差是不同的，随时间变化的函数，不能根据传感器测量<span class="math inline">\(\tilde{u}(t)\)</span>进行预测。</p><p>为清楚起见和简单性，本教程的大部分将<span class="math inline">\(z(t)\)</span>视为标量信号。基本思想适用于六自由度IMU随机误差模型。</p><h1 id="state-estimation-error-model">State Estimation Error Model</h1><p>当导航系统通过积分式(2)的非线性模型来传播车辆状态向量时，误差表示为<span class="math inline">\(\delta \vec{x}_v(t)=\vec{x}_v(t)-\hat{\vec{x}}_v(t)\)</span>，无论选择哪种姿态表示法(例如方向余弦矩阵或四元数)，姿态误差都可以由具有三个分量的向量来表示。因此，车辆误差状态包含位置、速度和姿态误差的子矢量，每个是具有三个分量的矢量，即<span class="math inline">\(\delta \vec{x}_v(t) \in \Re^{n_v}, n_v=9\)</span>。</p><p>车辆状态误差向量可以使用辅助传感器[10]、[13]、[12]、[31]、[43]、[44]的测量结果实时估计。估计算法包含误差状态的线性化状态空间模型：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678502779-0.png" alt="Clipboard 2023年3月11日 10.46"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.46</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(F(t)=\left.\frac{\partial f(\vec{x}, \vec{u})}{\partial \vec{x}}\right|_{\hat{\vec{x}}(t), \hat{\vec{u}}(t)}\)</span></li><li><span class="math inline">\(G(t)=\left.\frac{\partial f(\vec{x}, \vec{u})}{\partial \vec{u}}\right|_{\hat{\vec{x}}(t), \hat{\vec{u}}(t)}\)</span></li><li><span class="math inline">\(\delta \vec{u}(t)=\vec{u}(t)-\hat{\vec{u}}(t)\)</span></li><li>参见“Simplified INS Example.”中的示例F(t)和G(t)矩阵</li></ul><p>这个状态空间模型并不完整，除非指定<span class="math inline">\(\delta \vec{u}(t)\)</span>的IMU误差模型。对于状态估计，确定状态空间形式的IMU误差模型。</p><p>实时状态估计过程用于估计增广的状态向量：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678502968-0.png" alt="Clipboard 2023年3月11日 10.49"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.49</figcaption></figure><p>由车辆误差状态向量<span class="math inline">\(\delta \vec{x}_v(t) \in \Re^{n_v}\)</span>组成，其中，</p><ul><li><span class="math inline">\(\vec{x}_d(t) \in \Re^{n_d}\)</span>表示imu确定性误差</li><li><span class="math inline">\(\vec{x}_z(t) \in \Re^{n_z}\)</span>表示imu随机误差</li><li>错误状态的总维度<span class="math inline">\(n_x=n_v+n_d+n_2\)</span></li></ul><p>状态增广的过程，在“State Augmentation”中进行了讨论。这里的介绍将完全集中在随机IMU误差上<span class="math inline">\(z(t)\)</span>，其在式(3)中的累积用<span class="math inline">\(\vec{z}(t)\)</span>表示。</p><p>标量<span class="math inline">\(z(t)\)</span>的状态空间模型：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678503236-0.png" alt="Clipboard 2023年3月11日 10.53"><figcaption aria-hidden="true">Clipboard 2023年3月11日 10.53</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(A_z \in \Re^{n_z \times n_z}, B_z \in \Re^{n_z \times p}\)</span>, and <span class="math inline">\(C_z \in \Re^{1 \times n_z}\)</span></li><li>参数p表示IMU误差模型的微分方程式部分中不同的独立的噪声过程的数目</li><li>参数<span class="math inline">\(n_z\)</span>表示IMU随机误差模型中的状态数</li></ul><p>随机信号<span class="math inline">\(\vec{\omega}_z(t)\)</span> and <span class="math inline">\(\eta_z(t)\)</span>式相互独立的具有功率谱密度<span class="math inline">\((S_{\omega_z} \in \Re^{p \times p}\)</span> and <span class="math inline">\(S_{\eta_z} \in \Re)\)</span>的高斯白噪声过程。假设<span class="math inline">\(\vec{\omega}_z(t)\)</span>的元素是相互独立的，因此得到<span class="math inline">\(S_{\omega_z}\)</span>是对角线的。</p><blockquote><p>设计者在选择模型结构(特别是<span class="math inline">\(n_z\)</span>和<span class="math inline">\(P\)</span>)时必须谨慎，因为整个模型将有6<span class="math inline">\(n_z\)</span>状态和6<span class="math inline">\(P\)</span>个独立噪声源。</p></blockquote><h1 id="线性状态空间系统的功率谱密度">线性状态空间系统的功率谱密度</h1><p>对应于(6)-(7)中的状态空间模型，频域模型为</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504350-0.png" alt="Clipboard 2023年3月11日 11.12"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.12</figcaption></figure><p>其中，S是拉普拉斯变量。从<span class="math inline">\(\omega_z(t)\)</span>到<span class="math inline">\(z(t)\)</span>的传递函数模型为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504410-0.png" alt="Clipboard 2023年3月11日 11.13"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.13</figcaption></figure><p>它有1行和p列，符号<span class="math inline">\(Z(s), \Omega_z(s)\)</span>, and <span class="math inline">\(\eta_z(s)\)</span>分别表示为信号<span class="math inline">\(z(t), \omega_z(t)\)</span>, and <span class="math inline">\(\eta_z(t)\)</span>的拉普拉斯变换，因此，对应于信号<span class="math inline">\(z(t)\)</span>的功率谱密度（PSD）：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504552-0.png" alt="Clipboard 2023年3月11日 11.15"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.15</figcaption></figure><p>假设驱动噪声向量<span class="math inline">\(\omega_z(t)\)</span>和输出噪声<span class="math inline">\(\eta_z(t)\)</span>的所有元素是相互独立的并且是白的，这简化为</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504605-0.png" alt="Clipboard 2023年3月11日 11.16"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.16</figcaption></figure><p>其中，</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678504625-0.png" alt="Clipboard 2023年3月11日 11.17"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.17</figcaption></figure><p><span class="math inline">\(T_i(s)\)</span>是<span class="math inline">\(\vec{\omega}_z(t)\)</span>的第i个元素到<span class="math inline">\(z(t)\)</span>的(标量)传递函数，<span class="math inline">\(B_{z_i} \in \Re^{n_z \times 1}\)</span>是<span class="math inline">\(B_z\)</span>的第i列。每个<span class="math inline">\(T_i(s)\)</span>是<span class="math inline">\(s\)</span>中分子与分母之比，<span class="math inline">\(S_z\)</span>是<span class="math inline">\(\omega\)</span>的正实函数。因此，每个<span class="math inline">\(T_i(j \omega) T_i(-j \omega)\)</span>和<span class="math inline">\(S_z(\omega)\)</span>将始终是拉普拉斯变量<span class="math inline">\(s\)</span>的偶次幂的多项式函数的比率。证明这一事实的例子在《Finite Dimensional Linear StateSpace Systems have Even Power Spectra.》中给出</p><p><span class="math inline">\(S_z\)</span>是正实函数的事实导致了IMU误差建模方法中的主要挑战之一，因为一些IMU随机误差分量的PSD不能用式(10)的总和中的项精确地拟合。因此，设计者必须在近似状态空间模型中做出明智的选择，以达到满意的折衷。这个问题将在"Modeling via Independent Noise Sources”一节中进一步讨论。</p><h1 id="available-error-specification-information">Available Error Specification Information</h1><p>为了表征IMU的质量(根据IEEE规范[28]、[29]、[30])，制造商提供了AV曲线图、Allan标准偏差(ASD)曲线图或从中提取的参数。ASD图表既可以帮助仪器设计者理解和改进他们的传感器，也可以将预期性能传达给预期的用户。在本文的上下文中，主要主题是INS设计人员如何使用来自ASD图的信息来指定式(6)-(7)中的状态空间模型的参数。</p><p>图1和图2显示了示例ASD曲线图。图1显示了Crossbow μNav IMU陀螺仪的ASD曲线图[45]。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678505281-0.png" alt="Clipboard 2023年3月11日 11.28"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.28</figcaption></figure><p>这些ASD是根据[36]的作者提供的数据计算得出的。蓝色、黑色和绿色星号(‘*’)标记ASD数据点。</p><p>图2中的ASD10绘图是根据制造商提供的数据计算得出的，该数据来自安装在隔振系统顶部的大大理石平板上的IMU。图2中的每个蓝色‘x’标记一个ASD数据点。每个ASD图的水平轴是集群时间(或大小)，符号τ以秒为单位。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678505302-0.png" alt="Clipboard 2023年3月11日 11.28"><figcaption aria-hidden="true">Clipboard 2023年3月11日 11.28</figcaption></figure><p>请注意，这两张图中的ASD图既有相似之处，也有不同之处。对于较小的集群大小，两者都以-1/2的特征斜率减小，如每个图中的红色虚线切线所示。然后，在虚线青色切线所指示的值处，两者都变平到零的斜率。</p><p>对于较大的集群大小，图2中的ASD以1/2的斜率增加，如用黑色虚线绘制的切线所示。对于像τ=1000这样大的集群时间，图1中的ASD曲线图并没有(强烈地)表现出斜率为1/2的这种增加。</p><p>这些τ的值和发生变化的ASD值对于每个仪器都是不同的。它们指定了某些参数，这些参数对于比较惯性仪器的性能和评估权衡构建IMU随机误差模型都很有用。</p><h1 id="问题描述">问题描述</h1><p>本文的目的是讨论与开发模型相关的方法、问题和权衡，该模型将IMU误差的随机部分的性质定量地传达给状态估计算法。该误差模型的输入将是随机信号。</p><p>制造商提供的可用于模型开发的信息是AV或ASD特性。设计者无法获得产生这些特性的IMU真值输出数据；因此，系统辨识方法不适用。</p><p>由于误差状态估计算法是状态空间形式的，所以IMU误差模型也是状态空间形式的。输入被建模为独立的高斯白噪声过程。挑战在于构建这些模型，使它们具有与IMU相同的输出统计特性(即，AV方差)。</p><p>请注意，这种随机状态空间模型并不是唯一的。事实上，本文并不打算提出一个特定的模型；尽管本文讨论了一个特定的ASD情节，并给出了一个模型作为教程示例。相反，本文的目标是清楚地展示各种文章、书籍[9]和标准16[30]、[28]、[29]中使用或暗示的方法(使用各种特定模型)。作者认为，这种方法的许多方面都是行业标准的。不幸的是，大多数描述这种方法的出版物都不公开。</p><p>从高层次上，该方法的概要如下：</p><ul><li>(1)利用来自AV/ASD图的信息构建连续时间状态空间模型。</li><li>(2)将连续时间为IMU的随机模型转化为等价的离散时间模型。</li><li>(3)在模拟中使用离散时间模型产生数据，计算ASD图与仪器的ASD图进行比较。</li><li>(4)当设计者对IMU误差模型满意时，将其附加到车辆状态误差模型中，并用于INS误差状态估值器的设计。</li></ul><h1 id="allan-variance">Allan Variance</h1><p>AV是一种众所周知的时域分析技术，最初开发该技术是为了表征和研究振荡器的频率稳定性[48]、[49]、[50]。由于其相对简单，已被成功地用于传递IMU性能规范和来表征它们的随机误差[28]、[29]、[32]、[34]、[36]、[39]、[43]、[44]、[46]、[47]</p><p>给定一组数据，计算AV的过程如下。设<span class="math inline">\(D=\left\{\tilde{u}_i\right\}_{i=1}^L\)</span>是一组(去趋势的)比力(或角速率)数据（由静止的IMU以恒定采样间隔T测量）。对于每个<span class="math inline">\(n \in[1, L / 2]\)</span>，以<span class="math inline">\(\tau=n T\)</span>为变量，以<span class="math inline">\(\tau\)</span>的范围为从T到LT/2的簇时间的值分别计算方差。</p><p>对于给定的n，在每个时刻<span class="math inline">\(t_i \in[T, 2 T, \ldots,(L-n) T]\)</span>，一组n个连续的数据点(从<span class="math inline">\(t_i\)</span>开始)形成一个数据集<span class="math inline">\(\left\{\tilde{u}_j\right\}_{j=i}^{i+n-1}\)</span>，为每个这样的n点聚类计算平均值<span class="math inline">\(\bar{u}_i(\tau)=\frac{1}{n} \sum_{j=0}^{n-1} \tilde{u}_{i+j}\)</span>。然后，以<span class="math inline">\((L-2 n)\)</span>平方簇差[28]、[49]的平均值来计算持续时间τ的AV：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678523821-0.png" alt="Clipboard 2023年3月11日 16.37"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.37</figcaption></figure><p>由于一些IMU(尤其是那些高级IMU)提供比力(或角速率)的积分，表示为<span class="math inline">\(\tilde{\theta}_i\)</span>，因此<span class="math inline">\(\bar{u}_i(\tau)\)</span>可替换为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678523919-0.png" alt="Clipboard 2023年3月11日 16.38"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.38</figcaption></figure><p>将式(13)带入式(12)得到</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678524037-0.png" alt="Clipboard 2023年3月11日 16.40"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.40</figcaption></figure><p>这是计算AV的另一种公式[28]。</p><p>对于图形分析，AV的平方根<span class="math inline">\(\hat{\sigma}_u(\tau)\)</span>，称为ASD，被称为ASD，通常以对数-对数比例绘制，由于数据集D的长度有限，每组数据簇的数据量会随着<span class="math inline">\(\tau\)</span>的增加而减少；因此，ASD的标准差（注意，不是ASD本身）计算为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678524537-0.png" alt="Clipboard 2023年3月11日 16.48"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.48</figcaption></figure><p>其中，<span class="math inline">\(\kappa\)</span>是经验常数，对于imu分析，通常取<span class="math inline">\(\kappa \approx 1 / \sqrt{2}\)</span>，[53], [28], [29], [34], [54].</p><h1 id="power-spectral-density-and-allan-variance">Power Spectral Density and Allan Variance</h1><p>AV通过以下方式与双边PSD相关：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678524966-0.png" alt="Clipboard 2023年3月11日 16.56"><figcaption aria-hidden="true">Clipboard 2023年3月11日 16.56</figcaption></figure><p>IEEE标准952-1997[28]中(C.1)后面的文字将此等式解释为，当通过传递函数时，Allan Variance与信号<span class="math inline">\(u\)</span>中的总噪声功率成比例，该传递函数由用于创建和操作簇的方法确定。式(16)的推导可以在[55]第79页找到，(16)没有求逆公式(见[53])。在这个表达式中，<span class="math inline">\(S_u(f)=\left.S_u(s)\right|_{s=j 2 \pi f}\)</span>，其中<span class="math inline">\(s \in \mathbb{C}\)</span>是拉普拉斯变量，<span class="math inline">\(j=\sqrt{-1}\)</span>是复数、<span class="math inline">\(f \in \Re\)</span>的单位是hz。</p><h1 id="modeling-via-independent-noise-sources">Modeling via Independent Noise Sources</h1><p>当功率谱表示为频率f的幂函数级数时，它的形式为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678525335-0.png" alt="Clipboard 2023年3月11日 17.02"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.02</figcaption></figure><p>这种形式的PSD很方便。根据叠加原理，它与信号的功率谱相对应：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678525367-0.png" alt="Clipboard 2023年3月11日 17.02"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.02</figcaption></figure><p>其中，信号<span class="math inline">\(z_N(t), z_B(t)\)</span>, and <span class="math inline">\(z_K(t)\)</span>是相互独立的零均值噪声过程。</p><p>在此假设下，对式(16)到(17)应用，将产生具有以下形式的AV：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678525455-0.png" alt="Clipboard 2023年3月11日 17.04"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.04</figcaption></figure><p>其中每个AV项的具体功能形式可以计算，并可在各种来源中获得[28]、[29]、[30]、[34]、[55]。每个AV项的函数形式很容易与ASD图的一部分相关联。</p><p>“Continuous-Time State-Space Models”一节描述了建立这种关联并为每个术语定义连续时间状态空间模型的方法。每项的状态空间模型由它自己的独立的高斯白驱动噪声驱动，从而导致每个信号<span class="math inline">\(z_N(t), z_B(t)\)</span>, and <span class="math inline">\(z_K(t)\)</span>相互独立。</p><ul><li>这些状态空间模型对于对应于式(17)中f的偶函数的项（如<span class="math inline">\(\frac{K^2}{(2 \pi f)^2}\)</span>）可以是精确的</li><li>然而(如前所述并在侧栏中举例说明)是频率f的奇函数的功率谱项（如<span class="math inline">\(\frac{B^2}{2 \pi f}\)</span>）不能由任何有限维、线性、状态空间模型精确建模，因此，必须对这些术语进行近似建模，仔细权衡。</li></ul><p>在式(17)的幂级数表示中可以包括任意数量的项。这导致式(18)的信号模型和式(19)的AV模型中的项的数量相同。每个项代表来自独立来源的不同类型的噪声。ASD图的典型形状如图3所示，有五个独立的噪声源(另见[28]中的图C.8)</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678526032-0.png" alt="Clipboard 2023年3月11日 17.13"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.13</figcaption></figure><p>在ASD图中，每种噪声类型都与一个特征斜率相关联，该特征斜率有助于识别该噪声类型及其模型参数。并不是所有的噪声类型在每个设备都很明显。当存在时，噪声项占主导地位的<span class="math inline">\(\tau\)</span>的模型参数和范围对于每个仪器可能是不同的。</p><p>在商业级IMU中，N、B和K项通常占主导地位(例如，参见图1和图2)。对于较小的<span class="math inline">\(\tau\)</span>，仪器设计的选择(例如量化方法和10个采样周期)会导致随机误差表现为白噪声。这种白噪声在随机游走噪声项中被考虑（也就是N）。然而，随机误差并不是完全真正的白噪声。随着集群时间<span class="math inline">\(\tau\)</span>的增加，ASD曲线图可能表现出偏置不稳定(B)、速率随机游动(K)和其他噪声类型。要使ASD曲线图显示这些其他噪声类型，用于生成ASD曲线图的IMU数据集必须非常长。</p><p>ASD图绘制到几分钟（例如，几百秒），对于在观测不可用的间隔期间分析性能是有意义的。然而，对于非常大的<span class="math inline">\(\tau\)</span>，ASD曲线的具体形状通常是不确定的，并不重要。</p><p>表1的第1列和第2列包括了陀螺仪和加速度计的 N、B 和 K 个噪声项的具体名称。第3列和第4列总结了这些噪声类型的AV和PSD之间的关系，[28]、[34]</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678526752-0.png" alt="Clipboard 2023年3月11日 17.25"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.25</figcaption></figure><p>其中，N、B 和 K 项将是“"Continuous-Time State-Space Models”部分讨论的焦点。</p><h1 id="continuous-time-state-space-models">Continuous-Time State-Space Models</h1><p>本节考虑开发近似再现ASD图和式(17)PSD的连续时间状态空间模型。使用图2中的示例ASD来说明整个思路。图1将仅在参考B和K幂级数项时才讨论。整体模型将具有以下形式：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527004-0.png" alt="Clipboard 2023年3月11日 17.30"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.30</figcaption></figure><p>其中， <span class="math inline">\(z_N(t), z_B(t)\)</span>, and <span class="math inline">\(z_K(t)\)</span>分别是与系数N、B和K相关的IMU随机误差信号。</p><h2 id="随机游走误差z_nt角速度和速度">随机游走误差<span class="math inline">\(z_N(t)\)</span>:角速度和速度</h2><p>式(17)中的PSD项<span class="math inline">\(N^2\)</span>相对于频率f是恒定的，这对应于白噪声的功率谱[56]。因此，</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527127-0.png" alt="Clipboard 2023年3月11日 17.32"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.32</figcaption></figure><p>其中，<span class="math inline">\(\omega_N(t)\)</span>是PSD为<span class="math inline">\(S_N=N^2\)</span>的高斯白噪声。</p><blockquote><p>在文献中和制造商规范中，这种类型的误差称为<strong>陀螺角速度随机游走误差</strong>和<strong>加速度计的速度随机游走误差</strong>。</p></blockquote><p>将式(16)中的变换应用于<span class="math inline">\(S_{z_N}(f)=N^2\)</span>，将得到[28]，如表1中所示：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527260-0.png" alt="Clipboard 2023年3月11日 17.34"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.34</figcaption></figure><p>这表明，在ASD图上，角/速度随机游走将用斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的直线表示，如图4所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678527392-0.png" alt="Clipboard 2023年3月11日 17.36"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.36</figcaption></figure><p>随机游走参数N的值可以从提供ASD绘图的制造商中近似确定,这是通过识别ASD图上斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的<span class="math inline">\(\tau\)</span>范围，并绘制其切线来得到的。</p><p>在图2中，在<span class="math inline">\(\tau \in[0.01,30]\)</span>范围内绘制了红色虚线切线。从式(23)可以看出<span class="math inline">\(\left.\sigma_{z_N}(\tau)\right|_{\tau=1}=N\)</span>，因此，可以从ASD图中（<span class="math inline">\(\tau=1 \mathrm{~s}\)</span>，斜率为<span class="math inline">\(-\frac{1}{2}\)</span>的切线）提取N的值，对于图2，结果是<span class="math inline">\(N \approx 0.0033 \mathrm{~m} /\mathrm{s}/ \mathrm{s}^{1 / 2}\)</span></p><h2 id="随机游走误差z_kt速率和加速度">随机游走误差<span class="math inline">\(z_K(t)\)</span>：速率和加速度</h2><p>式（17）中的项<span class="math inline">\(\frac{K^2}{(2 \pi f)^2}=\left.\frac{K}{s} \frac{K}{s^*}\right|_{s=j 2 \pi f}\)</span>对应于具有传递函数为<span class="math inline">\(T(s)=\frac{1}{s}\)</span>的线性系统，因此，其状态空间模型为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528144-0.png" alt="Clipboard 2023年3月11日 17.49"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.49</figcaption></figure><p>其中<span class="math inline">\(z_K(t)\)</span>是输出，输入<span class="math inline">\(\omega_K(t)\)</span>是带有PSD为<span class="math inline">\(S_K=K^2\)</span>的高斯白噪声。</p><blockquote><p>在文献中和制造商规范中，这种类型的误差称为陀螺的速率随机游走误差和加速度计的加速随机游走误差.</p></blockquote><p>给定式（24）和（25），<span class="math inline">\(z_K(t)\)</span>的PSD是：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528628-0.png" alt="Clipboard 2023年3月11日 17.57"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.57</figcaption></figure><p>其所需形式对应于式（17）中的第三个项。使用式（16）代换<span class="math inline">\(S_{z_K}(f)\)</span>，得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528710-0.png" alt="Clipboard 2023年3月11日 17.58"><figcaption aria-hidden="true">Clipboard 2023年3月11日 17.58</figcaption></figure><p>总结在表1的相应行中，等式 (27) 显示，在ASD图上，速率/加速随机游走误差将由斜率为<span class="math inline">\(+\frac{1}{2}\)</span>的线表示，如图5所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678528824-0.png" alt="Clipboard 2023年3月11日 18.00"><figcaption aria-hidden="true">Clipboard 2023年3月11日 18.00</figcaption></figure><p>速率/加速度随机游走参数K可以从制造商提供的ASD图中近似确定。</p><p>第一步是识别ASD图上斜率为<span class="math inline">\(+\frac{1}{2}\)</span>的<span class="math inline">\(\tau\)</span>范围（如果存在），并绘制与其切线。在图2中，绘制的虚线黑线为<span class="math inline">\(\tau \in[3,500]\)</span>秒，斜率为<span class="math inline">\(+\frac{1}{2}\)</span>，在<span class="math inline">\(\tau \geq 100\)</span>秒时与ASD曲线大致相切。因为<span class="math inline">\(\tau\)</span>很大，这部分ASD通常具有更高程度的不确定性[如相对于 式(15) 所讨论的那样]。</p><p>第二步使用切线来估计K。从式(27)可以看出<span class="math inline">\(\left.\sigma_{z_K}(\tau)\right|_{\tau=3}=K\)</span>，因此，从ASD图中估计K值的简单方法是在<span class="math inline">\(\tau = 3 s\)</span>时找到直线近似的值，在图2的例子中，<span class="math inline">\(K \approx 0.00014 \mathrm{~m} / \mathrm{s}^2 / \mathrm{s}^{1 / 2}\)</span></p><p>基于图1中的ASD图，μNav单元中的陀螺可能不需要包含角速率随机游走噪声，即使聚类时间可达1000秒。</p><h2 id="累积误差模型nk">累积误差模型：N，K</h2><p>由于角随机游走和速率随机游走误差(或速度随机游走和加速度随机游走误差)都具有功率谱，因此可以直接建立状态空间模型来再现功率谱中相应的项，以及它们的ASD图部分。</p><p>基于前面的两个部分，状态空间模型将是：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678529391-0.png" alt="Clipboard 2023年3月11日 18.09"><figcaption aria-hidden="true">Clipboard 2023年3月11日 18.09</figcaption></figure><p>其中，<span class="math inline">\(z_N(t)=\omega_N(t)\)</span>是PSD为<span class="math inline">\(N^2\)</span>的白噪声，<span class="math inline">\(\omega_K(t)\)</span>是PSD为<span class="math inline">\(K^2\)</span>的白噪声。</p><p>随机信号<span class="math inline">\(\omega_N(t)\)</span>和<span class="math inline">\(\omega_K(t)\)</span>是独立的，因此，<span class="math inline">\(z_N(t)\)</span>和<span class="math inline">\(z_K(t)\)</span>也是独立的。</p><p>该模型的ASD为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678529561-0.png" alt="Clipboard 2023年3月11日 18.12"><figcaption aria-hidden="true">Clipboard 2023年3月11日 18.12</figcaption></figure><p>该模型的ASD图使用值<span class="math inline">\(N \approx 0.0033 \mathrm{~m} /\mathrm{s}/ \mathrm{s}^{1 / 2}\)</span>和<span class="math inline">\(K \approx 0.00014 \mathrm{~m} / \mathrm{s}^2 / \mathrm{s}^{1 / 2}\)</span>，如图2所示的绿色实线。</p><h2 id="偏差不稳定性z_bt">偏差不稳定性<span class="math inline">\(z_B(t)\)</span></h2><p>一些ASD图(如图1中的图)没有表现出与<span class="math inline">\(z_K(t)\)</span>相关的<span class="math inline">\(+\frac{1}{2}\)</span>斜率，但对于较大的<span class="math inline">\(\tau\)</span>值，确实有一个较宽的平坦区域。该平面区域不能由N或K值项来很好地建模。在这种情况下，式(30)中的NK模型的AV（和 ASD）图中，<span class="math inline">\(\tau\)</span>在N和K这个中间范围内太小。在任何一种情况下，都有足够的偏差不稳定性，这样可以通过在模型中考虑其性能来改进。</p><p>与<span class="math inline">\(S_{z_B}(f)=\frac{B^2}{2 \pi f}\)</span>对应的误差项<span class="math inline">\(z_B(t)\)</span>通常被称为偏差不稳定性（或闪烁噪声）[28], [29], [34], [44], [39].</p><p>将 式(16) 应用于<span class="math inline">\(S_{z_B}(f)=\frac{B^2}{2 \pi f}\)</span> for <span class="math inline">\(f \leq f_0\)</span>（并且排除0的情况），将会得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/11/1678547385-0.png" alt="Clipboard 2023年3月11日 23.09"><figcaption aria-hidden="true">Clipboard 2023年3月11日 23.09</figcaption></figure><p>其中，</p><ul><li><span class="math inline">\(x=\pi f_0 \tau\)</span></li><li><span class="math inline">\(C i\)</span>是[56]的cosine积分函数</li><li>参数<span class="math inline">\(f_0\)</span>是截断频率[28]</li></ul><p>偏差不稳定性ASD图如图6所示。</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678585362-0.png" alt="Clipboard 2023年3月12日 09.42"><figcaption aria-hidden="true">Clipboard 2023年3月12日 09.42</figcaption></figure><p>该图显示，对于小<span class="math inline">\(\tau\)</span>，<span class="math inline">\(\sigma_{z_B}(\tau)\)</span>增长，直到<span class="math inline">\(\tau&gt;\frac{1}{f_0}\)</span>的平台阶段。因此，<span class="math inline">\(\tau \approx \frac{1}{f_0}\)</span>的值定义了偏差不稳定性（或闪烁噪声）对其最大值贡献的部分。在该区域内，可以证明式(31)中的正弦项和余弦项接近于零，因此在平坦区域，有：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678585637-0.png" alt="Clipboard 2023年3月12日 09.47"><figcaption aria-hidden="true">Clipboard 2023年3月12日 09.47</figcaption></figure><p>这些方程提供了一种从ASD图中提取B近似值的简单方法。在这种方法中（例如，参见[35]中的p.6,[44]中的p.21, [54]中的p.10和[55] 中的p.114），可以从[28]中的B.4.5 节中推断，ASD图平坦的部分所对应的<span class="math inline">\(\sigma_z^2(\tau)\)</span>和<span class="math inline">\(\frac{2 B^2 \ln (2)}{\pi}\)</span>近似，来推断参数B的值。</p><p>对于图1中的ASD图，青色水平线近似于9.5e-3和1.40e-2deg/s的最小ASD值，对应的B的值为1.43e-2和2.11e-2 deg/s (9.5e-3/0.664, 1.40e-2/0.664)，对于图2中的ASD图，<span class="math inline">\(7.4 e-4 \mathrm{~m} / \mathrm{s}^2\)</span>的最小ASD值对应于<span class="math inline">\(B=1.11 e-3 \mathrm{~m} / \mathrm{s}^2\)</span>。</p><p>因为偏差不稳定性项的功率谱项（即<span class="math inline">\(\frac{B^2}{2 \pi f}\)</span>）不是<span class="math inline">\(s=j 2 \pi f\)</span>的偶数幂，所以没有完全拟合它的有限阶线性状态空间模型。因此，导航系统设计者必须选择一个状态空间模型来逼近偏差不稳定性误差效应。</p><p>人们提出了各种方法来近似地解释偏置不稳定性。其中包括一阶高斯-马尔科夫[4]，[32]，[36]，[39]，[44]，[58]和高阶自回归模型[43]，[46]，[47]。一个重要的权衡是，随着状态空间模型维数的增加，近似值的保真度可能会增加，但状态估计算法所需的实时计算负载也会增加。此外，更精细的模型可能对未建模的动力学和非线性不鲁棒，特别是当一些添加的状态是弱可观的。这些主题将在“Discussion of Issues and Tradeoffs”一节中进一步分析。</p><p>为了举例说明这个想法，下一节将考虑一阶高斯-马尔可夫模型，该模型使用指数相关噪声来模拟偏差不稳定性误差。</p><h2 id="gauss-markov-error-model">Gauss-Markov Error Model</h2><p>一阶连续时间高斯-马尔可夫模型为[9]，[56]：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586568-0.png" alt="Clipboard 2023年3月12日 10.02"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.02</figcaption></figure><p>且：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586591-0.png" alt="Clipboard 2023年3月12日 10.03"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.03</figcaption></figure><p>其中，</p><ul><li>符号<span class="math inline">\(T_B\)</span>表示进程的相关时间。</li><li>符号<span class="math inline">\(\omega_B(t)\)</span>表示带有PSD为<span class="math inline">\(S_B\)</span>的白色驱动噪声</li></ul><p>式(33)对应的传递函数为:</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586684-0.png" alt="Clipboard 2023年3月12日 10.04"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.04</figcaption></figure><p>产生的PSD为：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586716-0.png" alt="Clipboard 2023年3月12日 10.05"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.05</figcaption></figure><p>将式(16)应用于<span class="math inline">\(S_{z_G}(s)\)</span>将得到：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678586829-0.png" alt="Clipboard 2023年3月12日 10.07"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.07</figcaption></figure><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678588393-0.png" alt="Clipboard 2023年3月12日 10.33"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.33</figcaption></figure><p><span class="math inline">\(\sigma_{z_G}(\tau)\)</span>的曲线如图7所示。一些特殊情况值得注意：</p><p><strong>(1) 对于较小的集群时间（<span class="math inline">\(\tau&lt;&lt;T_B\)</span>）</strong></p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587018-0.png" alt="Clipboard 2023年3月12日 10.10"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.10</figcaption></figure><p>使ASD图对于小的<span class="math inline">\(\tau\)</span>阶段的斜率为<span class="math inline">\(+\frac{1}{2}\)</span>。</p><p><strong>(2) 当<span class="math inline">\(\tau=1.89 T_B\)</span>，曲线平滑且：</strong></p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587140-0.png" alt="Clipboard 2023年3月12日 10.12"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.12</figcaption></figure><p>或<span class="math inline">\(\sigma_{z_G}\left(1.89 T_B\right)=0.4365 \sqrt{S_B T_B}\)</span></p><blockquote><p>此处公式要注意，<span class="math inline">\(\sigma_{z_G}\left(1.89 T_B\right)\)</span>是一个值，不是两个值相乘，所以<span class="math inline">\(\sigma_{z_G}^2\left(1.89 T_B\right)\)</span>应该看作<span class="math inline">\(\sigma_{z_G}^2(\tau)\)</span></p></blockquote><p><strong>(1) 对于较大的集群时间（<span class="math inline">\(\tau&gt;&gt;T_B\)</span>）</strong></p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587284-0.png" alt="Clipboard 2023年3月12日 10.14"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.14</figcaption></figure><p>使ASD图对于大的<span class="math inline">\(\tau\)</span>阶段的斜率为<span class="math inline">\(-\frac{1}{2}\)</span>。</p><p>一阶标量高斯-马尔可夫过程可用于(近似地)对ASD图的平坦部分(即偏置不稳定性)建模。</p><blockquote><p>为什么长这样，与直觉相反？因为为了产生平坦区域，前面部分斜率为<span class="math inline">\(+\frac{1}{2}\)</span>刚好可以跟角度/速度随机游走N的斜率<span class="math inline">\(-\frac{1}{2}\)</span>抵消。后面部分也同样道理，但是这样就需要有截断的频率。</p></blockquote><p>如果制造商只提供了<span class="math inline">\(B\)</span>和<span class="math inline">\(T_B\)</span>的值，那么<span class="math inline">\(\mu_B\)</span>的值可以用(34)计算。通过使式(32)中的<span class="math inline">\(\sigma_{z_B}^2\)</span>等于式(37)中的<span class="math inline">\(\sigma_{z_G}^2\)</span>，可以求解<span class="math inline">\(S_B\)</span>：</p><figure><img src="https://s1.nsloop.com:58443/images/2023/03/12/1678587506-0.png" alt="Clipboard 2023年3月12日 10.18"><figcaption aria-hidden="true">Clipboard 2023年3月12日 10.18</figcaption></figure><p>当<span class="math inline">\(\mu_B\)</span>和<span class="math inline">\(S_B\)</span>已知时，式(33)的状态空间模型完全指定。</p><p>相反，如果制造商提供ASD图，并且偏差不稳定性足够大，足以保证包含在模型中，那么可以首先根据<span class="math inline">\(1.89T_B\)</span>靠近ASD图的平坦部分来得到<span class="math inline">\(T_B\)</span>参数，然后使式(37)中定义的<span class="math inline">\(\sigma_{z_G}\left(1.89 T_B\right)\)</span>的值接近ASD图平坦区域的值，从而得到<span class="math inline">\(S_B\)</span>。</p><p>对于图2中的ASD图，在<span class="math inline">\(\tau = 60 s\)</span>时，最小值为<span class="math inline">\(7.4 e-4 \mathrm{~m} / \mathrm{s}^2\)</span>。对应<span class="math inline">\(T_B= 60/1.89 = 31.7\)</span>, <span class="math inline">\(S_B=9.0 e-8 \mathrm{~m}^2 / \mathrm{s}^5\)</span>, <span class="math inline">\(B=1.11 e-3 \mathrm{~m} / \mathrm{s}^2\)</span></p><h2 id="cumulative-error-model-n-b-k">Cumulative Error Model: N , B, K</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;imu-error-modeling-tutorial-ins-state-estimation-with-real-time-sensor-calibration&quot;&gt;IMU Error Modeling Tutorial (INS state estimatio
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IKFOM代码解析</title>
    <link href="http://yoursite.com/2023/02/20/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2023/02/20/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/</id>
    <published>2023-02-20T01:22:58.000Z</published>
    <updated>2023-02-22T05:59:44.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kalman-filters-on-differentiable-manifolds">Kalman Filters on Differentiable Manifolds</h1><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227202357.png"></p><h1 id="ikfom在fast-lio2中的应用">IkFoM在Fast-LIO2中的应用</h1><p>Fast-LIO2中，主要使用了IkFoM作为状态，其中，在<code>use-ikfom.hpp</code>声明了关于各种状态、数据的宏定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IKFoM_toolkit/esekfom/esekfom.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">3</span>, <span class="keyword">double</span>&gt; vect3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::SO3&lt;<span class="keyword">double</span>&gt; SO3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::S2&lt;<span class="keyword">double</span>, <span class="number">98090</span>, <span class="number">10000</span>, <span class="number">1</span>&gt; S2; </span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">1</span>, <span class="keyword">double</span>&gt; vect1;</span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">2</span>, <span class="keyword">double</span>&gt; vect2;</span><br><span class="line"></span><br><span class="line">MTK_BUILD_MANIFOLD(state_ikfom,</span><br><span class="line">((vect3, pos))</span><br><span class="line">((SO3, rot))</span><br><span class="line">((SO3, offset_R_L_I))</span><br><span class="line">((vect3, offset_T_L_I))</span><br><span class="line">((vect3, vel))</span><br><span class="line">((vect3, bg))</span><br><span class="line">((vect3, ba))</span><br><span class="line">((S2, grav))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">MTK_BUILD_MANIFOLD(input_ikfom,</span><br><span class="line">((vect3, acc))</span><br><span class="line">((vect3, gyro))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">MTK_BUILD_MANIFOLD(process_noise_ikfom,</span><br><span class="line">((vect3, ng))</span><br><span class="line">((vect3, na))</span><br><span class="line">((vect3, nbg))</span><br><span class="line">((vect3, nba))</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>其中，<code>MTK_BUILD_MANIFOLD</code>宏定义是引用自<code>build_manifold.hpp</code>文件，即<code>mtk</code>文件夹内的内容，<code>mtk</code>文件夹原版是来自(OpenSLAM-MTK)[https://github.com/OpenSLAM-org/openslam_MTK]，并且经过了一定的修改和适配。</p><h2 id="mtk_build_manifold干了啥">MTK_BUILD_MANIFOLD干了啥</h2><p><code>MTK_BUILD_MANIFOLD</code>是由BOOST宏模板编程技术写的宏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MTK_AUTOCONSTRUCT_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_AUTOCONSTRUCT_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/preprocessor/seq.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/preprocessor/cat.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"src/SubManifold.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"startIdx.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PARSED_BY_DOXYGEN</span></span><br><span class="line"><span class="comment">//////// internals //////</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_APPLY_MACRO_ON_TUPLE(r, macro, tuple) macro tuple</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_TRANSFORM_COMMA(macro, entries) BOOST_PP_SEQ_ENUM(BOOST_PP_SEQ_TRANSFORM_S(1, MTK_APPLY_MACRO_ON_TUPLE, macro, entries))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_TRANSFORM(macro, entries) BOOST_PP_SEQ_FOR_EACH_R(1, MTK_APPLY_MACRO_ON_TUPLE, macro, entries)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_CONSTRUCTOR_ARG(  type, id) const type&amp; id = type()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_CONSTRUCTOR_COPY( type, id) id(id)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_BOXPLUS(          type, id) id.boxplus(MTK::subvector(__vec, &amp;self::id), __scale);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_OPLUS(               type, id) id.oplus(MTK::subvector_(__vec, &amp;self::id), __scale);</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li><code>#ifndef PARSED_BY_DOXYGEN</code> 表示接下来的代码，将不是由 DOXYGEN 工具来解析，而是由C++预处理来处理</li><li><code>build_manifold.hpp</code>文件使用了大量的Boost库的预处理(PP: preprocessor)模板元库技术，直接看代码比较复杂，所以这里反过来看，即直接对宏展开，然后往回看。</li></ul><h3 id="方法一使用ide展开宏定义">【方法一】使用IDE展开宏定义</h3><p>以<code>input_ikfom</code>的定义代码块为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MTK_BUILD_MANIFOLD(input_ikfom,</span><br><span class="line">((vect3, acc))</span><br><span class="line">((vect3, gyro))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>直接使用CLion展开是最快的，把鼠标移到附近，等待解析完成，显示如下：</p><p><img src="https://s1.nsloop.com:58443/images/2023/02/20/1676881479.png"></p><p>展开结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> input_ikfom self;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; S2_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; SO3_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt;&gt; vect_state;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> vect3::scalar scalar;</span><br><span class="line">    input_ikfom(<span class="keyword">const</span> vect3 &amp;acc = vect3(), <span class="keyword">const</span> vect3 &amp;gyro = vect3()) : acc(acc), gyro(gyro) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.boxplus(MTK::subvector(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.boxplus(MTK::subvector(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.oplus(MTK::subvector_(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.oplus(MTK::subvector_(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar, DOF&gt; __res, <span class="keyword">const</span> input_ikfom &amp;__oth)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        acc.boxminus(MTK::subvector(__res, &amp;self::acc), __oth.acc);</span><br><span class="line">        gyro.boxminus(MTK::subvector(__res, &amp;self::gyro), __oth.gyro);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;__os, <span class="keyword">const</span> input_ikfom &amp;__var) &#123;</span><br><span class="line">        <span class="keyword">return</span> __os &lt;&lt; __var.acc &lt;&lt; <span class="string">" "</span> &lt;&lt; __var.gyro &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">0</span>) &#123;</span><br><span class="line">            (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM), vect3::DOF));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">0</span>) &#123; (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM), vect3::DOF)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_hat(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_hat(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_Nx_yy(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Nx_yy(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123;</span><br><span class="line">            acc.S2_Mx(res, dx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Mx(res, dx); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp;<span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp;__is, input_ikfom &amp;__var) &#123; <span class="keyword">return</span> __is &gt;&gt; __var.acc &gt;&gt; __var.gyro; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="方法二编写代码展开宏定义并打印">【方法二】编写代码展开宏定义并打印</h3><p>新建<code>test</code>文件夹，添加<code>test_ikfom.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../include/IKFoM_toolkit/esekfom/esekfom.hpp"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">3</span>, <span class="keyword">double</span>&gt; vect3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::SO3&lt;<span class="keyword">double</span>&gt; SO3;</span><br><span class="line"><span class="keyword">typedef</span> MTK::S2&lt;<span class="keyword">double</span>, <span class="number">98090</span>, <span class="number">10000</span>, <span class="number">1</span>&gt; S2;</span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">1</span>, <span class="keyword">double</span>&gt; vect1;</span><br><span class="line"><span class="keyword">typedef</span> MTK::vect&lt;<span class="number">2</span>, <span class="keyword">double</span>&gt; vect2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(...) STR_(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR_(...) #__VA_ARGS__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> message <span class="meta-string">"Marco is : "</span> \</span></span><br><span class="line">    STR(MTK_BUILD_MANIFOLD(input_ikfom, \</span><br><span class="line">                            ((vect3, acc))  \</span><br><span class="line">                            ((vect3, gyro))  \</span><br><span class="line">                           )\</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,</span><br><span class="line">           STR(MTK_BUILD_MANIFOLD(input_ikfom, \</span><br><span class="line">                            ((vect3, acc))  \</span><br><span class="line">                            ((vect3, gyro))  \</span><br><span class="line">                           )\</span><br><span class="line">           )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>__VA_ARGS__</code>是可变参数宏标识符，<code>#define STR(...)</code>里面的<code>(...)</code>表示可以传递多个参数。</p><p>需要注意的是：</p><ul><li>​​#运算符​​ 把参数字符串化，功能就是转为字符串</li></ul><p>为什么需要用两个STR宏，是因为：</p><ul><li><code>STR(...)</code>将<code>MTK_BUILD_MANIFOLD(xxxx)</code>这一串字符传递给<code>__VA_ARGS__</code>变量，如果此时就调用<code>#__VA_ARGS__</code>进行打印，那么输出的仍然是<code>MTK_BUILD_MANIFOLD(xxxx)</code>，为了展开，需要将<code>__VA_ARGS__</code>的值（也就是<code>MTK_BUILD_MANIFOLD(xxxx)</code>的值）进行传递，所以有了<code>STR_(...)</code>，此时<code>MTK_BUILD_MANIFOLD(xxxx)</code>的具体值就会传递给<code>STR_(...)</code>的<code>__VA_ARGS__</code>，这个时候再打印，就是完整的宏定义展开了。</li></ul><p>运行此CPP，得到输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span> <span class="keyword">typedef</span> input_ikfom self; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state; MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc; MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro; <span class="keyword">enum</span> &#123;DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF&#125;; <span class="keyword">enum</span> &#123;DIM = vect3::DIM+<span class="number">0</span> + vect3::DIM&#125;; <span class="keyword">typedef</span> vect3::scalar scalar; input_ikfom ( <span class="keyword">const</span> vect3&amp; acc = vect3(), <span class="keyword">const</span> vect3&amp; gyro = vect3() ) : acc(acc), gyro(gyro) &#123;&#125; <span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125; <span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; acc.boxplus(MTK::subvector(__vec, &amp;self::acc), __scale); gyro.boxplus(MTK::subvector(__vec, &amp;self::gyro), __scale); &#125; <span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; acc.oplus(MTK::subvector_(__vec, &amp;self::acc), __scale); gyro.oplus(MTK::subvector_(__vec, &amp;self::gyro), __scale); &#125; <span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar,DOF&gt; __res, <span class="keyword">const</span> input_ikfom&amp; __oth)</span> <span class="keyword">const</span> </span>&#123; acc.boxminus(MTK::subvector(__res, &amp;self::acc), __oth.acc); gyro.boxminus(MTK::subvector(__res, &amp;self::gyro), __oth.gyro); &#125; <span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; __os, <span class="keyword">const</span> input_ikfom&amp; __var)&#123; <span class="keyword">return</span> __os &lt;&lt; __var.acc &lt;&lt; <span class="string">" "</span> &lt;&lt; __var.gyro &lt;&lt; <span class="string">" "</span> ; &#125; <span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span></span>&#123; <span class="keyword">if</span>(acc.TYP == <span class="number">1</span>)&#123;S2_state.push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM));&#125; <span class="keyword">if</span>(gyro.TYP == <span class="number">1</span>)&#123;S2_state.push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM));&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span></span>&#123; <span class="keyword">if</span>(acc.TYP == <span class="number">0</span>)&#123;(vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM), vect3::DOF));&#125; <span class="keyword">if</span>(gyro.TYP == <span class="number">0</span>)&#123;(vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM), vect3::DOF));&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span></span>&#123; <span class="keyword">if</span>(acc.TYP == <span class="number">2</span>)&#123;(SO3_state).push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM));&#125; <span class="keyword">if</span>(gyro.TYP == <span class="number">2</span>)&#123;(SO3_state).push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM));&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123; <span class="keyword">if</span>(acc.IDX == idx)&#123;acc.S2_hat(res);&#125; <span class="keyword">if</span>(gyro.IDX == idx)&#123;gyro.S2_hat(res);&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123; <span class="keyword">if</span>(acc.IDX == idx)&#123;acc.S2_Nx_yy(res);&#125; <span class="keyword">if</span>(gyro.IDX == idx)&#123;gyro.S2_Nx_yy(res);&#125; &#125; <span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123; <span class="keyword">if</span>(acc.IDX == idx)&#123;acc.S2_Mx(res, dx);&#125; <span class="keyword">if</span>(gyro.IDX == idx)&#123;gyro.S2_Mx(res, dx);&#125; &#125; <span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; __is, input_ikfom&amp; __var)&#123; <span class="keyword">return</span> __is &gt;&gt; __var.acc &gt;&gt; __var.gyro ; &#125; &#125;;</span><br></pre></td></tr></table></figure><p>重新格式化后，得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> input_ikfom self;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line">    MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> vect3::scalar scalar;</span><br><span class="line">    input_ikfom(<span class="keyword">const</span> vect3 &amp;acc = vect3(), <span class="keyword">const</span> vect3 &amp;gyro = vect3()) : acc(acc), gyro(gyro) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.boxplus(MTK::subvector(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.boxplus(MTK::subvector(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp;__vec, scalar __scale = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">        acc.oplus(MTK::subvector_(__vec, &amp;self::acc), __scale);</span><br><span class="line">        gyro.oplus(MTK::subvector_(__vec, &amp;self::gyro), __scale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar, DOF&gt; __res, <span class="keyword">const</span> input_ikfom &amp;__oth)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        acc.boxminus(MTK::subvector(__res, &amp;self::acc), __oth.acc);</span><br><span class="line">        gyro.boxminus(MTK::subvector(__res, &amp;self::gyro), __oth.gyro);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream &amp;__os, <span class="keyword">const</span> input_ikfom &amp;__var) &#123;</span><br><span class="line">        <span class="keyword">return</span> __os &lt;&lt; __var.acc &lt;&lt; <span class="string">" "</span> &lt;&lt; __var.gyro &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">1</span>) &#123; S2_state.push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">0</span>) &#123;</span><br><span class="line">            (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM), vect3::DOF));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">0</span>) &#123; (vect_state).push_back(<span class="built_in">std</span>::make_pair(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM), vect3::DOF)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(acc.IDX, acc.DIM)); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.TYP == <span class="number">2</span>) &#123; (SO3_state).push_back(<span class="built_in">std</span>::make_pair(gyro.IDX, gyro.DIM)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_hat(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_hat(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123; acc.S2_Nx_yy(res); &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Nx_yy(res); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.IDX == idx) &#123;</span><br><span class="line">            acc.S2_Mx(res, dx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (gyro.IDX == idx) &#123; gyro.S2_Mx(res, dx); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="built_in">std</span>::istream &amp;<span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream &amp;__is, input_ikfom &amp;__var) &#123; <span class="keyword">return</span> __is &gt;&gt; __var.acc &gt;&gt; __var.gyro; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>两种方法得到的结果，是一致的</strong>。</p><h2 id="mtk_build_manifold细读">MTK_BUILD_MANIFOLD细读</h2><p>有了输入、输出，这个时候结合<code>MTK_BUILD_MANIFOLD</code>的代码来分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_BUILD_MANIFOLD(name, entries) \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span> \</span><br><span class="line"><span class="keyword">typedef</span> name self; \</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;\</span><br><span class="line">MTK_SUBVARLIST(entries, S2_state, SO3_state) \</span><br><span class="line">name ( \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_ARG, entries) \</span><br><span class="line">) : \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_COPY, entries) &#123;&#125;\</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_OPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar,DOF&gt; __res, <span class="keyword">const</span> name&amp; __oth)</span> <span class="keyword">const</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXMINUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; __os, <span class="keyword">const</span> name&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __os MTK_TRANSFORM(MTK_OSTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_vect_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_SO3_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_hat, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Nx_yy, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Mx, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; __is, name&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __is MTK_TRANSFORM(MTK_ISTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把<code>name = input_ikfom</code>代入上面，得到：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_BUILD_MANIFOLD(name, entries) \</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_ikfom</span> &#123;</span> \</span><br><span class="line"><span class="keyword">typedef</span> input_ikfom self; \</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;\</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;\</span><br><span class="line">MTK_SUBVARLIST(entries, S2_state, SO3_state) \</span><br><span class="line">input_ikfom ( \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_ARG, entries) \</span><br><span class="line">) : \</span><br><span class="line">MTK_TRANSFORM_COMMA(MTK_CONSTRUCTOR_COPY, entries) &#123;&#125;\</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDOF</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> DOF; &#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DOF&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oplus</span><span class="params">(<span class="keyword">const</span> MTK::vectview&lt;<span class="keyword">const</span> scalar, DIM&gt; &amp; __vec, scalar __scale = <span class="number">1</span> )</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_OPLUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">boxminus</span><span class="params">(MTK::vectview&lt;scalar,DOF&gt; __res, <span class="keyword">const</span> input_ikfom&amp; __oth)</span> <span class="keyword">const</span> </span>&#123; \</span><br><span class="line">MTK_TRANSFORM(MTK_BOXMINUS, entries)\</span><br><span class="line">&#125; \</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::ostream&amp; __os, <span class="keyword">const</span> input_ikfom&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __os MTK_TRANSFORM(MTK_OSTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_S2_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_vect_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_vect_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_SO3_state</span><span class="params">()</span></span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_SO3_state, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_hat</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_hat, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Nx_yy</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">3</span>&gt; &amp;res, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Nx_yy, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2_Mx</span><span class="params">(Eigen::Matrix&lt;scalar, <span class="number">3</span>, <span class="number">2</span>&gt; &amp;res, Eigen::Matrix&lt;scalar, <span class="number">2</span>, <span class="number">1</span>&gt; dx, <span class="keyword">int</span> idx)</span> </span>&#123;\</span><br><span class="line">MTK_TRANSFORM(MTK_S2_Mx, entries)\</span><br><span class="line">&#125;\</span><br><span class="line"><span class="keyword">friend</span> <span class="built_in">std</span>::istream&amp; <span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::istream&amp; __is, input_ikfom&amp; __var)&#123; \</span><br><span class="line"><span class="keyword">return</span> __is MTK_TRANSFORM(MTK_ISTREAM, entries); \</span><br><span class="line">&#125; \</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来，还有</p><ul><li><code>MTK_SUBVARLIST</code>,</li><li><code>MTK_TRANSFORM_COMMA</code>,</li><li><code>MTK_TRANSFORM</code>,</li><li><code>MTK_CONSTRUCTOR_ARG</code>,</li><li><code>MTK_CONSTRUCTOR_COPY</code>,</li><li><code>MTK_BOXPLUS</code>,</li><li><code>MTK_OSTREAM</code>,</li><li><code>MTK_S2_state</code>,</li><li><code>MTK_vect_state</code>,</li><li><code>MTK_SO3_state</code>,</li><li><code>MTK_S2_hat</code>,</li><li><code>MTK_S2_Nx_yy</code>,</li><li><code>MTK_S2_Mx</code>,</li><li><code>MTK_ISTREAM</code>,</li><li><code>MTK::vectview</code></li></ul><p>需要展开。</p><h3 id="mtk_subvarlist">MTK_SUBVARLIST</h3><p><code>MTK_SUBVARLIST</code>的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_SUBVARLIST(seq, S2state, SO3state) \</span></span><br><span class="line">BOOST_PP_FOR_1( \</span><br><span class="line">( \</span><br><span class="line">BOOST_PP_SEQ_SIZE(seq), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq) (~), \</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state ),\</span><br><span class="line">MTK_ENTRIES_TEST, MTK_ENTRIES_NEXT, MTK_ENTRIES_OUTPUT)</span><br></pre></td></tr></table></figure><p>输入：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;</span><br><span class="line">MTK_SUBVARLIST(((vect3, acc)) ((vect3, gyro)) , S2_state, SO3_state) \</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; S2_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; SO3_state;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">int</span>&gt; &gt; vect_state;</span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vect3::scalar scalar;</span><br></pre></td></tr></table></figure><p>此处用了<code>BOOST_PP_FOR_1</code>，根据附录，BOOST_PP_FOR(state, pred, op, macro) 宏用于执行一定数量的宏展开操作</p><p>在这里，</p><ul><li>循环变量的初始状态state为</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">BOOST_PP_SEQ_SIZE(seq), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq) (~), \</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state )</span><br></pre></td></tr></table></figure><ul><li>结束循环的条件pred为<code>MTK_ENTRIES_TEST</code></li><li>产生新状态的操作op为<code>MTK_ENTRIES_NEXT</code></li><li>具体输出操作macro为<code>MTK_ENTRIES_OUTPUT</code></li></ul><hr><p>============= 第一轮循环 ============</p><p><strong>初始状态</strong></p><p>原始输入:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seq =     ((vect3, acc))  \</span><br><span class="line">               ((vect3, gyro))  \</span><br></pre></td></tr></table></figure><p>输入初始状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">BOOST_PP_SEQ_SIZE(seq), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq) (~), \</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line"><span class="number">0</span>,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state )</span><br></pre></td></tr></table></figure><ul><li>BOOST_PP_SEQ_SIZE(seq) = 2</li><li>BOOST_PP_SEQ_HEAD(seq) = (vect3, acc)</li><li>BOOST_PP_SEQ_TAIL(seq) (~) = ((vect3, gyro))</li></ul><p>即初始状态为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">    <span class="number">2</span>, \</span><br><span class="line">    (vect3, acc), \</span><br><span class="line">    ((vect3, gyro)), \</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    S2state,\</span><br><span class="line">    SO3state\</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_TEST</strong></p><p>取state第0个元素，非0则继续循环，为0则结束循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! this used to be BOOST_PP_TUPLE_ELEM_4_0:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_TUPLE_ELEM_4_0(a,b,c,d,e,f, g) a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取state第0个元素</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_TEST(r, state) MTK_TUPLE_ELEM_4_0 state</span></span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_OUTPUT</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_APPLY_MACRO_ON_TUPLE(r, macro, tuple) macro tuple</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PUT_TYPE(type, id, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK::SubManifold&lt;type, dof, dim&gt; id; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PUT_TYPE_AND_ENUM(type, id, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK_PUT_TYPE(type, id, dof, dim, S2state, SO3state) \</span><br><span class="line"><span class="keyword">enum</span> &#123;DOF = type::DOF + dof&#125;; \</span><br><span class="line"><span class="keyword">enum</span> &#123;DIM = type::DIM+dim&#125;; \</span><br><span class="line"><span class="keyword">typedef</span> type::scalar scalar; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_OUTPUT_I(s, head, seq, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK_APPLY_MACRO_ON_TUPLE(~, \</span><br><span class="line">BOOST_PP_IF(BOOST_PP_DEC(s), MTK_PUT_TYPE, MTK_PUT_TYPE_AND_ENUM), \</span><br><span class="line">( BOOST_PP_TUPLE_REM_2 head, dof, dim, S2state, SO3state)) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要调用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_OUTPUT(r, state) MTK_ENTRIES_OUTPUT_I state</span></span><br></pre></td></tr></table></figure><p>初始状态为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">    <span class="number">2</span>, \</span><br><span class="line">    (vect3, acc), \</span><br><span class="line">    ((vect3, gyro)), \</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    S2state,\</span><br><span class="line">    SO3state\</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MTK_ENTRIES_OUTPUT_I (s = <span class="number">2</span>, head = (vect3, acc), seq = ((vect3, gyro)), dof = <span class="number">0</span>, dim = <span class="number">0</span>, S2state = S2state, SO3state = SO3state)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MTK_ENTRIES_OUTPUT_I的内部流程为：</span></span><br><span class="line"><span class="comment">// 如果 s-1 &gt; 0 :</span></span><br><span class="line"><span class="comment">// 那么，以(head[0], head[1], dof, dim, S2state, SO3state)为参数，调用MTK_PUT_TYPE宏</span></span><br><span class="line"><span class="comment">// 如果 s-1 &lt;=0:</span></span><br><span class="line"><span class="comment">// 那么，以(head[0], head[1], dof, dim, S2state, SO3state)为参数，调用MTK_PUT_TYPE_AND_ENUM宏</span></span><br></pre></td></tr></table></figure><p>此处，s - 1=2 - 1 &gt; 0，所以会调用<code>MTK_PUT_TYPE</code>宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_PUT_TYPE(type, id, dof, dim, S2state, SO3state) \</span></span><br><span class="line">MTK::SubManifold&lt;type, dof, dim&gt; id;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_NEXT</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_NEXT(r, state) MTK_ENTRIES_NEXT_I state</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MTK_ENTRIES_NEXT_I(len, head, seq, dof, dim, S2state, SO3state) ( \</span></span><br><span class="line">BOOST_PP_DEC(len), \</span><br><span class="line">BOOST_PP_SEQ_HEAD(seq), \</span><br><span class="line">BOOST_PP_SEQ_TAIL(seq), \</span><br><span class="line">dof + BOOST_PP_TUPLE_ELEM_2_0 head::DOF,\</span><br><span class="line">dim + BOOST_PP_TUPLE_ELEM_2_0 head::DIM,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state)</span><br></pre></td></tr></table></figure><p>初始状态为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">( \</span><br><span class="line">    <span class="number">2</span>, \</span><br><span class="line">    (vect3, acc), \</span><br><span class="line">    ((vect3, gyro)), \</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    <span class="number">0</span>,\</span><br><span class="line">    S2state,\</span><br><span class="line">    SO3state\</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MTK_ENTRIES_NEXT_I(len = <span class="number">2</span>, head = (vect3, acc), seq = ((vect3, gyro)), <span class="number">0</span>, <span class="number">0</span>, S2state, SO3state)</span><br></pre></td></tr></table></figure><p>经过op操作（MTK_ENTRIES_NEXT）之后，得到新的state：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, \</span><br><span class="line">(vect3, gyro), \</span><br><span class="line">, \</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DOF,\</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DIM,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state\</span><br></pre></td></tr></table></figure><p>============= 第二轮循环 ============</p><p>当前状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, \</span><br><span class="line">(vect3, gyro), \</span><br><span class="line">, \</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DOF,\</span><br><span class="line"><span class="number">0</span> + head[<span class="number">0</span>]::DIM,\</span><br><span class="line">S2state,\</span><br><span class="line">SO3state\</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_TEST</strong></p><p>第0个元素为1，继续执行</p><p><strong>MTK_ENTRIES_OUTPUT</strong></p><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vect3::scalar scalar;</span><br></pre></td></tr></table></figure><p><strong>MTK_ENTRIES_NEXT</strong></p><p>op操作，得到下一个状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>,BOOST_PP_SEQ_ELEM_III,BOOST_PP_SEQ_TAIL_I,<span class="number">0</span>+vect3::DOF+vect3::DOF,<span class="number">0</span>+vect3::DIM+vect3::DIM,S2state,SO3state)</span><br></pre></td></tr></table></figure><p>============= 结束循环 ============</p><p>最终，<code>MTK_SUBVARLIST</code>得到结果如下：</p><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一轮循环输出的</span></span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span>, <span class="number">0</span>&gt; acc;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二轮循环输出的</span></span><br><span class="line">MTK::SubManifold&lt;vect3, <span class="number">0</span> + vect3::DOF, <span class="number">0</span> + vect3::DIM&gt; gyro;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DOF = vect3::DOF + <span class="number">0</span> + vect3::DOF</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    DIM = vect3::DIM + <span class="number">0</span> + vect3::DIM</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> vect3::scalar scalar;</span><br></pre></td></tr></table></figure><h1 id="附录">附录</h1><h2 id="boost_pp_for">BOOST_PP_FOR</h2><p>BOOST_PP_FOR 是 Boost Preprocessor 库中的一个宏，用于实现基于循环的元编程。BOOST_PP_FOR(state, pred, op, macro) 表示泛化的for水平重复结构，它接受四个参数：</p><ul><li>state : 初始状态</li><li>pred : 判断是否继续展开，形如 pred(r, state) 的二元谓词。该宏必须展开为一个位于 0 到 BOOST_PP_LIMIT_MAG 间的整数。当该谓词返回非零时，BOOST_PP_FOR 重复展开 macro</li><li>op : 操作生成新的状态，形如 op(r, state) 的二元操作; 该宏被重复应用于 state, <strong>每次产生一个新的 state</strong>, 直至 pred 返回 0.</li><li>macro: 利用state生成做后的输出，形如 macro(r, state) 的二元宏;该宏被 BOOST_PP_FOR 重复调用，直至 pred 返回 0</li></ul><p>简单来说，使用<code>BOOST_PP_FOR</code>，大概会展开成这个模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">macro(r, state) macro(r, op(r, state)) … macro(r, op(r, … op(r, state) … ))</span><br><span class="line">&#96;&#96;</span><br><span class="line"></span><br><span class="line">常用的pred大概长这样:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line"> &#x2F;&#x2F; 当state的首元素不等于state第二元素+1时，返回1，否则返回0</span><br><span class="line">#define PRED(r, state) \</span><br><span class="line">   BOOST_PP_NOT_EQUAL( \</span><br><span class="line">      BOOST_PP_TUPLE_ELEM(2, 0, state), \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(2, 1, state)) \</span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; BOOST_PP_NOT_EQUAL ， BOOST_PP_INC 可以看下面的BOOST_PP运算部分</span><br><span class="line">&#x2F;&#x2F; BOOST_PP_TUPLE_ELEM表示从state中取第0个元素</span><br></pre></td></tr></table></figure><p>一个op操作举例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP(r, state) \</span></span><br><span class="line">   ( \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">0</span>, state)), \ <span class="comment">// 递增首元素</span></span><br><span class="line">      BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">1</span>, state) \ <span class="comment">// 取出第二元素 ，组合成新的元组（state）</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 输入: (5, 10) 则state = (5, 10)</span></span><br><span class="line"> <span class="comment">// 输出: (6, 10)</span></span><br></pre></td></tr></table></figure><p>一个macro操作举例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACRO(r, state) BOOST_PP_TUPLE_ELEM(2, 0, state) <span class="comment">// 取元组的首元素</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入: (5, 10)</span></span><br><span class="line"><span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入: (6, 10)</span></span><br><span class="line"><span class="comment">// 输出: 6</span></span><br></pre></td></tr></table></figure><p>对上面的操作进行组合，形成一个<code>BOOST_PP_FOR</code>操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 当state的首元素不等于state第二元素+1时，返回1，否则返回0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRED(r, state) \</span></span><br><span class="line">   BOOST_PP_NOT_EQUAL( \</span><br><span class="line">      BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">0</span>, state), \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">1</span>, state)) \</span><br><span class="line">   )</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP(r, state) \</span></span><br><span class="line">   ( \</span><br><span class="line">      BOOST_PP_INC(BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">0</span>, state)), \ <span class="comment">// 递增首元素</span></span><br><span class="line">      BOOST_PP_TUPLE_ELEM(<span class="number">2</span>, <span class="number">1</span>, state) \ <span class="comment">// 取出第二元素 ，组合成新的元组（state）</span></span><br><span class="line">   )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取元组的首元素  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MACRO(r, state) BOOST_PP_TUPLE_ELEM(2, 0, state)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开为 5 6 7 8 9 10（当状态为（11，10）停止，不输出）</span></span><br><span class="line">BOOST_PP_FOR((<span class="number">5</span>, <span class="number">10</span>), PRED, OP, MACRO)</span><br></pre></td></tr></table></figure><h2 id="boost_pp运算">BOOST_PP运算</h2><p>算术运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_ADD(x,y)          x + y</span><br><span class="line">BOOST_PP_DEC(x)            x - <span class="number">1</span></span><br><span class="line">BOOST_PP_DIV(x,y)          x / y</span><br><span class="line">BOOST_PP_INC(x)              x + <span class="number">1</span></span><br><span class="line">BOOST_PP_MOD(x,y)          x % y</span><br><span class="line">BOOST_PP_MUL(x,y)         x * y</span><br><span class="line">BOOST_PP_SUB(x,y)          x – y</span><br></pre></td></tr></table></figure><p>整型逻辑运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_AND(x,y)          x &amp;&amp; y</span><br><span class="line">BOOST_PP_NOR(x,y)          !(x || y)</span><br><span class="line">BOOST_PP_OR(x,y)            x || y</span><br><span class="line">BOOST_PP_XOR(x,y)          (<span class="keyword">bool</span>)x != (<span class="keyword">bool</span>)y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_NOT(x)            x ? <span class="number">0</span> : <span class="number">1</span></span><br><span class="line">BOOST_PP_BOOL(x)          x ? <span class="number">1</span> : <span class="number">0</span></span><br></pre></td></tr></table></figure><p>位逻辑运算（单个位操作的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_BITAND(x,y) x &amp;&amp; y</span><br><span class="line">BOOST_PP_BITNOR(x,y)          !(x || y)</span><br><span class="line">BOOST_PP_BITOR(x,y)                x || y</span><br><span class="line">BOOST_PP_BITXOR(x,y)          (<span class="keyword">bool</span>)x != (<span class="keyword">bool</span>)y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_COMPL(x)                x ? <span class="number">0</span> : <span class="number">1</span></span><br></pre></td></tr></table></figure><p>比较运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOST_PP_EQUAL(x,y)                               x == y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_NOT_EQUAL(x,y)            x != y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_LESS(x,y)                                    x &lt; y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_LESS_EQUAL(x,y)                    x &lt;= y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_GREATER(x,y)                           x &gt; y ? <span class="number">1</span> : <span class="number">0</span></span><br><span class="line">BOOST_PP_GREATER_EQUAL(x,y)          x &gt;= y ? <span class="number">1</span> : <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="boost_pp序列">BOOST_PP序列</h2><p>序列 (简称为 seq)是一组相邻的带括号的元素。例如, (a)(b)©(d) seq 不能为空。因此，一个 “空的” seq 被认为是一种特殊情况，必须由C++单独处理。 对于序列的处理效率是非常高的，可以认为是随机访问的。</p><p>BOOST_PP_SEQ_HEAD(seq) 展开为一个 seq 的第一个元素。 BOOST_PP_SEQ_TAIL(seq) 展开为一个 seq 中除了第一个元素以外的其它元素。(还是一个序列)</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/preprocessor/seq/seq.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEQ (a)(b)(c)</span></span><br><span class="line"></span><br><span class="line">BOOST_PP_SEQ_HEAD(SEQ) <span class="comment">// expands to a</span></span><br><span class="line">BOOST_PP_SEQ_TAIL(SEQ) <span class="comment">// expands to (b)(c)</span></span><br><span class="line">BOOST_PP_SEQ_CAT(SEQ) <span class="comment">// expands to abc</span></span><br></pre></td></tr></table></figure><h2 id="boost_pp_ifcond-t-f">BOOST_PP_IF(cond, t, f)</h2><p>类似三元运算符 cond ? t : f ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kalman-filters-on-differentiable-manifolds&quot;&gt;Kalman Filters on Differentiable Manifolds&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.nsloop.com:58443
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/12/18/M_LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/12/18/M_LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-12-18T08:25:38.825Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="robust-odometry-and-mapping-for-multi-lidar-systems-with-online-extrinsic-calibration">Robust Odometry and Mapping for Multi-LiDAR Systems with Online Extrinsic Calibration</h1><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002092755.png"></p><h1 id="摘要">摘要</h1><p>组合多个LIDARS使机器人能够最大化其对环境的感知意识，并获得足够的测量。本文提出了一种实现鲁棒和同步的外参标定，里程计和多个LIDAR的建图系统。</p><p>我们的方法从测量预处理开始，从原始测量中提取边缘和平面特征，在运动和外参初始化过程之后，基于滑动窗口的多激光雷达里程计将板载运行，以估计具有在线标定和收敛性检测的位姿。</p><p>我们进一步开发了一种建图算法来构造全局地图，并优化具有足够特征的Pose以及捕获和减少数据不确定性的方法。</p><h1 id="介绍">介绍</h1><p>如果没有手动干预，我们的系统可以从多个未知外参的激光雷达开始，自动校准其外参，并提供准确的姿势以及全局一致的地图。先前的工作（LIOM），启发了本文，我们尝试解决多激光雷达融合问题的地方。此外，我们介绍了一种基于运动的方法[4]以初始化外参的方法，并使用[19]中的工具来表示不确定性。 本文贡献如下：</p><ul><li>自动初始化，计算所有关键状态，包括连续帧之间的运动以及后续阶段的外参。它可以在任意位置开始，而无需任何先前的机械配置或校准对象知识(Section VI)</li><li>使用常规收敛准则的在线自标定与里程计同时执行，它具有以完全无监督的方式监控收敛性和触发终止的能力(Section VII-B)</li><li>基于滑动窗口的里程计，充分利用来自多个 LiDAR 的信息，该实现可以解释为小规模的帧到地图注册表，这进一步减少了连续帧到帧的帧累积的漂移(Section VII-C)</li><li>使用二阶段方法进行建图，捕获传感器噪声并传播不确定性，来消除姿势估计和外参估计的外部扰动，这种方法使建图过程能够了解不确定性，并有助于我们保持全局地图的一致性以及提高系统的鲁棒性以进行长期导航任务。</li></ul><p>据我们所知，M-LOAM是第一个对多激光雷达外参标定和SLAM的完整解决方案，该系统在手持设备和自动驾驶汽车上进行了广泛的实验评估，从室内办事处到户外城市道路的各种情景，优于基于Sota Lidar的方法。关于各种平台上的校准，我们的方法实现了外参上的平移的厘米级精度和旋转的分数。对于不同尺度的SLAM，已成功应用M-LOAM以提供准确的姿势和地图结果。 图1可视化每个阶段的M-Loam的输出。</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002095249.png"></p><h1 id="相关工作">相关工作</h1><h2 id="lidar-based-slam">LiDAR-Based SLAM</h2><h2 id="multi-sensor-calibration">Multi-Sensor Calibration</h2><p>Kummerle等 [52]开创了一个超图优化框架，用于校准带轮式编码器的车载激光扫描仪，Teichman等人[53] 同时，提出了一种迭代的SLAM-Fitting Pipline，以解决两个RGB-D相机的畸变，为了恢复多摄像时系统的空间偏移，恒等人[54]将问题转换为为<code>Bundle Adjustment</code>，而欧阳展鹏等[55]采用<code>Ackermann</code>转向模型来限制外参。</p><p>如[47]所示，[56] - [58]，传感器之间的时间偏移的在线估计对IMU的系统至关重要。 Qin等 [56]利用QIU等人的视觉特征的重新注入误差制定时间校准问题。 [58]提出了一种通过分析传感器的运动相关来校准异质传感器的更一般的方法。</p><p>本文隐含地同步了基于硬件的外部时钟的多个激光雷达的时间系统，并明确关注外参标定。 我们的方法包括在线程序，以实现灵活的多激光雷达外参标定。 要监控估计的外部的融合，我们提出了一般标准。 此外，我们对外部扰动进行建模，以减少其对长期导航任务的负面影响。</p><h1 id="问题描述">问题描述</h1><p>我们根据最大似然估计（Maximum Like- lihood Estimation， MLE）制定M-LOAM，MLE导致非线性优化问题，其中，高斯协方差的逆对残差函数进行加权。</p><p>在深入研究 M-LOAM 的细节之前，我们先介绍一些基本概念：</p><ul><li>第 III-A 节介绍了符号</li><li>第 III-B 节介绍了 MLE</li><li>第 III-C 节描述了合适的模型来表示 <span class="math inline">\(\mathbb{R}^{3}\)</span>中的不确定测量和 SE(3) 中的变换。</li><li>最后，第 III-D 节简要介绍了 MLE 在 M-LOAM 中具有近似高斯噪声的实现</li></ul><h2 id="符号约定">符号约定</h2><p>命名法如表I所示</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002103027.png"></p><p>我们考虑一个由一个主要激光雷达和多个辅助灵敏器组成的系统，主激光雷达作为<code>base_frame</code>，我们使用()<span class="math inline">\(^{l^{1}} /()^{b}\)</span>来表示，对于其他辅助雷达，使用()<span class="math inline">\(^{l^{i, i&gt;1}}\)</span>来表示。</p><p>我们记<span class="math inline">\(\mathcal{F}\)</span>为从原始激光雷达提取的有效特征，每个特征都表示为3D空间中的一个点：<span class="math inline">\(\mathbf{p}=[x, y, z]^{\top}\)</span>。</p><p>状态向量，由平移和旋转部件组成，记为<span class="math inline">\(\mathbf{x}=[\mathbf{t}, \mathbf{q}]\)</span>，其中<span class="math inline">\(\mathbf{t}\)</span>是3x1向量，<span class="math inline">\(\mathbf{q}\)</span>是汉密尔顿四元数，但在我们需要旋转向量的情况下，我们在SO(3)中使用3×3旋转矩阵<span class="math inline">\(\mathbf{R}\)</span>.</p><p>第VIII节将不确定性与矢量空间上的构成相关联，我们使用SE（3）中的4×4变换矩阵T表示Pose:</p><p><span class="math display">\[\mathbf{T}=\left[\begin{array}{cc}\mathbf{R} &amp; \mathbf{p} \\\mathbf{0}^{\top} &amp; 1\end{array}\right]\]</span></p><h2 id="最大似然估计">最大似然估计</h2><p>我们为MLE问题制定了多激光雷达系统的姿势和外参估计[60] 式（1）：</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \max } p\left(\mathcal{F}_{k} \mid \mathbf{x}_{k}\right)=\underset{\mathbf{x}_{k}}{\arg \min } f\left(\mathbf{x}_{\mathbf{k}}, \mathcal{F}_{k}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{F}_{k}\)</span>表示第k帧的有效特征</li><li><span class="math inline">\(\mathbf{x}_{k}\)</span>表示待优化的状态</li><li><span class="math inline">\(f(\cdot)\)</span>表示目标函数</li></ul><p>假设观测模型使用高斯噪声[3]来替换，那么式（1）变成非线性最小二乘(NLS)问题:</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \min } \sum_{i=1}^{m} \rho\left(\left\|\mathbf{r}\left(\mathbf{x}_{k}, \mathbf{p}_{k i}\right)\right\|_{\mathbf{\Sigma}_{i}}^{2}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\rho(\cdot)\)</span>表示鲁棒性Huber损失[61]，用于处理outlier</li><li><span class="math inline">\(\mathbf{r}(\cdot)\)</span>表示残差函数</li><li><span class="math inline">\(\Sigma_i\)</span>表示协方差矩阵</li></ul><p>迭代方法如高斯牛顿、LM等方法常用于解决NLS问题，这些方法通过计算目标函数相对于状态向量<span class="math inline">\(\mathbf{x}_k\)</span>的<code>Jacobian</code>来进行局部线性化，即<span class="math inline">\(\mathbf{J}=\partial f / \partial \mathbf{x}_{k}\)</span>。通过给定初始值，<span class="math inline">\(\mathbf{x}_k\)</span>通过使用<span class="math inline">\(\mathbf{J}\)</span>进行迭代优化，直到收敛到局部最优。</p><p>在最终的迭代中，状态的最小二乘协方差计算为<span class="math inline">\(\boldsymbol{\Xi}=\boldsymbol{\Lambda}^{-1}\)</span>[62]，其中，<span class="math inline">\(\boldsymbol{\Lambda}=\mathbf{J}^{\top} \mathbf{J}\)</span>称为<code>信息矩阵</code>。</p><h2 id="不确定性表示">不确定性表示</h2><p>我们使用[19]中的工具来表示数据不确定性，首先，考虑噪声的激光点如下，式（3）：</p><p><span class="math display">\[\mathbf{p}=\overline{\mathbf{p}}+\boldsymbol{\zeta}, \quad \boldsymbol{\zeta} \sim \mathcal{N}(\mathbf{0}, \mathbf{Z})\]</span></p><p>其中,</p><ul><li><span class="math inline">\(\bar{\mathbf{p}}\)</span>表示不含噪声的点</li><li><span class="math inline">\(\zeta \in \mathbb{R}^{3}\)</span>是零均值的高斯扰动变量，<span class="math inline">\(\mathbf{Z}\)</span>是激光测量的噪声协方差</li><li>为了使得式（3）与转换矩阵(i.e., <span class="math inline">\(\left.\mathbf{p}_{h}^{\prime}=\mathbf{T} \mathbf{p}_{h}\right)\)</span>更加紧凑，我们使用齐次坐标系来表示：</li></ul><p><span class="math display">\[\mathbf{p}_{h}=\left[\begin{array}{l}\overline{\mathbf{p}} \\1\end{array}\right]+\mathbf{D} \boldsymbol{\zeta}=\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}, \quad \boldsymbol{\zeta} \sim \mathcal{N}(\mathbf{0}, \mathbf{Z})\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{D}\)</span>是将3x1向量转换为齐次坐标的矩阵</li></ul><p>如[63]中的研究，LIDARS深度测量误差（也称为传感器噪声）主要受目标距离的影响，矩阵<span class="math inline">\(\mathbf{Z}\)</span>被简单的设置为常值矩阵。</p><blockquote><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002114842.png"></p></blockquote><p>然后，我们定义SE(3)中受小扰动的随机变量：</p><p><span class="math display">\[\mathbf{T}=\exp \left(\boldsymbol{\xi}^{\wedge}\right) \overline{\mathbf{T}}, \quad \boldsymbol{\xi} \sim \mathcal{N}(\mathbf{0}, \boldsymbol{\Xi})\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\overline{\mathbf{T}}\)</span>是不含噪声的变换矩阵</li><li><span class="math inline">\(\xi \in \mathbb{R}^{6}\)</span>是协方差为<span class="math inline">\(\Xi\)</span>的小扰动变量</li></ul><p>这种表示允许我们在状态空间中储存变换的均值作为<span class="math inline">\(\overline{\mathbf{T}}\)</span>，并使用<span class="math inline">\(\xi\)</span>作为扰动。</p><blockquote><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002114918.png"></p></blockquote><p>我们考虑<span class="math inline">\(\Xi\)</span>包含两个部分的来源：</p><ul><li>Degenerate Pose Estimatio，来自案例，例如在受限制的环境中缺乏几何结构[34]，它通常在其退化方向上不确定姿势[62]，[64]，现有工程诉诸基于模型和基于学习的[65]方法来估算ICP的背景下的姿势协方差。</li><li>Extrinsic Perturbation，该项始终存在，由于外参误差的存在[12]。这种扰动不利于多传感器系统的测量精度 [66]、[67] 但很难测量。</li></ul><p>特别的，<span class="math inline">\(\Xi\)</span>的详细计算在Section VIII</p><h2 id="m-loam中的mle问题">M-LOAM中的MLE问题</h2><p>我们扩展了 MLE 以设计多个 M-LOAM 估计器，以从粗到细的方式解决机器人姿态和外参。最重要的步骤是将高斯噪声协方差<span class="math inline">\(\Sigma\)</span>近似于现实的测量模型。</p><p>根据第 III-C 节中的（上述）讨论，我们确定了三个可能使地标不确定的误差源：传感器噪声、退化姿态估计和外参扰动。</p><p>帧到帧运动估计（部分VI-A）归结于传感器噪声，紧耦合的里程计（第VII-C部分）建立了局部地图用于位姿优化，因此我们应该<code>传播位姿的不确定性到每一个地图点</code>。尽管如此，如果涉及更多的雷达和滑动窗口，这种操作通常是耗时的（大约10ms-20ms）。为了保证里程计的实时性，我们不在此处计算的位姿不确定性。</p><p>因此，我们简单地设置<span class="math inline">\(\Sigma=\mathbf{Z}\)</span>作为残差的协方差。在建图部分，我们有足够的时间来获得准确的姿势和全局地图，因此，我们考虑所有不确定性来源。 第VIII部分解释了姿势不确定性如何影响建图精度和<span class="math inline">\(\Sigma\)</span>的传播。</p><h1 id="系统概览">系统概览</h1><p>我们制作三个假设来简化系统设计</p><ul><li>Lidars是同步的，这意味着不同雷达之间的时间延迟几乎为零</li><li>该平台在校准初始化期间经历了足够的旋转和平移运动</li><li>主激光雷达的局部地图应与辅助LIDAR共享重叠的FOV，用于在改进中匹配以缩短校准阶段，这可以通过移动机器人来实现</li></ul><p>图 2 展示了 M-LOAM 的流水线。 系统从测量预处理（第 V 部分）开始，即从去噪点云中提取和跟踪边缘和平面特征</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/02/20211002195854.png"></p><p>初始化模块（第VI部分）提供了所有必要的值，包括姿势和外参，用于启动后续的非线性优的M-LO。M-LO融合多激光雷达测量在滑动窗口内优化里程计和外参，如果外参已经收敛，我们跳过外参初始化以及细化步骤，然后进入纯里程计和建图阶段。</p><p>概率建图模块（第VIII节）构造了一种具有足够特征的全局地图，以消除里程计累计漂移。 里程计和建图模块分别运行在隔离的线程上。</p><h1 id="测量预处理">测量预处理</h1><p>我们实施三个顺序步骤来处理LiDARS'raw测量，我们首先将点云分割成许多簇以去除嘈杂的对象，然后提取边缘和平面特征。 为了将连续帧之间的特征关联起来，我们匹配了一系列的对应关系。 <code>在本节中，每个 LiDAR 都是独立处理的</code>。</p><h2 id="噪声去除分割">噪声去除分割</h2><p>通过了解LIDAR的垂直扫描角度，我们可以将原始点云投影到没有数据丢失的范围图像上,在图像中，每个有效点由像素表示。像素值记录了该点到原点的欧几里德距离。我们将[68]中提出的分割方法应用于将像素分组到多个集群中。</p><p>我们假设，如果两个相邻点的连接线大致垂直于（大于60度）激光束，则认为这两个相邻点属于相同的对象。我们采用广度第一搜索算法来遍历所有像素，确保恒定的时间复杂度，特别的，我们丢弃小集群，因为它们可能会在优化中提供不可靠的约束。</p><h2 id="特征提取和匹配">特征提取和匹配</h2><p>我们有兴趣提取一般边缘和平面特征，我们遵循[16]选择根据其曲率从测量中选择一组特征点。该组提取的特征<span class="math inline">\(\mathcal{F}\)</span>由两个子集组成：边缘子集（高曲率）<span class="math inline">\(\mathcal{E}\)</span>和平面子集（低曲率）<span class="math inline">\(\mathcal{H}\)</span>。我们进一步从<span class="math inline">\(\mathcal{E}\)</span>收集曲率最高边缘点，从平面<span class="math inline">\(\mathcal{H}\)</span>收集曲率最低的平面点，得到另外两组点<span class="math inline">\(\hat{\mathcal{E}},\hat{\mathcal{H}}\)</span>。</p><p>下一步是确定两个连续帧之间的特征对应关系，()<span class="math inline">\(^{l_{k-1}^{i}} \rightarrow()^{l_{k}^{i}}\)</span>，以构造几何约束：</p><ul><li>对于边缘点集合<span class="math inline">\(\hat{\mathcal{E}}^{l_{k}^{i}}\)</span>中的点，将从前一帧的边缘点集合<span class="math inline">\(\mathcal{E}^{l_{k-1}^{i}}\)</span>中查找两个最近邻的边缘点以形成边缘线关联。</li><li>对于平面点集合<span class="math inline">\(\hat{\mathcal{H}}^{l_{k}^{i}}\)</span>中的点，则从上一帧的边缘点集合<span class="math inline">\(\mathcal{H}^{l_{k-1}^{i}}\)</span>中查找3个最近邻点作为平面关联。</li></ul><p><img src="https://s1.nsloop.com:58443/images/2021/10/03/20211003174638.png"></p><h1 id="初始化">初始化</h1><p>优化多个LIDARS的状态是高度非线性的，需要给出初始估计值。本节介绍了我们的运动和外在初始化方法，不需要任何先前的传感器套件的机械配置。 它还不涉及任何手动努力，使其对自主机器人特别有用。</p><h2 id="scan-based-motion-estimation">Scan-Based Motion Estimation</h2><p>在每个LIDAR的两个连续帧之间找到了相应的对应关系，我们通过最小化所有功能的残差误差来估计帧到帧变换。如图3所示，残差由边缘和平面对应关系制定，设<span class="math inline">\(\mathbf{x}_k\)</span>为第k帧的相对变换，对于平面特征，对于平面点<span class="math inline">\(\mathbf{p} \in \hat{\mathcal{H}}^{l_{k}^{i}}\)</span>，如果<span class="math inline">\(\Pi\)</span>是关联的平面，那么该平面点对应的残差如下计算，式（6）：</p><p><span class="math display">\[\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi\right)=a \mathbf{w}, \quad a=\mathbf{w}^{\top}\left(\mathbf{R}_{k} \mathbf{p}+\mathbf{t}_{k}\right)+d\]</span></p><p>其中，</p><ul><li><span class="math inline">\(a\)</span>是点到平面的距离</li><li><span class="math inline">\([\mathbf{w}, d]\)</span>是平面的参数</li></ul><p>对于边缘线特征点<span class="math inline">\(\mathbf{p} \in \hat{\mathcal{E}}^{l_{k}^{i}}\)</span>，如果<span class="math inline">\(L\)</span>是与之关联的边缘线，那么我们使用如式（6）的两个平面特征的组合来表示点与边缘线的残差：</p><p><span class="math display">\[\mathbf{r}_{\mathcal{E}}\left(\mathbf{x}_{k}, \mathbf{p}, L\right)=\left[\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi_{1}\right), \mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi_{2}\right)\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\left[\mathbf{w}_{1}, d_{1}\right]\)</span>,<span class="math inline">\(\left[\mathbf{w}_{2}, d_{2}\right]\)</span>分别是平面<span class="math inline">\(\Pi_{1}\)</span>、<span class="math inline">\(\Pi_{2}\)</span>的系数</li><li><span class="math inline">\(\mathbf{w}_{1}\)</span>恰好与点<span class="math inline">\(\mathbf{p}\)</span>到直线<span class="math inline">\(L\)</span>的投影方向一致</li><li>并且平面<span class="math inline">\(\Pi_{2}\)</span>垂直于<span class="math inline">\(\Pi_{1}\)</span>，满足s.t. <span class="math inline">\(\mathbf{w}_{2} \perp \mathbf{w}_{1}\)</span>, and <span class="math inline">\(\mathbf{w}_{2} \perp L\)</span></li><li>上述定义与<code>LOAM</code>[16]有所不同，其中有两个好处，一是边缘残差为状态量提供了额外的约束，其次，残差可以使用向量表示，这允许我们乘以3x3的协方差矩阵</li></ul><p>我们最小化所有残差项的总和以获得MLE：</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \min } \sum_{\mathbf{p} \in \hat{\mathcal{F}}^{i \atop k}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\]</span></p><p><span class="math display">\[\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{k}, \mathbf{p}\right)=\left\{\begin{array}{ll}\mathbf{r}_{\mathcal{E}}\left(\mathbf{x}_{k}, \mathbf{p}, L\right) &amp; \text { if } \mathbf{p} \in \hat{\mathcal{E}}^{i_{k}^{i}} \\\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi\right) &amp; \text { if } \mathbf{p} \in \hat{\mathcal{H}}^{i_{k}^{i}}\end{array}\right.\]</span></p><p>特别的，关于<span class="math inline">\(\mathbf{r}_{\mathcal{F}}(\cdot)\)</span>的雅克比在Appendix A进行详细讨论。</p><p>在实践中，在带滚动快门扫描的LiDars运动后，点存在一些倾斜畸变，在求出增量运动<span class="math inline">\(\mathbf{x}_k\)</span>后，我们将这些点转换到前一帧扫描的最后时刻（即第k帧扫描的起始）以矫正畸变。</p><p>令<span class="math inline">\(t_{k-1},t_{k}\)</span>表示激光扫描的起始和结束，对于每一个扫描点<span class="math inline">\(\mathbf{p}\)</span>，都可以进行转换如下：</p><p><span class="math display">\[\mathbf{p}^{l_{k-1}^{i}}=\mathbf{R}_{k}^{\tau} \mathbf{p}+\mathbf{t}_{k}^{\tau}, \quad \tau=\frac{t-t_{k-1}}{t_{k}-t_{k-1}}\]</span></p><p>其中，旋转和平移部分使用se(3)进行插值？参考文献[5]</p><p><span class="math display">\[\mathbf{R}_{k}^{\tau}=\exp \left(\boldsymbol{\phi}_{k}^{\wedge}\right)^{\tau}=\exp \left(\tau \boldsymbol{\phi}_{k}^{\wedge}\right), \quad \mathbf{t}_{k}^{\tau}=\tau \mathbf{t}_{k}\]</span></p><h2 id="calibration-of-multi-lidar-system">Calibration of Multi-LiDAR System</h2><p>通过对准两个传感器的运动序列来获得初始外参，即这被称为手眼标定问题<span class="math inline">\(\mathbf{A X}=\mathbf{X B}\)</span>，其中<span class="math inline">\(\mathbf{A},\mathbf{B}\)</span>是两个传感器的位姿增量，<span class="math inline">\(\mathbf{B}\)</span>是他们的外参。</p><p>当机器人移动时，第i个激光雷达的第k帧时刻，有：</p><p>式（11）：</p><p><span class="math display">\[\mathbf{R}_{l_{k}^{i}}^{l_{k-1}^{i}} \mathbf{R}_{l^{i}}^{b}=\mathbf{R}_{l^{i}}^{b} \mathbf{R}_{b_{k}}^{b_{k-1}}\]</span></p><p>式（12）：</p><p><span class="math display">\[\left(\mathbf{R}_{l_{k}^{i}}^{l_{k-1}^{i}}-\mathbf{I}_{3}\right) \mathbf{t}_{l^{i}}^{b}=\mathbf{R}_{l^{i}}^{b} \mathbf{t}_{b_{k}}^{b_{k-1}}-\mathbf{t}_{l_{k}^{i}}^{l_{k-1}^{i}}\]</span></p><p>上面两式实际上是根据[14]，将情况下原始问题<span class="math inline">\(\mathbf{A X}=\mathbf{X B}\)</span>分解为旋转和平移部分。我们实现了此方法可在线初始化外参。</p><h3 id="旋转初始化">旋转初始化</h3><p>通过使用四元数，可以将式（11）重写成如下式（13）：</p><p><span class="math display">\[\begin{aligned}&amp; \mathbf{q}_{l_{k}^{i}}^{l_{k-1}} \otimes \mathbf{q}_{l^{i}}^{b}=\mathbf{q}_{l^{i}}^{b} \otimes \mathbf{q}_{b_{k}}^{b_{k-1}} \\\Rightarrow &amp;\left[\mathbf{Q}_{1}\left(\mathbf{q}_{l_{k-1}^{i}}^{l_{k}}\right)-\mathbf{Q}_{2}\left(\mathbf{q}_{b_{k}}^{b_{k-1}}\right)\right] \mathbf{q}_{l^{i}}^{b}=\mathbf{Q}_{k}^{k-1} \mathbf{q}_{l^{i}}^{b} = 0\end{aligned}\]</span></p><p>其中，<span class="math inline">\(\otimes\)</span>表示四元数乘法，<span class="math inline">\(\mathbf{Q}_{1}(\cdot)，\mathbf{Q}_{1}(\cdot)\)</span>表示四元数的左乘、右乘等价矩阵[59]。</p><p>通过多次时间间隔，可以将式（13）就行堆叠，形成超定线性方程组：</p><p>式（14）：</p><p><span class="math display">\[\left[\begin{array}{c}w_{1}^{0} \cdot \mathbf{Q}_{1}^{0} \\\vdots \\w_{K}^{K-1} \cdot \mathbf{Q}_{K}^{K-1}\end{array}\right]_{4 K \times 4} \mathbf{q}_{l^{i}}^{b}=\mathbf{Q}_{K} \mathbf{q}_{l^{i}}^{b}=\mathbf{0}_{4 K \times 4}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(K\)</span>表示约束的数量</li><li><span class="math inline">\(w_{k}^{k-1}\)</span>是鲁棒性权重，定义为残差四元素的角度轴表示中的角度？</li></ul><p><span class="math display">\[w_{k}^{k-1}=\rho^{\prime}(\phi), \quad \phi=2 \arctan \left(\left\|\mathbf{q}_{x y z}\right\|, q_{w}\right)\]</span></p><p><span class="math display">\[\mathbf{q}=\left(\check{\mathbf{q}}_{l^{i}}^{b}{ }\right)^{*}\otimes\left(\mathbf{q}_{l_{k}^{i}}^{l_{k-1}^{i}}\right)^{*} \otimes \check{\mathbf{q}}_{l^{i}}^{b} \otimes \mathbf{q}_{b_{k}}^{b_{k-1}}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\rho^{\prime}(\cdot)\)</span>是Huber loss的微分</li><li><span class="math inline">\(\check{\mathbf{q}}_{l^{i}}^{b}\)</span>是当前估计的旋转外参</li><li><span class="math inline">\(\mathbf{q}^{*}\)</span>是<span class="math inline">\(\mathbf{q}\)</span>的逆</li></ul><p>令<span class="math inline">\(\| \mathbf{q}_{l^{\prime}}^{b}\|=1\)</span>，我们可以使用<code>SVD</code>来获取式（14）的<code>close form</code>解。</p><p>对于3-DOF旋转的全部可观察性，需要足够的运动激励，在足够的约束下，<span class="math inline">\(Q_k\)</span>的零空间的秩应为1，也就是说，我们只有1个零奇异值（4个变量，3个维度，剩下一个为0）。</p><p>否则，由于在一个轴或多个轴上的运动退化会导致<span class="math inline">\(Q_k\)</span>的零空间&gt;1。因此，我们需要确保第二小的奇异值<span class="math inline">\(\sigma_{min2}\)</span>足够大以确保条件满足。我们设置了阈值<span class="math inline">\(\sigma_{\mathbf{R}}\)</span>，<code>and terminate the rotation calibration if σmin2&gt; σR.</code> ???</p><p>越来越多的数据会使得<span class="math inline">\(Q_k\)</span>行数迅速增长，为了维持计算时间，我们使用优先级队列[69]，长度k = 300逐渐存储历史约束，并删除小旋转的约束。</p><h3 id="平移初始化">平移初始化</h3><p>一旦旋转校准完成，我们通过式（12）将所有可用数据结合，构造一个线性系统：</p><p>式（16）：</p><p><span class="math display">\[\left[\begin{array}{c}\mathbf{R}_{l_{1}^{i}}^{l_{0}}-\mathbf{I}_{3} \\\vdots \\\mathbf{R}_{l_{K}^{i}}^{l_{K-1}^{i}}-\mathbf{I}_{3}\end{array}\right]_{3 K \times 3} \mathbf{\mathbf { t }}_{l^{i}}^{b}=\left[\begin{array}{c}\hat{\mathbf{R}}_{l^{i}}^{b} \mathbf{t}_{b_{1}}^{b_{0}}-\mathbf{t}_{l_{1}^{i}}^{l_{0}^{i}} \\\vdots \\\hat{\mathbf{R}}_{l^i}^{b} \mathbf{t}_{b_{K}}^{b_{K-1}}-\mathbf{t}_{l_{K}^{i}}^{l^{i}_{K-1}}\end{array}\right]_{3 K \times 1}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{t}_{l^{i}}^{b}\)</span>通过使用最小二乘法获取</li></ul><p>然而，如果机器人只在平面上运动，z轴方向上的平移是不可观的，在这种情况下，我们设置<span class="math inline">\(t_z=0\)</span>然后重写式（16）以移除<span class="math inline">\(\mathbf{t}_{l^{i}}^{b}\)</span>中的Z轴分量。</p><p>不像文献[4]，我们的方法不能通过地面来初始化<span class="math inline">\(t_z\)</span>，因此需要在后续的<code>refinement</code>阶段来恢复<span class="math inline">\(t_z\)</span>.(Section VII-B)</p><h1 id="具备传感器外参细化的紧耦合多激光雷达里程计">具备传感器外参细化的紧耦合多激光雷达里程计</h1><p>将最初的猜测作为输入，我们提出了一个紧密耦合的M-LO，以优化滑动窗口内的所有状态，该过程的灵感来自多传感器系统的<code>BA</code>，<code>Graph-Based</code>和<code>marginalization</code>的启发[5],[15],[70].</p><h2 id="问题构造">问题构造</h2><p>滑动窗口中的全部状态向量如下定义：</p>$$<span class="math display">\[\begin{aligned}\mathcal{X} &amp;=[\mathcal{X}_{f},\qquad \mathcal{X}_{v},  \qquad  \qquad \qquad \mathcal{X}_{e}] \\&amp;=[\mathbf{x}_{1}, \cdots, \mathbf{x}_{p}, \mathbf{x}_{p+1}, \cdots, \mathbf{x}_{N+1}, \mathbf{x}_{l^{2}}^{b}, \cdots, \mathbf{x}_{l^{l}}^{b}]\end{aligned}\]</span><p>$$</p><p><span class="math display">\[\begin{aligned}\mathbf{x}_{k} &amp;=\left[\mathbf{t}_{b_{k}}^{w}, \mathbf{q}_{b_{k}}^{w}\right], \quad k \in[1, N+1] \\\mathbf{x}_{l^{i}}^{b} &amp;=\left[\mathbf{t}_{l^{i}}^{b}, \mathbf{q}_{l^{i}}^{b}\right], \quad i \in[1, I],\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_k\)</span>是主激光雷达在世界坐标系下不同时间戳的状态</li><li><span class="math inline">\(\mathbf{x}_{l^{i}}^{b}\)</span>表示主激光雷达到第i辅助激光雷达的外参</li><li><span class="math inline">\(N+1\)</span>是滑动窗口中的状态数量</li></ul><p>为了建立这些状态之间的数据关联，我们建立了局部地图</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/04/20211004171829.png"></p><p>图4对<code>Graph-base</code>的构造进行了可视化，我们使用<span class="math inline">\(p\)</span>来索引滑动窗口中的枢轴状态，并设置<span class="math inline">\(\mathbf{x}_p\)</span>作为局部地图的原点（起始）。</p><p>利用从枢轴帧到其他帧的相对变换，通过连接前N帧（如<span class="math inline">\(\mathcal{F}^{l_{k}^{i}}, k \in[1, N]\)</span>）的特征点来构造局部地图。第i个激光雷达的局部特征地图由局部边缘地图和局部平面地图组成，记为<span class="math inline">\(\mathcal{M}^{l^{i}}\)</span>。</p><p>我们分割全状态向量<span class="math inline">\(\mathcal{X}\)</span>为3个部分：<span class="math inline">\(\mathcal{X}_{f},\mathcal{X}_{v},\mathcal{X}_e\)</span>：</p><ul><li><span class="math inline">\(\mathcal{X}_{f}=[\mathbf{x}_1,\dots,\mathbf{x}_p]\)</span>是由已经固定的准确状态组成</li><li><span class="math inline">\(\mathcal{X}_{v}=\left[\mathbf{x}_{p+1}, \cdots, \mathbf{x}_{N+1}\right]\)</span>被考虑作为在优化过程中迭代更新的变量</li><li><span class="math inline">\(\mathcal{X}_{e}=\left[\mathbf{x}_{l^{2}}^{b}, \cdots, \mathbf{x}_{l^I}^{b}\right]\)</span>是外参向量，它们的设置取决于在线校准的收敛性。</li><li></li><li>我们最小化滑动窗口内所有残差的总和以获得 MAP 估计为：</li></ul><p><span class="math display">\[\hat{\mathcal{X}}=\underset{\mathcal{X}}{\arg \min }\left\{\left\|\mathbf{r}_{p r i}(\mathcal{X})\right\|^{2}+f_{\mathcal{M}}(\mathcal{X})\right\}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{r}_{p r i}(\mathcal{X})\)</span>是VII-E节中定义的边缘化状态的先验项</li><li><span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>是基于地图的残差的总和，其式（18）的雅克比矩阵推导见Appendix A</li></ul><p>本文呈现的滑动窗口估计器与帧到帧估计不同，该估计器联合优化了窗口中的所有状态。这种方法，输出更准确的结果，因为局部地图提供了密集和可靠的对应关系。如果传感器精确标定，还使用来自其他雷达的约束。根据标定的收敛性，我们将问题分为两个子任务：</p><ul><li>在线标定online calibration (variable <span class="math inline">\(\mathcal{X}_e\)</span>)</li><li>纯里程计pure odometry (fixed <span class="math inline">\(\mathcal{X}_e\)</span>)</li></ul><p>在每个任务中，<span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>的定义是不同的，我们在第 VII-B 和 VII-C 节中介绍了详细信息</p><h2 id="考虑在线标定的优化">考虑在线标定的优化</h2><p>我们利用基于地图的测量来改进粗略初始化结果，在这里，我们将标定问题视为配准问题，<span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>分为两个函数，分别相对于<span class="math inline">\(\mathcal{X}_{v}\)</span>和<span class="math inline">\(\mathcal{X}_{e}\)</span>。</p><p><strong>对于<span class="math inline">\(\mathcal{X}_{v}\)</span>中的状态</strong>，这些约束由主传感器的最新帧的特征如<span class="math inline">\(\mathcal{F}^{b_{k}}, k \in[p+1, N+1]\)</span>，与主激光雷达的局部地图<span class="math inline">\(\mathcal{M}^{b}\)</span>之间的关联构成。</p><p><strong>对于<span class="math inline">\(\mathcal{X}_{e}\)</span>中的状态</strong>，这些约束由第i辅助激光雷达的第p帧的特征<span class="math inline">\(\mathcal{F}^{l_{p}^{i}}\)</span>与局部地图<span class="math inline">\(\mathcal{M}^{b}\)</span>的特征关联构成。</p><p><span class="math inline">\(\mathcal{F}^{b_{k}}\)</span>与局部特征地图<span class="math inline">\(\mathcal{M}^{b}\)</span>的关联使用[16]中的方法进行寻找，其中特征地图<span class="math inline">\(\mathcal{M}^{b}\)</span>使用了KD-TREE进行索引。</p><ol type="1"><li><p>对于边缘点，我们在局部边缘地图中的指定范围查找与之最近邻的点集合，记为<span class="math inline">\(\mathcal{S}\)</span>，然后计算点集的方差。点集的最大特征值对应的特征向量表示了与该边缘点所关联的直线的方向。通过计算点集的均值，即可确定边缘点对应的边缘线。</p></li><li><p>对于平面点，通过求解线性系统<span class="math inline">\(\mathbf{w s}+d=0, \forall \mathbf{s} \in \mathcal{S}\)</span>，可以得到在局部平面点云地图中与之关联的平面的系数，同样的，我们寻找<span class="math inline">\(\mathcal{F}^{l_{p}^{i}}\)</span>和<span class="math inline">\(\mathcal{M}^{b}\)</span>的关联。</p></li></ol><p>最后，我们将目标定义为在线标定的所有测量残差的总和，式（19）：</p><p><span class="math display">\[\begin{aligned}f_{\mathcal{M}}(\mathcal{X}) &amp;=f_{\mathcal{M}}\left(\mathcal{X}_{v}\right)+f_{\mathcal{M}}\left(\mathcal{X}_{e}\right) \\&amp;=\sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{b_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\Sigma_{\mathrm{p}}}^{2}\right)+\sum_{i=2}^{I} \sum_{\mathbf{p} \in \mathcal{F}^{l_{p}^{i}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}\)</span>表示从中枢坐标系到第k帧的变换</li><li><span class="math inline">\(\mathbf{x}_{p}\)</span>作为局部地图的起点状态</li></ul><h2 id="纯里程计的优化">纯里程计的优化</h2><p>一旦我们通过满足收敛标准完成在线校准（VII-D部分），然后就可以在给定准确外参的情况下进行纯里程计的优化。在这种情况下，我们没有优化外参，并利用基于地图的测量来改善单激光的里程计。</p><p>我们将所有 LiDAR 和局部地图的特征之间的约束合并到成本函数中：</p><p><span class="math display">\[\begin{aligned}f_{\mathcal{M}}(\mathcal{X}) &amp;=f_{\mathcal{M}}\left(\mathcal{X}_{v}\right) \\&amp;=\sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{b_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\Sigma_{\mathbf{p}}}^{2}\right) \\&amp;+\sum_{i=2}^{I} \sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{l^{i}_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k} \mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{p}^{-1} \mathbf{x}_{k} \mathbf{x}_{l^{i}}^{b}\)</span>表示第k帧下，从主激光雷达的局部地图坐标系（pivot frame）到辅助激光雷达坐标系的变换。</li></ul><h2 id="外参标定收敛性管理">外参标定收敛性管理</h2><p>在以无人监督的方式工作在线标定时，判断标定是否收敛是有意义的，收敛后，我们就可以固定外参。这对我们的系统有益，因为里程计和建图都是从辅助雷达获得更多几何约束，以便更准确地进行位姿估计。</p><p>如[34]中得出，作为信息矩阵的最小特征值的退化因子λ揭示了基于优化的状态估计问题的条件。通过这项工作的影响，我们使用λ表示是否包含足够的约束来获取准确的外参。</p><p>更新外参和收敛性监视器的详细流水线总结如算法1所示：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/04/20211004233254.png"></p><p>算法采用式（19）定义的函数<span class="math inline">\(f_{\mathcal{M}}(\cdot)\)</span>，以及使用当前的外参作为输入，并返回优化后的外参。</p><ul><li>在第4行，我们从<code>cost function</code>的信息矩阵中计算<span class="math inline">\(\lambda\)</span>，</li><li>在5-7行，如果<span class="math inline">\(\lambda\)</span>大于阈值，则对外参进行更新。</li><li>在第8行，我们使用的外参候选值来检查收敛性。</li><li>在第9-10行，收敛性判断条件满足，因此触发停止标定。然后计算<span class="math inline">\(\mathcal{L}\)</span>的采样均值，作为输出的外参结果，并且采样协方差作为标定的协方差。</li></ul><h2 id="边缘化">边缘化</h2><p>我们应用边缘化技术来删除滑动窗口中的最旧变量状态，边缘化是将历史约束作为目标融合的过程，这是维持里程计和标定结果一致性的重要步骤。</p><p>在我们的系统中，<span class="math inline">\(\mathbf{x}_{p}\)</span>是在每次优化后被边缘化的唯一的状态，通过应用<code>Schur Complement</code>，我们得到关于保留状态的信息矩阵<span class="math inline">\(\mathbf{A}_{rr}^{*}\)</span>和残差<span class="math inline">\(\mathbf{g}_{r}^{*}\)</span>。因此，由边缘化得到的先验残差项可写成：<span class="math inline">\(\left\|\mathbf{r}_{p r i}\right\|^{2}=\mathbf{g}_{r}^{* \top} \boldsymbol{\Lambda}_{r r}^{*-1} \mathbf{g}_{r}^{*}\)</span>，<code>Appendix B</code>会给出更加详细的数学推导。</p><h1 id="考虑不确定性的多激光雷达建图">考虑不确定性的多激光雷达建图</h1><p>我们首先回顾了典型 LiDAR SLAM 系统的建图模块的管道 [16]-[18]，以里程计先验作为输入，算法构建全局地图并使用足够的约束来对pose关键帧进行精细化调整。这通过最小化所有基于地图的残差项之和来实现，式（21）：</p><p><span class="math display">\[\hat{\mathbf{x}}_{b_{k}}^{w}=\underset{\mathbf{x}_{b_{k}}^{w}}{\arg \min } \sum_{i=1}^{I}\sum_{\mathbf{p} \in \mathcal{F}_{k}^{l^{i}_{k}}}\rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{b_{k}}^{w} \mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\]</span></p><p>其中,</p><ul><li><span class="math inline">\(\mathcal{F}^{l_{k}^{i}}\)</span>是第k帧点云的特征点</li><li><span class="math inline">\(\mathcal{G}_{\mathcal{F}}^{w_{k}}\)</span>是全局地图</li><li><span class="math inline">\(\mathbf{x}_{b_{k}}^{w} \mathbf{x}_{l^{i}}^{b}\)</span>表示第k帧时刻第i个激光雷达的状态</li></ul><p>我们使用Section VII-B中的方法查找<span class="math inline">\(\mathcal{F}^{l_{k}^{i}}\)</span>和<span class="math inline">\(\mathcal{G}_{\mathcal{F}}^{w_{k}}\)</span>之前的特征关联。在求解式（21）之后，求解的位姿将用于将特征点转换到世界坐标系，然后添加到全局地图上。为了降低计算和内存复杂性，地图也使用体素滤波器[71]进行降采样。但是，优化的精度取决于地图质量。图5展示了使用不确定的pose得到的带有噪声的地图点。我们认为，三个不确定性来源使地图点嘈杂：传感器噪声，退化姿态估计和外参扰动。</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/05/20211005104501.png"></p><p>在下一节中，我们将激光测量点和位姿求解的不确定性传播到地图点上。结果，每个地图点都被建模为高斯变量。 然后，我们提出了一种考虑不确定性的方法来提高多激光雷达建图算法的鲁棒性和准确性。</p><h2 id="不确定性传播">不确定性传播</h2><p>继续在第III-C节中描述，我们现在计算协方差<span class="math inline">\(\Xi\)</span>，mapping的位姿通过求解式（21）的NLS问题得到，我们直接计算信息矩阵的逆，即<span class="math inline">\(\mathbf{\Xi}_{\mathbf{x}_{b_{k}}^{w}}=\boldsymbol{\Lambda}^{-1}\)</span>作为协方差。</p><p>外参协方差的设置取决于特定的情况，我们通用的把外参协方差定义如下：</p><p><span class="math display">\[\boldsymbol{\Xi}_{\mathbf{x}_{l^{i}}^{b}}=\alpha \cdot \boldsymbol{\Xi}_{\text {calib }}, \quad \boldsymbol{\xi}_{l^{i}}^{b} \sim \mathcal{N}\left(\mathbf{0}, \boldsymbol{\Xi}_{\mathbf{x}_{l^{i}}^{b}}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\boldsymbol{\xi}_{l^{i}}^{b}\)</span>是外参的扰动变量</li><li><span class="math inline">\(\boldsymbol{\Xi}_{\text {calib }}\)</span>是通过算法1计算得到的标定协方差</li><li><span class="math inline">\(\alpha\)</span>是缩放系数，用于控制协方差的量级</li></ul><p>如果多激光雷达系统最近被标定过，我们设置<span class="math inline">\(\alpha=1\)</span>，如果系统使用了很长时间且没有进行重新标定，激光雷达之间的外参会存在小的偏差，<span class="math inline">\(\alpha\)</span>将被设置为更大的值。它具有与时间和外部影响的隐含关系，以及温度漂移。</p><p>给定主激光雷达的pose均值以及外参的均值和协方差，然后计算其他雷达pose的均值和协方差，如<span class="math inline">\(\left\{\mathbf{T}_{l_{k}^{i}}^{w}, \boldsymbol{\Xi}_{l_{k}^{i}}^{w}\right\}\)</span>，这是一个关于两个含有噪声的复合pose的问题，我们遵循[19]中的4阶近似来计算他们。</p><p>然后，我们需要通过一个包含噪声的位姿变换来传播高斯不确定性，以产生新的地图点（landmark），如<span class="math inline">\(\mathbf{y} \in \mathcal{G}_{\mathcal{F}}^{w_{k+1}}\)</span>，其均值和方差为<span class="math inline">\(\{\overline{\mathbf{y}}, \boldsymbol{\Sigma}\}\)</span>，利用将点进行坐标变换的公式，可得：</p><p><span class="math display">\[\begin{aligned}\mathbf{y} \triangleq \mathbf{T}_{l_{k}^{i}}^{w} \mathbf{p}_{h} &amp;=\exp \left(\boldsymbol{\xi}_{e l_{k}^{i}}^{w^{\wedge}}\right) \overline{\mathbf{T}}_{l_{k}^{i}}^{w}\left(\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}\right) \\&amp; \approx\left(\mathbf{I}+\boldsymbol{\xi}_{l_{k}^{i}}^{w^{\wedge}}\right) \mathbf{\mathbf { T }}_{l_{k}^{i}}^{w}\left(\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}\right)\end{aligned}\]</span></p><p>其中，我们只保留指数映射<span class="math inline">\(\exp(\cdot)\)</span>的一阶近似。</p><p>进一步的，如果我们展开等式，并仅保留一阶项，我们有：</p><p><span class="math display">\[\mathbf{y} \approx \mathbf{h}+\mathbf{H} \boldsymbol{\theta}\]</span></p><p>其中，</p><p><span class="math display">\[\mathbf{h}=\overline{\mathbf{T}}_{l_{k}^{i}}^{w} \overline{\mathbf{p}}_{h}, \quad \mathbf{H}=\left[\left(\overline{\mathbf{T}}_{l_{k}^{i}}^{w} \overline{\mathbf{p}}_{h}\right)^{\odot} \quad \overline{\mathbf{T}}_{l_{k}^{i}}^{w} \mathbf{D}\right]\]</span></p><p><span class="math display">\[\boldsymbol{\theta}=\left[\boldsymbol{\xi}_{l_{k}^{i}}^{w \top}, \boldsymbol{\zeta}^{\top}\right]^{\top}, \quad \boldsymbol{\theta} \sim \mathcal{N}(\mathbf{0}, \boldsymbol{\Theta}), \quad \boldsymbol{\Theta}=\operatorname{diag}\left(\boldsymbol{\Xi}_{l_{k}^{i}}^{w}, \mathbf{Z}\right)\]</span></p><p>特别的，操作符<span class="math inline">\(\odot\)</span>表示将4x1的向量转换为4x6的矩阵：</p><p><span class="math display">\[\left[\begin{array}{l}\varepsilon \\\eta\end{array}\right]^{\odot}=\left[\begin{array}{cc}\eta \mathbf{I} &amp; -\boldsymbol{\varepsilon}^{\wedge} \\\mathbf{0}^{\top} &amp; \mathbf{0}^{\top}\end{array}\right], \quad \boldsymbol{\varepsilon} \in \mathbb{R}^{3}, \quad \eta=1\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;robust-odometry-and-mapping-for-multi-lidar-systems-with-online-extrinsic-calibration&quot;&gt;Robust Odometry and Mapping for Multi-LiDAR S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/12/18/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_6/"/>
    <id>http://yoursite.com/2022/12/18/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_6/</id>
    <published>2022-12-18T08:25:38.748Z</published>
    <updated>2022-06-26T21:28:37.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
      <category term="传感器标定" scheme="http://yoursite.com/categories/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>基于层次BA的高一致性大规模激光建图</title>
    <link href="http://yoursite.com/2022/11/12/HBA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/11/12/HBA%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-11-12T12:16:30.000Z</published>
    <updated>2023-06-27T14:17:32.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="large-scale-lidar-consistent-mapping-using-hierarchical-lidar-bundle-adjustment">Large-Scale LiDAR Consistent Mapping using Hierarchical LiDAR Bundle Adjustment</h1><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343283-0.png"></p><h1 id="摘要">摘要</h1><p>重建精确一致的大规模激光雷达点云图对机器人应用至关重要。现有的位姿图优化方法虽然效率高，但不能直接优化建图一致性。激光雷达束调整(BA)最近被提出来解决这个问题;然而，这在大尺度地图上太耗时了。为了解决这一问题，本文提出了一种适用于大尺度地图的全局一致且高效的制图方法。</p><p>我们提出的工作包括自底向上的层次BA和自顶向下的姿态图优化，结合了两种方法的优点。通过分层设计，我们用比原始BA小得多的Hessian矩阵大小解决了多个BA问题;通过姿态图优化，实现了激光雷达姿态的平稳高效更新。</p><p>我们提出的方法的有效性和鲁棒性已在多个空间和及时的大规模公共旋转LiDAR数据集上得到验证，如KITTI、MulRan和Newer College，以及结构化和非结构化场景下自收集的固态LiDAR数据集。通过适当的设置，我们证明了我们的工作可以在大约12%的序列时间内生成全局一致的建图。</p><h1 id="介绍">介绍</h1><p>激光雷达束调整(LiDAR bundle adjustment, BA)方法[5,6]通过最小化总体点面距离直接优化了建图一致性，这通常会带来高的建图质量，这是建图应用所必需的。在<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>中，首先解析求解平面参数，这样最终的优化问题只与LiDAR姿态有关。在<a href="LiDAR%20SLAM%20With%20Plane%20Adjustment%20for%20Indoor%20Environment">6</a>中，与visual BA[7,8]一样，通过Schur补技巧在每次优化迭代中消除平面参数。无论哪种方式，得到的优化结果(至少)是LiDAR位姿数N的维数，需要O(n3)时间来求解<a href="Efficient%20and%20Consistent%20Bundle%20Adjustment%20on%20Lidar%20Point%20Clouds(BALM2)">9</a>。由于计算时间的三次增长，对于具有较大位姿数的大比例尺地图，无法进行束调整。</p><blockquote></blockquote><p>针对上述问题，我们提出了一种分层LiDAR BA方法，在保持时间效率的前提下全局优化建图一致性。该方法构建框架位姿的金字塔结构(如图1)，并进行自底向上的层次BA调整和自顶向下的位姿图优化(如图2)。自底向上过程在从底层(局部BA)到顶层帧(全局BA)的局部窗口内进行层次BA调整。这样的设计大大提高了计算时间，每层局部BA的处理适合并行处理，而且由于涉及的位姿较少，每个局部BA的时间复杂度相对较低。自底向上过程中的一个问题是它忽略了在不同的局部窗口中共同可见的特征，这可能会降低精度。为了缓解这个问题，自顶向下的过程构造一个从上到下的位姿图，并通过位姿图优化分配错误。这两个过程迭代直到收敛。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343687-0.png"></p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343704-0.png"></p><p>通过分层BA调整设计，既可以直接优化点云内平面的一致性，又可以避免求解大维的代价函数。通过位姿图优化，我们以快速可靠的方式对整个激光雷达位姿进行适当的收敛更新。为了保持每两个相邻关键帧之间的平滑性，我们通过设置步幅大小小于窗口大小来保持它们之间的重叠区域。为了进一步提高优化速度，我们在构建金字塔时使用了滤波器去除异常点，并实现了基于cpu的并行处理。综上所述，我们的贡献如下:</p><ul><li>提出了一种分层束调整方法，以全局优化激光雷达建图一致性和里程测量精度。在给定良好的初始位姿轨迹(例如，从位姿图优化)的情况下，我们提出的方法提高了建图质量，甚至在初始位姿轨迹有较大漂移时缩小间隙</li><li>我们提出的工作的有效性已经在多个公共机械旋转激光雷达数据集和我们自己收集的固态激光雷达数据集上进行了结构化和非结构化场景的验证</li></ul><h1 id="相关工作">相关工作</h1><p>文献中讨论了多种提高建图质量的方法，主要分为两类:基于位姿图优化的方法和基于平面(束)调整的方法。在位姿图优化中，两帧之间的相对变换(位姿约束)由ICP[10]或其变体估计[11,12]。这个相对位姿误差然后由信息矩阵加权，通常是对应的Hessian<a href="Real-time%20loop%20closure%20in%202D%20LIDAR%20SLAM">13</a>的逆矩阵或简单的常数矩阵[14]。当总和相对位姿误差最小时，对位姿图进行优化。尽管姿态图优化的计算效率很高，但它的一个重要问题是<strong>不能直接优化点云的一致性</strong>。由于相对位姿约束的不正确估计或不精确建模，位姿图可能收敛到局部最小值，点云内仍可能存在较大的发散<a href="MULLS,">3,15</a>。</p><p>平面调整方法通过最小化点到平面的总和距离，直接优化点云的一致性。在平面调整中，每个平面特征用两个参数表示，即平面到原点的距离和平面法向量<a href="LiDAR%20SLAM%20With%20Plane%20Adjustment%20for%20Indoor%20Environment">6</a>，在[16]中，作者同时优化了激光雷达姿态和几何平面特征。该方法在优化过程中需要对所有特征的参数进行维护和更新，而随着地图规模的扩大，特征的总数会迅速增长，导致代价函数的维数很大。虽然使用舒尔补法可以将优化变量简化为激光雷达位姿，但在实际操作中，该方法在优化过程中容易产生位姿估计故障。</p><p>BA调整方法改进了平面调整技术，通过在优化前消除特征估计参数，使用一个封闭形式的解<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>，在<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>中，作者将点云分割为多个体素，每个体素包含一个平面特征。将原来的点到面最小化问题转化为每个体素中点协方差特征值的最小化问题。这种方法需要遍历每个特征内的每个点来推导Hessian矩阵，而Hessian矩阵的时间复杂度是点数的平方，计算量很大。该问题在后续工作<a href="**Efficient%20and%20Consistent%20Bundle%20Adjustment%20on%20Lidar%20Point%20Clouds**">9</a>中得到解决，该工作将同一姿态观察到的特征的所有点进行了聚合，从根本上消除了时间复杂度对点数的依赖。</p><p>尽管如此，在上述所有的平面和束调整方法中，计算复杂度仍然是位姿数量的三次方，对于大比例尺地图来说并不实用。此外，当地图中的散度大于或接近最大体素大小时，这些方法可能具有较慢的收敛速度。</p><p>我们提出的分层束调整方法同时利用了BA和姿态图优化。我们使用BA直接最小化点到面距离和位姿图优化来平滑有效地更新激光雷达的位姿，以避免位姿估计中的故障。通过分层设计，我们可以用比原来的<a href="BALM">5</a>小得多的Hessian矩阵大小并行解决多个BA问题。通过分层设计，我们可以用比原来的<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>小得多的Hessian矩阵大小并行解决多个BA问题。此外，我们可以根据初始姿态轨迹的质量灵活地设置从底层到顶层的BA参数。</p><h1 id="方法">方法</h1><h2 id="概览">概览</h2><p>所提方法的系统工作流程如图2所示。输入是来自每次激光雷达扫描的原始点或去畸变点云，以及它们在全局坐标系中相应姿态的初始估计，这可以从一般激光雷达里程计或同步运动和建图(SLAM)算法中获得。该方法由两个过程组成，自底向上(见第III-B节)和自顶向下(见第III-C节)，迭代直到收敛。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343704-0.png"></p><p>在自底向上的过程中，对较小的局部窗口内的LiDAR帧进行局部BA，构建从第一层到第二层的关键帧(如图1)。这个过程是分层执行的，直到满足最优层数，并在顶层关键帧上执行全局BA。然后利用各优化层和相邻层之间的因子构建位姿图(如图1所示)。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/07/1670343687-0.png"></p><p>如图1所示，<code>first layer</code>(在上文中的bottom layer)描述了初始LiDAR帧和姿态的集合。类似地，<code>second laye</code>r表示使用局部BA从<code>first layer</code>创建的LiDAR关键帧和姿态的集合。<code>top layer</code>是指最后剩下的LiDAR关键帧的集合(在图1中，顶层指第三层)。</p><p>核心思想：</p><ul><li>从底层到顶层分层创建LiDAR关键帧的过程称为自底向上过程。</li><li>通过姿态图优化来更新底层激光雷达姿态的过程称为自顶向下过程。</li></ul><h2 id="自底向上的ba-bottom-up-hierarchical-ba">自底向上的BA （Bottom-Up Hierarchical BA）</h2><ul><li>记<span class="math inline">\(\mathbb{F}_j^i\)</span>为第i层的第j帧雷达，以及<span class="math inline">\(\mathbf{x}_j^i \triangleq \mathbf{T}_j^i=(\mathbf{R}, \mathbf{t}) \in \operatorname{SE}(3)\)</span>为对应的位姿。</li><li>记<span class="math inline">\(\mathbf{T}_{j, k}^i\)</span>为<span class="math inline">\(\mathbf{T}_j^i\)</span>和<span class="math inline">\(\mathbf{T}_k^i\)</span>的相对位姿，即<span class="math inline">\(\mathbf{T}_{j, k}^i=\left(\mathbf{T}_j^i\right)^{-1} \cdot \mathbf{T}_k^i\)</span></li><li>需要注意的是，<span class="math inline">\(\mathbb{F}_j^i\)</span>是在雷达坐标系的点云，而位姿T是全局坐标系下的</li><li>此外，记<span class="math inline">\(w\)</span>为局部窗口大小，<span class="math inline">\(S\)</span>为自底向上构造LiDAR关键帧时的步幅大小，如图1所示。</li></ul><p>假设我们有<span class="math inline">\(N_i\)</span>帧点云（在第i层），在自底向上的过程中，利用所提供的初始姿态轨迹在每个局部窗口中进行局部BA，并优化<strong>每帧与该窗口第一帧之间的相对姿态</strong>。特别的，各局部窗口BA导出的Hessian矩阵H会被记录，并将其作为后续自顶向下的姿态图构造的信息矩阵。</p><p>给定一个在第i层，含有w帧点云的局部窗口<span class="math inline">\(\left\{\mathbb{F}_{s j+k}^i \mid j=0, \cdots,\left\lfloor\frac{N_i-w}{s}\right\rfloor ; k=0, \cdots, w-1\right\}\)</span>及其优化之后的所有相对位姿<span class="math inline">\(\mathbf{T}_{j, k}^{i *}\)</span>，我们将这些帧聚合成第(i+1)层的<strong>一个关键帧</strong>。即每一帧中的所有点都转换到局部窗口的第一帧，新的关键帧的位姿<span class="math inline">\(\mathbf{T}_j^{i+1}\)</span>，其初值被设置为前一次局部窗口优化后的第一帧的pose。即有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/08/1670507170-0.png"></p><p>这一过程可以从下层到上层重复进行，直到达到最优层数<span class="math inline">\(l\)</span>。值得注意的是，新的关键帧(局部BA)的构造不依赖于局部窗口外的帧，这使得可以同一层中的多个局部窗口并行处理。假设我们总共有N帧雷达点云，如<span class="math inline">\(N_1=N\)</span>，在每个时间，我们选择<span class="math inline">\(w\)</span>帧以<span class="math inline">\(s\)</span>为步长从低层到高层，设n为可用于并行处理的线程数。由于BA的计算时间为<span class="math inline">\(O\left(M^3\right)\)</span>， <span class="math inline">\(M\)</span>为涉及的姿态数，我们可以推导出第<span class="math inline">\(l\)</span>层金字塔的总时间消耗<span class="math inline">\(O\left(T_l\right)\)</span></p><p>第l层金字塔的总时间消耗包括每层局部BA消耗的时间和顶层全局BA消耗的时间。对于第l层金字塔，第i层的局部窗口数(i &lt; l)为<span class="math inline">\(\frac{N}{s^i}\)</span>，每个局部窗口消耗<span class="math inline">\(O\left(w^3\right)\)</span>个时间。当有n个并行线程时，本地BA的总时间消耗为各层本地BA的总和，即<span class="math inline">\(w^3 \cdot\left(\sum_{i=1}^{l-1} \frac{N}{s^i} \cdot \frac{1}{n}\right)\)</span>，以及第l层的全局BA花费时间为：<span class="math inline">\(O\left(\left(\frac{N}{s^{l-1}}\right)^3\right)\)</span>。因此，第l层的时间复杂度总结如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/11/1670766549-0.png"></p><p>我们把<span class="math inline">\(T_l\)</span>看作l的函数，通过让<span class="math inline">\(T_l\)</span>的导数等于零来计算最优<span class="math inline">\(l^*\)</span>，这就得到：</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/11/1670766625-0.png"></p><p>图3给出了不同帧数N时，计算时间<span class="math inline">\(T_l\)</span>随层数l的变化示例，可以看出，随着层数从l=1(原始BA)增加到<span class="math inline">\(l^*\)</span>，计算时间大大减少，这表明了所提出的分层BA的有效性。当<span class="math inline">\(l &gt; l^*\)</span>时，计算时间不会增加太多，几乎保持不变，这表明任何大于<span class="math inline">\(l^*\)</span>的层数都同样有效。</p><p><img src="https://s1.nsloop.com:58443/images/2022/12/11/1670766690-0_1.png"></p><p>对于自底向上的分层BA中各层的特征提取和关联，我们使用<a href="BALM:%20Bundle%20Adjustment%20for%20Lidar%20Mapping">5</a>（BALM）中提出的自适应体素化方法，提取适合不同结构环境的不同大小的平面特征。为了提取这些<strong>不同尺寸的平面特征</strong>，整个点云在使用初始姿态轨迹转换为相同的全局坐标系后，被分割成大小为V的多个体素，每一个都通过平面测试，检查所含点的最小(V1)和最大特征值(V3)之比小于阈值，如<span class="math inline">\(\frac{\lambda_1}{\lambda_3}&lt;\theta\)</span>，如果平面测试通过，体素中的点将被视为位于同一平面上并在BA中使用，否则，体素将被递归分割，直到包含的点形成一个平面。</p><p>上述自适应体素化过程在点数非常大的情况下非常耗时。为了缓解这个问题，我们注意到<strong>在低层中不被认为是平面特征的点在上层中也不会形成平面</strong>。因此，在自底向上的过程中，我们<strong>只使用局部BA中每个体素的平面特征点来构造上层的关键帧</strong>。该方法进一步节省了下一层自适应体素图构建的时间，提高了局部BA的计算精度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;large-scale-lidar-consistent-mapping-using-hierarchical-lidar-bundle-adjustment&quot;&gt;Large-Scale LiDAR Consistent Mapping using Hierarch
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ICP协方差分析 On the Covariance of ICP-based Scan-matching Techniques</title>
    <link href="http://yoursite.com/2022/11/12/ICP%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2022/11/12/ICP%E5%8D%8F%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90/</id>
    <published>2022-11-12T12:16:30.000Z</published>
    <updated>2023-06-27T14:17:57.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="on-the-covariance-of-icp-based-scan-matching-techniques">On the Covariance of ICP-based Scan-matching Techniques</h1><p><img src="https://s1.nsloop.com:58443/images/2022/11/12/1668261534-0.png"></p><h1 id="摘要">摘要</h1><p>本文研究迭代最近点(ICP)算法计算旋转平移的协方差估计问题。这个问题与移动机器人和装备了深度传感相机(如Kinect)或激光雷达(如Velodyne)的车辆的定位问题有关。以往文献中提出的封闭形式的协方差公式通常建立在ICP的解是通过最小化线性最小二乘问题得到的这一事实之上。在本文中，我们表明这种方法需要谨慎，因为算法的重新匹配步骤没有显式解释，并将其应用于点到点版本的ICP导致完全错误的协方差。然后，我们给出了一个形式化的数学证明，证明了该方法在点到平面的ICP版本中是有效的，从而验证了从业者的直觉和实验结果。</p><h1 id="介绍">介绍</h1><p>相对旋转-平移估计的协方差不仅取决于传感器噪声特性，还取决于环境的几何形状。实际上，当使用ICP进行扫描匹配时，有几个误差来源会起作用：</p><ul><li>在一次扫描中没有在后续扫描中观察到几何图形的存在，也就是说，缺乏重叠</li><li>点的不匹配，也就是说，如果扫描开始时彼此距离很远，则ICP可能会降到局部(而不是全局)最小值，从而产生错误的旋转平移估计</li><li>即使1)和2)没有发生，由于传感器噪声和可能的欠约束环境(如长而无特征的走廊)，计算出的估计仍然具有不确定性</li></ul><p>在实践中，第一个问题可以通过拒绝具有过多距离度量或位于扫描边界[11]附近的点对来解决，第二个问题可以通过使用航迹估计预对齐扫描或使用足够快的采样率来解决。因此，我们将把重点放在<strong>第三个</strong>误差来源上。</p><p>通过扫描匹配算法(如ICP)得到的估计的协方差可以从文献[12]，[13]得到。</p><p>要估计的变换<span class="math inline">\(\hat{x}\)</span>由代价函数J(x, z)的局部argmin得到，其中<span class="math inline">\(z\)</span>为当前扫描到的点云。</p><p>结果，我们期望得到<span class="math inline">\(\frac{\partial}{\partial x} J(\hat{x}, z)=0\)</span>，根据隐函数定理，此时x是数据z在这个函数最小值附近。</p><p>因此，如果此时观测数据z(点云)有一个小的扰动<span class="math inline">\(\delta z\)</span>，意味着<span class="math inline">\(\delta x\)</span>也有小的变化<span class="math inline">\(\frac{\partial^2 J}{\partial x^2} \delta x+\frac{\partial^2 J}{\partial z \partial x} \delta z=0\)</span>，即有：</p><p><span class="math display">\[\delta x=-\left(\frac{\partial^2 J}{\partial x^2}\right)^{-1} \frac{\partial^2 J}{\partial z \partial x} \delta z\]</span></p><p>因此，如果<span class="math inline">\(\delta z\)</span>表示由于传感器噪声造成的测量(随机)差异，则估计中相应的可变性<span class="math inline">\(\delta x=\hat{x}-x\)</span>，其中方差为：</p><p><span class="math display">\[\mathbb{E}\left(\delta x \delta x^T\right)=\operatorname{cov}(\hat{x})\]</span></p><p><img src="https://s1.nsloop.com:58443/images/2022/11/12/1668263744-0.png"></p><p>我们的目标是指出这个公式在ICP协方差计算方面的<strong>潜在有效性不足</strong>，但也要描述它可以安全使用的情况。具体来说，几何配准(1)的问题在于它依赖于<span class="math inline">\(\delta x=-\left(\frac{\partial^2 J}{\partial x^2}\right)^{-1} \frac{\partial^2 J}{\partial z \partial x} \delta z\)</span>，这是基于局部隐函数定理的，它只适用于无穷小的变化<span class="math inline">\(\delta x, \delta z\)</span>。在ICP的情况下，无穷小意味着亚像素位移，的确，在匹配扫描时，ICP执行的重新匹配步骤使代价函数远不是平滑的，因此对代价函数进行泰勒展开有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/11/12/1668263773-0.png"></p><p>这在极限∆x→0中是正确的，但当位移∆x大于几个像素时，结果可能完全错误。这方面的一个例子将在Section II-A.2. 中给出。另一方面，如果将配准误差投影到参考曲面上，如点到面ICP[2]，则式(1)将给出有效结果。这将在第三节中得到正式证明。</p><p>我们的论文是[13]和[14]结果的推广和严格证明。我们的主要贡献是指出盲目应用(1)的潜在缺点。然后基于第三节中的几何论证，为(1)点到面ICP的有效性提供形式化的数学证明。最后，我们将在第四节中用一个简单的3D示例说明结果。</p><h1 id="数学框架">数学框架</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;on-the-covariance-of-icp-based-scan-matching-techniques&quot;&gt;On the Covariance of ICP-based Scan-matching Techniques&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ROLI激光雷达IMU初始化及标定</title>
    <link href="http://yoursite.com/2022/03/06/Fast-LIO%E7%B3%BB%E5%88%97/ROLI%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEIMU%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%A0%87%E5%AE%9A/"/>
    <id>http://yoursite.com/2022/03/06/Fast-LIO%E7%B3%BB%E5%88%97/ROLI%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEIMU%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%A0%87%E5%AE%9A/</id>
    <published>2022-03-06T04:02:22.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="robust-and-online-lidar-inertial-initialization">Robust and Online LiDAR-inertial Initialization</h1><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306201811.png"></p><h1 id="介绍">介绍</h1><p>摘要：对于大多数LiDAR惯性里程计来说，精确的初始状态，包括时间偏差和LiDAR与6轴IMU之间的外参，起着重要的作用，通常被认为是前提条件。然而，在定制的激光雷达惯性系统中，这样的信息并不总是可用的，本文提出了一种完全在线的激光雷达惯性系统初始化过程，该过程通过校准激光雷达和IMU之间的时间偏差和外参，并通过将激光雷达测量的状态估计值与IMU测量的状态值对齐来校正重力矢量和IMU偏差。我们将所提出的方法实现为一个初始化模块，如果启用该模块，它将自动检测采集数据的激发程度，同时校准时间偏移量、外参偏移量、重力矢量和惯性测量单元偏差，然后将其用作在线激光雷达惯性里程仪系统的高质量初始状态值。对不同类型的激光雷达和激光雷达-惯性组合进行的实验表明了该初始化方法的鲁棒性、适应性和有效性。</p><p>我们的LiDAR-惯性初始化法的主要目的之一是在<strong>没有任何初始估计</strong>的情况下校准LiDAR和IMU之间的外特性。现有的一些外部标定方法是基于批量优化的，数据关联性很强，耗时较大。例如，Lveal。[14]提出了一种基于连续时间批优化的标定方法。B样条的使用使得需要估计的参数较多，计算量也较大。[15]使用扩展卡尔曼过滤估计运动补偿复杂的外域变换，收敛速度有限。与这些方法相比，我们的方法更轻量级，能够快速运行，同时仍然可以获得足够精确的外部校准，以便后续的在线估计(例如，通过[1])。我们的方法还校准了[14，15]中没有考虑的时间偏移。此外，文献[14，15]所采用的基于NDT的扫描-扫描匹配通常不适用于具有非重复扫描模式的激光雷达。相比之下，我们的方法采用了扫描到地图的匹配策略，可以很容易地应用重复扫描和非重复扫描的LiDAR。</p><h1 id="方法">方法</h1><h2 id="系统框架">系统框架</h2><p>由于IMU只有在运动时才被激发[15]，所以我们的初始化过程是基于运动的方法，这意味着充分的激励是必要的。我们工作流程的概述如图2所示，一些重要符号如表一所示。我们建议的LiDAR里程计(参见第III-B节)由FAST-LIO2[1]改进而来，采用恒定(角和线)速度(CV)模型来预测LiDAR运动并进行畸变矫正。</p><p>为了缓解恒速模型与传感器实际运动之间的失配，通过将输入帧分割成几个子帧来提高LiDAR里程计速率。</p><p>如果LiDAR里程计没有失效(例如，退化)，并且估计的LiDAR角速度和线速度满足我们建议的评估标准(参见第III-C5节)，则认为激励是足够的，并且LiDAR里程计输出和相应的IMU数据都被馈送到初始化模块(参见第III-C节)</p><p>在初始化中，首先通过移动IMU测量值来校准时间偏移，以与LiDAR里程计对准，然后进行优化处理，进一步细化时间偏移，校准外参，估计IMU偏差和重力矢量。通过融合后续的LiDAR和IMU数据，可以将初始化的状态附加到紧耦合的LiDAR惯性里程计(例如，[1])，用于在线状态估计。</p><h2 id="激光里程计">激光里程计</h2><p>我们的LiDAR里程计是建立在恒速(CV)运动模型上的，该模型假设在tk和tk+1接收到的两个连续扫描之间的角速度和线速度是恒定的，即，在tk和tk+1接收到的两个连续扫描之间，有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306215022.png"></p><p>其中<span class="math inline">\(\Delta t\)</span>是两帧扫描的时间间隔，状态向量<span class="math inline">\(\mathbf{x}\)</span>、噪声<span class="math inline">\(\mathbf{w}\)</span>和离散的状态转移函数<span class="math inline">\(\mathbf{f}\)</span>定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306215311.png"></p><p>其中：</p><ul><li><span class="math inline">\({ }^{G} \mathbf{R}_{L} \in S O(3)\)</span>和<span class="math inline">\({ }^{G} \mathbf{p}_{L}\)</span>分别表示激光雷达在全局坐标系（此处为第0帧激光坐标系）的姿态的位置</li><li><span class="math inline">\({ }^{G} \mathbf{v}_{L}\)</span>是激光雷达在全局坐标系的速度表示</li><li><span class="math inline">\(\omega_{L}\)</span>是激光雷达线速度（在激光雷达坐标系）</li><li>上述两个速度被分别被建模为由高斯噪声<span class="math inline">\(\mathbf{n}_{\mathbf{v}}\)</span>和<span class="math inline">\(\mathbf{n}_{\omega}\)</span>驱动的随机游走过程。</li></ul><p>在对于公式（1），使用文献[22]的记号<span class="math inline">\(\boxplus / \boxminus\)</span>紧凑地表示状态流形上的“+”。具体地说，对于公式(2)中的状态流形<span class="math inline">\(S O(3) \times \mathbb{R}^{n}\)</span>，运算及其逆定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306220010.png"></p><p>其中：</p><ul><li><span class="math inline">\(\mathbf{R}, \mathbf{R}_{1}, \mathbf{R}_{2} \in S O(3)\)</span>，</li><li><span class="math inline">\(\mathbf{r}, \mathbf{a}, \mathbf{b} \in \mathbb{R}^{n}\)</span></li><li><span class="math inline">\(\operatorname{Exp}(\cdot): \mathbb{R}^{3} \mapsto S O(3)\)</span> 表示指数映射</li><li><span class="math inline">\(\log (\cdot): S O(3) \mapsto \mathbb{R}^{3}\)</span>是指数映射的逆，即对数映射</li></ul><p>在实践中，传感器的运动可能不具有恒定速度。<strong>为了减轻这种模型误差的影响，我们可以将输入的LiDAR扫描分割成多个持续时间较短的子帧</strong>，在这些子帧上传感器的运动更符合CV模型。</p><h3 id="误差迭代卡尔曼">误差迭代卡尔曼</h3><p>基于流形上的系统表示(1)，我们使用误差状态迭代卡尔曼过滤(ESIKF)[23]来估计其状态，ESIKF的预测步骤由状态预测和协方差传播组成，如下所示：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306220634.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{P}\)</span>表示状态估计的协方差</li><li><span class="math inline">\(\mathbf{Q}\)</span>表示过程噪声<span class="math inline">\(\mathbf{w}\)</span>对应的协方差</li></ul><p><span class="math inline">\(\mathbf{F}_{\tilde{\mathbf{x}}}\)</span> 和 <span class="math inline">\(\mathbf{F}_{\mathbf{w}}\)</span>定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306220815.png"></p><blockquote><p>由误差状态微分方程可导出（上述Fx Fw是离散时间下的）</p></blockquote><h3 id="运动补偿">运动补偿</h3><p>在我们考虑的问题中，<strong>IMU和LiDAR是不同步的</strong>，因此文献[14，15]所采用的IMU辅助运动补偿方法是不可行的。</p><p>在时间戳<span class="math inline">\(t_{k+1}\)</span>处接收到新的激光雷达扫描之后，为了补偿运动失真，我们将在时间戳<span class="math inline">\(\rho_{j} \in\left(t_{k}, t_{k+1}\right)\)</span>处采样的每个包含点<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{j}\)</span>投影到扫描端激光雷达帧<span class="math inline">\(L_{k+1}\)</span>中，也就是将激光矫正<strong>到扫描结束时刻</strong>。</p><p>在恒速模型下，我们有<span class="math inline">\({}^G \widehat{\mathbf{v}}_{L_{k+1}}={}^G{\overline{\mathbf{v}}}_{L_{k}}, \widehat{\boldsymbol{\omega}}_{L_{k+1}}=\overline{\boldsymbol{\omega}}_{L_{k}}\)</span>，因此，可以导出<span class="math inline">\({}^{L_{k+1}} \check{\mathbf{T}}_{L_{j}}=\left({ }^{L_{k+1}} \check{\mathbf{R}}_{L_{j}},{ }^{L_{k+1}} \check{\mathbf{p}}_{L_{j}}\right)\)</span>的计算如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306221754.png"></p><p>然后，在时间段<span class="math inline">\(\rho_{j} \in\left(t_{k}, t_{k+1}\right)\)</span>内的测量<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{j}\)</span>可以被投影到扫描结束时刻，即：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306222001.png"></p><p>矫正之后的激光扫描<span class="math inline">\(\left\{ {}^{L_{k+1}} \mathbf{p}_{j}\right\}\)</span>用于提供未知状态<span class="math inline">\({}^G \mathbf{T}_{L_{k+1}}\)</span>的隐式测量，表示为点到面距离残差，在此基础上，在迭代卡尔曼滤波器框架中迭代估计完整状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>，直到收敛。这种迭代估计的细节可以参考FAST-LIO2[1]或[23]，以便更一般地处理流形约束。</p><p>收敛后的状态估计记为<span class="math inline">\(\overline{\mathbf{x}}_{k+1}\)</span>，将用于传播后续IMU测量，如第III-B1节所述。</p><p>图3中示出了使用有运动补偿和无运动补偿的扫描的映射结果比较。</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306222357.png"></p><h3 id="激光-惯性初始化">激光-惯性初始化</h3><p>第III-B节中的激光雷达里程计在每个扫描结束时间<span class="math inline">\(t_{k}\)</span>输出激光雷达的角速度<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>和线速度<span class="math inline">\({ }^{G} \mathbf{V}_{L_{k}}\)</span>。同时，惯性测量单元提供了原始测量，包括时间戳<span class="math inline">\(\tau_{i}\)</span>的body系角速度<span class="math inline">\(\omega_{m}\)</span>和线加速度<span class="math inline">\(\mathbf{a}_{m_{i}}\)</span>。这些数据按照第III-C5节所示的激励标准进行累积和重复评估。</p><p>一旦收集到足够激励的数据，就调用初始化模块，然后输出如下信息：</p><ul><li>时间偏移<span class="math inline">\({ }^{I} t_{L} \in \mathbb{R}\)</span></li><li>外参<span class="math inline">\({ }^{I} \mathbf{T}_{L}=\left({ }^{I} \mathbf{R}_{L},{ }^{I} \mathbf{p}_{L}\right) \in SE(3)\)</span></li><li>IMU Bias<span class="math inline">\(\mathbf{b}_{\omega}, \mathbf{b}_{\mathbf{a}} \in \mathbb{R}^{3}\)</span></li><li>以及全局坐标系下的重力向量<span class="math inline">\({ }^{G} \mathbf{g} \in \mathbb{R}^{3}\)</span></li></ul><ol type="1"><li>数据处理</li></ol><p>IMU原始测量数据收到噪声<span class="math inline">\(\mathbf{n}_{\omega_{i}}\)</span> 和 <span class="math inline">\(\mathbf{n}_{\mathbf{a}}\)</span>的影响，因此IMU测量模型如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306223946.png"></p><p>其中，</p><ul><li><span class="math inline">\(\omega_{i}^{\mathrm{gt}}, \mathbf{a}_{i}^{\mathrm{gt}}\)</span>是测量真值</li><li>同时，从激光里程计估计出来的<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},{ }^{G} \mathbf{v}_{L_{k}}\)</span>也包含了噪声</li></ul><p>为了消除这些通常是高频的噪声，使用了非因果零阶低通滤波器[24]来过滤噪声，而不会引入任何过滤延迟。<strong>零相位过滤是通过巴特沃斯低通滤波器的前向和后向运行来实现</strong>的[24]，得到噪声衰减（去除噪声影响的测量）的IMU测量<span class="math inline">\(\boldsymbol{\omega}_{I_{i}}=\boldsymbol{\omega}_{i}^{\mathrm{gt}}+\mathbf{b}_{\omega}, \mathbf{a}_{I_{i}}=\mathbf{a}_{i}^{\mathrm{gt}}+\mathbf{b}_{\mathbf{a}}\)</span>为表示简单起见，噪声衰减的激光里程计速度估计值仍然表示为<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},{ }^{G} \mathbf{v}_{L_{k}}\)</span>。</p><p>从激光雷达里程计得到的<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},^{G} \mathbf{v}_{L_{k}}\)</span>，通过非因果中心差分[25]得到激光雷达角加速度和线加速度<span class="math inline">\(\boldsymbol{\Omega}_{L_{k}},{ }^{G} \mathbf{a}_{L_{k}}\)</span>，因此，根据激光里程计得到的数据记为：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306233851.png"></p><p>类似地，我们从噪声衰减的陀螺测量<span class="math inline">\(\omega_{I}\)</span>得到角加速度<span class="math inline">\(\boldsymbol{\Omega}_{I_{i}}\)</span>，因此有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306234056.png"></p><p>由于IMU频率通常高于LiDAR odometer的频率，因此两个序列<span class="math inline">\(\mathcal{I}_{i}\)</span>和<span class="math inline">\(\mathcal{L}_{k}\)</span>的长度并不相同。为了解决这一问题，我们提取在同一时间段内接收的LiDAR和IMU数据，并通过在每个LiDAR里程计时间<span class="math inline">\(t_{k}\)</span>对<span class="math inline">\(\mathcal{I}_{i}\)</span>进行线性插值来实现下采样(参见图4)。</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306234448.png"></p><p>降采样的IMU数据记为<span class="math inline">\(\mathcal{I}_{k}\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306234533.png"></p><p>其中，<span class="math inline">\(\mathcal{I}_{k}\)</span>具有与<span class="math inline">\(\mathcal{L}_{k}\)</span>相同的时间戳<span class="math inline">\(t_{k}\)</span>(但是数据实际上被已知的时间常数<span class="math inline">\({ }^{I} t_{L}\)</span>延迟)。</p><ol start="2" type="1"><li>用互相关法进行时间初始化(Temporal Initialization by Cross-Correlation)</li></ol><p>在大多数情况下，由于LiDAR惯性里程计模块受到接收数据之前不可避免的传输和处理延迟，在LiDAR <span class="math inline">\(\mathcal{L}_{k}\)</span>和IMU <span class="math inline">\(\mathcal{I}_{k}\)</span>之间将存在未知但恒定的偏移<span class="math inline">\({ }^{I} t_{L}\)</span>（例如IMU数据，全部向前推进<span class="math inline">\({ }^{I} t_{L}\)</span>，则与激光雷达数据对齐）。</p><p>由于激光雷达数据公式(9)和IMU数据公式(11)处于离散时间<span class="math inline">\(t_{k}\)</span>，因此IMU数据的推进实质上是以离散时间步<span class="math inline">\(d={ }^{I} t_{L} / \Delta t\)</span>进行的，其中<span class="math inline">\(\Delta t\)</span>是两次激光雷达扫描之间的时间间隔。具体地说，对于角速度，我们有：</p><p>[[Pasted image 20220306235340.png]]</p><p>忽略通常很小的陀螺偏置bω，我们发现<span class="math inline">\(\boldsymbol{\omega}_{I_{k+d}}\)</span>和<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>的大小(模长)应该是相同的，而与外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>无关。受[16]的启发，我们使用互相关来量化它们之间的相似度。然后，偏移量<span class="math inline">\(d\)</span>可以从下面的优化问题中求解：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/06/20220306235549.png"> 通过枚举<span class="math inline">\(\mathcal{L}_{k}\)</span>的索引范围内的偏移量<span class="math inline">\(d\)</span>。</p><blockquote><p>这里是通过对IMU数据逐个前挪来实现对齐，所以<span class="math inline">\(d\)</span>的理解是：IMU前移1个数据，即前移了<span class="math inline">\(\Delta t\)</span>时间，所以<span class="math inline">\({ }^{I} t_{L}= d * \Delta t\)</span></p></blockquote><ol start="3" type="1"><li>统一的旋转外参和时间校准</li></ol><p>(2)中的互相关法对噪声和小尺度陀螺偏差具有较强的鲁棒性。但其的一个明显缺陷是，时间偏移的校准分辨率只能达到激光雷达里程计的一个采样间隔<span class="math inline">\(\Delta t\)</span>，不能识别任何小于<span class="math inline">\(\Delta t\)</span>的剩余偏移δt。</p><p>设<span class="math inline">\({ }^{I} t_{L}\)</span>为激光雷达里程计ωL与IMU数据ωi之间的总偏移量，则<span class="math inline">\({ }^{I_{t}} t_{L}=d^{*} \Delta t+\delta t\)</span>。与公式(12)类似，如果IMU测量<span class="math inline">\(\boldsymbol{\omega}_{I}\)</span>提前时间<span class="math inline">\({ }^{I} t_{L}\)</span>，则通过下式将与激光雷达里程计<span class="math inline">\(\omega_{L}\)</span>对齐：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308094706.png"></p><p>由于公式(9)中的实际激光雷达里程计<span class="math inline">\(\boldsymbol{\omega}_{L}\)</span>仅在时间戳<span class="math inline">\(t_{k}\)</span>处可用，用<span class="math inline">\(t=t_{k}\)</span>和<span class="math inline">\({ }^{I} t_{L}=d^{*} \Delta t+\delta t\)</span>代入到公式(14)，并注意到<span class="math inline">\(\boldsymbol{\omega}_{L}\left(t_{k}\right)=\boldsymbol{\omega}_{L_{k}}\)</span>，我们有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308094924.png"></p><p>注意到，<span class="math inline">\(\boldsymbol{\omega}_{I}\left(t_{k}+d^{*} \Delta t+\delta t\right)\)</span>是在时间戳为<span class="math inline">\(t_{k}+d^{*} \Delta t\)</span>之后紧跟的IMU角速度，而时间戳为<span class="math inline">\(t_{k}+d^{*} \Delta t\)</span>对应的角速度和角加速度分别为<span class="math inline">\(\omega_{I}\left(t_{k}+d^{*} \Delta t\right)=\omega_{I_{k}}\)</span>和<span class="math inline">\(\boldsymbol{\Omega}_{I}\left(t_{k}+d^{*} \Delta t\right)=\boldsymbol{\Omega}_{I_{k^{\prime}}}\)</span>，假设角加速度在小量<span class="math inline">\(\delta t\)</span>上恒定，我们可以插值得到<span class="math inline">\(\boldsymbol{\omega}_{I}\left(t_{k}+d^{*} \Delta t+\delta t\right)\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308095413.png"></p><p>将上式（16）代入公式（16），可以获得：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308095500.png"></p><p>最后，基于公式(17)中的约束，统一的时空优化问题可以表述为：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/08/20220308095721.png"></p><p>上述问题可通过<code>Ceres</code>迭代求解(由于非线性约束<span class="math inline">\({ }^{I} \mathbf{R}_{L} \in S O(3)\)</span>)，并且给定初始值为<span class="math inline">\(\left({ }^{I} \mathbf{R}_{L}, \mathbf{b}_{\omega}, \delta t\right)=\left(\mathbf{I}_{3 \times 3}, \mathbf{0}_{3 \times 1}, 0\right)\)</span></p><ol start="4" type="1"><li>平移外参与重力向量初始化</li></ol><p>在第III-C3节中，我们得到了外旋转<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>、陀螺偏置<span class="math inline">\(\mathbf{b}_{\omega}\)</span>和时间偏移量<span class="math inline">\({ }^{I} t_{L}\)</span>。在这一部分中，我们将固定这些值，然后进行平移外参、重力矢量和加速度偏差的校准。</p><p>首先，我们使用之前得到的偏移<span class="math inline">\(d^{*}\)</span>和<span class="math inline">\(\delta t\)</span>来对齐IMU数据<span class="math inline">\(\mathcal{I}_{k}\)</span>和雷达数据<span class="math inline">\(\mathcal{L}_{k}\)</span>。对齐的IMU数据表示为̄<span class="math inline">\(\overline{\mathcal{I}}_{k}\)</span>，现在认为它与<span class="math inline">\(\mathcal{L}_{k}\)</span>完全对齐，没有时间偏移。</p><p>具体地，在时间<span class="math inline">\(t_{k}\)</span>对应于LiDAR角速度̄<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>的IMU角速度<span class="math inline">\(\bar{\omega}_{I_{k}}\)</span>为（其实就是公式（15））：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309230908.png"></p><p>相似的，与时刻<span class="math inline">\(t_{k}\)</span>的LiDAR加速度<span class="math inline">\({ }^{G} \mathbf{a}_{L_{k}}\)</span>对应的IMU加速度̄<span class="math inline">\(\overline{\mathbf{a}}_{I_{k}}\)</span>为：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309231105.png"></p><p>与公式（14）类似，我们可以找到IMU和LiDAR之间的加速度约束。如文献[26]所述，具有固定外参的两个坐标系A、B的加速度具有以下关系：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309231254.png"></p><p>其中，</p><ul><li><span class="math inline">\({ }^{A} \mathbf{R}_{B},{ }^{A} \mathbf{p}_{B}\)</span>表示从B系到A系的外参变换</li><li><span class="math inline">\(\mathbf{a}_{A}, \mathbf{a}_{B}\)</span>分别是加速度在两个坐标系的表示</li></ul><blockquote><p>上面公式（21）怎么来的，为啥不是 <span class="math inline">\({ }^{A} \mathbf{R}_{B} \mathbf{a}_{B}=\mathbf{a}_{A}\)</span></p></blockquote><p>对于LiDAR-惯性系统，我们有两种选择：A用于IMU，B用于LiDAR，或者相反的情况。值得注意的是，在第一种情况下，<span class="math inline">\(\boldsymbol{\omega}_{A}=\overline{\boldsymbol{\omega}}_{I_{k}}-\mathbf{b}_{\omega}\)</span>的精度受到陀螺仪偏差估计的影响，并且<span class="math inline">\(\boldsymbol{\Omega}_{A}\)</span>的误差会因角速度测量中的噪声而被放大。</p><p>为了避免这一问题，增加外源平移校准的鲁棒性，我们将LiDAR设置为A，将IMU设置为B，由于LiDAR的加速度<span class="math inline">\({ }^{G} \mathbf{a}_{L_{k}}\)</span>是在全局坐标系中（即第0帧激光坐标系）描述的，所以我们需要将这个加速度转换到激光雷达坐标系下，记为<span class="math inline">\(\mathbf{a}_{L_{k}}\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309232853.png"></p><p>其中，<span class="math inline">\({ }^{G} \mathbf{R}_{L}\)</span>是LiDAR在激光里程计全局坐标系的姿态，由第III-B节中的LiDAR里程计获得。</p><p>最后，平移外参、加速度计偏置和重力矢量可以从以下优化问题中联合估计：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/09/20220309233109.png"></p><p>上述问题可以由<code>ceres</code>求解器迭代求解(由于约束<span class="math inline">\({ }^{G} \mathbf{g} \in \mathrm{S}_{2}\)</span>)，并且指定初始值<span class="math inline">\(\left({ }^{I} \mathbf{p}_{L}, \mathbf{b}_{\mathbf{a}},{ }^{G} \mathbf{g}\right)= \left(\mathbf{0}_{3 \times 1}, \mathbf{0}_{3 \times 1}, 9.81 \mathbf{e}_{3}\right)\)</span>。</p><p>在估计<span class="math inline">\({ }^{L} \mathbf{p}_{I}\)</span>之后，从激光雷达到IMU的转换计算如下：<span class="math inline">\({ }^{I} \mathbf{p}_{L}=-{ }^{I} \mathbf{R}_{L}^{L} \mathbf{p}_{I}\)</span></p><ol start="5" type="1"><li>数据累积评估</li></ol><p>提出的初始化方法依赖于LiDAR惯性器件的充分激励(充分运动)。因此，系统应该能够自行评估激励是否足以执行初始化。</p><p>理想情况下，可以通过公式（18）关于<span class="math inline">\(\left({ }^{I} \mathbf{R}_{L}, \mathbf{b}_{\omega}, \delta t\right)\)</span>和公式（23）关于<span class="math inline">\(\left({ }^{I} \mathbf{p}_{L}, \mathbf{b}_{\mathbf{a}},{ }^{G} \mathbf{g}\right)\)</span>的的全雅可比矩阵的秩来评估激励。</p><p>在实际中，我们发现，使用关于外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>和<span class="math inline">\({ }^{I} \mathbf{p}_{L}\)</span>的雅可比来评估运动就足够了，因为对外参的激发通常需要复杂的运动，这也会激发其他状态。因此，记<span class="math inline">\(\mathbf{J}_{r}\)</span>为公式（18）对旋转外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>的雅可比，<span class="math inline">\(\mathbf{J}_{t}\)</span>为公式（23）对平移外参<span class="math inline">\({ }^{I} \mathbf{p}_{L}\)</span>的雅可比，如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/10/20220310094624.png"></p><p>那么，激励可以通过对以下矩阵的秩来进行评估：</p><ul><li><span class="math inline">\(\mathbf{J}_{r}^{T} \mathbf{J}_{r}=\sum\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor{ }_{\wedge}^{T}\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor \wedge\)</span></li><li><span class="math inline">\(\mathbf{J}_{t}^{T} \mathbf{J}_{t}=\sum\left(\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor_{\wedge}^{2}+ \left\lfloor\boldsymbol{\Omega}_{\left.L_{k}\right\rfloor}\right\rfloor_{\wedge}\right)^{T}\left(\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor_{\Lambda}^{2}+\left\lfloor\boldsymbol{\Omega}_{L_{k}}\right\rfloor \wedge\right)\)</span></li></ul><p>更定量地，用<span class="math inline">\(\mathbf{J}_{r}^{T} \mathbf{J}_{r}\)</span>和<span class="math inline">\(\mathbf{J}_{t}^{T} \mathbf{J}_{t}\)</span>的奇异值来表示激发的程度。<strong>根据这一原理，我们开发了一个评估程序，可以指导用户如何移动他们的设备以获得足够的激励</strong>。我们根据雅可比矩阵的奇异值来量化激励，并用来评估激励是否充分。</p><h1 id="参考">参考</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;robust-and-online-lidar-inertial-initialization&quot;&gt;Robust and Online LiDAR-inertial Initialization&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.nsloop
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>IEKF迭代扩展卡尔曼滤波器</title>
    <link href="http://yoursite.com/2022/02/28/Fast-LIO%E7%B3%BB%E5%88%97/IEKF%E8%BF%AD%E4%BB%A3%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>http://yoursite.com/2022/02/28/Fast-LIO%E7%B3%BB%E5%88%97/IEKF%E8%BF%AD%E4%BB%A3%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/</id>
    <published>2022-02-28T14:02:22.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="performance-evaluation-of-iterated-extended-kalman-filterwith-variable-step-length">Performance evaluation of iterated extended Kalman filterwith variable step-length</h1><h1 id="介绍">介绍</h1><p>优化方法主要基于最小化均方误差准则，对于线性高斯系统，导致了著名的卡尔曼滤波。与提供状态的条件PDF的贝叶斯方法不同，最优化方法提供状态的点估计和估计误差的相应协方差矩阵(CM)。与贝叶斯方法一样，基于最优化方法的状态估计问题只能在少数特殊情况下得到解析解。对于其他情况，估计方法通常遵循卡尔曼滤波框架，并利用非线性函数的线性化等逼近技术，例如，扩展(EKF)和二阶扩展卡尔曼滤波器[6]、[1]分别通过围绕当前估计到一阶或二阶的泰勒级数展开来逼近非线性函数，当线性化误差的影响往往会扰乱过滤的性能或其收敛性时，在更新状态附近重新线性化测量方程可能会减轻困难。</p><p>这种方法被称为迭代扩展卡尔曼过滤(IEKF)[6]。</p><p>IEKF计算状态估计不是作为近似条件平均值(就像EKF那样)，而是作为最大后验(MAP)估计[7]。文献[8]证明了IEKF量测更新是高斯-牛顿(GN)方法的应用，而EKF是仅用一次GN方法迭代的IEKF的特例。</p><p>第二节简要介绍了EKF和IEKF的非线性状态估计及其求解方法。第三节简要介绍了IEKF的最新发展。第四节介绍了分析中使用的各种性能度量。接下来，在第五节中，通过两个数值例子对两种滤波器进行了比较，并在第六节中对本文进行了总结。</p><h1 id="nonlinear-state-estimation-by-ekf-and-iekf">Nonlinear state estimation by EKF and IEKF</h1><h2 id="系统描述">系统描述</h2><p>离散时间非线性随机系统的状态空间形式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228191455.png"></p><p>其中，</p><ul><li><p>向量<span class="math inline">\(\mathbf{x}_{k} \in \mathbb{R}^{n_{x}}\)</span>和<span class="math inline">\(\mathbf{z}_{k} \in \mathbb{R}^{n_{z}}\)</span>分别表示在时间k下，系统的状态和观测。</p></li><li><p><span class="math inline">\(\mathbf{f}_{k}: \mathbb{R}^{n_{x}} \rightarrow \mathbb{R}^{n_{x}}\)</span> and <span class="math inline">\(\mathbf{h}_{k}: \mathbb{R}^{n_{x}} \rightarrow \mathbb{R}^{n_{z}}\)</span>是已知的向量函数。</p></li><li><p><span class="math inline">\(\mathbf{w}_{k} \in \mathbb{R}^{n_{x}}\)</span>和<span class="math inline">\(\mathbf{v}_{k} \in \mathbb{R}^{n_{z}}\)</span>是相互独立的状态白噪声和测量白噪声。</p></li></ul><p>噪声的概率密度函数是零均值且已知协方差矩阵<span class="math inline">\(\Sigma_{k}^{\mathbf{w}}\)</span> and <span class="math inline">\(\Sigma_{k}^{\mathbf{v}}\)</span>的高斯分布，即有<span class="math inline">\(p\left(\mathbf{w}_{k}\right)=\mathcal{N}\left\{\mathbf{w}_{k} ; \mathbf{0}_{n_{x} \times 1}, \Sigma_{k}^{\mathbf{w}}\right\} *\)</span>和<span class="math inline">\(p\left(\mathbf{v}_{k}\right)=\mathcal{N}\left\{\mathbf{v}_{k} ; \mathbf{0}_{n_{z} \times 1}, \Sigma_{k}^{\mathbf{v}}\right\}\)</span>。初始态的概率密度函数是高斯的，也是已知的，即<span class="math inline">\(p\left(\mathbf{x}_{0}\right)=\mathcal{N}\left\{\mathbf{x}_{0} ; \hat{\mathbf{x}}_{0}, \mathbf{P}_{0}\right\}\)</span>。初始状态与噪声无关</p><h2 id="扩展卡尔曼">扩展卡尔曼</h2><p>最初，卡尔曼过滤是在1960年利用正交性原理[13]推导出来的。给出了具有线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>的系统(1)和(2)的最小均方误差估计。</p><p>对于非线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>，必须使用近似，例如在EKF中使用的近似。EKF基于一阶泰勒级数展开(TE1)。在假设状态预测平均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k-1}=\mathrm{E}\left[\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right]\)</span>(定义线性化点)已知的条件下，函数<span class="math inline">\(\mathbf{h}_{k}\)</span>的泰勒一阶展开由下式给出：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228192900.png"></p><p>其中，矩阵<span class="math inline">\(\mathbf{H}_{k}=\left.\frac{\partial \mathbf{h}\left(\mathbf{x}_{k}\right)}{\partial \mathbf{x}_{k}}\right|_{\mathbf{x}_{k}=\hat{\mathbf{x}}_{k \mid k-1}}\)</span>是测量函数<span class="math inline">\(\mathbf{h}_{k}(\cdot)\)</span>关于<span class="math inline">\(\mathbf{X}_{k}\)</span>在线性化点<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>的雅可比。</p><p>预测更新步骤的TE1近似的使用是类似的。在已知滤波均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}=\mathrm{E}\left[\mathbf{x}_{k} \mid \mathbf{z}^{k}\right]\)</span>的假设下，(1)中的<span class="math inline">\(\mathbf{f}_{k}\)</span>的TE1具有如下形式：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193333.png"></p><p>其中，<span class="math inline">\(\mathbf{F}_{k}=\left.\frac{\partial \mathbf{f}\left(\mathbf{x}_{k}\right)}{\partial \mathbf{x}_{k}}\right|_{\mathbf{x}_{k}=\hat{\mathbf{x}}_{k \mid k}}\)</span>是系统矩阵<span class="math inline">\(\mathbf{f}_{k}(\cdot)\)</span>关于关于<span class="math inline">\(\mathbf{X}_{k}\)</span>在线性化点<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k}\)</span>的雅可比。</p><p>扩展卡尔曼算法如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193529.png"></p><blockquote><p>对于具有轻度非线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>的系统，扩展卡尔曼滤波性能良好，但是如果测量方程(2)是强非线性的(例如在纯方位跟踪问题中)，滤波器的性能就会恶化。在这种情况下，IEKF往往比EKF提供更准确的估计。</p></blockquote><h2 id="迭代扩展卡尔曼">迭代扩展卡尔曼</h2><p>IEKF[6]的想法是在存在显著非线性的情况下改进参考轨迹，从而改进估计。这些改进是通过EKF测量更新的局部迭代实现的(参见算法2)。迭代通常在连续迭代中没有显著变化或满足其他标准(如最大迭代次数)时停止。算法如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193907.png"></p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228200156.png"></p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228193927.png"></p><p>翻译一下，就是以下步骤:</p><ol type="1"><li><p>初始化：设置迭代次数<span class="math inline">\(i=0\)</span>，此时有<span class="math inline">\(\hat{\mathbf{x}}_{k}^{0}=\hat{\mathbf{x}}_{k \mid k-1}\)</span>，表示在第k次观测的第0次迭代的状态<span class="math inline">\(\mathbf{x}_{k}^{0}\)</span>等于利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span></p></li><li><p>测量更新：计算测量函数在迭代状态<span class="math inline">\(\mathbf{x}_{k}^{i}\)</span>处的雅可比<span class="math inline">\(\mathbf{H}_{k}^{i}\)</span>，更新第i次迭代的卡尔曼增益<span class="math inline">\(\mathbf{K}_{k}^{i}\)</span>，更新第i次迭代后的状态<span class="math inline">\(\hat{\mathbf{x}}_{k}^{i+1}\)</span>,如下：</p></li></ol><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228200516.png"></p><p>其中，</p><ul><li><p><span class="math inline">\(\mathbf{H}_{k}^{i}\)</span>是测量函数在迭代状态<span class="math inline">\(\mathbf{x}_{k}^{i}\)</span>处</p></li><li><p><span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>是利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的协方差，即第0次迭代前的协方差</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k \mid k-1}\)</span>是利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态，即第0次迭代前的状态</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k}^{i}\)</span>是第k观测下，迭代i次后的状态</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k}^{i+1}\)</span>是第k观测下，迭代i+1次后的状态</p></li></ul><ol start="3" type="1"><li>迭代完成后，需要更新（保存）状态和协方差：</li></ol><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228201345.png"></p><p>即协方差是在迭代结束后再更新的，迭代过中一直使用的是<span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>，即上一次更新完后又预测到k时刻的协方差。</p><p>值得一提的是，即使在IEKF算法中发生的重新线性化也不能保证滤波器的收敛性，IEKF也不总是比扩展卡尔曼滤波性能好。不过，IEKF测量更新有两个非常有趣的属性：</p><ul><li><p>它可以看作是高斯-牛顿法的一种应用</p></li><li><p>它生成最大后验（MAP）估计：<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}^{\mathrm{MAP}}=\underset{\mathbf{x}_{k}}{\arg \max } p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span></p></li></ul><h2 id="对迭代扩展卡尔曼过滤算法的改进">对迭代扩展卡尔曼过滤算法的改进</h2><p>如上所述，IEKF可以看作是求解非线性最小二乘问题的GN方法的一种应用。因此，在IEKF中可以使用对GN方法的改进来提高方法的性能和收敛性，以提高估计的质量。改变步长是常用的改进措施之一。首先，介绍了IEKF最小化的MAP准则。</p><h3 id="map-criterion">MAP criterion</h3><p>如果使用系统(1)和(2)的概率描述，则使用先验的概率密度函数<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>来求后验PDF<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span>。</p><p>先验的概率分布<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的均值<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>和协方差<span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>在算法1的时间更新步骤中计算。其假设为高斯，并且在算法2的测量更新中计算后验PDF<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}\)</span>和方差<span class="math inline">\(\mathbf{P}_{k \mid k}\)</span>。</p><p>后验概率<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span>与似然<span class="math inline">\(p\left(\mathbf{z}_{k} \mid \mathbf{x}_{k}\right)=p_{\mathbf{v}_{k}}\left(\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right)\)</span>与先验<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的乘积成正比，即有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202344.png"></p><p>其中，为方便起见，不依赖于<span class="math inline">\(\mathbf{X}_{k}\)</span>的项已被删除。然后由下式给出MAP估计：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202535.png"></p><p>现在，有了MAP模型，可以使用GN方法来找到<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}\)</span>，以达到最小化函数。理想情况下，每次GN方法迭代(即IEKF测量更新迭代)都应该减小准则<span class="math inline">\(\mathbf{V}_{k}\)</span>。</p><p>IEKF测量更新(16)可以用隐式方式被重写：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202910.png"></p><p>本次迭代更新偏移量<span class="math inline">\(\Delta_{k}^{i}\)</span>如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/28/20220228202946.png"></p><p>其中，<span class="math inline">\(\hat{\mathbf{x}}_{k}^{0}=\hat{\mathbf{x}}_{k \mid k-1}\)</span>，即在第k次观测的第0次迭代的状态<span class="math inline">\(\mathbf{x}_{k}^{0}\)</span>等于利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>（先验）</p><p><strong>对于高斯牛顿方法</strong>，也可以求出更新偏移量<span class="math inline">\(\Delta_{k}^{i}\)</span>的另一种表达形式：</p><p>高斯牛顿法就是将<span class="math inline">\(f(\mathbf{x})\)</span>进行一届泰勒展开（注意这里的<span class="math inline">\(f(\mathbf{x})\)</span>不是目标函数，而是原函数，即<span class="math inline">\(f(\mathbf{x}) = z-h(\mathbf{x})\)</span></p><p>因此，有：</p><p><span class="math display">\[    f(\mathbf{x}+\Delta{\mathbf{x}}) \approx f(\mathbf{x}) + \mathbf{J}(\mathbf{x})\Delta{\mathbf{x}}\]</span></p><p>其中，<span class="math inline">\(\mathbf{J}(\mathbf{x})\)</span>为<span class="math inline">\(f(\mathbf{x})\)</span>关于<span class="math inline">\(\mathbf{x}\)</span>的雅克比。</p><p>经过系列变换，最终可以得到正规方程：</p><p><span class="math display">\[    \mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x}) \Delta{\mathbf{x}} = -\mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \]</span></p><p>因此有：</p><p><span class="math display">\[    \Delta{\mathbf{x}} = - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \]</span></p><p>对于式（17）（18）所展示的MAP问题，可以进一步建模为：</p><p><span class="math display">\[\begin{aligned}\hat{\mathbf{x}}_{k \mid k} &amp;=\underset{\mathbf{x}_{k}}{\arg \min } \frac{1}{2}\left(\left[\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right]^{T}\left(\Sigma_{k}^{v}\right)^{-1}\left[\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right]+\left[\hat{\mathbf{x}}_{k \mid k-1}-\mathbf{x}_{k}\right]^{T} \mathbf{P}_{k \mid k-1}^{-1}\left[\hat{\mathbf{x}}_{k \mid k-1}-\mathbf{x}_{k}\right]\right) \\&amp;=\underset{\mathbf{x}_{k}}{\arg \min } \frac{1}{2} r(\mathbf{X})^{T}r(\mathbf{X})\end{aligned}\]</span></p><p>其中，</p><p><span class="math display">\[r(\mathbf{X})=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_k-h(\mathbf{x}_k)) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k \right)\end{array}\right]\]</span></p><p>雅克比<span class="math inline">\(J(\mathbf{X})\)</span>如下：</p><p><span class="math display">\[\mathbf{J}_{k}=-\left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]\]</span></p><p><span class="math display">\[\mathbf{H}_{k}=\left.\frac{\partial h(s)}{\partial s}\right|_{s=\mathbf{x}_{k}}\]</span></p><p>将信息回代到高斯牛顿正规方程，可以得到增量<span class="math inline">\(\Delta{\mathbf{x}}\)</span>如下：</p><p><span class="math display">\[ \begin{aligned}    \Delta{\mathbf{x}} &amp;= - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \\    &amp;=     \left(        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]^{T}        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]    \right)^{-1}        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]^{T}        \left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_k-h(\mathbf{x}_k)) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k \right)\end{array}\right]\\    &amp;=     \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        (\mathbf{z}_k-h(\mathbf{x}_k))    +    \mathbf{P}_k^{-1}(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    \right)    \\    &amp;=    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \{    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        (\mathbf{z}_k-h(\mathbf{x}_k) - \mathbf{H}_k (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k))    +    \\    &amp;  \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k    (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    +    \mathbf{P}_k^{-1}(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    \}    \\    &amp;=    \hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k +    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}    \left (        \mathbf{z}_k-h(\mathbf{x}_k) - \mathbf{H}_k (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)        \right)\end{aligned} \]</span></p><p>此时，如果令<span class="math inline">\(\mathbf{K}_{k}\)</span>满足:</p><p><span class="math display">\[\mathbf{K}_{k} = \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}\]</span></p><p>定睛一看，这货不就是公式（20）由IEKF的增量吗？</p><p>所以，<strong>IEKF实际上是高斯牛顿的一种应用</strong>，如果多个观测放在一起来求解，就是最小二乘，如果迭代的求解，就成了IEKF。</p><h1 id="iekf在fast-lio系列的应用">IEKF在Fast-LIO系列的应用</h1><p>回顾Fast-LIO1论文，公式(17)，要优化的目标函数是：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312105428.png"></p><p>其中，包含了先验项和观测项</p><h2 id="先验项">先验项</h2><ol type="1"><li>第一项<span class="math inline">\(\left\|\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\right\|_{\widehat{\mathbf{P}}_{k}^{-1}}^{2}\)</span>是先验项，其表述有点奇怪</li></ol><hr><p>原文描述如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312105720.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{X}_{k}\)</span>表示状态真值</li><li><span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>表示k时刻预测值</li><li><span class="math inline">\(\mathbf{J}^{\kappa}\)</span>表示<span class="math inline">\(\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxplus \widetilde{\mathbf{x}}_{k}^{\kappa}\right) \boxminus \widehat{\mathbf{x}}_{k}\)</span>关于误差状态<span class="math inline">\(\tilde{\mathbf{x}}_{k}^{\kappa}\)</span>的雅克比</li></ul><p>按照原文的意思是，<span class="math inline">\(\left\|\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\right\|_{\widehat{\mathbf{P}}_{k}^{-1}}^{2}\)</span>用于约束预测值<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>不应该离状态真值太远，即误差状态应尽可能小（这个先验看起来跟平时的形式不一样，<strong>难以理解</strong>）。</p><hr><p>下面，按照我们通用的理解去描述：</p><p>先验一般约束着迭代状态值<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa}\)</span>不应该离预测值<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>太远，因此，先验对应的残差项可以写为：</p><p><span class="math display">\[\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\]</span></p><blockquote><p>因此，个人认为，原文公式（17）第一项不应该为<span class="math inline">\(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\)</span>，替换为<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\)</span>更合理</p></blockquote><h2 id="观测项">观测项</h2><ol start="2" type="1"><li>第二项<span class="math inline">\(\left\|\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>在原文中的表述比较牵强：</li></ol><hr><p>原文公式如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312174507.png"> <img src="https://s1.nsloop.com:58443/images/2022/03/12/20220312173821.png"></p><p>上面<span class="math inline">\(\mathbf{h}_{j}\left(\mathbf{x}_{k},{ }^{L_{j}} \mathbf{n}_{f_{j}}\right)\)</span>的意思是，给定状态真值<span class="math inline">\(\mathbf{x}_{k}\)</span>和测量噪声<span class="math inline">\({ }^{L_{j}} \mathbf{n}_{f_{j}}\)</span>，那么理论上得到的观测值（即点到平面的距离）为0。</p><p>然而，由于无法得知状态真值，因此使用一阶近似得到的公式（14）。此处使用的<span class="math inline">\(\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\)</span>让人容易混淆，还是看下文的另外一种描述。</p><hr><p>前面提到，实际的观测值其实不用去观测，因为点就在平面上，所以实际的观测值为0，即<span class="math inline">\(\mathbf{z_{true}} = 0\)</span>。</p><p>为了衡量当前估计的状态是否足够接近真值，我们利用迭代的状态去计算点-面距离，<strong>这一个操作称为观测预测</strong>，<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\)</span>为观测预测模型，即通过给定状态来计算在该状态下得到的观测值，此处为计算得到的点-面距离。</p><p>因此，残差项可以写为：</p><p><span class="math display">\[    \mathbf{z_{true}} -\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\]</span></p><p>其中，已知<span class="math inline">\(\mathbf{z_{true}} = 0\)</span>，因此，残差项就是利用迭代的状态计算得到的点-面距离<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}\right)\)</span>。</p><blockquote><p>因此，个人认为，原文描述的第二项不应该为<span class="math inline">\(\left\|\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>，替换为<span class="math inline">\(\left\| \mathbf{z_{true}} -\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\right\|_{\mathbf{R}_{j}^{-1}}^{2} = \left\|\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>更为合适。</p></blockquote><h2 id="推导">推导</h2><p>综上，我们继续使用上面的方法再一次推导：</p><p>假设目标函数<span class="math inline">\(r(\mathbf{X})\)</span>如下:</p><p><span class="math display">\[r(\mathbf{X})=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}\left ( \mathbf{z_{true}} -\mathbf{h}_{j}(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}) \right) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k} \right)\end{array}\right] = \left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}\left ( \mathbf{h}_{j}(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}) \right) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k} \right)\end{array}\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\)</span>是观测模型，对其进行泰勒一阶展开，可得：<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}\boxplus\tilde{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right) \approx \mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \tilde{\mathbf{x}}_{k}^{\kappa}\)</span>，其中<span class="math inline">\(\mathbf{z}_{j}^{\kappa}\)</span>就是利用状态<span class="math inline">\(\widehat{\mathbf{X}}_{k}^{\kappa}\)</span>计算得到的点到平面距离</li><li><span class="math inline">\(j\)</span>表示第j个激光点</li></ul><p>根据高斯牛顿的思想，对残差函数进行一阶泰勒展开如下：</p><p><span class="math display">\[\begin{aligned}r(\mathbf{X^{\kappa} +\Delta \mathbf{x}}) = r(\mathbf{X^{\kappa} +\tilde{\mathbf{x}}_{k}^{\kappa}}) &amp;=r(\mathbf{X^{\kappa}})+ J(\mathbf{X}^{\kappa})\tilde{\mathbf{x}}_{k}^{\kappa}\\&amp;=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \tilde{\mathbf{x}}_{k}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}+\mathbf{J}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right)\end{array}\right]\\&amp;=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)\end{array}\right]+\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{H}_{j}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{J}^{\kappa} \right)\end{array}\right]\widetilde{\mathbf{x}}_{k}^{\kappa}\end{aligned}\]</span></p><p>其中</p><ul><li><span class="math inline">\(\mathbf{H}^{\kappa}_{j}\)</span>是激光投影点到地图上最近的平面的距离关于误差状态的雅克比，其推导可从<a href="https://readpaper.com/paper/3131967444" target="_blank" rel="noopener">R2LIVE</a>中找到。</li><li><span class="math inline">\(\mathbf{J}^{\kappa}\)</span>表示<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\)</span>关于误差状态<span class="math inline">\(\tilde{\mathbf{x}}_{k}^{\kappa}\)</span>的雅克比</li></ul><p>雅克比<span class="math inline">\(J(\mathbf{X}^{\kappa})\)</span>如下：</p><p><span class="math display">\[\mathbf{J}_{k}^{\kappa} =\left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\\mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa} \end{array}\right]\]</span></p><p><span class="math display">\[\mathbf{H}_{k}^{\kappa} =\left.\frac{\partial h(s)}{\partial s}\right|_{s=\mathbf{x}_{k}^{\kappa} }\]</span></p><p><span class="math display">\[\mathbf{J}^{\kappa}=\left[\begin{array}{cc}\mathbf{A}\left({ }^{G} \widehat{\mathbf{R}}_{I_{k}}^{\kappa} \boxminus^{G} \widehat{\mathbf{R}}_{I_{k}}\right)^{-T} &amp; \mathbf{0}_{3 \times 15} \\\mathbf{0}_{15 \times 3} &amp; \mathbf{I}_{15 \times 15}\end{array}\right]\]</span></p><p>这里注意区分<span class="math inline">\(\mathbf{J}_{k}\)</span>和<span class="math inline">\(\mathbf{J}^{\kappa}\)</span>。</p><p>将<span class="math inline">\(r(\mathbf{X^{\kappa}})\)</span>以及雅克比<span class="math inline">\(J(\mathbf{X}^{\kappa})\)</span>回代到高斯牛顿正规方程，可以得到增量<span class="math inline">\(\Delta{\mathbf{x}}\)</span>如下：</p><p><span class="math display">\[\begin{aligned}    \Delta{\mathbf{x}} &amp;= - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x})     \\    &amp;= -    \left(        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]^{T}        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]    \right)^{-1}        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]^{T}    \left[\begin{array}{c}    \left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}) \\    \mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \end{array}\right]    \\    &amp;= -    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    \left \{        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        \mathbf{z}_k^{\kappa} +        (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right \}    \\    &amp;= -    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    \{        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        \mathbf{z}_k^{\kappa} +        (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \\    &amp;+ \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k (\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) - \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k (\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \}    \\    &amp;= -(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) -     \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    (\mathbf{H}_k^{T} \mathbf{R}_k^{-1})    \left (        \mathbf{z}_k^{\kappa} +        \mathbf{H}_k(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right )    \\    &amp;= -(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) -      \mathbf{K}_{k}^{\kappa}    \left (        \mathbf{z}_k^{\kappa} +        \mathbf{H}_k(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right )    \\    &amp;=    -\mathbf{K} \mathbf{z}_{k}^{\kappa}-(\mathbf{I}-\mathbf{K} \mathbf{H})\left(\mathbf{J}^{\kappa}\right)^{-1}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)\end{aligned}\]</span></p><p>按照上述推导，即可得到与论文公式（18）一致的结果。</p><h1 id="参考">参考</h1><p><a href="https://zhuanlan.zhihu.com/p/141018958" target="_blank" rel="noopener">知乎：迭代扩展卡尔曼滤波(IEKF)</a></p><p><a href="https://readpaper.com/pdf-annotate/note?noteId=658232918830911488&amp;pdfId=658232843626635264" target="_blank" rel="noopener">论文：Performance evaluation of iterated extended Kalman filter with variable step-length</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;performance-evaluation-of-iterated-extended-kalman-filterwith-variable-step-length&quot;&gt;Performance evaluation of iterated extended Kalm
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>IKFOM论文阅读</title>
    <link href="http://yoursite.com/2022/02/27/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/02/27/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-02-27T12:22:58.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kalman-filters-on-differentiable-manifolds">Kalman Filters on Differentiable Manifolds</h1><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227202357.png"></p><h1 id="摘要">摘要</h1><p>卡尔曼滤波是现代控制系统中最重要和应用最广泛的滤波技术之一。然而，几乎所有当前的卡尔曼滤波器的变体都是在欧几里得空间Rn中制定的，而许多现实世界的系统(例如，机器人系统)实际上是在流形上进化的。</p><p>在本文中，我们提出了一种为这类流形上系统设计卡尔曼滤波器的方法。利用运算<span class="math inline">\(\boxplus \backslash \boxminus\)</span>，并进一步定义了相应流形上的⊕运算，给出了流形上系统的规范表示。这种非正则形式使我们能够在卡尔曼过滤的每一步中将多种约束从系统行为中分离出来，最终产生一个在流形上自然演化的通用的和象征性的卡尔曼过滤框架。</p><p>此外，这种流形上的卡尔曼滤波器集成了C++包实现，它使用户能够实现集成卡尔曼滤波器，就像在<span class="math inline">\(\mathbb{R}^{n}\)</span>空间中的普通卡尔曼过滤一样：用户只需要提供系统特定的描述，然后调用各自的过滤步骤(例如，预测、更新)，而不需要处理任何流形约束。</p><h1 id="preliminaries-of-differentiable-manifolds">PRELIMINARIES OF DIFFERENTIABLE MANIFOLDS</h1><h2 id="可微分流形differentiable-manifolds">可微分流形（Differentiable manifolds）</h2><p>如文[34]所示，维数为n的流形是局部同胚于<span class="math inline">\(\mathbb{R}^{n}\)</span>的集合M(称为homeomorphicspace)。、</p><p>也就是说，对于任意一个点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>以及一个包含该点的开子集<span class="math inline">\(U \subset \mathcal{M}\)</span>，存在一个双射函数(称为homeomorphism)φ，它将<span class="math inline">\(U\)</span>中的点映射到<span class="math inline">\(\mathbb{R}^{n}\)</span>的开子集。该对<span class="math inline">\((\phi, U)\)</span>称为局部坐标图，如果任何两个图<span class="math inline">\((\phi, U)\)</span>和<span class="math inline">\((\psi, V)\)</span>共享重叠的合成映射<span class="math inline">\(\phi \circ \psi^{-1}\)</span>是可微的，则该流形称为可微流形。</p><h2 id="boxplus-backslash-boxminus操作"><span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作</h2><p>流形M中任意点周围<code>homeomorphisms</code>的存在使我们能够封装两个算子<span class="math inline">\(\boxplus_{\mathcal{M}}\)</span>(“boxplus”)和<span class="math inline">\(\boxminus_{\mathcal{M}}\)</span>(“boxminus”)到流形[25]：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227204348.png"></p><p>其中，<span class="math inline">\(\mathcal{M}_{\varphi_{\mathrm{x}}}\)</span>是点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>的一个<code>homeomorphism</code>.</p><p><span class="math inline">\(\mathbf{y}=\mathbf{x} \boxplus_{\mathcal{M}} \mathbf{u}\)</span>的物理含义是向点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>添加一个扰动<span class="math inline">\(\mathbf{u}\)</span>，然后产生了流形上的<span class="math inline">\(\mathbf{y} \in \mathcal{M}\)</span>， 如图2所示。</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227204921.png"></p><p>其中，逆操作<span class="math inline">\(\mathbf{u}=\mathbf{y} \boxminus_{\mathcal{M}} \mathbf{x}\)</span>可以确定扰动量<span class="math inline">\(\mathbf{u}\)</span>，该扰动量<span class="math inline">\(\mathbf{u}\)</span>就是产生<span class="math inline">\(\mathbf{y} \in \mathcal{M}\)</span>时，对点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>进行<span class="math inline">\(\boxplus_{\mathcal{M}^{-}}\)</span>操作所添加的扰动。</p><p>这两个操作符创建了一个局部的、矢量化视角，对应于流形上复杂的全局结构。</p><p>对于李群来说，当<span class="math inline">\(\mathcal{M}\)</span>是Lie group (e.g., <span class="math inline">\(\left.\mathbb{R}^{n}, S O(3), S E(3)\right)\)</span>，正切空间具有表示为m的李代数结构和指数映射<span class="math inline">\(\exp : \mathfrak{m} \mapsto \mathcal{M}\)</span>。</p><p>令<span class="math inline">\(\mathfrak{f}: \mathbb{R}^{n} \mapsto \mathfrak{m}\)</span>作为从最小参数化空间到李代数、指数映射<span class="math inline">\(\operatorname{Exp}=\exp \circ f\)</span>以及其逆操作<span class="math inline">\(\log\)</span>的的映射，那么<span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作的定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227210416.png"></p><p>其中·是M上的二元运算，使得<span class="math inline">\((\mathcal{M}, \cdot)\)</span>形成李群，<span class="math inline">\(\mathbf{x}^{-1}\)</span>是<span class="math inline">\(\mathbf{X}\)</span>的逆，对于李群上的元素，它总是存在。</p><p>当流形M不是李群时，找出流形与其切空间参数化之间的同胚没有一般准则。例如，2球面流形<span class="math inline">\(\mathbb{S}^{2}(r) \triangleq\{\mathbf{x} \in \left.\mathbb{R}^{3} \mid\|\mathbf{x}\|=r, r&gt;0\right\}\)</span>在点x处的切线空间就是在点<span class="math inline">\(\mathbf{X}\)</span>的简单正切平面，如图3所示。</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227211039.png"><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227211039.png"><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227211039.png"></p><p>对于点<span class="math inline">\(\mathbf{x} \in \mathbb{S}^{2}(r)\)</span>，扰动可以通过沿着正切平面上的向量旋转来实现，结果仍将保留在<span class="math inline">\(\mathbb{S}^{2}(r)\)</span>上。</p><p>正切平面中的旋转向量被<span class="math inline">\(\mathbf{u} \in \mathbb{R}^{2}\)</span>最小参数化表达，其中，所在的空间为由两个bias向量<span class="math inline">\(\mathbf{b}_{1}, \mathbf{b}_{2} \in \mathbb{R}^{3}\)</span>所展开的正切平面。也就是说：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227212601.png"></p><p>其中，<span class="math inline">\(\mathbf{R}(\mathbf{w})=\operatorname{Exp}(\mathbf{w}) \in S O(3)\)</span>记为关于由向量<span class="math inline">\(\mathbf{w} \in \mathbb{R}^{3}\)</span>所表示的轴-角旋转。特别的，<span class="math inline">\(\mathbf{b}_{1}, \mathbf{b}_{2}\)</span>的选择不是唯一的，只要它们是正交的并且都垂直于x。</p><blockquote><p><span class="math inline">\(\mathbb{S}^{2}\)</span>常用于重力的表示，如VINS-Mono就用这个来表示并进一步refine重力向量。</p></blockquote><h2 id="oplus操作符"><span class="math inline">\(\oplus\)</span>操作符</h2><p>现实世界的系统通常是由一些外在的输入驱动的。为了模拟这一现象，除了描述流形本身所在的状态之外，还需要一个额外的操作来描述流形上的状态是如何在无限小的时间周期内由恒定的外生速度驱动的。</p><p>尽管速度对状态的影响增加了对流形上其原始位置的扰动，这在流形上有很好的描述运算符<span class="math inline">\(\boxplus\)</span>，则外部速度不一定在相同的homeomorphic空间(即，切线空间)中，该空间定义操作，因此需要表示为<span class="math inline">\(\oplus_{\mathcal{M}}\)</span>的新操作。</p><p>假设外部速度的维度是l，那么新的操作为：<span class="math inline">\(\oplus_{\mathcal{M}}: \mathcal{M} \times \mathbb{R}^{l} \mapsto \mathcal{M}\)</span></p><p>具体地说，当<span class="math inline">\(\mathcal{M}\)</span>是李群时，外生速度通常位于正切空间，同时也定义了公式(2)中的<span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作，因此操作⊕与<span class="math inline">\(\boxplus\)</span>重合，即：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214214.png"></p><p>。。。</p><h2 id="差分">差分</h2><p><span class="math inline">\((((\mathbf{x} \boxplus \mathbf{u}) \oplus \mathbf{v}) \boxminus \mathbf{y})\)</span>相对于<span class="math inline">\(\mathbf{u}\)</span>和<span class="math inline">\(\mathbf{V}\)</span>的差分将会在后面的卡尔曼滤波器中用到，其中，<span class="math inline">\(\mathbf{x}, \mathbf{y} \in \mathcal{M}, \mathbf{u} \in \mathbb{R}^{n}\)</span>，<span class="math inline">\(\mathbf{v} \in \mathbb{R}^{l}\)</span>。</p><p>由链式法则，可得：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214416.png"></p><p>对于某些流形(例如，SO(3))，计算微分通常更为方便，而不用使用链式法则展开。</p><h2 id="复合可微流形">复合可微流形</h2><p>基于流形的笛卡儿积原理，给出了流形的定义由两个子流形(归纳为任意个子流形)组成的复合流形上的<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>操作定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214841.png"></p><p>因此复合流形上的偏微分满足(见引理)：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227214913.png"></p><p><span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>运算及其在复合流形上的偏微分非常有用，使用户能够定义<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>运算及其导数(例如，<span class="math inline">\(\mathbb{R}^{n}, S O(3), \mathbb{S}^{2}(r)\)</span>)，然后将这些定义推广到更复杂的复合流形。</p><p>例如，根据前面讨论<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>的定义，总结了几个重要流形，包括<span class="math inline">\(\mathbb{R}^{n}, S O(3), \mathbb{S}^{2}(r)\)</span>的运算，并在表中总结了它们的局部微分，其中：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227215246.png"></p><p>其中，<span class="math inline">\(\lfloor\mathbf{u}\rfloor\)</span>记为反对称矩阵，并且有：</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227215356.png"></p><p>总结表如下： （详细推导见附录B）</p><p><img src="https://s1.nsloop.com:58443/images/2022/02/27/20220227215458.png"></p><h2 id="流形系统的规范表示">流形系统的规范表示</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kalman-filters-on-differentiable-manifolds&quot;&gt;Kalman Filters on Differentiable Manifolds&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.nsloop.com:58443
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>Cyber-RT系列之协程Croutine</title>
    <link href="http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%8F%E7%A8%8BCroutine/"/>
    <id>http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%8F%E7%A8%8BCroutine/</id>
    <published>2021-11-28T15:10:29.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>协程是Cyber-RT的实现任务轮转的最小单位，是处理数据回调的运行模块。协程可以理解为“可以暂停”的函数，相比于线程，其具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即可达到类似线程的效果。</p><p>为什么选用协程，因为基于协程的特性再加上Cyber中枢调度<code>Scheduler</code>的线程调度，可以避免回调时由于阻塞导致其他回调不能被执行的情况；此外，协程是在用户态来完成上下文切换的，所以切换耗时只有区区100ns多一些，比进程切换要高30倍。</p><h1 id="cybercroutine目录">Cyber/croutine目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── BUILD</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── croutine.cc</span><br><span class="line">├── croutine.h</span><br><span class="line">├── detail</span><br><span class="line">│   ├── routine_context.cc</span><br><span class="line">│   ├── routine_context.h</span><br><span class="line">│   ├── swap_aarch64.S</span><br><span class="line">│   └── swap_x86_64.S</span><br><span class="line">└── routine_factory.h</span><br></pre></td></tr></table></figure><h1 id="croutine类图">Croutine类图</h1><p>...</p><h1 id="结构图">结构图</h1><h1 id="协程的创建">协程的创建</h1><p>Cyber-RT中有两个地方创建了协程：</p><ul><li><code>Component</code>的初始化</li><li><code>Reader</code>的初始化</li></ul><p>两处地方的创建大同小异，这里给出<code>Component&lt;M0, NullType, NullType, NullType&gt;::Initialize</code>函数中关于创建协程的代码片段:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0&gt;</span><br><span class="line"><span class="keyword">bool</span> Component&lt;M0, NullType, NullType, NullType&gt;::Initialize(</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// lambda函数 （这个后面作为）</span></span><br><span class="line">  <span class="keyword">auto</span> func = [self](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;M0&gt;&amp; msg) &#123;</span><br><span class="line">    <span class="comment">// 处理msg</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造 data::DataVisitor</span></span><br><span class="line">  <span class="keyword">auto</span> dv = <span class="built_in">std</span>::make_shared&lt;data::DataVisitor&lt;M0&gt;&gt;(conf);</span><br><span class="line">  <span class="comment">// 创建协程工厂</span></span><br><span class="line">  croutine::RoutineFactory factory =</span><br><span class="line">      croutine::CreateRoutineFactory&lt;M0&gt;(func, dv);</span><br><span class="line">  <span class="keyword">auto</span> sched = scheduler::Instance();</span><br><span class="line">  <span class="keyword">return</span> sched-&gt;CreateTask(factory, node_-&gt;Name());</span><br></pre></td></tr></table></figure><p>其流程大概是这样:</p><ol type="1"><li>写出一个lambda函数，内部进行msg的回调处理</li><li>构造一个<code>DataVistor</code></li><li>将lambda函数和创建的<code>DataVistor</code>一并作为参数，用于创建协程工厂croutine::RoutineFactory</li><li>将协程工厂作为参数，调用中枢调度Scheduler::CreateTask(...)函数</li></ol><h2 id="why-routinefactory">Why RoutineFactory?</h2><p>看到上面的代码片段可能会觉得奇怪，为什么需要协程工厂这一层，直接创建一个协程不好吗？</p><p>这其实是一种封装，假设我们直接创建一个协程，那么需要传入一个回调函数，用于处理msg，然而Cyber-RT一共考虑了1-4种msg的情况，那么创建协程时传入的回调函数的参数就有4种情况，这使得接口不能统一。使用协程工厂就是为了对4种情况进行封装，并统一接口，即创建协程时只需要把协程工厂传入作为参数即可。</p><h2 id="what-is-routinefactory">What is RoutineFactory?</h2><h1 id="重要过程时序流图">重要过程时序流图</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;协程是Cyber-RT的实现任务轮转的最小单位，是处理数据回调的运行模块。协程可以理解为“可以暂停”的函数，相比于线程，其具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即
      
    
    </summary>
    
    
    
      <category term="Cyber_RT" scheme="http://yoursite.com/tags/Cyber-RT/"/>
    
  </entry>
  
  <entry>
    <title>Cyber-RT系列之中枢调度Scheduler</title>
    <link href="http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E6%9E%A2%E8%B0%83%E5%BA%A6Scheduler/"/>
    <id>http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E6%9E%A2%E8%B0%83%E5%BA%A6Scheduler/</id>
    <published>2021-11-28T15:10:29.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Scheduler是Cyber-RT的调度核心，是协程的调度载体。特别的，对于自动驾驶任务而言，任务调度的实时性发挥至关重要的作用，因此有必要对各种任务的优先级进行分类排序，如对于控制任务而言，需要单独分配CPU以供实时运行，Cyber-RT通过Scheduler来实现这种功能。</p><h1 id="cyberscheduler目录">Cyber/Scheduler目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── BUILD</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── common</span><br><span class="line">│   ├── cv_wrapper.h</span><br><span class="line">│   ├── mutex_wrapper.h</span><br><span class="line">│   ├── pin_thread.cc</span><br><span class="line">│   ├── pin_thread.h</span><br><span class="line">├── policy</span><br><span class="line">│   ├── choreography_context.cc</span><br><span class="line">│   ├── choreography_context.h</span><br><span class="line">│   ├── classic_context.cc</span><br><span class="line">│   ├── classic_context.h</span><br><span class="line">│   ├── scheduler_choreography.cc</span><br><span class="line">│   ├── scheduler_choreography.h</span><br><span class="line">│   ├── scheduler_classic.cc</span><br><span class="line">│   └── scheduler_classic.h</span><br><span class="line">├── processor.cc</span><br><span class="line">├── processor_context.cc</span><br><span class="line">├── processor_context.h</span><br><span class="line">├── processor.h</span><br><span class="line">├── processor_test.cc</span><br><span class="line">├── scheduler.cc</span><br><span class="line">├── scheduler_factory.cc</span><br><span class="line">├── scheduler_factory.h</span><br><span class="line">├── scheduler.h</span><br><span class="line">└── scheduler_test.cc</span><br></pre></td></tr></table></figure><h1 id="scheduler类图">Scheduler类图</h1><p><img src="https://s1.nsloop.com:58443/images/2021/11/29/Scheduler.png"></p><h1 id="两种策略">两种策略</h1><p>通过阅读上面的类图可以发现，Scheduler类是基类，其拥有两个子类，分别为<code>SchedulerClassic</code>和<code>SchedulerChoreography</code>，分别对应两种策略，Classic(经典)策略与Choreophgray(编排)策略。两者并不是互斥关系，后者可看作对前者的扩展。它们的介绍和示例可参考官方文档 <a href="https://github.com/ApolloAuto/apollo/blob/master/docs/cyber/CyberRT_Scheduler_cn.md" target="_blank" rel="noopener">Cyber RT Scheduler</a>，这里暂不详细展开，下面的叙述以<code>SchedulerClassic</code>策略为主。</p><p>调度策略配置文件用protobuf定义，协议格式文件在cyber/proto目录下：<code>scheduler_conf.proto</code>，<code>classic_conf.proto</code>和<code>choreography_conf.proto</code>。调度策略配置文件在cyber/conf目录下。对于上面mkz_close_loop.pb.txt中的两个process group：compute_sched和control_sched，根据调度策略不同分别有两个版本</p><p><img src="https://s1.nsloop.com:58443/images/2021/11/29/20211129002744.png"></p><h1 id="一个scheduler实例">一个Scheduler实例</h1><p><code>Scheduler</code>是个单例，因此在程序启动时就被初始化了，尽管它不是程序的入口，但是从它却是系统子模块Component调度的管理者。</p><h2 id="实例化">实例化</h2><p><code>Scheduler</code>的实例化过程由<code>scheduler_factory.cc</code>提供，其调用函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">Scheduler</span>* <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// instance是原子模板的</span></span><br><span class="line">  <span class="built_in">Scheduler</span>* obj = instance.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="comment">// 如果obj为空</span></span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    obj = instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 双检查</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 默认策略</span></span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">policy</span><span class="params">(<span class="string">"classic"</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">conf</span><span class="params">(<span class="string">"conf/"</span>)</span></span>;</span><br><span class="line">      <span class="comment">// conf = conf/xxxxx.conf</span></span><br><span class="line">      conf.append(GlobalData::Instance()-&gt;ProcessGroup()).append(<span class="string">".conf"</span>);</span><br><span class="line">      <span class="comment">// cfg_file = CYBER_PATH + 相对路径</span></span><br><span class="line">      <span class="keyword">auto</span> cfg_file = GetAbsolutePath(WorkRoot(), conf);</span><br><span class="line">      <span class="comment">// 检查配置文件是否存在，并读取配置到proto类型</span></span><br><span class="line">      apollo::cyber::proto::CyberConfig cfg;</span><br><span class="line">      <span class="keyword">if</span> (PathExists(cfg_file) &amp;&amp; GetProtoFromFile(cfg_file, &amp;cfg)) &#123;</span><br><span class="line">        <span class="comment">// 从配置文件读取策略</span></span><br><span class="line">        policy = cfg.scheduler_conf().policy();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AWARN &lt;&lt; <span class="string">"No sched conf found, use default conf."</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据策略，实例化不同的调度器</span></span><br><span class="line">      <span class="keyword">if</span> (!policy.compare(<span class="string">"classic"</span>)) &#123;</span><br><span class="line">        obj = <span class="keyword">new</span> SchedulerClassic();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!policy.compare(<span class="string">"choreography"</span>)) &#123;</span><br><span class="line">        obj = <span class="keyword">new</span> SchedulerChoreography();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AWARN &lt;&lt; <span class="string">"Invalid scheduler policy: "</span> &lt;&lt; policy;</span><br><span class="line">        obj = <span class="keyword">new</span> SchedulerClassic();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保存到instance单例</span></span><br><span class="line">      instance.store(obj, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化主要做了几个事情：</p><ol type="1"><li>获取配置文件<code>conf/xxxx.conf</code></li><li>读取策略配置项<code>policy</code></li><li>根据<code>policy</code>配置项来选择实例化<code>SchedulerClassic()</code>还是<code>SchedulerChoreography()</code>，如果没有提供，则默认选择实例化<code>SchedulerClassic()</code></li><li>这个实现确保了线程安全，即<code>Scheduler</code>单例只能被创建一个</li></ol><p>以<code>SchedulerClassic()</code>为例，接下来看其实例化过程（构造函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SchedulerClassic::SchedulerClassic()&#123;</span><br><span class="line">    <span class="comment">// 由于函数篇幅较长，下面用文字描述</span></span><br><span class="line">    <span class="number">1.</span> 再次获取配置文件<span class="string">"conf/xxxxx.conf"</span></span><br><span class="line">    <span class="number">2.</span> 解析proto配置文件</span><br><span class="line">    <span class="number">3.</span> 读取threads字段的配置 ===&gt; 这个暂时还不知道用来干嘛</span><br><span class="line">    <span class="number">4.</span> 读取cpu编号配置[process_level_cpuset_]，根据这个配置项来设置当前调度线程的CPU亲和性,这样就指定了该进程中的所有任务都只能在限定的CPU核上运行</span><br><span class="line">    <span class="number">5.</span> 读取[classic_conf]配置项，遍历配置项中的每一个[group]配置，而每个[group]内又包含若干个[task]，目的是把所有[task]的配置都保存下来，记录到成员变量cr_confs_内。需要注意的点是，在这个过程中，会根据每个[task]所在的[group]填充group_name，后面会用到。</span><br><span class="line">    <span class="number">6.</span> 最后为每个group创建对应数量的Processor，并设置相关策略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化过程中，有很多部分都与配置文件直接相关，这里我们以<code>conf/example_sched_classic.conf</code>为例展开：</p><p><img src="https://s1.nsloop.com:58443/images/2021/11/29/20211129005008.png"></p><p>我们从第4点开始看，首先是读取配置项<code>process_level_cpuset_</code>,根据配置文件，这个字符串一般填<code>"0-7,16-23"</code>形式的内容，表示当前调度线程可以由0-7,16-23号CPU核心来执行。最终实现这个功能的函数是<code>Scheduler::ProcessLevelResourceControl()</code>，其内部是通过glibc提供的接口<code>pthread_setaffinity_np(pthread_self(), sizeof(set), &amp;set);</code>来实现对线程设置CPU亲和性。</p><p><strong>注意配置文件中有两个优先级：</strong></p><ul><li>一个是<code>processor_prio</code>，对应系统Linux中线程的优先级，即nice值，范围从-20到19，值越低优先级越高，默认值为0；</li><li>另一个是task的<code>prio</code>，它是Cyber RT中的协程调度的优先级，共20级，值越高优先越高</li></ul><p>接下来第5点，简单来说就是读取每个[task]字段的配置项，并保存下来，其代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">classic_conf_ = cfg.scheduler_conf().classic_conf();</span><br><span class="line"><span class="comment">// 遍历每一个group</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; group : classic_conf_.groups()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; group_name = group.name();</span><br><span class="line">  <span class="comment">// 遍历group内的task配置项</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> task : group.tasks()) &#123;</span><br><span class="line">    <span class="comment">// 对task反过来设置group_name</span></span><br><span class="line">    task.set_group_name(group_name);</span><br><span class="line">    <span class="comment">// 保存起来</span></span><br><span class="line">    cr_confs_[task.name()] = task;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应配置文件举例如下：</p><p><img src="https://s1.nsloop.com:58443/images/2021/11/29/20211129005901.png"></p><p>这里有一点需要注意的是，由于配置文件中每个[task]内部没有写明其所在的[group]名称，因此在读取配置的时候，通过<code>task.set_group_name(group_name);</code>进行了设置，这个<code>group_name</code>相当的重要，接下来会用到。</p><p>最后看第6点，为每个group创建对应数量的Processor，并设置相关策略，这是由函数<code>SchedulerClassic::CreateProcessor()</code>来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SchedulerClassic::CreateProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历每一个group</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; group : classic_conf_.groups()) &#123;</span><br><span class="line">    <span class="number">1.</span> 获取该group的group_name、proc_num配置参数</span><br><span class="line">    <span class="number">2.</span> 获取该group的affinity、processor_policy、processor_prio配置参数</span><br><span class="line">    <span class="number">3.</span> 内部再进行一次遍历，为每个组创建对应数量的processor,部分代码如下：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; proc_num; i++) &#123;</span><br><span class="line">      <span class="number">3.1</span> 先创建执行器的上下文ClassicContext，并放入全局的pctxs_队列中</span><br><span class="line">      <span class="keyword">auto</span> ctx = <span class="built_in">std</span>::make_shared&lt;ClassicContext&gt;(group_name);</span><br><span class="line">      pctxs_.emplace_back(ctx);</span><br><span class="line">      <span class="number">3.2</span> 创建执行器Processor，并将上面创建的上下文与之绑定</span><br><span class="line">      <span class="keyword">auto</span> proc = <span class="built_in">std</span>::make_shared&lt;Processor&gt;();</span><br><span class="line">      <span class="number">3.3</span> 关键：</span><br><span class="line">      proc-&gt;BindContext(ctx);</span><br><span class="line">      <span class="number">3.4</span> 设置该Processor的CPU亲和性，根据affinity = <span class="string">"range"</span> <span class="keyword">or</span> <span class="string">"1to1"</span>来决定该Processor在多个CPU上进行还是单个CPU上进行</span><br><span class="line">      SetSchedAffinity(proc-&gt;Thread(), cpuset, affinity, i);</span><br><span class="line">      <span class="number">3.5</span> 设置调度策略</span><br><span class="line">      SetSchedPolicy(proc-&gt;Thread(), processor_policy, processor_prio,</span><br><span class="line">                     proc-&gt;Tid());</span><br><span class="line">      <span class="number">3.6</span> 将这个新创建的Processor保存到容器</span><br><span class="line">      processors_.emplace_back(proc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，通过<code>SetSchedAffinity()</code>函数对新创建的某个Processor对象内部的thread进行CPU亲和性设置，以实现CPU的分配，特别的，根据该<code>group</code>的<code>affinity</code>配置项，有两种CPU分配策略：</p><ul><li>range: 采用range策略，即每个Processor对象内部的thread都可以由<code>cpuset</code>字段给定的范围内自由调度，即范围内的CPU都可以处理</li><li>1to1: 即每个Processor对象内部的thread只能对应一个CPU核心，<code>cpuset</code>字段提供的是有多少个CPU可分配，但是个Processor对象内部的thread只能对应<code>cpuset</code>字段的第i个核心</li></ul><p>以上是关于线程的CPU亲和性设置，接下来的一个关键问题是，创建这么多Processor，如何真正处理我们的任务?</p><p>代码片段中的<code>3.3</code>是关键，<code>proc-&gt;BindContext(ctx)</code>将新创建的ProcessorContext上下文保存到成员变量<code>Processor::context_</code>，然后开启线程来执行<code>Processor::Run</code>，该函数代码不长，就两句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processor::BindContext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ProcessorContext&gt;&amp; context)</span> </span>&#123;</span><br><span class="line">  context_ = context;</span><br><span class="line">  <span class="built_in">std</span>::call_once(thread_flag_,</span><br><span class="line">                 [<span class="keyword">this</span>]() &#123; thread_ = <span class="built_in">std</span>::thread(&amp;Processor::Run, <span class="keyword">this</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先保存传进来的<code>ProcessorContext</code>对象指针，然后启动了一个线程，看来<code>Processor::Run</code>这个线程就是实际执行任务的线程了，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processor::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 暂时先忽略snap_shot_这个对象的内容</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是一个循环，只要Processor的running_状态weitrue</span></span><br><span class="line">  <span class="keyword">while</span> (cyber_likely(running_.load())) &#123;</span><br><span class="line">    <span class="comment">// 检查context_不为空</span></span><br><span class="line">    <span class="keyword">if</span> (cyber_likely(context_ != <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="comment">// 尝试从cr_group_获取下一个协程</span></span><br><span class="line">      <span class="keyword">auto</span> croutine = context_-&gt;NextRoutine();</span><br><span class="line">      <span class="comment">// 如果获取成功</span></span><br><span class="line">      <span class="keyword">if</span> (croutine) &#123;</span><br><span class="line">        <span class="comment">// 恢复协程运行</span></span><br><span class="line">        croutine-&gt;Resume();</span><br><span class="line">        <span class="comment">// 释放协程锁( 上面获取协程context_-&gt;NextRoutine()时，调用了croutine-&gt;Aquire() )</span></span><br><span class="line">        croutine-&gt;Release();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待，超时自动解除阻塞</span></span><br><span class="line">        context_-&gt;Wait();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果context_为空，阻塞10毫秒，超时后结束阻塞，下一次循环</span></span><br><span class="line">      <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mtx_ctx_);</span><br><span class="line">      cv_ctx_.wait_for(lk, <span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Processor::Run</code>这个线程不断的尝试从<code>context_</code>成员变量中获取协程，并恢复协程运行，一个协程的任务处理完后，继续从上下文获取下一个协程<code>context_-&gt;NextRoutine();</code>。至于这个协程的切入和切出，到后面协程篇章的时候再详细讨论。接下来，就要看看这个上下文成员变量<code>context_</code>是啥。</p><p><code>processor.h</code>头文件内可知，成员变量<code>context_</code>声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessorContext只是基类，实际保存下来的是 ClassicContext 或 ChoreographyContext</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ProcessorContext&gt; context_;</span><br></pre></td></tr></table></figure><p>即每个<code>Processor</code>对象内维护着一个<code>ProcessorContext</code>。</p><h1 id="processorcontext">ProcessorContext</h1><p>实际上，<code>ProcessorContext</code>只是基类，根据Scheduler的两种策略，分别对应着两种<code>ProcessorContext</code>，分别是:</p><ul><li>ClassicContext</li><li>ChoreographyContext</li></ul><p>uml类图如下：</p><p><img src="https://s1.nsloop.com:58443/images/2021/11/29/processorContext.png"></p><p>接下来，以<code>ClassicContext</code>为主进行展开：</p><h2 id="processorcontext实例化">ProcessorContext实例化</h2><p>ProcessorContext实例化不是在<code>Processor</code>内部进行，而是在上面提到的<code>SchedulerClassic::CreateProcessor()</code>函数中进行，具体代码片段为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ctx = <span class="built_in">std</span>::make_shared&lt;ClassicContext&gt;(group_name);</span><br></pre></td></tr></table></figure><p>接下来，看<code>ClassicContext</code>的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassicContext::ClassicContext()</span><br><span class="line">&#123;</span><br><span class="line">  InitGroup(DEFAULT_GROUP_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassicContext::ClassicContext(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; group_name) &#123;</span><br><span class="line">  InitGroup(group_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassicContext</code>类有两个构造函数，其中一个需要传参[group_name],另外一个不需传参。两个构造函数内部都调用了<code>ClassicContext::InitGroup</code>函数，<strong>该函数从全局静态容器中取对应<code>[group_name]</code>的引用并保存到<code>ClassicContext</code>类的成员变量中，目的是，当其他地方向全局静态容器添加元素时，直接调用<code>ClassicContext</code>类的成员变量即可访问到新增加的元素</strong>。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassicContext::InitGroup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; group_name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// cr_group_是ClassicContext类静态成员变量</span></span><br><span class="line">  <span class="comment">// cr_group_包含了多个组，每个组有分为多个优先级，每个优先级对应着多个协程</span></span><br><span class="line">  multi_pri_rq_ = &amp;cr_group_[group_name]; <span class="comment">// 取cr_group_中对应group_name的组，保存到multi_pri_rq_</span></span><br><span class="line">  lq_ = &amp;rq_locks_[group_name];           <span class="comment">// 取rq_locks_中对应group_name的组，保存到lq_</span></span><br><span class="line">  mtx_wrapper_ = &amp;mtx_wq_[group_name];    <span class="comment">// 取mtx_wrapper_中对应group_name的组，保存到mtx_wrapper_</span></span><br><span class="line">  cw_ = &amp;cv_wq_[group_name];              <span class="comment">// 取cv_wq_中对应group_name的组，保存到cw_</span></span><br><span class="line">  notify_grp_[group_name] = <span class="number">0</span>;</span><br><span class="line">  current_grp = group_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="classiccontext的静态容器">ClassicContext的静态容器</h2><p>上面提到<code>ClassicContext</code>类里面有几个全局静态容器，其在<code>classic_context.h</code>中声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class ClassicContext&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// CR_GROUP: 容器[组名] = std::array&lt;std::vector&lt;std::shared_ptr&lt;CRoutine&gt;&gt;, MAX_PRIO&gt;&gt;</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> CR_GROUP cr_group_;  <span class="comment">///&lt; cr_group_包含了多个组，每个组有分为多个优先级，每个优先级对应着多个协程</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// RQ_LOCK_GROUP: 容器[组名] = std::array&lt;base::AtomicRWLock, MAX_PRIO&gt;;</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> RQ_LOCK_GROUP rq_locks_; <span class="comment">///&lt; rq_locks_包含多个组，每组分为多个优先级，每个优先级对应一个base::AtomicRWLock，关于cr_group_变量的锁</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// GRP_WQ_CV: 容器[组名] = CvWrapper</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> GRP_WQ_CV cv_wq_;  <span class="comment">///&lt; cv_wq_包含多个组，每组对应一个CvWrapper</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// GRP_WQ_MUTEX: 容器[组名] = MutexWrapper</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> GRP_WQ_MUTEX mtx_wq_;  <span class="comment">///&lt; mtx_wq_包含多个组，每组对应一个MutexWrapper，是关于notify_grp_[group_name]的锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// NOTIFY_GRP: 容器[组名] = int</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> NOTIFY_GRP notify_grp_;  <span class="comment">///&lt; notify_grp_包含多个组，每组对应一个int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个容器都是<code>Public</code>的且静态的，所以其他地方可以直接往里面读写数据，而线程问题则通过<code>rq_locks_</code>容器和<code>mtx_wq_</code>容器进行加锁控制。</p><p>实际上，<code>Scheduler</code>要调度的任务，都保存到了这几个静态容器内部，如何存进去，以及存了什么进去，<code>SchedulerClassic::DispatchTask</code>函数给出了答案，该函数以一个协程指针作为参数，做了以下几个工作:</p><ol type="1"><li>首先把这个新协程放入<code>Scheduler::id_cr_</code>中，</li><li>然后根据[协程名]查找保存的构造Scheduler单例时，产生的<code>cr_confs_</code>中是否有该task对应的策略，如果有就根据策略设置该协程的[优先级]和[group_name]</li><li>最后往<code>ClassicContext</code>中的全局静态变量<code>ClassicContext::cr_group_</code>中对应该协程的[group_name]和优先级的队列中加入该协程</li><li>最后调用<code>ClassicContext::Notify(</code>来通知该协程所属的组，让<code>Processor::Run()</code>结束阻塞，马上运行一次</li></ol><p>这个函数，着重看以下代码块:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SchedulerClassic::DispatchTask</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CRoutine&gt;&amp; cr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据协程名进行查表，cr_confs_在实例化SchedulerClassic对象时，就根据配置文件读取配置进去了，对应的是sched_classic.conf配置文件中的"tasks:"项</span></span><br><span class="line">  <span class="keyword">if</span> (cr_confs_.<span class="built_in">find</span>(cr-&gt;name()) != cr_confs_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到配置项，则取对应的value</span></span><br><span class="line">    ClassicTask task = cr_confs_[cr-&gt;name()];</span><br><span class="line">    <span class="comment">// 协程设置属性（从ClassicTask获取）</span></span><br><span class="line">    cr-&gt;set_priority(task.prio());    <span class="comment">// 设置优先级?</span></span><br><span class="line">    cr-&gt;set_group_name(task.group_name());  <span class="comment">// 设置分组名? 如果没有给这个值呢？ ==&gt; 在SchedulerClassic::SchedulerClassic()构造时，会设置值的</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果cr_confs_没有这个协程名的条目，直接设置分组名为默认的 classic_conf_.groups(0).name()</span></span><br><span class="line">    <span class="comment">// croutine that not exist in conf</span></span><br><span class="line">    cr-&gt;set_group_name(classic_conf_.groups(<span class="number">0</span>).name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue task.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 取ClassicContext::cr_group_对应该组该优先级的写锁</span></span><br><span class="line">    <span class="function">WriteLockGuard&lt;AtomicRWLock&gt; <span class="title">lk</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassicContext::rq_locks_[cr-&gt;group_name()].at(cr-&gt;priority()))</span></span>;</span><br><span class="line">    <span class="comment">// 将输入参数中的协程添加到ClassicContext::cr_group_，等待被调度</span></span><br><span class="line">    ClassicContext::cr_group_[cr-&gt;group_name()]</span><br><span class="line">        .at(cr-&gt;priority())</span><br><span class="line">        .emplace_back(cr);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，需要调度的协程，都通过这个函数，根据协程所在的组，把协程指针保存到<code>ClassicContext::cr_group_</code>静态变量中。</p><h3 id="classiccontextcr_group数据结构">ClassicContext::cr_group数据结构</h3><p><img src="https://s1.nsloop.com:58443/images/2021/12/01/cr_group_.drawio.png"></p><p><code>ClassicContext::cr_group_</code>是一张大的表格，分为多个[group]，每个[group]又分多个优先级，每个优先级对应着一个<code>std::vector</code>，<code>vector</code>内部存放着多个协程。</p><p>一个需要注意的点是，由于<code>ClassicContext::cr_group_</code>是静态变量，多个线程访问时会有<code>data race</code>的问题，因此cyber-rt增加了对应的锁<code>ClassicContext::rq_locks_</code>来解决。</p><h3 id="classiccontextrq_locks数据结构">ClassicContext::rq_locks数据结构</h3><p><img src="https://s1.nsloop.com:58443/images/2021/12/04/rq_locks_.drawio.png"></p><p>显然，<code>ClassicContext::rq_locks_</code>内按<code>group_name</code>进行分组，每个组内又按优先级进行划分，因此，这里一个锁对应<code>ClassicContext::cr_group_</code>中的一个<code>std::vector&lt;CRoutine&gt;</code>，其对应关系如下图所示：</p><p><img src="https://s1.nsloop.com:58443/images/2021/12/04/rq_locak_and_cr_group.drawio1f9420f739656693.png"></p><h2 id="classiccontext的动态容器">ClassicContext的动态容器</h2><p>前面讨论了<code>ClassicContext</code>的静态成员变量，接下来我们看其类内动态成员变量。代码片段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassicContext</span> :</span> <span class="keyword">public</span> ProcessorContext &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// std::array&lt;std::vector&lt;std::shared_ptr&lt;CRoutine&gt;&gt;, MAX_PRIO&gt;</span></span><br><span class="line">MULTI_PRIO_QUEUE *multi_pri_rq_ = <span class="literal">nullptr</span>; <span class="comment">///&lt; 优先队列，每个优先级有一个协程列表</span></span><br><span class="line">LOCK_QUEUE *lq_ = <span class="literal">nullptr</span>;</span><br><span class="line">MutexWrapper *mtx_wrapper_ = <span class="literal">nullptr</span>; <span class="comment">///&lt; 这个是对成员notify_grp_[current_grp]的锁</span></span><br><span class="line">CvWrapper *cw_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_grp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="classiccontextmulti_pri_rq队列">ClassicContext::multi_pri_rq队列</h3><p>在函数<code>ClassicContext::InitGroup</code>中，将<code>ClassicContext::cr_group_</code>的某个组的引用赋值给了成员变量<code>ClassicContext::multi_pri_rq_</code>，因此，<code>ClassicContext::multi_pri_rq_</code>的数据结构如下:</p><p><img src="https://s1.nsloop.com:58443/images/2021/12/05/multi_pri_rq.drawio.png"></p><p><code>ClassicContext::multi_pri_rq_</code>与<code>ClassicContext::cr_group_</code>的映射关系如下:</p><p><img src="https://s1.nsloop.com:58443/images/2021/12/05/multi_pri_rq.drawiofeae01cd4a05a6ac.png"></p><p>所以，通过向全局静态表<code>ClassicContext::cr_group_</code>写入协程后，可以通过<code>ClassicContext::multi_pri_rq_</code>来读取对应的协程，最后通过<code>Processor::Run</code>来完成协程的调用。</p><h1 id="重要过程时序流图">重要过程时序流图</h1><h2 id="创建schedulerclassic实例">创建SchedulerClassic实例</h2><p><img src="https://s1.nsloop.com:58443/images/2021/12/05/SchedulerClassicSchedulerClassic.jpg"></p><h2 id="创建processor并绑定上下文">创建Processor并绑定上下文</h2><p><img src="https://s1.nsloop.com:58443/images/2021/12/05/SchedulerClassicCreateProcessor.jpg"></p><h2 id="创建task并分配给processor">创建Task并分配给Processor</h2><p><code>Scheduler::CreateTask</code>这个函数是<code>Scheduler</code>基类的函数，其内部会调用子类<code>SchedulerClassic</code>或<code>SchedulerChoreography</code>的<code>DispatchTask()</code>函数，最后将子类的<code>NotifyProcessor</code>函数注册给<code>DataVistor</code>对象，其详细的时序流程如下：</p><p><img src="https://s1.nsloop.com:58443/images/2021/12/05/SchedulerCreateTaskbdbced6bb306a41f.jpg"></p><h2 id="运转核心processorrun">运转核心Processor::Run</h2><p><img src="https://s1.nsloop.com:58443/images/2021/12/05/ProcessorRun.jpg"></p><h2 id="唤醒机制schedulerclassicnotifyprocessor">唤醒机制SchedulerClassic::NotifyProcessor</h2><p><img src="https://s1.nsloop.com:58443/images/2021/12/07/SchedulerClassicNotifyProcessor.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;Scheduler是Cyber-RT的调度核心，是协程的调度载体。特别的，对于自动驾驶任务而言，任务调度的实时性发挥至关重要的作用，因此有必要对各种任务的优先级进行分类排序，如对于控制任务而言，需要单独分配CPU以供实时运行，Cybe
      
    
    </summary>
    
    
    
      <category term="Cyber_RT" scheme="http://yoursite.com/tags/Cyber-RT/"/>
    
  </entry>
  
  <entry>
    <title>FAST-LIO论文阅读</title>
    <link href="http://yoursite.com/2021/10/13/FAST-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/10/13/FAST-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-10-13T13:03:53.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fast-lio-a-fast-robust-lidar-inertial-odometry-package-by-tightly-coupled-iterated-kalman-filter">FAST-LIO: A Fast, Robust LiDAR-inertial Odometry Package by Tightly-Coupled Iterated Kalman Filter</h1><p><img src="https://s1.nsloop.com:58443/images/2021/10/13/20211013205305.png"></p><h1 id="摘要">摘要</h1><h1 id="方法">方法</h1><h2 id="架构总览">架构总览</h2><p>本文使用的符号如表一所示</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/13/20211013205455.png"></p><p>系统的流图如图2所示</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/13/20211013205632.png"></p><p>将激光雷达输入输入特征提取模块，获取平面和边缘特征。然后将提取的特征和IMU测量值输入状态估计模块进行10Hz和50Hz的状态估计。然后，估计的姿态将特征点注册到全局坐标系，并将它们与到目前为止建立的特征点地图合并，最后，在下一步中使用更新后的特征地图来注册更多的新点。</p><h2 id="系统描述">系统描述</h2><h3 id="操作符">操作符</h3><p>设M为考虑维度n的流形(如： <span class="math inline">\(\mathcal{M}=S O(3)\)</span>），因为流形对于<span class="math inline">\(\mathbb{R}^{n}\)</span>是局部homeomorphic的，因此我们可以建立双向的映射，即通过操作符<span class="math inline">\(\boxplus,\boxminus\)</span>[23]，从流形 <span class="math inline">\(\mathcal{M}\)</span>的局部邻域映射到其正切空间<span class="math inline">\(\mathbb{R}^{n}\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/14/20211014094942.png"></p><p>其中，<span class="math inline">\(\operatorname{Exp}(\mathbf{r})=\mathbf{I}+\frac{\mathbf{r}}{\|\mathbf{r}\|} \sin (\|\mathbf{r}\|)+\frac{\mathbf{r}^{2}}{\|\mathbf{r}\|^{2}}(1-\cos (\|\mathbf{r}\|))\)</span>是指数映射[23]，<span class="math inline">\(\log (\cdot)\)</span>则是其逆映射。对于组合的流形<span class="math inline">\(\mathcal{M}=S O(3) \times \mathbb{R}^{n}\)</span>，我们有：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/14/20211014095245.png"></p><p>利用上述定义，我们可以得到：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/14/20211014095319.png"></p><h3 id="连续时间模型">连续时间模型</h3><p>假设IMU与激光雷达之间是刚体变换，其中外参是<span class="math inline">\({ }^{I} \mathbf{T}_{L}=\left({ }^{I} \mathbf{R}_{L},{ }^{I} \mathbf{p}_{L}\right)\)</span>。以IMU坐标系（记为<span class="math inline">\(I\)</span>）作为body坐标系，可得运动学模型：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/14/20211014095614.png"></p><p>其中，</p><ul><li><span class="math inline">\({ }^{G} \mathbf{p}_{I},{ }^{G} \mathbf{R}_{I}\)</span>分别是IMU在全局坐标系（如第一帧IMU坐标系，记为<span class="math inline">\(G\)</span>）的位置和姿态。</li><li><span class="math inline">\({ }^{G} \mathbf{g}\)</span>是全局坐标系下未知的重力向量</li><li><span class="math inline">\(\mathbf{a}_{m}\)</span>,<span class="math inline">\(\boldsymbol{\omega}_{m}\)</span>是IMU测量</li><li><span class="math inline">\(\mathbf{n}_{\mathbf{a}}\)</span> and <span class="math inline">\(\mathbf{n}_{\boldsymbol{\omega}}\)</span>是IMU测量白噪声</li><li><span class="math inline">\(\mathbf{b}_{\mathbf{a}}\)</span> and <span class="math inline">\(\mathbf{b}_{\boldsymbol{\omega}}\)</span>是由高斯噪声<span class="math inline">\(\mathbf{n}_{\mathbf{b a}}\)</span> , <span class="math inline">\(\mathbf{n}_{\mathbf{b} \omega}\)</span>随机游走过程建模的bias</li><li><span class="math inline">\(\lfloor\mathbf{a}\rfloor_{\wedge}\)</span>表示向量<span class="math inline">\(\mathbf{a} \in \mathbb{R}^{3}\)</span>的反对称矩阵</li></ul><h3 id="离散时间模型">离散时间模型</h3><p>基于上面的<span class="math inline">\(\boxplus\)</span>操作符，我们在IMU采样周期<span class="math inline">\(\Delta t\)</span>内使用零阶保持器来对式（1）的连续时间模型进行离散化，得到：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/14/20211014173846.png"></p><p>其中，i表示IMU测量的索引，函数<span class="math inline">\(\mathbf{f}\)</span>，状态<span class="math inline">\(\mathbf{x}\)</span>，输入<span class="math inline">\(\mathbf{u}\)</span>，噪声<span class="math inline">\(\mathbf{w}\)</span>定义如下：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/14/20211014174415.png"></p><h3 id="激光测量预处理">激光测量预处理</h3><p>激光雷达测量是点坐标在它的局部坐标系。由于原始激光雷达点的采样速率非常高(例如，200kHz)，通常不可能在接收到每个新点后马上进行处理，一种更实际的方法是在一段时间内积累这些点，然后一次性处理它们。</p><p><code>FAST-LIO</code>中，最小积累间隔设置为20毫秒，可产生高达50 Hz的全状态估计(即里程计输出)和地图更新，如图2 （a）所示。这种累积的点集称为scan，其处理时间记为<span class="math inline">\(t_k\)</span>(见图2 (b)。</p><p>我们从原始点中提取局部光滑度高的平面点[8]和局部光滑度低的边缘点[10]，假设特征点的数量为m，每个特征点在<span class="math inline">\(\rho_{j} \in\left(t_{k-1}, t_{k}\right]\)</span>时刻采样，特征点记为<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{f_{j}}\)</span>，其中<span class="math inline">\(L_{j}\)</span>是<span class="math inline">\(\rho_{j}\)</span>时刻下激光雷达坐标系。</p><p>在激光扫描期间，通常会收到几帧IMU测量，假设每一个IMU采样时间<span class="math inline">\(\tau_{i} \in\left[t_{k-1}, t_{k}\right]\)</span>，其对应的状态<span class="math inline">\(\mathbf{x}_i\)</span>如式（2）。注意，最后一个激光雷达特征点是扫描的结束，即<span class="math inline">\(\rho_{m}=t_{k}\)</span>，而IMU测量值不一定与扫描开始或结束时对齐。</p><h3 id="状态估计">状态估计</h3><p>为了估计状态公式(2)中的状态，我们使用了迭代扩展卡尔曼滤波器，此外，我们刻画了状态估计的正切空间中的估计协方差，如[23,24]。</p><p>假设在<span class="math inline">\(t_{k-1}\)</span>时刻下最后一次激光雷达扫描的最佳状态估计为<span class="math inline">\(\bar{\mathbf{x}}_{k-1}\)</span>，协方差为<span class="math inline">\(\overline{\mathbf{P}}_{k-1}\)</span>。其中，<span class="math inline">\(\overline{\mathbf{P}}_{k-1}\)</span>代表了如下误差状态向量的协方差：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/14/20211014214313.png"></p><p>其中，</p><ul><li><span class="math inline">\(\delta \boldsymbol{\theta}=\log \left({ }^{G} \overline{\mathbf{R}}_{I}^{T G} \mathbf{R}_{I}\right)\)</span>是姿态误差</li><li>剩下的其他都是直接相减</li></ul><p>直觉的，<span class="math inline">\(\delta \boldsymbol{\theta}\)</span>描述了姿态真值和估计值之间的小偏差，使用这个来定义姿态误差的好处是允许使用3x3协方差矩阵<span class="math inline">\(\mathbb{E}\left\{\delta \boldsymbol{\theta} \delta \boldsymbol{\theta}^{T}\right\}\)</span>来描述姿态的不确定性。因为姿态是3自由度，因此这是最小表达。</p><p>1）前向传播</p><p>一旦接收到IMU输入，则执行一次前向传播（如图2所示），特别的，前向传播根据式（2）进行，且把噪声<span class="math inline">\(\mathbf{W}_{i}\)</span>设置为零，（相当于nominal state）：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/15/20211015095745.png"></p><p>其中，<span class="math inline">\(\Delta t=\tau_{i+1}-\tau_{i}\)</span>，为了传播协方差，我们使用下面的误差状态动态模型：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/15/20211015095952.png"></p><p>矩阵<span class="math inline">\(\mathbf{F}_{\widetilde{\mathbf{x}}}\)</span>和<span class="math inline">\(\mathbf{F}_{\mathbf{w}}\)</span>为误差状态模型(实际上就是误差分析，可参考<a href="http://epsilonjohn.club/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">博客</a>)，具体计算见附录A.</p><p>此处直接给出结果：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/16/20211016095853.png"></p><p>其中，</p><ul><li><span class="math inline">\(\widehat{\boldsymbol{\omega}}_{i}=\boldsymbol{\omega}_{m_{i}}-\widehat{\mathbf{b}}_{\boldsymbol{\omega}_{i}}\)</span></li><li><span class="math inline">\(\widehat{\mathbf{a}}_{i}=\mathbf{a}_{m_{i}}-\widehat{\mathbf{b}}_{\mathbf{a}_{i}}\)</span></li></ul><p>且<span class="math inline">\(\mathbf{A}(\mathbf{u})^{-1}\)</span>遵循[25]中的定义，如下计算：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/16/20211016100101.png"></p><p>记白噪声<span class="math inline">\(\mathbf{w}\)</span>的协方差为Q，然后可以通过下式来迭代传播协方差<span class="math inline">\(\widehat{\mathbf{P}}_{i}\)</span>：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/16/20211016100233.png"></p><p>前向传播直到新的一帧数据结束<span class="math inline">\(t_k\)</span>，传播的状态和协方差分别记为<span class="math inline">\(\widehat{\mathbf{x}}_{k}, \widehat{\mathbf{P}}_{k}\)</span>，协方差表示状态真值与传播值之间的误差协方差。</p><p>2）反向传播和运动补偿</p><p>当在时间<span class="math inline">\(t_k\)</span>，新一帧的特征点应该与传播状态<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>和协方差<span class="math inline">\(\widehat{\mathbf{P}}_{k}\)</span>进行结合以产生最优状态更新。然而，尽管新的一帧是在<span class="math inline">\(t_k\)</span>到达，实际上特征点是在各自的采样时刻<span class="math inline">\(\rho_j\)</span>下得到的，因此要进行运动畸变矫正。</p><p>为了补偿<span class="math inline">\(\rho_j\)</span>到<span class="math inline">\(t_k\)</span>之间的相对运动（即运动畸变），根据式（2），可得传播方程<span class="math inline">\(\check{\mathbf{x}}_{j-1}=\check{\mathbf{x}}_{j}\)</span> 田 <span class="math inline">\(\left(-\Delta t \mathbf{f}\left(\check{\mathbf{x}}_{j}, \mathbf{u}_{j}, \mathbf{0}\right)\right)\)</span>。</p><p>向后传播在特征点的频率下执行，这通常远高于IMU速率，对于在两个IMU测量之间采样的所有特征点，我们使用左IMU测量作为后传播中的输入。</p><p>此外，注意到<span class="math inline">\(\mathbf{f}\left(\mathbf{x}_{j}, \mathbf{u}_{j}, \mathbf{0}\right)\)</span>中最后三个块元素（对应于gyro bias，accelerometer bias和外参）都是零，因此，反向传播可以简化为：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/16/20211016101449.png"></p><p>其中，</p><ul><li><span class="math inline">\(\rho_{j-1} \in\left[\tau_{i-1}, \tau_{i}\right)\)</span>表示一帧扫描内的某个时刻</li><li><span class="math inline">\(\Delta t=\rho_{j}-\rho_{j-1}\)</span>表示两个点之间的时间差</li><li><span class="math inline">\(s.f.\)</span>表示“starting form”的意思</li></ul><p>反向传播会计算出时间<span class="math inline">\(\rho_{j}\)</span>到时间<span class="math inline">\(t_k\)</span> 的相对位姿变换<span class="math inline">\({ }^{I_{k}} \check{\mathbf{T}}_{I_{j}}=\left({ }^{I_{k}} \check{\mathbf{R}}_{I_{j}},{ }^{I_{k}} \check{\mathbf{p}}_{I_{j}}\right)\)</span>，这个相对位姿变换运行我们将激光扫描观测点<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{f_{j}}\)</span>投影到扫描结束时刻下的坐标系，如下：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/16/20211016102337.png"></p><p>其中，<span class="math inline">\({ }^{I} \mathbf{T}_{L}\)</span>是已知外参，投影点<span class="math inline">\({ }^{L_{k}} \mathbf{p}_{f_{j}}\)</span>用于下一步构造残差。</p><p>3）残差计算</p><p>使用式（10）的运动补偿，我们可以看到在<span class="math inline">\(t_k\)</span>时刻下所有特征点<span class="math inline">\(\left\{ { }^{L_{k}} \mathbf{p}_{f_{j}}\right\}\)</span>正确的位置，并且用来构造残差。</p><p>假设当前IEKF迭代为<span class="math inline">\(\kappa\)</span>，对应的状态估计为<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa}\)</span>。当<span class="math inline">\(\kappa=0\)</span>，<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa}=\widehat{\mathbf{x}}_{k}\)</span>，预测的状态即为式（4）传播的状态。因此，特征点可以被投影到全局坐标系，如下：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/17/20211017225552.png"></p><p>对于每一个激光特征点，假设其附近的附近特征点定义的最接近的平面或边缘是与之关联的特征。残差即为特征点与关联特征（平面、边缘）的欧式距离（全局坐标系下）。</p><p>记<span class="math inline">\(\mathbf{u}_{j}\)</span>为平面法向量或者边缘方向，对于根据状态估计投影到全局坐标系的特征点<span class="math inline">\({ }^{G} \widehat{\mathbf{p}}_{f_{j}}^{\kappa}\)</span>，假设平面/边缘上有点<span class="math inline">\({ }^{G} \mathbf{q}_{j}\)</span>，残差<span class="math inline">\(\mathbf{z}_{j}^{\kappa}\)</span>如下计算：</p><p><img src="https://s1.nsloop.com:58443/images/2021/10/17/20211017230052.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{G}_{j}=\mathbf{u}_{j}^{T}\)</span>是平面特征</li><li><span class="math inline">\(\mathbf{G}_{j}=\left\lfloor\mathbf{u}_{j}\right\rfloor_{\wedge}\)</span>是边缘特征</li><li><span class="math inline">\(\mathbf{u}_{j}\)</span>的计算和最近邻点的搜索是通过构建局部地图KD-TREE来实现的</li><li>此外，我们只考虑<code>norm</code>低于某些阈值（例如，0.5米）的残差。 超过此阈值的残差是异常值或新观察点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fast-lio-a-fast-robust-lidar-inertial-odometry-package-by-tightly-coupled-iterated-kalman-filter&quot;&gt;FAST-LIO: A Fast, Robust LiDAR-ine
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>FAST-LIO2论文阅读</title>
    <link href="http://yoursite.com/2021/09/11/FAST-LIO2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/09/11/FAST-LIO2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-09-11T06:03:53.000Z</published>
    <updated>2022-06-26T21:28:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fast-lio2-fast-direct-lidar-inertial-odometry">FAST-LIO2: Fast Direct LiDAR-inertial Odometry</h1><p><img src="https://s1.nsloop.com:58443/images/2021/09/12/20210912151410.png"></p><h1 id="摘要">摘要</h1><p>在高效的紧密耦合迭代卡尔曼滤波器上，FAST-LiO2有两个关键的新科技，可允许快速，强大，准确的LIDAR导航（和建图）。</p><ul><li>直接将原始点注册到地图（随后更新地图）而不提取特征点。这使得能够利用环境中的微妙特征，因此提高了准确性。取消手工设计的特征提取模块也使其自然适应不同扫描模式的新兴 LiDAR。</li><li>第二个主要新颖性是通过增量K-D树数据结构，来维护地图，该映射可以增量更新（即点插入，删除）和动态重新平衡。与现有的动态数据结构相比（Octree，R * -tree，Nanoflann K-D树），IKD-Tree实现了卓越的整体性能，同时支持基于数的降采样</li></ul><p>我们在来自各种开放式LIDAR数据集中的19个序列中进行详尽的基准比较，与其他最先进的 LiDAR 惯性导航系统相比，FAST-LIO2 以更低的计算负载持续实现更高的精度，还进行了关于具有小FOV的固态激光雷达的各种真实实验。</p><p>总的来说，FAST-LiO 2是计算上有效的（例如，高达100 Hz的里程计和大型环境中的建图），鲁棒（例如，杂乱的室内环境中具有旋转的杂乱的室内环境的可靠姿态估计，多功能（即， 适用于多线和固态LIDARS，UAV和手持平台，英特尔和基于ARM的处理器），同时仍然比现有方法实现更高的准确性。</p><h1 id="介绍">介绍</h1><p>我们开发一个增量K-D树数据结构，IKD树，有效地表示大规模稠密点云地图。 除了有效的最近邻搜索之外，新的数据结构还支持增量地图更新（即，点插入，基于数的降采样，点删除）和最小计算成本的动态重新平衡。</p><p>这些功能使IKD树非常适合基于激光雷达的里程计和建图应用，在计算限制平台上实现100 Hz 里程计和建图，如微型UAV板载计算机（英特尔I7）甚至基于ARM的处理器。</p><p>通过增加IKD树的计算效率允许，我们直接将原始点注册到地图，即使具有激进的运动和非常杂乱的环境，也能够更准确和可靠的扫描配准。我们将此使用原始点的配准称为类似于Visual Slam的直接方法[21]。消除手工工程特征提取使得系统自然适用于不同的激光雷达传感器。</p><p>我们将以上两个改进整合到先前的工作<code>FAST-LIO</code>中，该系统使用IMU通过严格的反向传播步骤来遵从每个点的运动，并通过迭代扩展卡尔曼滤波器估计系统的完整状态。为了进一步加速计算，使用新的和数学上等同的计算卡尔曼增益的公式用于<strong>将计算复杂性降低到状态的维度（而不是观测的维度）</strong>。</p><p>新的系统称为<code>FAST-LIO2</code>，关于各种尺寸的18个序列的实验表明，IKD树在应用激光雷达测量和测绘时实现了相比于现有动态数据结构（Octree，R * -Tree，Nanoflann K-D树）的卓越性能</p><h1 id="系统概述">系统概述</h1><p><img src="https://s1.nsloop.com:58443/images/2021/09/12/20210912200058.png"></p><p><code>FAST-LIO2</code>的数据流如图所示，为了执行状态估计，新扫描中的点被通过紧密耦合的迭代卡尔曼滤波器框架（有红色的大虚线块）注册到大型局部地图中。大型局部地图中的全局地图点由增量K-D树结构IKD-Tree组织（蓝色虚线块）。如果当前LIDAR的FOV范围交叉地图边界，则将删除IKD树中，从LIDAR位置到最远地图区域中的历史点。</p><p>结果，IDK-TREE跟踪在一个大范围立方体区域（<code>map size</code>）中的所有地图点，并用于计算状态估计模块中的残差。优化后的位姿最后将新扫描中的点注册到全局坐标系，并通过以里程计频率插入到IKD树，来将它们合并到地图中。</p><h1 id="状态估计">状态估计</h1><p><code>FAST-LIO2</code>的状态估计是从<code>FAST-LIO</code>[22]继承的，且进一步整合了Lidar-IMU的外参在线标定。在这里，我们简要解释滤波器的基本配方和工作流程，并参考[22]了解更多细节。</p><h2 id="系统模型">系统模型</h2><p>我们首先导出系统模型，由状态转换模型和测量模型组成</p><h3 id="状态转移模型">状态转移模型</h3><p>取第一个 IMU 帧（记为 I）作为全局帧（记为 G），记<span class="math inline">\({ }^{I} \mathbf{T}_{L}=\left({ }^{I} \mathbf{R}_{L},{ }^{I} \mathbf{p}_{L}\right)\)</span>为激光雷达到IMU的外参（未知），那么模型如下：</p><p><span class="math display">\[\begin{aligned}{ }^{G} \dot{\mathbf{R}}_{I} &amp;={ }^{G} \mathbf{R}_{I}\left\lfloor\boldsymbol{\omega}_{m}-\mathbf{b}_{\boldsymbol{\omega}}-\mathbf{n}_{\boldsymbol{\omega}}\right\rfloor_{\wedge}\\ { }^{G} \dot{\mathbf{p}}_{I} &amp;={ }^{G} \mathbf{v}_{I} \\{ }^{G} \dot{\mathbf{v}}_{I} &amp;={ }^{G} \mathbf{R}_{I}\left(\mathbf{a}_{m}-\mathbf{b}_{\mathbf{a}}-\mathbf{n}_{\mathbf{a}}\right)+{ }^{G} \mathbf{g} \\\dot{\mathbf{b}}_{\boldsymbol{\omega}} &amp;=\mathbf{n}_{\mathbf{b} \omega}, \dot{\mathbf{b}}_{\mathbf{a}}=\mathbf{n}_{\mathbf{b a}} \\{ }^{G} \dot{\mathbf{g}} &amp;=\mathbf{0},{ }^{I} \dot{\mathbf{R}}_{L}=\mathbf{0},{ }^{I} \dot{\mathbf{p}}_{L}=\mathbf{0}\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\({ }^{G} \mathbf{p}_{I},{ }^{G} \mathbf{R}_{I}\)</span>分别为全局坐标系下的IMU的位置和姿态</li><li><span class="math inline">\({ }^{G} \mathbf{g}\)</span>是全局坐标系下的重力向量</li><li><span class="math inline">\(\mathbf{a}_{m}\)</span>，<span class="math inline">\(\omega_{m}\)</span>是IMU测量</li><li><span class="math inline">\(\mathbf{b}_{\mathbf{a}}\)</span>，<span class="math inline">\(\mathbf{b}_{\boldsymbol{\omega}}\)</span>是由噪声<span class="math inline">\(\mathbf{n}_{\mathbf{b a}},\mathbf{n}_{\mathbf{b \omega}}\)</span>驱动的随机游走过程建模的IMU偏置</li><li><span class="math inline">\(\lfloor\mathbf{a}\rfloor_{\wedge}\)</span>表示由向量<span class="math inline">\(\mathbf{a}\)</span>构成的反对称矩阵</li></ul><p>记<span class="math inline">\(i\)</span>为IMU测量的索引，基于[22]中定义的<span class="math inline">\(\boxplus\)</span> 操作符，连续时间下的动态模型可以根据IMU采样周期<span class="math inline">\(\Delta t\)</span>进行离散化，如下：</p><p><span class="math display">\[\mathbf{x}_{i+1}=\mathbf{x}_{i} \boxplus \left(\Delta t \mathbf{f}\left(\mathbf{x}_{i}, \mathbf{u}_{i}, \mathbf{w}_{i}\right)\right)\]</span></p><p>其中，函数<span class="math inline">\(\mathbf{f}\)</span>，状态<span class="math inline">\(\mathbf{x}\)</span>，输入<span class="math inline">\(\mathbf{u}\)</span>和噪声<span class="math inline">\(\mathbf{w}\)</span>定义如下：</p><p><span class="math display">\[\mathcal{M} \triangleq S O(3) \times \mathbb{R}^{15} \times S O(3) \times \mathbb{R}^{3} ; \operatorname{dim}(\mathcal{M})=24\]</span></p><p><span class="math display">\[\mathbf{x} \triangleq\left[\begin{array}{llllllll}{ }^{G} \mathbf{R}_{I}^{T} &amp; { }^{G} \mathbf{p}_{I}^{T} &amp; { }^{G} \mathbf{v}_{I}^{T} &amp; \mathbf{b}_{\boldsymbol{\omega}}^{T} &amp; \mathbf{b}_{\mathbf{a}}^{T} &amp; { }^{G} \mathbf{g}^{T} &amp; { }^{I} \mathbf{R}_{L}^{T} &amp; { }^{I} \mathbf{p}_{L}^{T}\end{array}\right]^{T} \in \mathcal{M}\]</span></p><p><span class="math display">\[\mathbf{u} \triangleq\left[\begin{array}{ll}\boldsymbol{\omega}_{m}^{T} &amp; \mathbf{a}_{m}^{T}\end{array}\right]^{T}\]</span></p><p><span class="math display">\[\mathbf{w} \triangleq\left[\begin{array}{llll}\mathbf{n}_{\boldsymbol{\omega}}^{T} &amp; \mathbf{n}_{\mathbf{a}}^{T} &amp; \mathbf{n}_{\mathbf{b} \boldsymbol{\omega}}^{T} &amp; \mathbf{n}_{\mathbf{b a}}^{T}\end{array}\right]^{T}\]</span></p><p><span class="math display">\[\mathbf{f}(\mathbf{x}, \mathbf{u}, \mathbf{w})=\left[\begin{array}{c}\boldsymbol{\omega}_{m}-\mathbf{b}_{\boldsymbol{\omega}}-\mathbf{n}_{\boldsymbol{\omega}} \\{ }^{G} \mathbf{v}_{I}+\frac{1}{2}\left({ }^{G} \mathbf{R}_{I}\left(\mathbf{a}_{m}-\mathbf{b}_{\mathbf{a}}-\mathbf{n}_{\mathbf{a}}\right)+{ }^{G} \mathbf{g}\right) \Delta t \\{ }^{G} \mathbf{R}_{I}\left(\mathbf{a}_{m}-\mathbf{b}_{\mathbf{a}}-\mathbf{n}_{\mathbf{a}}\right)+{ }^{G} \mathbf{g} \\\mathbf{n}_{\mathbf{b} \omega} \\\mathbf{n}_{\mathbf{b a}} \\\mathbf{0}_{3 \times 1} \\\mathbf{0}_{3 \times 1} \\\mathbf{0}_{3 \times 1}\end{array}\right] \in \mathbb{R}^{24}\]</span></p><h3 id="量测模型">量测模型</h3><p>LIDAR通常是一个接一个地点的样品。 因此，当激光雷达经历连续运动时，所得到的点在不同的姿势处采样，为了纠正这种扫描运动，我们采用[22]中提出的反向传播，<strong>其估计每个激光点时刻下的激光雷达位姿相对于该帧激光扫描最后时刻的激光雷达位姿</strong>。估计的相对姿势使我们能够基于扫描中每个单独点的精确采样时间将所有点投影到扫描结束时间，以实现校正。</p><p>记<span class="math inline">\(k\)</span>为激光扫描的索引，<span class="math inline">\(\{ { }^{L} \mathbf{p}_{j}, j = 1,\dots,m\}\)</span>是第<span class="math inline">\(k\)</span>帧激光坐标系下的激光点（扫描结束时刻），由于激光测量存在噪声，每一个点<span class="math inline">\(\mathbf{p}_{j}\)</span>都会受到由测距和方向组合的噪声项<span class="math inline">\({ }^{L} \mathbf{n}_{j}\)</span>影响。因此，真正的激光点与测量值之间存在如下关系：</p><p><span class="math display">\[{ }^{L} \mathbf{p}_{j}^{\mathrm{gt}}={ }^{L} \mathbf{p}_{j}+{ }^{L} \mathbf{n}_{j}\]</span></p><p>真正的激光点<span class="math inline">\({ }^{L} \mathbf{p}_{j}^{\mathrm{gt}}\)</span>，根据对应的激光雷达位姿<span class="math inline">\({ }^{\mathbf{G}}\mathbf{T}_{I_{k}}=\left({ }^{G} \mathbf{R}_{I_{k}},{ }^{G} \mathbf{p}_{I_{k}}\right)\)</span>以及外参<span class="math inline">\({ }^{I} \mathbf{T}_{L}\)</span>进行坐标转换，其应该准确的位于地图中的局部的平面上，满足：</p><p><span class="math display">\[\mathbf{0}={ }^{G} \mathbf{u}_{j}^{T}\left({ }^{G} \mathbf{T}_{I_{k}}{ }^{I} \mathbf{T}_{L}\left({ }^{L} \mathbf{p}_{j}+{ }^{L} \mathbf{n}_{j}\right)-{ }^{G} \mathbf{q}_{j}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\({ }^{G} \mathbf{u}_{j}\)</span>是对应关联平面的法向量</li><li><span class="math inline">\({ }^{G} \mathbf{q}_{j}\)</span>是平面上的点</li><li>值得注意的是，<span class="math inline">\({ }^{G} \mathbf{T}_{I_{k}},{ }^{I} \mathbf{T}_{L}\)</span>都包含在状态向量<span class="math inline">\(\mathbf{x}_k\)</span>中</li></ul><p>因此，第<span class="math inline">\(j\)</span>个点的测量<span class="math inline">\({ }^{L} \mathbf{p}_{j}\)</span>，可以写成统一紧凑形式如下：</p><p><span class="math display">\[\mathbf{0}=\mathbf{h}_{j}\left(\mathbf{x}_{k},{ }^{L} \mathbf{p}_{j}+{ }^{L} \mathbf{n}_{j}\right)\]</span></p><p>这定义了状态矢量<span class="math inline">\(\mathbf{x}_k\)</span>的隐式测量模型</p><h2 id="迭代卡尔曼滤波器">迭代卡尔曼滤波器</h2><p>基于上面的状态模型和基于流形<span class="math inline">\(\mathcal{M} \triangleq S O(3) \times \mathbb{R}^{15} \times S O(3) \times \mathbb{R}^{3}\)</span>的量测模型，我们使用迭代卡尔曼滤波器直接在流形<span class="math inline">\(\mathcal{M}\)</span>上进行操作，遵循文献[55][22]。</p><p>其包含两个关键步骤：</p><ul><li>在每个IMU测量上传播</li><li>在每一帧激光扫描上进行迭代</li></ul><p>这两个步骤都自然地估计流形<span class="math inline">\(\mathcal{M}\)</span>上的状态，从而避免了<code>renormalization</code>。</p><h3 id="传播">1）传播</h3><p>假设最优状态估计在融合完最后一帧（如<span class="math inline">\(k-1\)</span>帧）激光扫描后的状态为<span class="math inline">\(\overline{\mathbf{x}}_{k-1}\)</span>，且协方差矩阵为<span class="math inline">\(\overline{\mathbf{P}}_{k-1}\)</span>，前向传播是在IMU测量到达时进行的，更具体地说，通过将过程噪声<span class="math inline">\(\mathbf{w}_i\)</span>设置为零，状态和协方差将按照状态转移模型进行传播：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fast-lio2-fast-direct-lidar-inertial-odometry&quot;&gt;FAST-LIO2: Fast Direct LiDAR-inertial Odometry&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.nsloop.co
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>Camera与单线激光标定</title>
    <link href="http://yoursite.com/2021/09/04/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/Camera%E4%B8%8E%E5%8D%95%E7%BA%BF%E6%BF%80%E5%85%89%E6%A0%87%E5%AE%9A/"/>
    <id>http://yoursite.com/2021/09/04/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/Camera%E4%B8%8E%E5%8D%95%E7%BA%BF%E6%BF%80%E5%85%89%E6%A0%87%E5%AE%9A/</id>
    <published>2021-09-04T08:44:05.000Z</published>
    <updated>2022-06-26T21:28:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="camera-单线激光标定">Camera-单线激光标定</h1><blockquote><p>本文来源于 <a href="https://zhuanlan.zhihu.com/p/137501892" target="_blank" rel="noopener">《标定系列三 | 实践之Camera-Lidar标定》</a></p></blockquote><h2 id="前言"><strong>1. 前言</strong></h2><p>从理论上看，相机和激光之间外参数的标定原理非常简单，但在实际标定过程中，特别是一个初学者采集数据进行标定时，却发现标定结果非常不理想。如何采集有效的标定数据（何种运动轨迹，如何晃动标定板）对于激光相机标定而言非常重要。</p><p>读完本文，你会发现原来<strong>采集数据时标定板和传感器之间只做纯粹的平移运动是没有意义的</strong>。本文也对相机激光标定的一些基础知识和小细节进行讨论，主要贡献点有三：</p><ol type="1"><li>从理论开始对激光（单线、多线都适用）和相机外参数的标定进行简要推导（公式多但简单），然后给出一些可以提升标定精度的改进建议。</li><li>给出一个简单的开源代码对上述标定原理进行实践。</li><li>提供一个仿真程序，可以直观感受标定数据对系统可观性的影响。</li></ol><h2 id="理论">2.理论</h2><p>通常，标定激光和相机之间的外参数有两类方法：一类是利用 3D-3D 的约束，即利用激光测量的三维激光点 (3D) 和相机测量的标定板三维坐标 (3D) 两者来构建约束；另一类是利用 3D-2D 的约束，即利用激光测量的三维激光点 (3D) 和图像二维特征（2D、点特征、线段特征）来构建约束。</p><p>本文主要讲解利用 3D-3D 约束来进行外参数标定的方法，而 3D-2D 这一方法和 PnP 或 PnL 问题类似，这里不做展开。另外，标定过程的通常做法是先利用少量观测求解外参数的初始值，然后利用多帧数据的约束进行最小二乘优化对初始值进行 refine。接下来，将按照这个逻辑对标定算法进行讲解并推荐一些改进的算法。</p><h3 id="基于平面约束的相机激光标定算法"><strong>2.1 基于平面约束的相机激光标定算法</strong></h3><p>如下图所示，相机可以通过标定板平面的二维码或棋盘格来计算标定板平面在相机坐标系下的表示。同时，激光发出的光束落在标定板平面上（图中红点），利用激光点在激光坐标系下的坐标和平面方程在相机坐标系下的坐标，构建点在平面上的约束从而求解外参数。</p><p><img src="https://s1.nsloop.com:58443/images/2021/09/04/20210904170031.png"></p><p><strong>2.1.1 平面约束</strong></p><p>假设标定板平面在相机坐标系<span class="math inline">\(c\)</span>中的参数为<span class="math inline">\(\pi^{c}=\left[\mathrm{n}^{c}, d\right] \in \mathbb{R}^{4}\)</span>，其中<span class="math inline">\(\mathrm{n}^{c} \in \mathbb{R}^{3}\)</span>是平面法向量，<span class="math inline">\(d\)</span>是相机坐标系原点到平面的距离。</p><p>假设平面上的一个三维空间点在相机坐标系的坐标为<span class="math inline">\(\mathbf{P}^{c} \in \mathbb{R}^{3}\)</span>，那么该点满足如下约束方程：</p><p><span class="math display">\[\mathbf{n}^{c \top} \mathbf{P}^{c}+d=0\]</span></p><p>假设从激光雷达坐标系<span class="math inline">\(l\)</span>到相机坐标系<span class="math inline">\(c\)</span>的旋转和平移表示为：<span class="math inline">\(\mathbf{R}_{c l}, \mathbf{t}_{c l}\)</span>，一旦知道激光坐标系中的某个激光点<span class="math inline">\(\mathbf{P}^{l}\)</span>落在标定板上，则通过点在平面上的约束可以构建关于外参的方程（1）：</p><p><span class="math display">\[\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}^{l}+\mathbf{t}_{c l}\right)+d^{c}=0\]</span></p><p>上述方程能够提供一个约束，通过多个这样的约束就能求解外参数。求解时，一个直观的想法是利用 g2o 或者 ceres 等优化工具构建非线性最小二乘进行优化求解。但是对于非线性最小二乘问题，需要知道外参数的一个初始值，如果初始值不准确，则有可能会优化到局部最小值。因此，一个合理的求解流程应该是闭式解提供初始值，对该初始值利用多帧数据进行优化，得到更准确的标定结果。</p><p>虽然平面约束对于 2D 激光和 3D 激光而言是一样的，但 2D 激光和 3D 激光闭式求解外参数的方式稍有不同。因为 3D 激光的激光点更多，从而可以直接计算激光点云的法向量，利用这个法向量简化外参数计算流程，下文将详述。接下来，介绍 2D 激光和相机外参数的求解。</p><h3 id="d-激光和相机外参数初始值求解"><strong>2.1.2 2D 激光和相机外参数初始值求解</strong></h3><p>这里主要参考 2004 年 Zhou 等人的论文【1】，该论文是比较早期的工作，求解思路清晰。论文中估计的参数为从相机坐标系到激光坐标系的变换矩阵<span class="math inline">\(\mathbf{R}_{c l},\mathbf{t}_{c l}\)</span>，因此，激光点从激光雷达坐标系到相机坐标系的变换如下：</p><p><span class="math display">\[\mathbf{P}^{c}=\mathbf{R}_{l c}^{\top}\left(\mathbf{P}^{l}-\mathbf{t}_{l c}\right)\]</span></p><p>考虑到，激光为 2D 激光，激光束形成的平面不妨假设为 xy 平面，即<span class="math inline">\(z=0\)</span>，此时，激光点形如<span class="math inline">\(\mathbf{P}^{l}=[x, y, 0]^{\top}\)</span>，因此，上面的坐标变换可以写成更紧凑（矩阵、向量相乘）的形式：</p><p><span class="math display">\[\mathbf{P}^{c}=\mathbf{R}_{l c}^{\top}\left(\left[\begin{array}{l}x \\y \\0\end{array}\right]-\mathbf{t}_{l c}\right)=\underbrace{\mathbf{R}_{l c}^{\top}\left[\begin{array}{lll}1 &amp; 0 &amp; \\0 &amp; 1 &amp; -\mathbf{t}_{l c} \\0 &amp; 0 &amp;\end{array}\right]}_{\mathbf{H} }\left[\begin{array}{l}x \\y \\1\end{array}\right]=\mathbf{H} \overline{\mathbf{P} }^{l}\]</span></p><p>因此，将紧凑形式的坐标变换代入公式（1），得到：</p><p><span class="math display">\[\mathbf{n}^{c \top} \mathbf{H} \overline{\mathbf{P} }^{l}=-d^{c}\]</span></p><p>如果把 3 乘 3 的<span class="math inline">\(\mathbf{H}\)</span>矩阵当做新的未知量（ 9 个参数）进行估计，那上述约束就变成了一个<strong>线性最小二乘</strong>问题。</p><p>对于单线激光而言，一帧激光可以提供两个有效约束（直线上两个点在平面上即能确定直线在平面上），因此大于等于 5 帧激光（不同姿态）就能得到 10 个以上的约束，来直接求得 9 参数的<span class="math inline">\(\mathbf{H}\)</span>矩阵，然后还原出<span class="math inline">\(\mathbf{R}_{c l}, \mathbf{t}_{c l}\)</span>：</p><p><span class="math display">\[\begin{aligned}\mathbf{R}_{l c} &amp;=\left[\begin{array}{lll}\mathbf{h}_{1} &amp; \mathbf{h}_{2} &amp; \mathbf{h}_{1} \times \mathbf{h}_{2}\end{array}\right]^{\top} \\\mathbf{t}_{l c} &amp;=-\left[\begin{array}{lll}\mathbf{h}_{1} &amp; \mathbf{h}_{2} &amp; \mathbf{h}_{1} \times \mathbf{h}_{2}\end{array}\right]^{\top} \mathbf{h}_{3}\end{aligned}\]</span></p><p>简单推导：</p><p><img src="https://s1.nsloop.com:58443/images/2021/09/04/20210904180148.png"></p><p>但是，利用上述方式求得的旋转矩阵并不满足旋转矩阵的性质<span class="math inline">\(\mathbf{R}^{\top} \mathbf{R}=\mathbf{I}_{3 \times 3}\)</span>，假设期望的旋转矩阵为<span class="math inline">\(\hat{\mathbf{R} }_{l c}\)</span>，则可通过计算带约束的最小化F范数问题来估计出期望的旋转矩阵<span class="math inline">\(\hat{\mathbf{R} }_{l c}\)</span>：</p><p><span class="math display">\[\arg \min \left\|\hat{\mathbf{R} }_{l c}-\mathbf{R}_{l c}\right\|_{F}, \quad \text { subject to } \hat{\mathbf{R} }_{l c}^{\top} \hat{\mathbf{R} }_{l c}=\mathbf{I}\]</span></p><p>其意义为：找一个最接近<span class="math inline">\(\mathbf{R}_{c l}\)</span>又满足旋转矩阵质<span class="math inline">\(\mathbf{R}^{\top} \mathbf{R}=\mathbf{I}_{3 \times 3}\)</span>的矩阵<span class="math inline">\(\hat{\mathbf{R} }_{l c}\)</span>作为要求的旋转矩阵。此外，参考文献【2，3】给出了闭式解。</p><p>然而，文献【3】指出，上述方式求解的精度不高，实际应用过程并不推荐，正如多视角几何中估计本征矩阵<code>E</code>矩阵一样，也分为 DLT 算法（直接计算 8 个参数）和其他算法。</p><p>因此，在这里，优雅的方式应该是<strong>直接闭式求解 6 自由度的外参数</strong>，即旋转矩阵只用 3 个参数而不是上述方法中先估计 9 个参数。参考文献【4】给出了一种闭式求解 6 自由度外参数的方法，由于估计的参数为 6 ，因此需要的最少激光观测变成了 3 帧（每帧提供两个有效约束）。</p><h3 id="d-激光和相机外参数初始值求解-1"><strong>2.1.3 3D 激光和相机外参数初始值求解</strong></h3><p>跟 2D 激光的单线数据仅仅能提供一条线相比， 3D 激光的多线数据能提供点云面的信息。因此，同样是利用激光点在标定板平面上这个约束，3D 激光的约束可以比 2D 激光更多一个。</p><p>3D 的激光的点云平面和标定板平面重合，意味着单帧 3D激光提供的有效约束为 3 个（即点云平面上的3个点落在标定板平面上），从而可以用 3 个激光点来构建公式 (1) 的约束。这样两帧激光（6个约束）就能求解外参数了，求解方式可以利用前面 2D 激光所描述的方法（则同样存在 DLT 方法初始值不准的问题）。</p><p>这里给出了 3D 激光求解外参数的<strong>另一个思路</strong>，该方法中，求解的旋转矩阵能自然地满足旋转矩阵的性质：<span class="math inline">\(\mathbf{R}^{\top} \mathbf{R}=\mathrm{I}, \operatorname{det}(\mathrm{R})=1\)</span>。</p><p>将单帧激光的点云平面和标定板平面重合的约束进行简单置换，如下公式（2）：</p><p><span class="math display">\[\begin{aligned}\mathbf{R}_{c l} \mathbf{n}^{l} &amp;=\mathbf{n}^{c} \\\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}^{l}+\mathbf{t}_{c l}\right)+d^{c} &amp;=0\end{aligned}\]</span></p><p>公式 (2) 中的两个方程中，第一个方程能提供 2 个有效约束，第二个方程提供 1 个有效约束。虽然公式 (2) 和三个点落在平面上的物理意义一样，但是，公式 (2) 中<strong>第一个方程只和旋转矩阵有关</strong>，和平移无关。意味着可以先求解旋转矩阵，再线性求解平移向量，从而简化参数估计。</p><p>当激光帧数 N 大于等于 2 时，可以求解如下非线性最小二乘问题来计算旋转矩阵，如下公式（3）：</p><p><span class="math display">\[C=\sum_{i=1}^{N}\left\|\mathbf{n}_{i}^{c}-\mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right\|^{2}\]</span></p><p>这里基于参考文献【5】介绍上述问题的通用解法。将公式 (3) 进行展开有：</p><p><span class="math display">\[\begin{aligned}C &amp;=\sum_{i=1}^{N}\left(\mathbf{n}_{i}^{c}-\mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right)^{\top}\left(\mathbf{n}_{i}^{c}-\mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right) \\&amp;=\sum_{i=1}^{N}\left(\mathbf{n}_{i}^{c \top} \mathbf{n}_{i}^{c}+\mathbf{n}_{i}^{l \top} \mathbf{n}_{i}^{l}-2 \mathbf{n}_{i}^{c \top} \mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right)\end{aligned}\]</span></p><p>由于两个坐标系下的平面法向量<span class="math inline">\(n\)</span>已知，因此，最小化损失函数 C 转化成最大化如下目标：</p><p><span class="math display">\[\begin{aligned}F &amp;=\sum_{i=1}^{N} \mathbf{n}_{i}^{c \top} \mathbf{R}_{c l} \mathbf{n}_{i}^{l} \\&amp;=\operatorname{Trace}\left(\sum_{i=1}^{N} \mathbf{R}_{c l} \mathbf{n}_{i}^{l} \mathbf{n}_{i}^{c \top}\right)=\operatorname{Trace}(\mathbf{R} \mathbf{H})\end{aligned}\]</span></p><blockquote><p>此处应用了迹的性质 （跟ICP的推导一样） - 常数等于常数的迹 - 迹内的元素顺序可交换</p></blockquote><p>其中，这里引入了一个中间矩阵<span class="math inline">\(\mathbf{H}\)</span></p><p><span class="math display">\[\mathbf{H}=\sum_{i=1}^{N} \mathbf{n}_{i}^{l} \mathbf{n}_{i}^{c \top}\]</span></p><p>下面还要用到一个引理：</p><p>对于任意的正定矩阵<span class="math inline">\(\mathrm{AA}^{\top}\)</span>以及任意正交矩阵B，有下面的不等式成立：</p><p><span class="math display">\[\operatorname{Trace}\left(\mathbf{A} \mathbf{A}^{\top}\right) \geq \operatorname{Trace}\left(\mathbf{B A A}^{\top}\right)\]</span></p><p>接下来，回到之前的推导，我们对中间矩阵<span class="math inline">\(\mathbf{H}\)</span>进行SVD分解，有：</p><p><span class="math display">\[\mathbf{H}=\mathbf{U} \mathbf{\Lambda} \mathbf{V}^{\top}\]</span></p><p>其中，<span class="math inline">\(\mathbf{U}, \mathbf{V}\)</span>是3x3矩阵，<span class="math inline">\(\mathbf{\Lambda}\)</span> 是3x3的对角阵，其元素非负。</p><p>下面做一个假设，令<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>，那么上面的<span class="math inline">\(\operatorname{Trace}(\mathbf{R} \mathbf{H})\)</span>可以重写为：</p><p><span class="math display">\[\begin{aligned}\mathbf{R}_{c l} \mathbf{H} &amp;=\mathbf{V} \mathbf{U}^{\top} \mathbf{U} \mathbf{\Lambda} \mathbf{V}^{\top} \\&amp;=\mathbf{V} \mathbf{\Lambda} \mathbf{V}^{\top}\end{aligned}\]</span></p><p>此时，<span class="math inline">\(\mathbf{R}_{c l} \mathbf{H}\)</span>是对称的正定矩阵，这时候就要使用前面埋下的引理，来证明<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>即为解。</p><p>反证：如果<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>不是解，那么它和正确解之前存在一个增量旋转矩阵<span class="math inline">\(\mathbf{R}_{\Delta}\)</span>，即<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{R}_{\Delta}\mathbf{V} \mathbf{U}^{\top}\)</span> ，此时根据上面的引理，可得，这个解不会使得损失函数F的值取最大，因为：</p><p><span class="math display">\[\operatorname{Trace}\left(\mathbf{R}_{c l} \mathbf{H}\right) \geq \operatorname{Trace}\left(\mathbf{R}_{\Delta} \mathbf{R}_{c l} \mathbf{H}\right)\]</span></p><p>最后，还需要做旋转矩阵性质的判断，如果<span class="math inline">\(\operatorname{det}\left(\mathbf{V} \mathbf{U}^{\top}\right)=1\)</span>，则说明所求得的正交矩阵<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>是旋转矩阵。如果<span class="math inline">\(\operatorname{det}\left(\mathbf{V} \mathbf{U}^{\top}\right)=-1\)</span>，则说明这个正交矩阵是镜面反射矩阵，不是旋转矩阵。幸运的是，在实际应用中，采集的多帧不同姿态下的激光数据并不会出现镜面反射矩阵的情况。</p><p>在旋转矩阵已知的情况下，利用公式 (1) 就可以求解平移向量<span class="math inline">\(\mathbf{t}_{c l}\)</span>，这时候求解只涉及到平移，是个线性最小二乘问题<span class="math inline">\(\mathbf{A} \mathbf{t}_{c l}=\mathbf{b}\)</span>，可以使用闭式解求解。</p><p>最后，关于上面使用的引理<span class="math inline">\(\operatorname{Trace}\left(\mathbf{A} \mathbf{A}^{\top}\right) \geq \operatorname{Trace}\left(\mathbf{B A A}^{\top}\right)\)</span>，证明如下：</p><p>假设<span class="math inline">\(a_{i}\)</span>是矩阵<span class="math inline">\(\mathbf{A}\)</span>的第i列，则有：</p><p><span class="math display">\[\begin{aligned}\operatorname{Trace}\left(\mathbf{B A} \mathbf{A}^{\top}\right) &amp;=\operatorname{Trace}\left(\mathbf{A}^{\top} \mathbf{B} \mathbf{A}\right) \\&amp;=\sum_{i} \mathbf{a}_{i}^{\top}\left(\mathbf{B} \mathbf{a}_{i}\right)\end{aligned}\]</span></p><p>根据<code>Cauchy-Schwarz</code>不等式<span class="math inline">\(x y \leq \sqrt{x^{2} y^{2} }\)</span>，且矩阵B为正交矩阵，有：</p><p><span class="math display">\[\mathbf{a}_{i}^{\top}\left(\mathbf{B} \mathbf{a}_{i}\right) \leq \sqrt{\left(\mathbf{a}_{i}^{\top} \mathbf{a}_{i}\right)\left(\mathbf{a}_{i}^{\top} \mathbf{B}^{\top} \mathbf{B a}_{i}\right)}=\mathbf{a}_{i}^{\top} \mathbf{a}_{i}\]</span></p><p>因此，可证得：</p><p><span class="math display">\[\operatorname{Trace}\left(\mathbf{A} \mathbf{A}^{\top}\right)=\sum_{i} a_{i}^{\top} a_{i} \geq \operatorname{Trace}\left(\mathbf{B A} \mathbf{A}^{\top}\right)\]</span></p><h3 id="联合优化进行调优"><strong>2.1.4 联合优化进行调优</strong></h3><p>通过上述方式计算出外参数的初始值之后，再对采集的N组数据进行联合优化得到最优估计，假设第i帧激光有<span class="math inline">\(N_{i}\)</span>个激光点落在标定板上，同时第i帧激光时刻下对应的标定板平面方程在相机坐标系的表示为<span class="math inline">\(\left[\mathbf{n}_{i}^{c}, d_{i}^{c}\right]^{\top}\)</span>，则问题可以描述为：</p><p><span class="math display">\[\hat{\mathbf{R} }_{c l}, \hat{\mathbf{t} }_{c l}=\arg \min _{\mathbf{R}_{cl}, t_{cl} } \sum_{i=1}^{N} \frac{1}{N_{i} } \sum_{m=1}^{N_{i} }\left\|\mathbf{n}_{i}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}_{i m}^{l}+\mathbf{t}_{c l}\right)+d_{i}^{c}\right\|^{2}\]</span></p><p>优化过程中，对于旋转矩阵<span class="math inline">\(\mathbf{R}_{c l}\)</span>，可以使用 SO3 的参数化方式，也可以采用四元数的参数化方式。优化方法 (LM算法），雅克比的推导等知识点这里不再赘述，大家可以对照开源的代码自行推导验证雅克比。</p><h3 id="推论所有平行的平面提供的约束等价"><strong>2.2 推论：所有平行的平面提供的约束等价</strong></h3><p>前面求解过程中，是假设采集的数据足够有效，即采集了不同姿态下标定板和激光数据的数据。那么，如何摆放标定板来采集数据是有效的呢？这里将证明<strong>只平移标定板对标定没有意义</strong>，标定过程中只需要旋转标定板。推荐阅读参考文献【6】</p><p>平移标定板意味着不同时刻之间的标定板平面是平行的。假设有两个平行平面<span class="math inline">\(\pi_{1}, \pi_{2}\)</span>，它们在相机坐标系中的参数分别为<span class="math inline">\(\left[\mathbf{n}^{c}, d_{1}^{c}\right]^{\top}\)</span>和<span class="math inline">\(\left[\mathbf{n}^{c}, d_{2}^{c}\right]^{\top}\)</span>。另外，假设在激光坐标系下，激光测量了两个平面上任意的一个点<span class="math inline">\(\mathbf{P}_{1}^{l}, \mathbf{P}_{2}^{l}\)</span>，考虑点在平面上的约束有：</p><p><span class="math display">\[\begin{array}{l}\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}_{1}^{l}+\mathbf{t}_{c l}\right)+d_{1}^{c}=0 \\\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}_{2}^{l}+\mathbf{t}_{c l}\right)+d_{2}^{c}=0\end{array}\]</span></p><p>通过简单的变换，可以发现上面两个等式能够相互转换，即表示平行的平面只能提供相同的约束信息。</p><p>变换如下：首先将<span class="math inline">\(\mathbf{n}^{c \top} \mathbf{t}_{c l}\)</span>这部分从两个等式中移除，然后有：</p><p><span class="math display">\[\begin{aligned}&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l} \mathbf{P}_{1}^{l}+d_{1}^{c} \\=&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l}\left(\mathbf{P}_{2}^{l}+\mathbf{P}_{1}^{l}-\mathbf{P}_{2}^{l}\right)+d_{2}^{c}+d_{1}^{c}-d_{2}^{c} \\=&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l} \mathbf{P}_{2}^{l}+d_{2}^{c}+\left(\mathbf{n}^{c \top} \mathbf{R}_{c l}\left(\mathbf{P}_{1}^{l}-\mathbf{P}_{2}^{l}\right)+d_{1}^{c}-d_{2}^{c}\right) \\=&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l} \mathbf{P}_{2}^{l}+d_{2}^{c}\end{aligned}\]</span></p><p>其中，<span class="math inline">\(\mathbf{n}^{c \top} \mathbf{R}_{c l}\left(\mathbf{P}_{1}^{l}-\mathbf{P}_{2}^{l}\right)\)</span>和<span class="math inline">\(d_{1}^{c}-d_{2}^{c}\)</span>表示两个平面之间的距离，式中，它们两个方向符号相反可以抵消。</p><p>由此证明：所有平行的平面物体提供的约束是等价的。这意味着：采集数据用于标定时，如果只平移标定板来采集数据，那就做了很多无用功。比如不断平移标定板采集了 100 个时刻的数据，那这 100 次的数据仅相当于 1 次有效数据。所以，采集标定数据时，<strong>只要不断旋转标定板采集数据就足够了</strong>，而不是不断平移。</p><h3 id="拓展标定板的边界约束"><strong>2.3 拓展：标定板的边界约束</strong></h3><p>上述标定过程只利用了平面标定板的平面约束来进行标定，也清楚了这个约束对于单次测量而言，其提供的有效约束 (2个或者3个) 不足以完成单帧标定，而采集多帧数据又容易由于采集轨迹不充分，导致外参在某些维度标定不好。</p><p>因此，如果标定板一次就能够提供 6 个以上的约束，那意味着单帧数据就能完成标定，并且多约束的加入能够提升标定精度。这方面的工作有两类方式，一种是改变标定板的形状，比如两个垂直的标定板，或者三个垂直的标定板，V 形标定板等。</p><p>另一种是充分利用其他约束，比如激光点落在标定板边缘直线上（标定板边缘的直线方程以及哪个激光点落在上面是可以计算出来的）。这里不作详细的推导和解释，仅推荐两篇2018年的经典论文，见参考文献【6】和参考文献【7】。论文【6】是利用标定板的边缘直线约束来标定3D激光，论文【7】对2D激光的多种标定板的有效约束进行了充分讨论。</p><h2 id="实践"><strong>3. 实践</strong></h2><p>根据上述的理论推导，本文完成了一个简单的 2D 激光和相机之间外参数的标定代码：</p><p><a href="https://github.com/MegviiRobot/CamLaserCalibraTool" target="_blank" rel="noopener">https://github.com/MegviiRobot/CamLaserCalibraTool</a></p><h3 id="代码梳理和上手操作"><strong>3.1 代码梳理和上手操作</strong></h3><p>关于数据的采集，标定板的制作，标定的流程以及标定结果等上手操作细节在项目的 README.md 里已经进行了详细说明，这里对系统中的几个主要文件进行简单梳理，帮助大家更快熟悉代码。</p><p>大家关注的外参数的代码大多都在 src 文件夹里的 LaserCamCalCeres.cpp，其中：</p><ul><li>CamLaserCalClosedSolution() ：闭式求解外参数初始值。</li><li>CamLaserCalibration() ：采用非线性最小二乘对初始值进行优化。</li></ul><p>另外，比较重要的为 main 文件夹中的三个主程序：</p><ul><li>kalibratag_detector_node.cpp : 相机利用二维码或者棋盘格估计标定板平面和相机之间的姿态。</li><li>calibr_offline.cpp : 处理激光数据（获取在标定板上的激光点云），读取事先处理好的相机姿态，利用这些数据构建平面约束进行外参数求解。</li><li>calibr_simulation.cpp : 生成仿真数据，验证系统参数是否可观。后面小结讲着重说明。</li></ul><h3 id="仿真代码的特别说明"><strong>3.2 仿真代码的特别说明</strong></h3><p>仿真代码可以帮助大家理解采集数据的有效性对标定结果的影响，对理解系统辨识（系统参数是否可观）非常有意义，因此在这里进行特别说明。</p><p>代码中的 GenerateSimData() 函数主要用来生成仿真数据，原理为利用激光射线和标定板平面相交，从而得到激光点在标定板上的三维坐标，通过不断变换标定板的姿态，得到多组有效数据（激光点云+标定板在相机中的姿态）用来完成标定。</p><p>其中标定板和相机之间的姿态保存在变量<span class="math inline">\(\mathbf{R}_{c a}, \mathbf{t}_{c a}\)</span>，代码中采用利用随机数的方式来生成标定板姿态，并可以通过对标定板参数进行不同的设置来对系统的可观性进行验证。</p><h3 id="系统可观性的判断"><strong>3.2.1 系统可观性的判断</strong></h3><p>熟悉 VIO(visual inertial odometry) 系统也会熟知可观性问题。实际上，系统的可观性在线代控制理论中有专门论述，涉及到可观性矩阵等知识点，但是那套从线性系统出发的理论可能容易让大家迷惑。这里会从大家熟知的非线性优化求解的角度来简单描述可观性问题。</p><p>关于状态量参数是否可观的一个简单解释是：如果改变状态向量<span class="math inline">\(\mathbf{X}\)</span>的值，系统对应的观测函数<span class="math inline">\(\mathrm{f}(\mathrm{x})\)</span>不发生变化，即<span class="math inline">\(\mathbf{f}(\mathbf{x})=\mathbf{f}\left(\mathbf{x}^{\prime}\right)\)</span>，则说明系统在某些维度上不可观。直观的理解就是，系统有无数个解从而使得状态量无法辨识。在非线性最小二乘问题中，通过构建误差函数利用高斯牛顿算法进行优化求解时，通常需要求解如下 normal equation：</p><p><span class="math display">\[\mathbf{J}^{\top} \mathbf{J} \delta \mathbf{x}=-\mathbf{J}^{\top} \mathbf{r} \Rightarrow \mathbf{H} \delta \mathbf{x}=\mathbf{b}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{J}\)</span>是残差对状态量求导的雅克比矩阵</li><li><span class="math inline">\(\mathbf{r}\)</span>是利用约束构建的残差</li></ul><p>如果系统求解过程中<span class="math inline">\(\mathbf{H}\)</span>矩阵不满秩，假设其零空间为<span class="math inline">\(\mathbf{N}\)</span>，有<span class="math inline">\(\mathbf{H} \mathbf{N}=0\)</span>，意味着求解存在多个解：</p><p><span class="math display">\[\begin{array}{r}\mathbf{H} \delta \mathbf{x}=\mathbf{b} \\\mathbf{H} \delta \mathbf{x}+\mathbf{H N}=\mathbf{b}\end{array}\]</span></p><p>即系统有无穷多个解<span class="math inline">\(\delta \mathbf{x}+\lambda \mathbf{N}\)</span>使得残差最小，零空间<span class="math inline">\(\mathbf{N}\)</span>的基底对应不可观的方向。所以可以通过判断<span class="math inline">\(\mathbf{H}\)</span>矩阵的秩来判断系统的可观性，比如<span class="math inline">\(\mathbf{H}\)</span>矩阵为 6 维的方阵，而秩等于 4，则意味着零空间维度为 2 ，有两个不可观的方向，<strong>这个结论在后面将用来指导采集数据</strong>。</p><p>那么，如果你熟悉 VIO，自然要问既然线性系统中的可观性矩阵和优化方法中的 H 矩阵都能够判断系统可观性？这两者之间存在什么样的联系呢？这里不再展开推导，推荐阅读参考文献【8】，读完第二章你将豁然开朗。</p><h3 id="利用仿真代码验证平行平面提供的约束等价"><strong>3.2.2 利用仿真代码验证平行平面提供的约束等价</strong></h3><p>为了生成平行的标定板平面，只需要把代码中的<span class="math inline">\(\mathbf{R}_{c a}\)</span>设置成常数，如单位矩阵。这时，标定板只有平移，意味着生成的所有数据里标定板平行。编译并运行仿真程序后会有如下信息：</p><p><img src="https://s1.nsloop.com:58443/images/2021/09/04/20210904212443.png"></p><p>由于估计的外参数为 6 维，其中 H 矩阵的奇异值有 4 个接近 0，意味着只产生了两个维度的有效信息。这和之前的推论结论一致，即多帧数据中平行的标定板产生的约束等效于一帧，而单线激光落在平面上的有效约束为 2。</p><p>另外利用数值的方法计算了 H 矩阵的零空间基底，从图中可以看到最右边两列的两个基底，它们是对应平移 x,y 不可观，而左边两列对应的的两个基底为旋转矩阵角度的两个维度不可观。不可观基底对应的方向表示外参数对应的维度无法求出正确解。</p><h3 id="利用仿真代码指导采集数据如何充分旋转标定板"><strong>3.2.2 利用仿真代码指导采集数据：如何充分旋转标定板</strong></h3><p>既然采集数据时只平移标定板不行，那是否意味着简单旋转一下标定板就可以了呢？比如标定板只绕着 y 轴旋转。这里可通过设置不同的旋转矩阵去验证 H 矩阵是否有零空间。通过简单修改代码（注释或反注释设置旋转矩阵的那几行代码），运行后会发现：标定时需要充分旋转 x 和 y 两个轴，标定过程中标定板只旋转一个轴一样会存在零空间基底。</p><p>这意味着拿着标定板旋转时，需要充分旋转 roll 和 pitch。更直白一点，假设在长方形的标定板中心画了个十字线，那请绕着十字线的两个轴充分旋转，比如绕着竖轴旋转，然后还要绕着横轴旋转。</p><h2 id="结语"><strong>4. 结语</strong></h2><p>至此，相机和激光标定从理论到实践就基本完成了。本文抛砖引玉，介绍了比较基础的标定原理，开源了相应的代码（包括求解代码、仿真代码、debug 验证代码），大家可以进一步改进和拓展（支持边界约束、V 形标定板等）。</p><p>最后，这种标定相机和激光外参数的方法估计可以有效避开两个传感器之间的时间延时问题，因为两个传感器都是静止的，晃动标定板时每摆好一个 pose 稍微静止几十毫秒就能避免传感器延时的问题。</p><h2 id="参考文献"><strong>5. 参考文献</strong></h2><ol type="1"><li>Qilong Zhang, <a href="https://link.zhihu.com/?target=http%3A//citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.80.7118%26rep%3Drep1%26type%3Dpdf">Extrinsic Calibration of a Camera and Laser Range Finder (improves camera calibration)</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iri.upc.edu/files/scidoc/2288-On-Closed-Form-Formulas-for-the-3D-Nearest-Rotation-Matrix-Problem.pdf">On Closed-Form Formulas for the 3D Nearest Rotation Matrix Problem</a>,</li><li><a href="https://link.zhihu.com/?target=http%3A//people.csail.mit.edu/bkph/articles/Nearest_Orthonormal_Matrix.pdf">Finding the Nearest Orthonormal Matrix</a>,</li><li><a href="https://link.zhihu.com/?target=https%3A//home.deec.uc.pt/~jpbar/Publication_Source/pami2012.pdf">A Minimal Solution for the Extrinsic Calibration of a Camera and a Laser-Rangefinde</a>r</li><li>K.S. Arun, <a href="https://link.zhihu.com/?target=http%3A//post.queensu.ca/~sdb2/PAPERS/PAMI-3DLS-1987.pdf">Least Squares Fitting of Two 3-d Point Set</a>,</li><li><a href="https://link.zhihu.com/?target=https%3A//www.cs.cmu.edu/~kaess/pub/Zhou18iros.pdf">Automatic Extrinsic Calibration of a Camera and a 3D LiDAR using Line and Plane Correspondences</a></li><li>Wenbo Dong, <a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1603.04132.pdf">A Novel Method for the Extrinsic Calibration of a 2D Laser Rangefinder and a Camera</a></li><li>B.T. Hinson,<a href="https://link.zhihu.com/?target=https%3A//digital.lib.washington.edu/researchworks/handle/1773/27387">Observability-based guidance and sensor placement</a>,</li></ol><h2 id="作者简介"><strong>作者简介</strong></h2><p>贺一家，中科院自动化所博士毕业，目前为旷视研究院 SLAM 组研究员，研究方向为基于多传感器融合的 SLAM，结构化特征 SLAM 等。乐于分享和开源，对机器人、AR 等领域有浓厚兴趣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;camera-单线激光标定&quot;&gt;Camera-单线激光标定&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文来源于 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/137501892&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="传感器标定" scheme="http://yoursite.com/categories/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
</feed>
