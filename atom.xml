<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EpsilonJohn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-11T13:35:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EpsilonJohn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Zotero导入CNKI文献</title>
    <link href="http://yoursite.com/2021/02/11/Zotero%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2021/02/11/Zotero%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</id>
    <published>2021-02-11T09:05:33.000Z</published>
    <updated>2021-02-11T13:35:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="why-zotero">Why Zotero?</h1><ul><li>可以一键导入并下载CNKI文献(pdf)</li><li>可以抓取硕士论文目录</li><li>与Word兼容性良好(安装插件即可实现gb7714等参考文献引用格式)</li><li>……</li></ul><h1 id="zotero以及浏览器插件安装">Zotero以及浏览器插件安装</h1><p>参考官网即可： https://www.zotero.org/</p><p>下载地址： https://www.zotero.org/download/</p><h1 id="cnki中文插件安装">CNKI中文插件安装</h1><p>参考： https://github.com/l0o0/translators_CN</p><h2 id="zotero-translator_cn-安装">Zotero translator_CN 安装</h2><p><strong>1 下载网页翻译器(web translator)文件</strong></p><p><img src="https://s1.ax1x.com/2020/08/19/dlKNRK.png"></p><p><strong>2 解压下载的压缩包，找到</strong>translators<strong>目录，将目录中的文件复制到 Zotero 的 translators 目录</strong></p><p><img src="https://s1.ax1x.com/2020/09/07/wnDwlV.jpg"><br><img src="https://s1.ax1x.com/2020/08/19/dlM36S.png"></p><blockquote><p>如果是macos系统，Zotero的目录就在用户主目录下</p></blockquote><p><strong>3 更新 translator 信息，Firefox 和 Chrome 浏览器操作类似。下面以 Firefox 为例</strong><br><img src="https://s1.ax1x.com/2020/08/19/dlQgKS.gif"></p><p>Chrome 浏览器按照下面信息找到更新按钮</p><p><img src="https://s1.ax1x.com/2020/08/19/dlKUxO.png"></p><p><strong>更新时请多点几下，根据我的经验，Chrome 浏览器更新比较快，Firefox 会比较慢</strong></p><p>如果你使用学校的 VPN 来登录知网，可以参考这个<a href="https://zhuanlan.zhihu.com/p/111857132" target="_blank" rel="noopener">链接</a>进行设置。设置过程不复杂，就是用特殊符号把网址中的字符替换掉。</p><h2 id="如何在zotero-connector-中添加中文姓名处理以及保留知网caj格式文件的设置"><span id="jump">🍇 如何在Zotero Connector 中添加中文姓名处理以及保留知网CAJ格式文件的设置</span></h2><p>需要特别注意的是，这里在 Zotero Connector 中添加的参数，只是方便控制的网页翻译器的数据抓取行为，限本页面列出的一些翻译器中起作用，并不影响其他翻译器和Zotero的其他功能。 添加的参数有：</p><ul><li><code>translators.zhnamesplit</code>，默认为true，抓取过程会拆分姓和名，如果想全并姓名，请设置为false</li><li><code>translators.CNKIPDF</code>,默认为true，~<del>下载知网上文章的PDF文件，如果想要下载学位论文的CAJ格式，请设置为false</del>~ (这个方法有点问题，建议直接下载pdf版本即可，后面会有利用插件添加硕士论文目录的部分)</li></ul><p>设置方法请参考下面：</p><p><img src="https://s1.ax1x.com/2020/08/19/dl1AyT.gif"></p><p>为防止设置错误，可以把参数名复制过去。设置完成后，请刷新网页，再重新抓取。如果你参数名写错了也没事，不会有什么问题，放着就好。</p><h2 id="使用方法">使用方法</h2><p><strong>1 打开<a href="https://www.cnki.net/" target="_blank" rel="noopener">知网</a></strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211211932.png"></p><p><strong>2 点击插件，选择需要导入的文献</strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212044.png"></p><p><strong>3 确认即可导入Zotero</strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212218.png"></p><p><strong>4 双击即可打开对应的pdf</strong></p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212359.png"></p><blockquote><p>由于直接下载的硕士论文pdf版本没有目录，因此下面通过安装插件的方法来解决这个问题</p></blockquote><h1 id="jasminum---茉莉花插件安装使用">Jasminum - 茉莉花插件安装使用</h1><p>插件官方地址：https://github.com/l0o0/jasminum</p><h2 id="安装步骤">安装步骤</h2><p><strong>1 Jasminum插件</strong></p><p>下载最新的<a href="https://github.com/l0o0/jasminum/releases/latest" target="_blank" rel="noopener">xpi</a>文件进行安装，安装方法：打开 Zotero -&gt; 工具 -&gt; 插件 -&gt; 右上小齿轮图标 -&gt; Install Add-on From File ... -&gt; 选择下载好的xpi文件。</p><p><strong>2 PDFtk server插件</strong></p><p>PDFtk server，该书签添加工具有 Windows， Linux 和 Mac，请根据自己的系统下载对应的版本进行安装，并在选项中设置好对应的目录。<a href="https://www.pdflabs.com/tools/pdftk-server/" target="_blank" rel="noopener">PDFtk server 下载链接</a></p><blockquote><p>官网：https://www.pdflabs.com/tools/pdftk-server/<br><font color="red">After installation, open a Terminal, type pdftk and press Return. Pdftk will respond by displaying brief usage information(注意！安装后请试试这一步，出现使用说明说明安装成功)</font>. Access pdftk documenation by running man pdftk.</p></blockquote><p><strong>Mac 用户</strong>（感谢<span class="citation" data-cites="GuokaiLiu">[@GuokaiLiu]</span>(https://github.com/GuokaiLiu)同学在 <a href="https://github.com/l0o0/jasminum/issues/7#issuecomment-706448964" target="_blank" rel="noopener">issue</a> 中的补充） macos(10.15)用户： 下载：https://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/pdftk_server-2.02-mac_osx-10.11-setup.pkg</p><blockquote><p>关于Mac系统的插件路径配置（我没有进行这一步，有需要的再看）<br>配置方法： 打开Zotero-&gt;首选项-&gt;茉莉花<br><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211212937.png"> 路径：<code>/opt/pdflabs/pdftk/</code>. （该路径默认对外隐藏无法选取） 选择路径的技巧：<code>shift+command+G</code>: 输入：<code>/opt/pdflabs/pdftk/</code>，选择<code>bin</code>确认</p></blockquote><h2 id="使用方法同上">使用方法（同上）</h2><p>稍微等一会，插件就抓取到目录了</p><p><img src="https://chevereto.epsilonjohn.club/images/2021/02/11/20210211213244.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;why-zotero&quot;&gt;Why Zotero?&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;可以一键导入并下载CNKI文献(pdf)&lt;/li&gt;
&lt;li&gt;可以抓取硕士论文目录&lt;/li&gt;
&lt;li&gt;与Word兼容性良好(安装插件即可实现gb7714等参考文献引用格式)&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Eigen-Operation</title>
    <link href="http://yoursite.com/2021/02/01/Eigen%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2021/02/01/Eigen%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2021-02-01T03:05:32.000Z</published>
    <updated>2021-02-02T02:01:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="eigen常用操作eigen-cheatsheet">Eigen常用操作|Eigen Cheatsheet</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; A simple quickref for Eigen. Add anything that&#39;s missing.</span><br><span class="line">&#x2F;&#x2F; Main author: Keir Mierle</span><br></pre></td></tr></table></figure><h2 id="包含头文件">1. 包含头文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="矩阵向量声明">2. 矩阵、向量声明</h2><h3 id="矩阵声明">2.1 矩阵声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>&gt; A;               <span class="comment">// Fixed rows and cols. Same as Matrix3d.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, Dynamic&gt; B;         <span class="comment">// Fixed rows, dynamic cols.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, Dynamic, Dynamic&gt; C;   <span class="comment">// Full dynamic. Same as MatrixXd.</span></span><br><span class="line">Matrix&lt;<span class="keyword">double</span>, <span class="number">3</span>, <span class="number">3</span>, RowMajor&gt; E;     <span class="comment">// Row major; default is column-major.</span></span><br><span class="line">Matrix3f P, Q, R;                     <span class="comment">// 3x3 float matrix.</span></span><br></pre></td></tr></table></figure><h3 id="向量声明">2.2 向量声明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector3f x, y, z;                     <span class="comment">// 3x1 float matrix.</span></span><br><span class="line">RowVector3f a, b, c;                  <span class="comment">// 1x3 float matrix.</span></span><br><span class="line">VectorXd v;                           <span class="comment">// Dynamic column vector of doubles</span></span><br><span class="line"><span class="keyword">double</span> s;</span><br></pre></td></tr></table></figure><h2 id="基础操作">3. 基础操作</h2><h3 id="计算大小">3.1 计算大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Basic usage</span></span><br><span class="line"><span class="comment">// Eigen          // Matlab           // comments</span></span><br><span class="line">x.<span class="built_in">size</span>()          <span class="comment">// length(x)        // vector size</span></span><br><span class="line">C.rows()          <span class="comment">// size(C,1)        // number of rows</span></span><br><span class="line">C.cols()          <span class="comment">// size(C,2)        // number of columns</span></span><br></pre></td></tr></table></figure><h3 id="访问元素">3.2 访问元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x(i)              <span class="comment">// x(i+1)           // Matlab is 1-based</span></span><br><span class="line">C(i,j)            <span class="comment">// C(i+1,j+1)       //</span></span><br></pre></td></tr></table></figure><h3 id="改变大小">3.3 改变大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.resize(<span class="number">4</span>, <span class="number">4</span>);   <span class="comment">// Runtime error if assertions are on.</span></span><br><span class="line">B.resize(<span class="number">4</span>, <span class="number">9</span>);   <span class="comment">// Runtime error if assertions are on.</span></span><br><span class="line">A.resize(<span class="number">3</span>, <span class="number">3</span>);   <span class="comment">// Ok; size didn't change.</span></span><br><span class="line">B.resize(<span class="number">3</span>, <span class="number">9</span>);   <span class="comment">// Ok; only dynamic cols changed.</span></span><br></pre></td></tr></table></figure><h3 id="矩阵赋值">3.4 矩阵赋值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,     <span class="comment">// Initialize A. The elements can also be</span></span><br><span class="line">     <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,     <span class="comment">// matrices, which are stacked along cols</span></span><br><span class="line">     <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>;     <span class="comment">// and then the rows are stacked.</span></span><br><span class="line">B &lt;&lt; A, A, A;     <span class="comment">// B is three horizontally stacked A's.</span></span><br><span class="line">A.<span class="built_in">fill</span>(<span class="number">10</span>);       <span class="comment">// Fill A with all 10's.</span></span><br></pre></td></tr></table></figure><h2 id="特殊矩阵">4. 特殊矩阵</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eigen                                    // Matlab</span></span><br><span class="line">MatrixXd::Identity(rows,cols)               <span class="comment">// eye(rows,cols)</span></span><br><span class="line">C.setIdentity(rows,cols)                    <span class="comment">// C = eye(rows,cols)</span></span><br><span class="line">MatrixXd::Zero(rows,cols)                   <span class="comment">// zeros(rows,cols)</span></span><br><span class="line">C.setZero(rows,cols)                        <span class="comment">// C = zeros(rows,cols)</span></span><br><span class="line">MatrixXd::Ones(rows,cols)                   <span class="comment">// ones(rows,cols)</span></span><br><span class="line">C.setOnes(rows,cols)                        <span class="comment">// C = ones(rows,cols)</span></span><br><span class="line">MatrixXd::Random(rows,cols)                 <span class="comment">// rand(rows,cols)*2-1            // MatrixXd::Random returns uniform random numbers in (-1, 1).</span></span><br><span class="line">C.setRandom(rows,cols)                      <span class="comment">// C = rand(rows,cols)*2-1</span></span><br><span class="line">VectorXd::LinSpaced(<span class="built_in">size</span>,low,high)          <span class="comment">// linspace(low,high,size)'</span></span><br><span class="line">v.setLinSpaced(<span class="built_in">size</span>,low,high)               <span class="comment">// v = linspace(low,high,size)'</span></span><br><span class="line">VectorXi::LinSpaced(((hi-low)/<span class="built_in">step</span>)+<span class="number">1</span>,      <span class="comment">// low:step:hi</span></span><br><span class="line">                    low,low+<span class="built_in">step</span>*(<span class="built_in">size</span><span class="number">-1</span>))  <span class="comment">//</span></span><br></pre></td></tr></table></figure><h2 id="矩阵元素提取与替换">5. 矩阵元素提取与替换</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix slicing and blocks. All expressions listed here are read/write.</span></span><br><span class="line"><span class="comment">// Templated size versions are faster. Note that Matlab is 1-based (a size N</span></span><br><span class="line"><span class="comment">// vector is x(1)...x(N)).</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                  PLEASE HELP US IMPROVING THIS SECTION                     */</span></span><br><span class="line"><span class="comment">/* Eigen 3.4 supports a much improved API for sub-matrices, including,        */</span></span><br><span class="line"><span class="comment">/* slicing and indexing from arrays:                                          */</span></span><br><span class="line"><span class="comment">/* http://eigen.tuxfamily.org/dox-devel/group__TutorialSlicingIndexing.html   */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">x.head(n)                          <span class="comment">// x(1:n)</span></span><br><span class="line">x.head&lt;n&gt;()                        <span class="comment">// x(1:n)</span></span><br><span class="line">x.tail(n)                          <span class="comment">// x(end - n + 1: end)</span></span><br><span class="line">x.tail&lt;n&gt;()                        <span class="comment">// x(end - n + 1: end)</span></span><br><span class="line">x.segment(i, n)                    <span class="comment">// x(i+1 : i+n)</span></span><br><span class="line">x.segment&lt;n&gt;(i)                    <span class="comment">// x(i+1 : i+n)</span></span><br><span class="line">P.block(i, j, rows, cols)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></span><br><span class="line">P.block&lt;rows, cols&gt;(i, j)          <span class="comment">// P(i+1 : i+rows, j+1 : j+cols)</span></span><br><span class="line">P.row(i)                           <span class="comment">// P(i+1, :)</span></span><br><span class="line">P.col(j)                           <span class="comment">// P(:, j+1)</span></span><br><span class="line">P.leftCols&lt;cols&gt;()                 <span class="comment">// P(:, 1:cols)</span></span><br><span class="line">P.leftCols(cols)                   <span class="comment">// P(:, 1:cols)</span></span><br><span class="line">P.middleCols&lt;cols&gt;(j)              <span class="comment">// P(:, j+1:j+cols)</span></span><br><span class="line">P.middleCols(j, cols)              <span class="comment">// P(:, j+1:j+cols)</span></span><br><span class="line">P.rightCols&lt;cols&gt;()                <span class="comment">// P(:, end-cols+1:end)</span></span><br><span class="line">P.rightCols(cols)                  <span class="comment">// P(:, end-cols+1:end)</span></span><br><span class="line">P.topRows&lt;rows&gt;()                  <span class="comment">// P(1:rows, :)</span></span><br><span class="line">P.topRows(rows)                    <span class="comment">// P(1:rows, :)</span></span><br><span class="line">P.middleRows&lt;rows&gt;(i)              <span class="comment">// P(i+1:i+rows, :)</span></span><br><span class="line">P.middleRows(i, rows)              <span class="comment">// P(i+1:i+rows, :)</span></span><br><span class="line">P.bottomRows&lt;rows&gt;()               <span class="comment">// P(end-rows+1:end, :)</span></span><br><span class="line">P.bottomRows(rows)                 <span class="comment">// P(end-rows+1:end, :)</span></span><br><span class="line">P.topLeftCorner(rows, cols)        <span class="comment">// P(1:rows, 1:cols)</span></span><br><span class="line">P.topRightCorner(rows, cols)       <span class="comment">// P(1:rows, end-cols+1:end)</span></span><br><span class="line">P.bottomLeftCorner(rows, cols)     <span class="comment">// P(end-rows+1:end, 1:cols)</span></span><br><span class="line">P.bottomRightCorner(rows, cols)    <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></span><br><span class="line">P.topLeftCorner&lt;rows,cols&gt;()       <span class="comment">// P(1:rows, 1:cols)</span></span><br><span class="line">P.topRightCorner&lt;rows,cols&gt;()      <span class="comment">// P(1:rows, end-cols+1:end)</span></span><br><span class="line">P.bottomLeftCorner&lt;rows,cols&gt;()    <span class="comment">// P(end-rows+1:end, 1:cols)</span></span><br><span class="line">P.bottomRightCorner&lt;rows,cols&gt;()   <span class="comment">// P(end-rows+1:end, end-cols+1:end)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Of particular note is Eigen's swap function which is highly optimized.</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.row(i) = P.col(j);               <span class="comment">// R(i, :) = P(:, j)</span></span><br><span class="line">R.col(j1).swap(mat1.col(j2));      <span class="comment">// R(:, [j1 j2]) = R(:, [j2, j1])</span></span><br></pre></td></tr></table></figure><h2 id="矩阵操作">6. 矩阵操作</h2><h3 id="转置与旋转">6.1 转置与旋转</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Views, transpose, etc;</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">/*                  PLEASE HELP US IMPROVING THIS SECTION                     */</span></span><br><span class="line"><span class="comment">/* Eigen 3.4 supports a new API for reshaping:                                */</span></span><br><span class="line"><span class="comment">/* http://eigen.tuxfamily.org/dox-devel/group__TutorialReshape.html           */</span></span><br><span class="line"><span class="comment">/******************************************************************************/</span></span><br><span class="line"><span class="comment">// Eigen                           // Matlab</span></span><br><span class="line">R.adjoint()                        <span class="comment">// R'</span></span><br><span class="line">R.transpose()                      <span class="comment">// R.' or conj(R')       // Read-write</span></span><br><span class="line">R.diagonal()                       <span class="comment">// diag(R)               // Read-write</span></span><br><span class="line">x.asDiagonal()                     <span class="comment">// diag(x)</span></span><br><span class="line">R.transpose().colwise().reverse()  <span class="comment">// rot90(R)              // Read-write</span></span><br><span class="line">R.rowwise().reverse()              <span class="comment">// fliplr(R)</span></span><br><span class="line">R.colwise().reverse()              <span class="comment">// flipud(R)</span></span><br><span class="line">R.replicate(i,j)                   <span class="comment">// repmat(P,i,j)</span></span><br></pre></td></tr></table></figure><h3 id="矩阵运算">6.2 矩阵运算</h3><h4 id="基本算数运算">6.2.1 基本算数运算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All the same as Matlab, but matlab doesn't have *= style operators.</span></span><br><span class="line"><span class="comment">// Matrix-vector.  Matrix-matrix.   Matrix-scalar.</span></span><br><span class="line">y  = M*x;          R  = P*Q;        R  = P*s;</span><br><span class="line">a  = b*M;          R  = P - Q;      R  = s*P;</span><br><span class="line">a *= M;            R  = P + Q;      R  = P/s;</span><br><span class="line">                   R *= Q;          R  = s*P;</span><br><span class="line">                   R += Q;          R *= s;</span><br><span class="line">                   R -= Q;          R /= s;</span><br></pre></td></tr></table></figure><h4 id="点运算">6.2.2 点运算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vectorized operations on each element independently</span></span><br><span class="line"><span class="comment">// Eigen                       // Matlab</span></span><br><span class="line">R = P.cwiseProduct(Q);         <span class="comment">// R = P .* Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() * s.<span class="built_in">array</span>();     <span class="comment">// R = P .* s</span></span><br><span class="line">R = P.cwiseQuotient(Q);        <span class="comment">// R = P ./ Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() / Q.<span class="built_in">array</span>();     <span class="comment">// R = P ./ Q</span></span><br><span class="line">R = P.<span class="built_in">array</span>() + s.<span class="built_in">array</span>();     <span class="comment">// R = P + s</span></span><br><span class="line">R = P.<span class="built_in">array</span>() - s.<span class="built_in">array</span>();     <span class="comment">// R = P - s</span></span><br><span class="line">R.<span class="built_in">array</span>() += s;                <span class="comment">// R = R + s</span></span><br><span class="line">R.<span class="built_in">array</span>() -= s;                <span class="comment">// R = R - s</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt; Q.<span class="built_in">array</span>();         <span class="comment">// R &lt; Q</span></span><br><span class="line">R.<span class="built_in">array</span>() &lt;= Q.<span class="built_in">array</span>();        <span class="comment">// R &lt;= Q</span></span><br><span class="line">R.cwiseInverse();              <span class="comment">// 1 ./ P</span></span><br><span class="line">R.<span class="built_in">array</span>().inverse();           <span class="comment">// 1 ./ P</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sin</span>()                <span class="comment">// sin(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">cos</span>()                <span class="comment">// cos(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">pow</span>(s)               <span class="comment">// P .^ s</span></span><br><span class="line">R.<span class="built_in">array</span>().square()             <span class="comment">// P .^ 2</span></span><br><span class="line">R.<span class="built_in">array</span>().cube()               <span class="comment">// P .^ 3</span></span><br><span class="line">R.cwiseSqrt()                  <span class="comment">// sqrt(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">sqrt</span>()               <span class="comment">// sqrt(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">exp</span>()                <span class="comment">// exp(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">log</span>()                <span class="comment">// log(P)</span></span><br><span class="line">R.cwiseMax(P)                  <span class="comment">// max(R, P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">max</span>(P.<span class="built_in">array</span>())       <span class="comment">// max(R, P)</span></span><br><span class="line">R.cwiseMin(P)                  <span class="comment">// min(R, P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">min</span>(P.<span class="built_in">array</span>())       <span class="comment">// min(R, P)</span></span><br><span class="line">R.cwiseAbs()                   <span class="comment">// abs(P)</span></span><br><span class="line">R.<span class="built_in">array</span>().<span class="built_in">abs</span>()                <span class="comment">// abs(P)</span></span><br><span class="line">R.cwiseAbs2()                  <span class="comment">// abs(P.^2)</span></span><br><span class="line">R.<span class="built_in">array</span>().abs2()               <span class="comment">// abs(P.^2)</span></span><br><span class="line">(R.<span class="built_in">array</span>() &lt; s).select(P,Q );  <span class="comment">// (R &lt; s ? P : Q)</span></span><br><span class="line">R = (Q.<span class="built_in">array</span>()==<span class="number">0</span>).select(P,R) <span class="comment">// R(Q==0) = P(Q==0)</span></span><br><span class="line">R = P.unaryExpr(ptr_fun(func)) <span class="comment">// R = arrayfun(func, P)   // with: scalar func(const scalar &amp;x);</span></span><br></pre></td></tr></table></figure><h4 id="矩阵函数">6.2.3 矩阵函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reductions.</span></span><br><span class="line"><span class="keyword">int</span> r, c;</span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">R.minCoeff()              <span class="comment">// min(R(:))</span></span><br><span class="line">R.maxCoeff()              <span class="comment">// max(R(:))</span></span><br><span class="line">s = R.minCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = min(R(:)); [r, c] = ind2sub(size(R), i);</span></span><br><span class="line">s = R.maxCoeff(&amp;r, &amp;c)    <span class="comment">// [s, i] = max(R(:)); [r, c] = ind2sub(size(R), i);</span></span><br><span class="line">R.sum()                   <span class="comment">// sum(R(:))</span></span><br><span class="line">R.colwise().sum()         <span class="comment">// sum(R)</span></span><br><span class="line">R.rowwise().sum()         <span class="comment">// sum(R, 2) or sum(R')'</span></span><br><span class="line">R.prod()                  <span class="comment">// prod(R(:))</span></span><br><span class="line">R.colwise().prod()        <span class="comment">// prod(R)</span></span><br><span class="line">R.rowwise().prod()        <span class="comment">// prod(R, 2) or prod(R')'</span></span><br><span class="line">R.trace()                 <span class="comment">// trace(R)</span></span><br><span class="line">R.all()                   <span class="comment">// all(R(:))</span></span><br><span class="line">R.colwise().all()         <span class="comment">// all(R)</span></span><br><span class="line">R.rowwise().all()         <span class="comment">// all(R, 2)</span></span><br><span class="line">R.any()                   <span class="comment">// any(R(:))</span></span><br><span class="line">R.colwise().any()         <span class="comment">// any(R)</span></span><br><span class="line">R.rowwise().any()         <span class="comment">// any(R, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dot products, norms, etc.</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">x.norm()                  <span class="comment">// norm(x).    Note that norm(R) doesn't work in Eigen.</span></span><br><span class="line">x.squaredNorm()           <span class="comment">// dot(x, x)   Note the equivalence is not true for complex</span></span><br><span class="line">x.dot(y)                  <span class="comment">// dot(x, y)</span></span><br><span class="line">x.cross(y)                <span class="comment">// cross(x, y) Requires #include &lt;Eigen/Geometry&gt;</span></span><br></pre></td></tr></table></figure><h4 id="类型转换">6.2.4 类型转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// Type conversion</span></span><br><span class="line"><span class="comment">// Eigen                  // Matlab</span></span><br><span class="line">A.cast&lt;<span class="keyword">double</span>&gt;();         <span class="comment">// double(A)</span></span><br><span class="line">A.cast&lt;<span class="keyword">float</span>&gt;();          <span class="comment">// single(A)</span></span><br><span class="line">A.cast&lt;<span class="keyword">int</span>&gt;();            <span class="comment">// int32(A)</span></span><br><span class="line">A.real();                 <span class="comment">// real(A)</span></span><br><span class="line">A.imag();                 <span class="comment">// imag(A)</span></span><br><span class="line"><span class="comment">// if the original type equals destination type, no work is done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Note that for most operations Eigen requires all operands to have the same type:</span></span><br><span class="line">MatrixXf F = MatrixXf::Zero(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">A += F;                <span class="comment">// illegal in Eigen. In Matlab A = A+F is allowed</span></span><br><span class="line">A += F.cast&lt;<span class="keyword">double</span>&gt;(); <span class="comment">// F converted to double and then added (generally, conversion happens on-the-fly)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Eigen can map existing memory into Eigen matrices.</span></span><br><span class="line"><span class="keyword">float</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">Vector3f::Map(<span class="built_in">array</span>).<span class="built_in">fill</span>(<span class="number">10</span>);            <span class="comment">// create a temporary Map over array and sets entries to 10</span></span><br><span class="line"><span class="keyword">int</span> data[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="function">Matrix2i <span class="title">mat2x2</span><span class="params">(data)</span></span>;                    <span class="comment">// copies data into mat2x2</span></span><br><span class="line">Matrix2i::Map(data) = <span class="number">2</span>*mat2x2;           <span class="comment">// overwrite elements of data with 2*mat2x2</span></span><br><span class="line">MatrixXi::Map(data, <span class="number">2</span>, <span class="number">2</span>) += mat2x2;      <span class="comment">// adds mat2x2 to elements of data (alternative syntax if size is not know at compile time)</span></span><br></pre></td></tr></table></figure><h4 id="求解线性方程组">6.2.5 求解线性方程组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Solve Ax = b. Result stored in x. Matlab: x = A \ b.</span></span><br><span class="line">x = A.ldlt().solve(b);  <span class="comment">// A sym. p.s.d.    #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.llt() .solve(b);  <span class="comment">// A sym. p.d.      #include &lt;Eigen/Cholesky&gt;</span></span><br><span class="line">x = A.lu()  .solve(b);  <span class="comment">// Stable and fast. #include &lt;Eigen/LU&gt;</span></span><br><span class="line">x = A.qr()  .solve(b);  <span class="comment">// No pivoting.     #include &lt;Eigen/QR&gt;</span></span><br><span class="line">x = A.svd() .solve(b);  <span class="comment">// Stable, slowest. #include &lt;Eigen/SVD&gt;</span></span><br><span class="line"><span class="comment">// .ldlt() -&gt; .matrixL() and .matrixD()</span></span><br><span class="line"><span class="comment">// .llt()  -&gt; .matrixL()</span></span><br><span class="line"><span class="comment">// .lu()   -&gt; .matrixL() and .matrixU()</span></span><br><span class="line"><span class="comment">// .qr()   -&gt; .matrixQ() and .matrixR()</span></span><br><span class="line"><span class="comment">// .svd()  -&gt; .matrixU(), .singularValues(), and .matrixV()</span></span><br></pre></td></tr></table></figure><h4 id="求解特征值">6.2.6 求解特征值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eigenvalue problems</span></span><br><span class="line"><span class="comment">// Eigen                          // Matlab</span></span><br><span class="line">A.eigenvalues();                  <span class="comment">// eig(A);</span></span><br><span class="line"><span class="function">EigenSolver&lt;Matrix3d&gt; <span class="title">eig</span><span class="params">(A)</span></span>;     <span class="comment">// [vec val] = eig(A)</span></span><br><span class="line">eig.eigenvalues();                <span class="comment">// diag(val)</span></span><br><span class="line">eig.eigenvectors();               <span class="comment">// vec</span></span><br><span class="line"><span class="comment">// For self-adjoint matrices use SelfAdjointEigenSolver&lt;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ol type="1"><li><a href="http://eigen.tuxfamily.org/dox-devel/AsciiQuickReference.txt" target="_blank" rel="noopener">Eigen short ASCII reference</a>eference.txt)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;eigen常用操作eigen-cheatsheet&quot;&gt;Eigen常用操作|Eigen Cheatsheet&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>占用栅格更新过程</title>
    <link href="http://yoursite.com/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/</id>
    <published>2021-01-30T03:05:20.000Z</published>
    <updated>2021-02-03T01:12:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="占用栅格更新from-概率机器人">占用栅格更新(From 《概率机器人》)</h1><h2 id="静态二值贝叶斯滤波">静态二值贝叶斯滤波</h2><p>机器人技术中的某些问题表达为不随时间变化的二值状态的最优估计间题。这些问题通过二值贝叶斯滤波 (binary Bayes filter) 来阐述。</p><p>如果一个机器人从传感器测量的序列中估计环境的一个固定的二值数,此时这类问题就产生了。例如,一个机器人可能想知道门是开着的还是关着的,并认为在检测期间门的状态不改变。</p><h3 id="更新算法">更新算法</h3><p>当状态静止时,置信度就仅是测量的函数:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-19-56-28.png"></p><p>这里状态有两种：</p><ul><li><span class="math inline">\(x\)</span></li><li><span class="math inline">\(\neg x\)</span></li></ul><p>具体来说，有</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-04-09.png"></p><blockquote><p>状态 x 不含时间项反映了状态不会改变的事实</p></blockquote><p>自然的,这类二值估计问题可以利用程序 4. 1 的离散贝叶斯滤波来处理。但是,置信度通常由一个<code>概率比的对数 (log odds ratio)</code>来实现。状态 x 的概率比(odds) 定义为此事件的概率除以该事件不发生的概率</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-06-20.png"></p><p>概率对数就是这个表达式的对数</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-06-53.png"></p><blockquote><p>逆向公式，即置信度<span class="math inline">\({bel}_t(x)\)</span>可以根据概率比对数<span class="math inline">\(l_t\)</span>通过下面的方程来求得: : <img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-34-49.png"></p></blockquote><p>概率对数将(0,1)映射到<span class="math inline">\(-\infty\)</span> ~ <span class="math inline">\(\infty\)</span>，用于更新以概率对数表示的置信度的贝叶斯滤波计算很简洁。它避免了概率接近<code>0</code>或<code>1</code>引起的截断间题。</p><p><code>程序 4.2</code>给出了其基本的更新算法。这种算法是加法。</p><p>事实上,任何对测量做出反应的变量的递增和递减都可以解释为贝叶斯滤波的概率对数形式。该二值贝叶斯滤波利用一个反向测量模型 (inverse measurement model) <span class="math inline">\(p(x|z_t)\)</span>代替熟 悉的前向模型<span class="math inline">\(p(z_i|x)\)</span> 。反向测量模型将关于(二值)状态变量的一个分布指定为测量<span class="math inline">\(z_t\)</span>的一个函数。</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-27-46.png"></p><blockquote><p>反向模型经常用于测凰比二值状态更复杂的情况。这种情况的一个实例就是: <code>从相机图像中估计门是否为关的问题</code>。这里状态很简单,但需要进行所有测量的空间却是很大的。通过设计一个函数<code>根据相机图像来计算门为关着的概率</code>, 要比<code>描述所有相机图像中显示门为关着的分布</code>更容易些。换旬话说,<strong>实现一个反向传感器模型比前向传感器模型更容易</strong>。</p></blockquote><h3 id="具体证明">具体证明</h3><p>根据贝叶斯公式及马尔可夫假设:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-36-49.png"></p><p>将贝叶斯准则应用于测量模型<span class="math inline">\(p(z_t|x)\)</span></p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-37-32.png"></p><p>将上述两式结合，得到:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-40-28.png"></p><p>对于对立事件<span class="math inline">\(\neg x\)</span>，可得:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-41-03.png"></p><p>用<code>式 (4. 18)</code>除以<code>式 (4. 17)</code> 可以将各种难以计算的概率抵消:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-41-30.png"></p><p>对上式两边同时取对数，用<span class="math inline">\(l_t(x)\)</span>表示，即为置信度 <span class="math inline">\({bel}_t (x)\)</span>的概率比对数<span class="math inline">\(log \frac{p(x|z_{1:t})}{1-p(x|z_{1:t})}\)</span>，有:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-49-03.png"></p><p>这里 <span class="math inline">\(p(x)\)</span> 是状态 x 的先验 (prior) 概率。在<code>式 (4. 20)</code>中, 每个测最更新涉及先验(以概率对数形式)的求和。先验也定义为处理传感器测量前的初始置信度的概率对数:</p><p><img src="/2021/01/30/%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B/2021-01-30-20-58-10.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;占用栅格更新from-概率机器人&quot;&gt;占用栅格更新(From 《概率机器人》)&lt;/h1&gt;
&lt;h2 id=&quot;静态二值贝叶斯滤波&quot;&gt;静态二值贝叶斯滤波&lt;/h2&gt;
&lt;p&gt;机器人技术中的某些问题表达为不随时间变化的二值状态的最优估计间题。这些问题通过二值贝叶斯滤波 (bin
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ICRA2020_dynamic_object_removing</title>
    <link href="http://yoursite.com/2021/01/29/ICRA2020_dynamic_object_removing/"/>
    <id>http://yoursite.com/2021/01/29/ICRA2020_dynamic_object_removing/</id>
    <published>2021-01-29T03:05:30.000Z</published>
    <updated>2021-02-03T01:11:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从点云中删除动态对象的稳健方法">从点云中删除动态对象的稳健方法</h1><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-09-49.png"></p><h1 id="摘要">摘要</h1><p>提出了一种从3D点云地图中删除动态对象的可靠方法。给定一组已配准的3D点云，我们构建一个占据栅格地图，其中体素表示扩展时间段内空间量的占用状态。构建占用地图后，我们将其用作过滤器，以在将激光雷达扫描中的动态点添加到地图之前将其删除。此外，我们使用对象检测和新颖的体素遍历方法来加速构建占用地图的过程。一旦构建了占用图，就可以实时运行动态对象移除。我们的方法在交通停滞或移动的宽阔城市道路上效果很好，并且由于包含了来自同一场景的更多激光雷达扫描，因此占用地图变得更好。</p><h1 id="介绍">介绍</h1><p>算法的输入是一组已配准的3D点云，通常由3D激光扫描仪获取。首先，我们使用地平面检测和对象检测算法将点云中的点分为三类：对象点，地面点和未知点。接下来，我们对未知点和地面点执行体素遍历，并降低从传感器原点到端点的光线路径上所有体素的占用分数，但增加端点体素的占用分数。类似地，我们在对象点上执行体素遍历，但是不增加端点体素的占用率，而是降低其占用率，因为我们从对象检测中已经知道端点落在移动的对象上。我们还维护了一组与地面点相对应的地面体素，并防止在两个体素遍历步骤中将它们标记为空闲。我们对注册集中的所有点云重复此过程，并构建一个占用图。最后，我们将完整的占用地图覆盖在点云地图上，并删除空闲体素中的点（请参阅图2）。应当注意，随着时间的推移，随着更多点云的集成，占用图将变得更加稳定和准确。</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-54-25.png"></p><p>具体贡献为：</p><ul><li>提出了一种新的占用概率更新策略，该策略通过考虑体素的占用历史来构建持久的占用图。与我们的方法不同，[3]赞成快速更新体素的占用分数，赞成最新看到的占用状态</li><li>提供了一种可选方法，可通过使用对象检测方法对对象点进行分类来加速占用地图的构建过程，并提供一种使用这些点更新占用地图的策略。</li><li>提供了一种生成手工端点的独特方法，该终点用于更新体素的占用分数。</li></ul><h1 id="相关工作">相关工作</h1><p>在检测/移除激光扫描中的动态对象方面已经完成了大量工作，并且已经提出了解决该问题的不同方法。这些方法可以大致分为三类：</p><ul><li><p>基于模型的无变化检测方法，该方法依赖于将当前激光扫描与之前或之前的一组扫描和将来的扫描进行比较[6]，[7]，[8]，[9]，[10]。</p></li><li><p>基于神经网络模型的方法，将动态对象对应的点分类[11]，并在激光扫描[12]，[13]，[14]中在对象周围生成边界框并将这些边界框内的点分类为动态对象点。</p></li><li><p>基于地图的方法，其中使用贝叶斯规则[3]通过激光扫描构建全局占用图/体素网格，或者仅将激光扫描标识符存储在体素中[5]，并且占用图用作过滤器以删除在自由空间中的点。本文提出的动态对象去除方法是基于神经网络模型和基于占用图的方法的混合。</p></li></ul><h1 id="算法介绍">算法介绍</h1><ul><li>在III-A节中，我们描述了为什么我们偏爱八叉树数据结构</li><li>在III-B节中，我们描述了如何使用对象检测来加快在地图中插入点云的过程</li><li>第III-D，III-E和III-F节讨论了使用自由计数器使占用图更倾向于持久性而不是易于更新的能力，以及如何使用自由计数器值修剪节点</li><li>第III-G节介绍了一种独特的过滤策略，以提高我们的入住地图的质量</li></ul><h2 id="占据八叉树">占据八叉树</h2><p>Octree是用于存储有关3D空间的信息的分层数据结构，八叉树中的每个节点代表一个空间容量，称为体素。我们使用<code>log odds</code>表格来表示空间的占用信息。另外，我们还记录着每个节点没有被观测到的次数作为<code>free counter</code>，后面会介绍使用<code>free counter</code>来更新体素的占用率</p><p>常用来表示3D空间数据结构的有：体素网格，k-d树和八叉树，我们选择octree作为占用地图，因为octree的层次结构可以紧凑有效地表示空间，与体素网格相反，我们只需在当观测到<code>occupancy information</code>时创建一个节点，在本文中，我们使用最大深度为16的八叉树和0.3米的叶节点体素大小 。</p><h2 id="目标检测与体素遍历">目标检测与体素遍历</h2><p>对象检测可用于加快生成占用图的过程，并提高动态对象去除的精度和召回得分，我们的方法不依赖于任何特定的对象检测方法，但是在我们的实验中，我们使用了AVOD（聚合视图对象检测）[13]网络来获取边界框，目前，该网络已接受训练以检测小型和大型车辆。</p><p>但是，许多基于神经网络的对象检测方法有时都无法检测到对象。这些模型只能检测对其进行训练的对象类别。此外，边界框通常不会完全包围检测到的对象，如图（3）所示。因此，使用上述方法构建的点云图仍将具有一些动态点。</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-44-04.png"></p><p>为了去除物体检测方法遗漏的动态物体，我们使用上述方法将点云中的点分为两类：</p><ul><li>对象点（位于检测到的对象的边界框内的点）</li><li>非对象点（位于边界框外的点）</li></ul><h3 id="非对象点遍历">非对象点遍历</h3><p><strong>对于点云中的每个非对象点，我们执行体素遍历以找到从传感器原点到终点沿激光射线的所有体素</strong>，我们降低了除端点体素以外的所有这些体素的占用率，并增加了端点体素的占用率</p><h3 id="对象点遍历">对象点遍历</h3><p>接下来，我们按照相同的步骤插入对象点，但是不增加端点体素的占用率外，而是降低其占用率，这是因为从对象检测中我们已经知道对象点对应于动态对象。</p><p>如前所述，有时，围绕对象生成的边界框不会完全包围对象。 我们通过在将非对象点插入到占用图中之后插入对象点来部分解决此问题。<strong>此顺序可确保在对对象点执行体素遍历时，将删除动态对象未被边界框包围的部分</strong></p><h2 id="地面点检测">地面点检测</h2><p>如[3]中所述，对以浅角度扫过平面的激光进行体素遍历会导致不良的离散化效果，当遍历另一个附近的体素时，在体素遍历期间被测量为占用的体素可能会标记为空闲，这种影响通常发生在平坦的表面（例如地面和平坦的墙壁）上，并且该影响呈现为平坦表面上的孔，如图（4）所示。</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-50-02.png"></p><blockquote><p>就是体素网格大小导致的</p></blockquote><p>此外，通过对象检测生成的边界框可能包括检测到的对象下方的地面点，并且将地面点错误地分类为动态对象点。 因此，某些地面体素可能仍被标记为空闲。</p><p>为了解决此问题，我们为每个地面体素维护一个计数器，该计数器指示将体素分类为地面体的次数，我们还将维护所有检测到的地面体素的集合，并为每次激光雷达扫描更新此集合。</p><p>只有地面体素集中那些计数器值大于某个阈值的体素才被视为真实地面体素，这些地面体素在射线遍历期间不会被标记为空闲体素。</p><p>我们使用[14]，[18]中所述的基于RANSAC的接地平面检测</p><h2 id="权重概率">权重概率</h2><p>Octomap [3]使用钳制策略允许占用八叉树图的易于更新性和可压缩性，钳位策略可确保节点的<code>log-odds</code>值不低于下限阈值<span class="math inline">\(l_{min}\)</span>，并且不会超出最高值<span class="math inline">\(l_{max}\)</span>.</p><p>当一个节点的<code>log-odds</code>值达到两个阈值中的任意一个时，就认为该节点是稳定的，并且具有较高的置信度。钳位策略可确保所有稳定的空闲和占用节点具有相同的对数奇数值，从而可以修剪具有相同<code>log-odds</code>值的相邻节点，还确保了节点的占用状态很容易更新</p><p>举例：考虑一个机器人已经绘制了某个区域并观测到其前面几个节点是空闲状态的，现在，如果有人走在机器人前面并站在机器人的路径上，则机器人应该能够快速将节点更新为已占用</p><p><img src="/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-11-19-04.png"></p><p>其中，<span class="math inline">\(L()\)</span>表示计算<code>log-odds</code>值</p><p>然而，[3]中的占用率更新策略倾向于体素的最新占用率状态 ，相反的，本文的目标是创建<code>代表环境长期占用状态的区域的占用地图</code>，我们希望占用率更新算法对动态对象不那么敏感。</p><p>本文通过维持每个体素的空闲计数器并使用加权概率来实现此目的。每个体素的计数器用于记录该体素被观测为空闲状态的次数，每次在体素遍历期间，当被观测为空闲状态时，将其递增1；如果其值大于1，并且在体素遍历期间观测到体素被占用，则将其减1。</p><p>为了理解原理，考虑两个场景：</p><ol type="1"><li><p>第一个情况是体素的空闲计数器值&gt;1，并且插入当前帧点云时，观测到这个体素是占用状态，由于空闲计数器值&gt;1，这表明这个体素先前被记录为空闲，因此该体素很有可能被当前帧点云中的动态对象所占用，因此，我们通过将体素的命中值概率除以空闲计数器值来减轻概率更新，如公式（2）所示，这个策略的动机是：其难以增加先前已经被观测为空闲的体素的占用概率。 体素的空闲计数器值越高，则增加体素的占用概率就越难。</p></li><li><p>第二种情况是由于对象检测方法的错误检测导致体素被错误地标记为已占用，在这种情况下，我们使用原始公式（1）。 这使得属于动态点的体素易于更新状态。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从点云中删除动态对象的稳健方法&quot;&gt;从点云中删除动态对象的稳健方法&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2021/01/29/ICRA2020_dynamic_object_removing/2021-01-29-10-09-49.png&quot;&gt;&lt;/p&gt;
&lt;h1 id
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第二章-相机模型与对极几何</title>
    <link href="http://yoursite.com/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/"/>
    <id>http://yoursite.com/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/</id>
    <published>2021-01-24T04:05:29.000Z</published>
    <updated>2021-01-24T09:05:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="成像原理与图像特征">成像原理与图像特征</h1><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-11-55-55.png"></p><h2 id="针孔相机模型">针孔相机模型</h2><p>外参矩阵： 世界坐标系与相机坐标系</p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-11-58-39.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-11-59-52.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-01-57.png"></p><blockquote><p>相机朝向就是外参矩阵中的旋转矩阵第三行</p></blockquote><p>内参矩阵：</p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-03-23.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-48-28.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-48-49.png"></p><p>小结：</p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-49-34.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-51-10.png"></p><h2 id="径向畸变">径向畸变</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-52-01.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-12-53-04.png"></p><h1 id="对极几何">对极几何</h1><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-24-34.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-26-00.png"></p><h2 id="八点法求基础矩阵">八点法求基础矩阵</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-31-43.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-32-27.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-34-01.png"></p><h2 id="ransac求基础矩阵">RANSAC求基础矩阵</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-39-38.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-42-02.png"></p><h3 id="ransac拟合直线举例">ransac拟合直线举例</h3><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-42-26.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-42-49.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-43-00.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-43-10.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-43-41.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-45-32.png"></p><h3 id="ransac估计基础矩阵流程">ransac估计基础矩阵流程</h3><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-47-19.png"></p><h2 id="本征矩阵e">本征矩阵E</h2><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-49-30.png"></p><h3 id="本质矩阵e恢复相机运动四种情况">本质矩阵E恢复相机运动（四种情况）</h3><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-51-03.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-55-41.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-16-59-47.png"></p><blockquote><p>H矩阵有效的情况：<br>(1) 空间点都在同一平面上<br>(2) 相机运动只有旋转</p></blockquote><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-17-01-02.png"></p><p><img src="/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95/2021-01-24-17-01-47.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;成像原理与图像特征&quot;&gt;成像原理与图像特征&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2021/01/24/%E7%AC%AC%E4%BA%8C%E7%AB%A0_%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%AF%B
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BaiDu-考虑lio的定位</title>
    <link href="http://yoursite.com/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-01-20T03:34:33.000Z</published>
    <updated>2021-01-21T08:03:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lidar-inertial-odometry-aided-robust-lidar-localization-system-in-changing-city-scenes">LiDAR Inertial Odometry Aided Robust LiDAR Localization System in Changing City Scenes</h1><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-20-08-42-25.png"></p><h1 id="摘要">摘要</h1><p>提出一种将激光惯性里程计(LIO)和激光扫描配定位模块进行整合，然后将两种观测融入到pose graph中进行联合优化的框架。基于激光扫描的global matching和 lio是互补的，这使的可以达到鲁棒的定位，以解决环境的短暂变化以及地图的误差问题，如图1所示。</p><p>本文贡献：</p><ul><li>一种车辆定位的联合框架，可自适应融合激光扫描匹配和局部里程计，从而有效保护定位系统，使其免受城市场景变化的影响</li><li>一种LIO方法，并结合了占据栅格和激光强度</li><li>每天在拥挤繁忙的城市街道上经过严格测试的强大车辆定位系统，证明了其在充满挑战和动态变化的环境中的强大能力</li></ul><h1 id="相关工作">相关工作</h1><h2 id="长期定位long-term-localization">长期定位（Long-term Localization）</h2><p>建立一个7天24小时的全天候定位系统是一项艰巨的任务，近年来受到了极大的关注。文献[6]表明，可以通过归一化每一帧的LiDAR扫描的亮度和标准偏差来调整由潮湿路面引起的较少反射率。文献[2][3]通过在地图中引入<strong>多分辨率高斯混合</strong>表示法，展示了一种强大的LiDAR定位系统，该系统可以通过道路翻修和降雪环境下运行。文献[5]，LiDAR定位系统<strong>通过结合高度信息</strong>成功地通过了具有挑战性的路段，其中包括新建的墙壁和重新铺设的道路。文献[4]通过引入<strong>主成分分析（PCA）</strong>和<strong>边缘轮廓</strong>来增强其定位系统的鲁棒性，尤其是在下雨天或下雪天时。</p><p>这些工作着重于利用利基技术解决特定问题，但我们力图通过将里程表和全局匹配模块中的补充线索自适应地融合在一起，从而寻求更通用的解决方案。</p><p>其他工作如[7,8,9,10,11]解决了类似的长期定位问题，但使用的视觉传感器对时间，光线或天气导致的场景外观变化敏感。</p><h2 id="激光惯性里程计lidar-inertial-odometry">激光惯性里程计（LiDAR Inertial Odometry）</h2><p>目前有大量关于激光里程计的工作，如[12,13,14,15,16,17,18,19,20,21,22,23,24]。如[14],[18],[17],[17]，惯性测量可通过提供先验估计并补偿运动失真来帮助解决问题。[18]构建更加紧密的局部运动约束，[23],[24]进一步建立紧密耦合的里程表。</p><p>在这项工作中，我们遵循Hess的工作[13]，并将基于占用栅格的LiDAR惯性里程表集成到我们的定位框架中，因为它的地图表示与我们的全局匹配模块相似，并且与多个激光扫描仪兼容</p><h2 id="融合定位方法">融合定位方法</h2><p>一类重要的是松耦合融合方法[25]，[5]，[26]利用误差状态卡尔曼滤波器并通过不同方法实现了松耦合的位姿估计。类似于[26]，我们的方法不是使用卡尔曼滤波器，而是利用基于图的融合框架，该框架以每单位计算时间的精度更高的性能优于滤波方法[27]，[28]。[29]展示了融合GNSS，LiDAR和惯性测量的紧密耦合导航系统。</p><h1 id="系统框架">系统框架</h1><p>提出的系统包含四个模块：LiDAR惯性里程计（LIO），LiDAR全局匹配（LGM），基于姿态图的融合（PGF）和环境变化检测（ECD），如图2所示。</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-20-09-06-51.png"></p><p>我们遵循G. Wan[5]等人的最新LiDAR定位工作来构建系统，并在我们的框架中将其作为子模块LGM。LGM模块是一种global定位方法，可将在线LiDAR扫描与预先构建的地图进行匹配，并进行3 DoF（x，y，yaw）估计，一旦我们成功地水平定位，就可以通过读取IMU重力测量值和数字高程模型（DEM）地图来估算其他3个自由度（侧倾，俯仰，高度）。</p><p>其他两个模块是，LIO和PGF，根据解决不同的最大后验概率（MAP）估计问题来实现。</p><p>最大后验概率（MAP）估计问题通常是在滑动窗口下定义的非线性优化问题，设<span class="math inline">\(\kappa\)</span>记为窗口中的所有帧集合</p><ul><li>滑动窗口中的状态<span class="math inline">\(\mathcal{X}=\left\{\mathbf{x}_{k}\right\}_{k \in \mathcal{K}}\)</span></li><li>观测集合分别记为<span class="math inline">\(\mathcal{Z}=\left\{\mathbf{z}_{k}\right\}_{k \in \mathcal{K}}\)</span></li><li>第k帧的状态<span class="math inline">\(\mathbf{x}_{k}=\left[\boldsymbol{\omega}_{k}, \mathbf{t}_{k}, \mathbf{v}_{k}, \mathbf{b}_{k}\right]\)</span>分别表示旋转、位置、速度和bias，其中<span class="math inline">\(\omega_k\)</span>是李代数中的<span class="math inline">\(so(3)\)</span>，即有<span class="math inline">\(R_k=\exp(\omega_k)\)</span>。</li></ul><h2 id="提出的lio框架">提出的LIO框架</h2><p>LiDAR惯性里程计在我们的系统中起着至关重要的作用，可在严峻的环境（例如，由于道路建设或恶劣天气导致的地图过期或环境变化）中提高定位性能。其中，激光里程计估计相邻帧的相对位姿变换，同时<strong>构建局部地图，称为子图</strong>，该子图始终是最新的，并且随着每个新的LiDAR SCAN不断更新。</p><p>我们的LiDAR惯性里程计的实现遵循W. Hess的工作[13] （注：cartographer），但有许多重要的扩展可提高其准确性。</p><ul><li>使用了3d占据栅格来代替2d，来实现6自由度的里程计，这种扩展可将系统应用到3维环境中，如停车场结构或立交桥，同时简化了下面提到的imu预积分</li><li>重要的惯性测量数据被合并以提供运动预测和帧之间的相对约束，更重要的是，惯性测量的结合使我们能够对由载体运动引起的扭曲的LiDAR扫描进行运动补偿，为了控制计算时间，我们在实现中采用了[30]<strong>引入的惯性测量值的预积分</strong></li><li>考虑到某些情况下来自车道或者路面标记的丰富信息，在占据栅格配准过程中整合了激光强度信息，用来补充每个网格单元的占用概率，它提供了有价值的环境纹理信息</li><li>最后，通过将多分辨率的占据栅格来实现求解非线性优化问题中的从粗到精细化的方法，它不仅有助于网格配准的收敛，而且可以避免计算需求</li></ul><p>LIO问题描述：在给定先前的状态<span class="math inline">\(x_{k-1}^L\)</span>、使用k-1帧更新后的子图<span class="math inline">\(\mathcal{S}_{k-1}\)</span>以及观测<span class="math inline">\(z_k\)</span>，求状态<span class="math inline">\(x_{k}^L\)</span>的最大后验概率。</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-24-22.png"></p><p>其中，<span class="math inline">\(\mathbf{z}_{k}=\left\{\mathbf{z}_{k}^{P}, \mathbf{z}_{k}^{I}\right\}\)</span>，<span class="math inline">\(\mathbf{z}_{k}\)</span>和<span class="math inline">\(\mathbf{z}_{I}\)</span>分别是点云和惯性测量的观测，上标<span class="math inline">\(L\)</span>表示由子图和里程计表示的局部帧的状态<span class="math inline">\(\mathbf{x}_{k}^L\)</span>.</p><p>在零均值高斯似概率的假设下，观测的似然概率通过构建cost func来定义：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-29-59.png"></p><p>其中，<span class="math inline">\(\|\mathbf{r}\|_{\Lambda}^{2}=\mathbf{r}^{T} \Lambda^{-1} \mathbf{r}\)</span>，并且有：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-31-20.png"></p><p>其中，</p><ul><li>等式(2)根据imu预积分方法计算，可参考文献<a href="On-manifold%20preintegration%20for%20real-time%20visual–inertial%20odometry">30</a></li><li>等式(3)中的<code>SSOP</code> （Sum of Squared Occupancy Probability）和<code>SSID</code>（Sum of Squared Intensity Difference）分别代表占用栅格概率和LiDAR强度损失，其定义如下：</li></ul><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-10-38-14.png"></p><p>给定一个激光点<span class="math inline">\(\mathbf{p}_j \in \R^3\)</span>，一个分辨率为<span class="math inline">\(i\)</span>的子图以及一个位姿状态<span class="math inline">\(\mathbf{x}_{k}^{L}=\left[\mathrm{R}_{k}, \mathbf{t}_{k}\right]\)</span>，子图中被击中的单元<span class="math inline">\(s\)</span>可以被找到。<span class="math inline">\(P(s)\)</span>是在分辨率i下击中子图的占用概率，这个占用概率的维持是通过以最大化后验概率<span class="math inline">\(P\left(\mathbf{x}_{k}^{L} \mid \mathbf{z}_{k}, \mathbf{x}_{k-1}^{L}, \mathcal{S}_{k-1}\right)\)</span>的方法不断的将新的激光雷达扫描插入到子图中。</p><p>这个增量式升级问题可以通过使用<code>inverse measurement</code>模型以及[31]中引入的<code>log adds ratio</code> 的二进制贝叶斯滤波器来解决。</p><p><span class="math inline">\(I(\mathbf{p}_j)\)</span>是点<span class="math inline">\(\mathbf{p}_j\)</span>的强度，<span class="math inline">\(u_s\)</span>和<span class="math inline">\(\sigma_s\)</span>是击中单元的激光强度均值和方差，（注：归一化到标准正态分布）。为了更好的确保配准性能，采用了三次插值从子图中获得概率和强度。方差<span class="math inline">\(\sigma_{Oi}\)</span>和<span class="math inline">\(\sigma_{ri}\)</span>用于在不同分辨率下对优化中的占据概率和强度项分别进行加权。</p><blockquote><p>MAP估计值与负对数后验的最小值相对应，后者可以写为残差平方的总和，从而产生非线性最小二乘优化问题</p></blockquote><h2 id="位姿图融合">位姿图融合</h2><p>虽然LiDAR惯性里程计可以在局部坐标系中提供良好的相对约束，但我们仍然需要全局约束才能实现全局定位，baidu-LGM模块为我们的系统提供了全局定位信息，我们的LGM遵循[5].</p><p>将此融合问题公式化为MAP估计，并假设先验分布具有统一形式，将后验概率分解为:</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-09-03.png"></p><p>分解可以可视化为如图3所示的贝叶斯网络。在零均值高斯似概率的假设下，观测的似然概率如下：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-10-27.png"></p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-10-49.png"></p><p>其中，<span class="math inline">\(\mathbf{r}_{k s}^{O}\)</span>、<span class="math inline">\(\mathbf{r}_{k}^{I}\)</span>、<span class="math inline">\(\mathbf{r}_{k}^{G}\)</span>分别代表里程计、惯性测量、全局匹配的残差。</p><p>坐标系定义如下：</p><ul><li>Local Frame: 局部坐标系，如使用utm投影，再划分，以某个位置作为原点</li><li>Global Frame: 全局坐标系，utm/wgs-84等</li><li>Submap Pose: 子图相对于局部坐标系的位姿</li><li>Lidar Local Frame: 激光雷达坐标系相对于局部坐标系的位姿</li></ul><p>如果定义如下：</p><ul><li>某帧相对于局部坐标系的位姿（待估计位姿）：<span class="math inline">\(\mathbf{x}_{k}^{L}=\left[\mathrm{R}_{k}^{L},\mathbf{t}_{k}^{L}\right]\)</span></li><li>局部坐标系到全局坐标系的变换（应该是已知的）：<span class="math inline">\(\mathbf{x}_{L}^{G}=\left[\mathrm{R}_{L}^{G}, \mathbf{t}_{L}^{G}\right]\)</span></li><li>由[5]中的LGM模块输出的全局位姿观测<span class="math inline">\(\mathbf{z}_{k}^{G}=\left[\mathrm{R}_{k}^{G}, \mathbf{t}_{k}^{G}\right]\)</span></li><li>全局残差可用如下表示： <span class="math inline">\(\left(\mathbf{r}_{k}^{G}\right)^{T}=\left[\log ^{T}\left(\mathrm{R}_{r G}\right), \mathbf{t}_{r G}^{T}\right]\)</span>，其中：</li></ul><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-26-37.png"></p><p>关于全局残差的协方差<span class="math inline">\(\Lambda_{k}^{G}\)</span>，我们将其写为：</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-11-29-55.png"></p><p>其中，</p><ul><li><span class="math inline">\(\Lambda^{G_\omega} \in \R^{3\times3}\)</span>是旋转协方差</li><li><span class="math inline">\(\Lambda^{G_{z}} \in \mathbb{R}^{1 \times 1}\)</span>是高度方差</li><li>上述协方差矩阵是恒定的对角矩阵，因为我们的LGM模块仅使用[5]中讨论的2D直方图滤波器来估计水平定位的不确定性</li><li>如[5]中的等式12所示，相应地针对每个帧k计算水平匹配协方差矩阵<span class="math inline">\(\Lambda_{k}^{G_{h}} \in \mathbb{R}^{2 \times 2}\)</span></li></ul><blockquote><p>注意，此处介绍的不确定性估计对于定位系统的性能至关重要，从而产生自适应融合</p></blockquote><p>关于里程计的残差问题，将会采用随着激光里程计的运行终结旧的子图更新并且创建新的子图。</p><p>由LIO模块输出的载体局部位姿与子图的之间的相对位姿关系约束<span class="math inline">\(\mathbf{z}_{ks}^O\)</span>被构建并存在于滑动窗口的生命周期中。相似的，如果由如下定义：</p><ul><li>某个子图的位姿:<span class="math inline">\(\mathbf{x}_{s}^{S}=\left[\mathrm{R}_{s}^{S}, \mathbf{t}_{s}^{S}\right]\)</span></li><li>某帧相对于子图的位姿观测: <span class="math inline">\(\mathbf{z}_{k s}^{O}=\left[\mathrm{R}_{k s}^{O}, \mathbf{t}_{k s}^{O}\right]\)</span></li><li>里程计残差可定义为： <span class="math inline">\(\left(\mathbf{r}_{k s}^{O}\right)^{T}=\left[\log ^{T}\left(R_{r O}\right), \mathbf{t}_{r O}^{T}\right]\)</span></li></ul><p>其中，</p><p><img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-14-54-18.png"></p><p>根据里程残差中的协方差<span class="math inline">\(\Lambda^O\)</span>，假设估计不确定性在所有帧之间均匀分布，我们在所有帧和子图上使用全局常数对角矩阵</p><p>惯性约束的预积分的处理方法与[30]中介绍的相同。 使用Ceres解算器[32]求解非线性最小二乘优化。</p><h1 id="实验">实验</h1><h2 id="传感配置">传感配置：</h2><ul><li>Velodyne HDL- 64E 360◦LiDAR</li><li>NovAtel PwrPak7D-E1 GNSS RTK receiver integrated with dual antennas and an Epson EG320N IMU.</li></ul><h2 id="基准参考">基准参考：</h2><p>没有用rtk，用的啥离线slam方法？</p><blockquote><p>The ground truth poses used in the evaluation are generated using offline LiDAR SLAM methods typically formulated as a large-scale global least-square optimization problem, which are beyond the scope of this work.</p></blockquote><h2 id="运行速度分析">运行速度分析</h2><ul><li>lio、pose graph fuse 运行在CPU上</li><li>全局激光匹配运行在FPGA上</li></ul><p> <img src="/2021/01/20/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BaiDu_LIO_ICRA2020%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2021-01-21-16-01-23.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lidar-inertial-odometry-aided-robust-lidar-localization-system-in-changing-city-scenes&quot;&gt;LiDAR Inertial Odometry Aided Robust LiDAR L
      
    
    </summary>
    
    
      <category term="文献阅读" scheme="http://yoursite.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>CUDA编程</title>
    <link href="http://yoursite.com/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/</id>
    <published>2020-12-24T14:05:33.000Z</published>
    <updated>2021-02-02T04:45:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="gpu硬件架构综述">GPU硬件架构综述</h1><h2 id="fermi-gpu">Fermi GPU</h2><p><img src="/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-05-29.png"></p><h2 id="相关术语">相关术语</h2><p><img src="/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-07-19.png"> <img src="/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-12-01.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;gpu硬件架构综述&quot;&gt;GPU硬件架构综述&lt;/h1&gt;
&lt;h2 id=&quot;fermi-gpu&quot;&gt;Fermi GPU&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/2020/12/24/CUDA%E7%BC%96%E7%A8%8B/2020-12-24-22-05-29.png&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>第六章-(1)-基于预积分的建图方法</title>
    <link href="http://yoursite.com/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/</id>
    <published>2020-12-21T00:36:46.000Z</published>
    <updated>2020-12-24T14:03:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于预积分优化的建图方法">基于预积分优化的建图方法</h1><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-45-26.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-48-29.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-51-20.png"></p><h1 id="预积分模型推导">预积分模型推导</h1><h2 id="导航方程">导航方程</h2><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-55-22.png"></p><h2 id="连续时间的预积分计算">连续时间的预积分计算</h2><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-08-58-03.png"></p><h2 id="离散时间的预积分计算中值积分">离散时间的预积分计算（中值积分）</h2><h3 id="预积分量的计算">预积分量的计算</h3><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-00-36.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-02-48.png"></p><h3 id="预积分的更新">预积分的更新</h3><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-06-09.png"></p><h3 id="预积分的方差传递">预积分的方差（传递）</h3><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-09-50.png"></p><h4 id="姿态误差微分方程推导">姿态误差微分方程推导</h4><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-19-27.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-22-17.png"></p><p><img src="/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-21-09-26-22.png"></p><blockquote><p>这是定义在local的误差角</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于预积分优化的建图方法&quot;&gt;基于预积分优化的建图方法&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/12/21/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>LiLi-om论文阅读</title>
    <link href="http://yoursite.com/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-12-09T03:34:33.000Z</published>
    <updated>2020-12-09T14:56:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="towards-high-performance-solid-state-lidar-inertial-odometry-and-mapping">Towards High-Performance Solid-State-LiDAR-Inertial Odometry and Mapping</h1><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-11-35-01.png"></p><blockquote><p>IN2LAAMA: Inertial Lidar Localization Autocalibration and Mapping. 用预积分去畸变，可以参考</p></blockquote><h1 id="系统架构">系统架构</h1><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-20-57-17.png"></p><ul><li>10hz激光雷达</li><li>Xsens MTi-670 200Hz imu</li></ul><ol type="1"><li>首先使用陀螺仪对点云去畸变（旋转）</li><li>提取平面、边缘线特征</li><li>基于点-线、点-面距离，进行scan-matching，求出相对运动后进一步对点云去畸变（平移）</li><li>选择关键帧策略</li><li>滑动窗口优化</li></ol><p>融合窗口通常包含了几个关键帧，当窗口滑动时，将对窗口内的关键帧状态进行优化，</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-21-03-30.png"></p><p>其中,</p><ul><li><span class="math inline">\(\breve{x}_k , \breve{q}_k\)</span>表示关键帧位姿</li><li><span class="math inline">\(\breve{v}_k\)</span>表示速度</li><li><span class="math inline">\(\breve{b}_k = [\breve{b}_{k,a}^T,\breve{b}_{k,g}^T]^T\)</span>表示imu的bias</li></ul><p>最终，维护一个全局的位姿图，对所有的lidar关键帧位姿进行整合</p><h1 id="特征点提取">特征点提取</h1><blockquote><p>这里关于Livox激光雷达的特征提取</p></blockquote><p>提出出来的边缘线特征和平面特征对前端里程计以后后端滑动窗口都有用</p><p>为了量化传感器融合过程中每个LiDAR残差的贡献，根据关联质量提出了度量加权函数，如下：</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-21-18-15.png"></p><p>其中，</p><ul><li><span class="math inline">\(o\)</span>表示特征（e表示边缘，s表示平面）</li><li>对于边缘线特征，<span class="math inline">\(\nu_e, n_e\)</span>分别表示在<span class="math inline">\(p_k^l\)</span>处的边缘线的方向向量，和最近5个边缘点特征所近似得到的边缘线</li><li>对于平面特征，<span class="math inline">\(\nu_s,n_s\)</span>分别表示在点<span class="math inline">\(p_k^l\)</span>处的平面法向量和由最近5个点形成的</li><li><span class="math inline">\(\gamma(p_k^l),\gamma_j\)</span>分别代表特征点<span class="math inline">\(p_k^l\)</span>及其关联的最近5个特征点的关联值</li></ul><p>因此，建议的度量加权函数考虑了特征关联的几何和外观一致性</p><h1 id="基于关键帧的imu-lidar紧耦合滑动窗口优化">基于关键帧的imu-lidar紧耦合滑动窗口优化</h1><p>基于关键帧的策略首先应用于视觉slam，LIO-SAM，使用isam2对前端激光前端里程计的关键帧和imu预积分约束进行融合，liom中紧密耦合的LiDAR惯性里程计系统通过滑动窗口优化实现了LiDAR和预集成IMU测量的直接融合，但是实时性不够，因为融合了每一帧lidar扫描</p><h2 id="关键帧策略">关键帧策略</h2><p>因此，保持后端直接LiDAR-惯性融合优化方案的稀疏性非常重要，如图5所示，提出的融合方案利用关键帧建立滑动窗口，其中，激光雷达和imu预积分观测使用非线性优化的方法进行融合。</p><p>但是关键帧的选取标准会影响前端里程计的准确性，由于imu积分在相邻两关键帧之间存在漂移，因此，提出了两个准则：</p><ul><li>当前帧的特征与局部特征地图重叠率&lt;60%</li><li>如果最后一个关键帧的时间差大于指定阈值</li></ul><p>在窗口优化后向前滑动时，构造一个局部因子图，对两个最旧的关键帧位姿作为约束，而regular-frame帧位姿则通过imu测量作为初始化值。使用一个小规模的因子图优化以获取与激光雷达采样频率一致的regular-frame位姿</p><h2 id="滑动窗口">滑动窗口</h2><p>目标是求解式(1)中的滑动窗口内关键帧状态，方法是通过求解激光特征点和imu预积分约束构成的非线性优化问题，使用一个包含三个分量的最大后验(MAP)目标函数：</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-21-47-49.png"></p><p>其中，</p><ul><li><span class="math inline">\(\breve{X}=[\breve{x}_1^T,\cdots,\breve{x}_2^T]^T \in \R^{15\times \tau_w}\)</span>表示滑动窗口中的关键帧状态，<span class="math inline">\(\tau_w\)</span>表示滑窗大小</li><li><span class="math inline">\(\mathcal{R}_{p}(\breve{X})\)</span>表示由于滑动窗口滑动时进行marginalized得到的关于观测的先验项</li><li><span class="math inline">\(\mathcal{R}_L(\breve{x}_k^w,\breve{p}_{k,i}^l,\breve{\Mu}^w)\)</span>表示激光雷达残差项（根据待估计的关键帧位姿<span class="math inline">\(\breve{x}_k^w\)</span>将观测到的点<span class="math inline">\(\breve{p}_{k,i}^l\)</span>对齐到局部特征点地图<span class="math inline">\(\breve{\Mu}^w\)</span>），m表示特征关联数</li><li>局部特征点地图<span class="math inline">\(\breve{\Mu}^w\)</span>结合了最近30帧关键帧观察到的特征</li><li><span class="math inline">\(\mathcal{R}_J(\breve{x}_k,\hat{z}_{k+1}^k)\)</span>是第k个关键帧以及imu数据从第k帧到k+1帧的imu预积分约束所构建的残差项</li></ul><h3 id="先验因子">先验因子</h3><p>为了在不造成实质性信息损失的情况下限制LiDAR惯性融合的计算负担，我们在基于关键帧的窗口中利用边缘化，vins-mono中，使用Schur-complement对最旧的关键帧及其观测进行边缘化，相应的计算得到一个新的先验，并将其添加到一存在的先验因子的顶部。</p><h3 id="激光雷达残差">激光雷达残差</h3><p>加权的点-线、点-面距离</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-22-36-30.png"></p><h3 id="imu观测残差预积分误差">imu观测残差（预积分误差）</h3><p>为了避免每次优化窗口滑动时都重新传播IMU状态，所以将两个连续的关键帧k和k+1之间的imu原始数据进行积分，并将预积分看作是两个关键帧之间的相对位姿观测，可以得到预积分误差：</p><p><img src="/2020/12/09/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/Lili-om%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-09-22-38-47.png"></p><p>其中，</p><ul><li><span class="math inline">\(\Delta \tau_k\)</span>表示第k关键帧与k+1帧的时间间隔</li><li><span class="math inline">\([\cdot]_{2:4}\)</span>表示取四元数向量中的最后3个元素</li><li><span class="math inline">\(\hat{z}_{k+1}^{k}=[\hat{\alpha}_{k+1}^{kT},\hat{\beta}_{k+1}^{kT},\hat{\gamma}_{k+1}^{kT}]\)</span>表示从第k帧到第k+1帧的imu预积分量</li><li>由于篇幅所限，论文不提供IMU预积分的推导和相应的噪声协方差<span class="math inline">\(C_{k+1}^{k}\)</span>,具体可参考vins-mono</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;towards-high-performance-solid-state-lidar-inertial-odometry-and-mapping&quot;&gt;Towards High-Performance Solid-State-LiDAR-Inertial Odomet
      
    
    </summary>
    
    
      <category term="文献阅读" scheme="http://yoursite.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>LINS论文阅读</title>
    <link href="http://yoursite.com/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-12-07T12:52:33.000Z</published>
    <updated>2020-12-09T03:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lins-a-lidar-inertial-state-estimator-for-robust-and-efficient-navigation">LINS: A Lidar-Inertial State Estimator for Robust and Efficient Navigation</h1><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-20-54-00.png"></p><h1 id="eskf模型">ESKF模型</h1><p>坐标系定义：</p><ul><li><span class="math inline">\(\mathcal{F}_w\)</span>表示固定的世界坐标系</li><li><span class="math inline">\(\mathcal{F}_{bk}\)</span>表示第k个激光雷达时间步的imu坐标系</li><li><span class="math inline">\(\mathcal{F}_{lk}\)</span>表示第k个激光雷达时间步的lidar坐标系</li><li>local frame是指前一个激光雷达时间步的imu坐标系</li></ul><h2 id="状态定义">状态定义</h2><ul><li><span class="math inline">\(x_w^{bk}\)</span>表示<span class="math inline">\(\mathcal{F}_{bk}\)</span>坐标系到<span class="math inline">\(\mathcal{F}_w\)</span>世界坐标系的变换</li><li><span class="math inline">\(x_{bk+1}^{bk}\)</span>表示从<span class="math inline">\(\mathcal{F}_{bk+1}\)</span>坐标系到<span class="math inline">\(\mathcal{F}_{bk}\)</span>坐标系的变换</li></ul><p><span class="math display">\[    x_w^{bk} = [p_w^{bk},q_w^{bk}]\]</span></p><p><span class="math display">\[    x_{bk+1}^{bk} = [p_{bk+1}^{bk},v_{bk+1}^{bk},q_{bk+1}^{bk},b_a,b_g,g^{bk}]\]</span></p><h2 id="误差状态定义">误差状态定义</h2><p><span class="math display">\[    \delta x=[\delta p, \delta v ,\delta \theta, \delta b_a , \delta b_g ,\delta g]\]</span></p><p>根据误差状态卡尔曼，一旦<span class="math inline">\(\delta x\)</span>被估计出来，我们就可以获得最终的结果<span class="math inline">\(x_{bk+1}^{bk}\)</span>，通过向state nominal的<span class="math inline">\(^-x_{bk+1}^{bk}\)</span>注入误差状态<span class="math inline">\(\delta\)</span>，即：</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-11-39.png"></p><h2 id="状态传播预测">状态传播（预测）</h2><p>这一步进行如下参数的传播</p><ul><li>误差状态<span class="math inline">\(\delta x\)</span></li><li>误差状态协防差矩阵<span class="math inline">\(P_k\)</span></li><li>state nominal的<span class="math inline">\(^-x_{bk+1}^{bk}\)</span></li></ul><p>当新的imu测量到达，线性连续时间模型如下：</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-14-58.png"></p><p>其中，</p><ul><li><span class="math inline">\(w=[n_a^T,n_g^G,n_{ba}^T,n_{bg}^T]\)</span>，分别表示高斯噪声模型，与VINS-Mono一致</li><li><span class="math inline">\(F_t\)</span>是误差状态转移矩阵</li><li><span class="math inline">\(G_t\)</span>是噪声雅克比矩阵</li></ul><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-21-26.png"></p><blockquote><p>论文公式有误，详细可参考 误差状态卡尔曼P69——The error state Jacobian and perturbation matrices 式(311)</p></blockquote><p>其中，</p><ul><li><span class="math inline">\([\cdot]_{\times} \in \R^{3\times 3}\)</span>表示将3D向量转换成反对称矩阵</li><li><span class="math inline">\(R_t^{bk}\)</span>表示将k时刻的imu坐标系转换到<span class="math inline">\(\mathcal{F}_{bk}\)</span>坐标系的旋转</li><li><span class="math inline">\(\hat{a}^t,\hat{\omega}_t\)</span>表示去除bias以及(重力影响?)的加速度计输出和陀螺仪输出</li></ul><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-27-08.png"></p><p>对式(5)进行离散化，得到离散时间的传播方程(预测)</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-27-47.png"></p><p>其中,</p><ul><li><span class="math inline">\(\Delta_t=t_\tau-t_{\tau-1}\)</span></li><li><span class="math inline">\(t_\tau,t_{\tau-1}\)</span>是imu数据时间戳</li><li>Q表示噪声w的协方差矩阵，可以由离线的传感器参数标定获取</li></ul><h2 id="更新">更新</h2><blockquote><p>文章的主要贡献在此</p></blockquote><p>在iekf里面，更新步骤其实可以与优化问题建立关联：</p><blockquote><p>参考文献:</p><ul><li>A review of point cloud registration algorithms for mobile robotics.</li><li>Iterated extended kalman filter based visual-inertial odometry using direct photometric feedback.</li></ul></blockquote><p>即以误差状态作为待求解的变量<span class="math inline">\(\delta x\)</span></p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-39-00.png"></p><p>其中，</p><ul><li><span class="math inline">\(f(\cdot)\)</span>是残差函数，其输出是点——线、点——面距离的对叠向量</li><li><span class="math inline">\(||\cdot||\)</span>是马氏距离</li><li><span class="math inline">\(J_k\)</span>是残差函数<span class="math inline">\(f(\cdot)\)</span>对观测噪声的雅克比</li><li><span class="math inline">\(M_k\)</span>是观测噪声的协方差矩阵</li></ul><p>当给定一个<span class="math inline">\(x_{bk+1}^{bk}\)</span>，<span class="math inline">\(f(\cdot)\)</span>中关于点<span class="math inline">\(p_i^{lk+1}\)</span>（<span class="math inline">\(\mathcal{F}_{lk+1}\)</span>坐标系中的第i个点）的误差项可以描述如下:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-45-57.png"></p><blockquote><p>就是LOAM的距离计算公式</p></blockquote><p>然后有:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-47-18.png"></p><p>其中,</p><ul><li><span class="math inline">\(\hat{p}_i^{lk}\)</span>表示将点<span class="math inline">\(p_i^{lk+1}\)</span>从<span class="math inline">\(\mathcal{F}_{lk+1}\)</span>坐标系转换到<span class="math inline">\(\mathcal{F}_{lk}\)</span>坐标系后的点</li><li><span class="math inline">\(R_l^b,p_l^b\)</span>表示激光雷达到imu的外參(可离线标定获取)</li></ul><p>关于式(13)的物理解释是：对于一个边缘线上的点，它描述了点<span class="math inline">\(\hat{p}_i^{lk}\)</span>到与他相关联的边缘线<span class="math inline">\(p_a^{lk}p_b^{lk}\)</span>，对于平面点，同理 (就是LOAM嘛)</p><p>然后使用iekf来求解式(12)所描述的优化问题:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-21-52-01.png"></p><p>其中，</p><ul><li><span class="math inline">\(\Delta x_j\)</span>表示在第j次迭代的矫正，即求解出来的增量</li><li><span class="math inline">\(H_{k,j}\)</span>表示<span class="math inline">\(f(^-x_{bk+1}^{bk}\boxplus\delta x_j)\)</span>关于<span class="math inline">\(\delta x_j\)</span>的雅克比</li></ul><blockquote><p>注意到，在每一次迭代中，将重新关联边缘线特征和平面特征，这样就可以重新计算<span class="math inline">\(H_{k,j},J_{k,j}和K_{k,j}\)</span>，相当于更新线性化点，重新关联特征</p></blockquote><p>当<span class="math inline">\(f(x_{bk+1}^{bk})\)</span>降低到一个特定的阈值，就对协方差<span class="math inline">\(P_k\)</span>进行更新，结束迭代</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-22-10-58.png"></p><p>使用式(4)，即可获取到最终的结果<span class="math inline">\(x_{bk+1}^{bk}\)</span>，然后还可以进行去畸变操作。</p><p>最后，可以对下一个状态<span class="math inline">\(x_{bk+2}^{bk+1}\)</span>进行初始化:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-22-18-51.png"></p><p>其中，</p><ul><li><span class="math inline">\(q_0\)</span>表示单位四元数</li><li><span class="math inline">\(v_{bk+1}^{bk+1}=R_{bk}^{bk+1}v_{bk+1}^{bk}\)</span></li><li><span class="math inline">\(g^{bk+1}=R_{bk}^{bk+1}g^{bk}\)</span></li></ul><p>注意到，在协方差矩阵中，速度、bias、重力都保持，而其他关于相对位姿的项都被置零，因为相对于自身坐标系没有不确定性.</p><h2 id="状态补偿">状态补偿</h2><p>每一个更新步完成，需要对全局位姿<span class="math inline">\(x_w^{bk}\)</span>进行更新，如下:</p><p><img src="/2020/12/07/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/LINS%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-12-07-22-37-02.png"></p><h2 id="初始化">初始化</h2><ul><li>初始加速度bias，Lidar-imu外參都通过离线标定获取</li><li>初始的陀螺仪bias通过求均值获取</li><li>初始roll和pitch在运动之前可通过去除bias的加速度计算得到</li><li>初始的重力向量使用前面获取的roll和pitch将导航坐标系的重力向量转换到载体坐标系(imu系)获取</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lins-a-lidar-inertial-state-estimator-for-robust-and-efficient-navigation&quot;&gt;LINS: A Lidar-Inertial State Estimator for Robust and Eff
      
    
    </summary>
    
    
      <category term="文献阅读" scheme="http://yoursite.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章-(3)-补充内容</title>
    <link href="http://yoursite.com/2020/12/07/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-3/"/>
    <id>http://yoursite.com/2020/12/07/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-3/</id>
    <published>2020-12-07T04:36:46.000Z</published>
    <updated>2020-12-07T07:35:06.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>IMU噪声模型</title>
    <link href="http://yoursite.com/2020/11/27/IMU%E7%9B%B8%E5%85%B3/IMU%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/11/27/IMU%E7%9B%B8%E5%85%B3/IMU%E5%99%AA%E5%A3%B0%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-11-27T05:05:29.000Z</published>
    <updated>2020-11-27T05:05:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kalibr">Kalibr</h1><p>Kalibr使用的IMU观测模型包含两种误差：</p><ul><li><code>n</code>，白噪声（波动较快）</li><li><code>b</code>，缓慢变化的bias</li></ul><p>因此，以陀螺仪为例子，角速度测量可写成：</p><p><span class="math display">\[    \tilde{\omega}(t) = \omega(t) + b(t) +n(t)\]</span></p><h2 id="附加白噪声">附加白噪声</h2><h3 id="连续时间">连续时间</h3><p>可以使用<code>零均值</code>、<code>独立</code>、<code>连续时间</code>的高斯白噪声来描述，即</p><p><span class="math display">\[ E[n(t)] =0\]</span></p><p><span class="math display">\[ E[n(t_1)n(t_2)]=\sigma_g^2 \delta(t_1-t_2)\]</span></p><ul><li><span class="math inline">\(\sigma_g\)</span>越大，表明陀螺仪测量越<code>嘈杂</code></li><li>这是连续时间的模型</li></ul><h3 id="离散化时间">离散化时间</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kalibr&quot;&gt;Kalibr&lt;/h1&gt;
&lt;p&gt;Kalibr使用的IMU观测模型包含两种误差：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;，白噪声（波动较快）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;，缓慢变化的bias&lt;/li&gt;
&lt;/ul&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="IMU相关" scheme="http://yoursite.com/categories/IMU%E7%9B%B8%E5%85%B3/"/>
    
    
  </entry>
  
  <entry>
    <title>滤波器分析——状态方程和观测方程</title>
    <link href="http://yoursite.com/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_2_%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_2_%E6%BB%A4%E6%B3%A2%E5%99%A8%E5%88%86%E6%9E%90/</id>
    <published>2020-11-20T13:36:46.000Z</published>
    <updated>2020-11-22T04:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于误差状态的滤波分析">基于误差状态的滤波分析</h1><p>根据《惯导解算原理——捷联惯导更新算法及误差分析》分析，已经得到了三个误差方程：</p><p><strong>姿态误差方程</strong></p><p><span class="math display">\[\begin{aligned}    \dot{\phi} = \phi \times \omega_{in}^n - \delta \omega_{ib}^n\end{aligned}\]</span></p><p><strong>速度误差方程</strong></p><p><span class="math display">\[\begin{aligned}    \delta \dot{V}^n = \delta f^n + (f^n \times)(\phi)\end{aligned}\]</span></p><p><strong>位置误差方程</strong></p><p><span class="math display">\[\begin{aligned}    \delta \dot{P} = \delta V\end{aligned}\]</span></p><p>现在，对上面的方程进行展开</p><h2 id="姿态误差方程矩阵形式">姿态误差方程（矩阵形式）</h2><p>这里姿态误差取全局误差角<span class="math inline">\(\phi=[\phi_E , \phi_N, \phi_U]\)</span>，表示的是从 n 系至 n'系的等效旋转矢量，即 n'系到 n系的旋转变换</p><p>由于:</p><p><span class="math display">\[\begin{aligned}    \phi=\begin{bmatrix}        \phi_E &amp; \phi_N &amp; \phi_U    \end{bmatrix}^T\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    \omega_{ie}^n=\begin{bmatrix}        0 &amp; \omega_{ie} \cos L &amp; \omega_{ie} \cos L    \end{bmatrix}^T\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    \delta \omega_{ib}^n= C_b^n    \begin{bmatrix}        \epsilon_x \\        \epsilon_y \\         \epsilon_z    \end{bmatrix}\end{aligned}\]</span></p><p>其中,</p><ul><li><span class="math inline">\(\omega_{ie}\)</span>为地球自转角速度</li><li><span class="math inline">\(\epsilon\)</span>为陀螺仪bias</li></ul><p>因此，姿态误差方程<span class="math inline">\(\dot{\phi}=\phi \times \omega_{ie}^n - \delta \omega_{ib}^n\)</span>可写成矩阵形式：</p><p><span class="math display">\[\begin{aligned}    \begin{bmatrix}        \dot{\phi}_E \\ \dot{\phi}_N \\ \dot{\phi}_U    \end{bmatrix} =     \begin{bmatrix}        0 &amp; -\phi_U &amp; \phi_N \\        \phi_U &amp; 0 &amp; -\phi_E \\        -\phi_N &amp; \phi_E &amp; 0    \end{bmatrix}    \begin{bmatrix}        0 \\ \omega_{ie} \cos L \\ \omega_{ie} \sin L    \end{bmatrix}    - C_b^n    \begin{bmatrix}        \epsilon_x \\ \epsilon_y \\ \epsilon_z    \end{bmatrix}\end{aligned}\]</span></p><h2 id="速度误差方程矩阵形式">速度误差方程（矩阵形式）</h2><p>由于：</p><p><span class="math display">\[    f^n=[f_E,f_N,f_U]^T\]</span></p><p>且比力误差为加速度计bias</p><p><span class="math display">\[\begin{aligned}    \delta f^n=C_b^n    \begin{bmatrix}        \triangledown_x \\        \triangledown_y \\        \triangledown_z    \end{bmatrix}\end{aligned}\]</span></p><p>其中，<span class="math inline">\(\triangledown\)</span>为加速度计的bias</p><p>因此，速度误差方程<span class="math inline">\(\delta \dot{V}=f^n \times \phi + \delta f^n\)</span>可写成矩阵形式如下：</p><p><span class="math display">\[\begin{aligned}    \begin{bmatrix}        \delta \dot{V}_E \\        \delta \dot{V}_N \\        \delta \dot{V}_U    \end{bmatrix}    =    \begin{bmatrix}        0 &amp; -f_U &amp; f_N \\        f_U &amp; 0 &amp; -f_E \\        -f_N &amp; f_E &amp; 0    \end{bmatrix}    \begin{bmatrix}        \phi_E \\ \phi_N \\ \phi_U    \end{bmatrix}    +C_b^n    \begin{bmatrix}        \triangledown_x \\        \triangledown_y \\        \triangledown_z    \end{bmatrix}\end{aligned}\]</span></p><h2 id="位置误差方程矩阵形式">位置误差方程（矩阵形式）</h2><p>直接把位置误差方程<span class="math inline">\(\delta \dot{P}=\delta V\)</span>写成矩阵形式:</p><p><span class="math display">\[\begin{aligned}    \begin{bmatrix}        \delta \dot{P}_E \\        \delta \dot{P}_N \\        \delta \dot{P}_U    \end{bmatrix}        =    \begin{bmatrix}        \delta V_E \\        \delta V_N \\        \delta V_U    \end{bmatrix}\end{aligned}\]</span></p><h2 id="状态方程">状态方程</h2><p>状态方程基本形式：</p><p><span class="math display">\[    \dot{X}=F_tX+B_tW\]</span></p><p>对于非线性系统,矩阵<span class="math inline">\(F_t\)</span>是误差状态导数对误差状态向量求偏导</p><hr><p>取状态向量:</p><p><span class="math display">\[\begin{aligned}    X=    \begin{bmatrix}        \delta P_{3x1} \\        \delta V_{3x1} \\        \phi_{3x1} \\        \epsilon_{3x1} \\        \triangledown_{3x1}    \end{bmatrix}_{15x1}\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\delta P\)</span>表示enu位置误差量</li><li><span class="math inline">\(\delta V\)</span>表示enu速度误差量</li><li><span class="math inline">\(\phi\)</span> 表示导航坐标系n系与计算坐标系n'系的等效旋转矢量偏差</li><li><span class="math inline">\(\epsilon\)</span>表示陀螺仪bias</li><li><span class="math inline">\(\triangledown\)</span>表示加速度计bias</li></ul><p>根据前面推导的误差状态方程，可以得到矩阵<span class="math inline">\(F_t\)</span>:</p>$$<span class="math display">\[\begin{aligned}    F_t &amp;=    \begin{bmatrix}        \frac{\partial \delta \dot{P}}{\partial \delta P} &amp;         \frac{\partial \delta \dot{P}}{\partial \delta V} &amp;        \frac{\partial \delta \dot{P}}{\partial \delta \phi} &amp;         \frac{\partial \delta \dot{P}}{\partial \delta \epsilon} &amp;        \frac{\partial \delta \dot{}}{\partial \delta \triangledown}  \\        \frac{\partial \delta \dot{V}}{\partial \delta P} &amp;         \frac{\partial \delta \dot{V}}{\partial \delta V} &amp;        \frac{\partial \delta \dot{V}}{\partial \delta \phi} &amp;         \frac{\partial \delta \dot{V}}{\partial \delta \epsilon} &amp;        \frac{\partial \delta \dot{V}}{\partial \delta \triangledown}  \\        \frac{\partial \delta \dot{\phi}}{\partial \delta P} &amp;         \frac{\partial \delta \dot{\phi}}{\partial \delta V} &amp;        \frac{\partial \delta \dot{\phi}}{\partial \delta \phi} &amp;         \frac{\partial \delta \dot{\phi}}{\partial \delta \epsilon} &amp;        \frac{\partial \delta \dot{\phi}}{\partial \delta \triangledown}  \\        \frac{\partial \delta \dot{\epsilon}}{\partial \delta P} &amp;         \frac{\partial \delta \dot{\epsilon}}{\partial \delta V} &amp;        \frac{\partial \delta \dot{\epsilon}}{\partial \delta \phi} &amp;         \frac{\partial \delta \dot{\epsilon}}{\partial \delta \epsilon} &amp;        \frac{\partial \delta \dot{\epsilon}}{\partial \delta \triangledown}  \\        \frac{\partial \delta \dot{\triangledown}}{\partial \delta P} &amp;         \frac{\partial \delta \dot{\triangledown}}{\partial \delta V} &amp;        \frac{\partial \delta \dot{\triangledown}}{\partial \delta \phi} &amp;         \frac{\partial \delta \dot{\triangledown}}{\partial \delta \epsilon} &amp;        \frac{\partial \delta \dot{\triangledown}}{\partial \delta \triangledown}     \end{bmatrix} \\    &amp;=    \begin{bmatrix}        0_{3x3} &amp; I_{3x3} &amp; 0_{3x3} &amp; 0_{3x3} &amp; 0_{3x3} \\        0_{3x3} &amp; 0_{3x3} &amp; F_{23} &amp; 0_{3x3} &amp; C_b^n \\        0_{3x3} &amp; 0_{3x3} &amp; F_{33} &amp; -C_b^n &amp; 0_{3x3} \\        &amp; &amp;  0_{3x15} &amp; &amp; \\        &amp; &amp; 0_{3x15} &amp; &amp;    \end{bmatrix}\end{aligned}\]</span><p>$$</p><p><span class="math display">\[\begin{aligned}    F_{23}=    \begin{bmatrix}        0 &amp; -f_U &amp; f_N \\        f_U &amp; 0 &amp; -f_E \\        -f_N &amp; f_E &amp; 0    \end{bmatrix}\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    F_{33}=    \begin{bmatrix}        0 &amp; \omega_{ie} \sin L &amp; -\omega_{ie} \cos L \\        -\omega_{ie} \sin L &amp; 0 &amp; 0 \\        \omega_{ie} \cos L &amp; 0 &amp; 0    \end{bmatrix}\end{aligned}\]</span></p><p>取噪声向量<span class="math inline">\(W\)</span>:</p><p><span class="math display">\[\begin{aligned}    W&amp;=    \begin{bmatrix}        W_{gyro} \\        W_{acc}    \end{bmatrix} \\    &amp;=    \begin{bmatrix}        w_{gx} \\ w_{gy} \\ w_{gz} \\        w_{ax} \\ w_{ay} \\ w_{az}    \end{bmatrix}\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(W_{gyro}\)</span>是陀螺仪噪声</li><li><span class="math inline">\(W_{acc}\)</span>是加速度计噪声</li></ul><p>由于噪声是跟bias通一个通道引入的，因此矩阵<span class="math inline">\(B_t\)</span>可以直接从<span class="math inline">\(F_t\)</span>矩阵的后两列取，也可以直接算:</p><p><span class="math display">\[\begin{aligned}    B_t=    \begin{bmatrix}        0_{3x3} &amp; 0_{3x3} \\        0_{3x3} &amp; C_b^n \\        -C_b^n &amp; 0_{3x3} \\        0_{6x3} &amp; 0_{6x3}    \end{bmatrix}\end{aligned}\]</span></p><h2 id="观测方程基于点云配准获得观测">观测方程（基于点云配准获得观测）</h2><p>观测方程基本形式：</p><blockquote><p><strong>这个方程其实是利用预测的状态向量X来计算出一个预测的Y</strong>，后面再根据真实的观测Y与这个预测的Y做差，求得差值</p></blockquote><p><span class="math display">\[    Y=G_tX+C_tN\]</span></p><p>由于这是观测，因此<span class="math inline">\(G_t\)</span>矩阵不是偏导</p><hr><p>假设观测量有位置和失准角，因此取观测向量<span class="math inline">\(Y\)</span>:</p><p><span class="math display">\[\begin{aligned}    Y=    \begin{bmatrix}        \delta P \\        \phi    \end{bmatrix}\end{aligned}\]</span></p><p>又由于</p><p><span class="math display">\[\begin{aligned}    X=    \begin{bmatrix}        \delta P_{3x1} \\        \delta V_{3x1} \\        \phi_{3x1} \\        \epsilon_{3x1} \\        \triangledown_{3x1}    \end{bmatrix}_{15x1}\end{aligned}\]</span></p><p>观测方程中的N为观测噪声：</p><p><span class="math display">\[\begin{aligned}    N &amp;=    \begin{bmatrix}        n_{P_{3x1}} \\        n_{\phi_{3x1}}    \end{bmatrix} \\    &amp;=    \begin{bmatrix}        n_{P_E} \\        n_{P_N} \\        n_{P_U} \\        n_{\phi_E} \\        n_{\phi_N} \\        n_{\phi_U}    \end{bmatrix}\end{aligned}\]</span></p><p>因此有：</p><p><span class="math display">\[\begin{aligned}    G_t =    \begin{bmatrix}        I_{3x3} &amp; 0_{3x3} &amp; 0_{3x3} &amp; 0_{3x6} \\        0_{3x3} &amp; 0_{3x3} &amp; I_{3x3} &amp; 0_{3x6}    \end{bmatrix}\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    C_t=    \begin{bmatrix}        I_{3x3} &amp; 0_{3x3} \\        0_{3x3} &amp; I_{3x3}    \end{bmatrix}\end{aligned}\]</span></p><p>获取真实观测量Y时，需要计算失准角<span class="math inline">\(\phi\)</span>，具体计算方法如下：</p><ol type="1"><li>先计算误差矩阵<span class="math inline">\(C_n^{n&#39;}\)</span></li></ol><p><span class="math display">\[\begin{aligned}    &amp; \because C_b^n=C_{n&#39;}^n C_b^{n&#39;} \\    &amp; \therefore C_n^{n&#39;} = C_b^{n&#39;}(C_b^n)^T\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(C_b^{n&#39;}\)</span>为当前时刻位姿的预测值</li><li><span class="math inline">\(C_b^n\)</span>为姿态矩阵的观测值（如点云匹配定位的结果）</li></ul><ol start="2" type="1"><li>根据罗德里格斯公式，获取<span class="math inline">\(\phi\)</span></li></ol><p><span class="math display">\[    C_n^{n&#39;} \approx I-(\phi \times)\]</span></p><h2 id="观测方程基于点云配准轮速计获得观测">观测方程（基于点云配准+轮速计获得观测）</h2><p>观测方程基本形式：</p><blockquote><p><strong>这个方程其实是利用预测的状态向量X来计算出一个预测的Y</strong>，后面再根据真实的观测Y与这个预测的Y做差，求得差值</p></blockquote><p><span class="math display">\[    Y=G_tX+C_tN\]</span></p><p>由于这是观测，因此<span class="math inline">\(G_t\)</span>矩阵不是偏导</p><p>假设已知轮速计观测误差方程如下（注意不是状态误差方程，因此跟导数没关系）：</p><blockquote><p>观测误差方程具体推导参见：*</p></blockquote><p><span class="math display">\[    \delta V_b = C_n^b \delta V_n - C_n^b (V_n \times)\phi\]</span></p><p>有了观测误差方程后，可以对观测方程进行重写，步骤如下：</p><ol type="1"><li>确定状态向量</li></ol><p><span class="math display">\[\begin{aligned}    Y=    \begin{bmatrix}        \delta P \\        \phi    \end{bmatrix}\end{aligned}\]</span></p><ol start="2" type="1"><li>确定观测向量</li></ol><p><span class="math display">\[\begin{aligned}    Y=    \begin{bmatrix}        \delta P \\        \delta V_b \\        \phi    \end{bmatrix}\end{aligned}\]</span></p><p>其中，</p><ul><li>相比于之前的观测向量，增加了<span class="math inline">\(\delta V_b\)</span>，表示根据当前状态预测得到的载体轮速 与 轮速计测量值的差值</li></ul><p>误差量<span class="math inline">\(\delta V_b\)</span>计算公式如下：</p><p><span class="math display">\[\begin{aligned}        \delta V_b = \tilde{V_b}-V_b=\tilde{C}_n^b \tilde{V}_n -        \begin{bmatrix}            0 \\ v_m \\ 0        \end{bmatrix}\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\tilde{C}_n^b\tilde{V}_n\)</span>表示利用当前的状态值计算得到轮速的预测值</li><li><span class="math inline">\(V_b=V_m=[0,v_m,0]^T\)</span>表示轮速计实际观测值(假设轮速计观测是右x-前y-上z坐标系)</li></ul><ol start="3" type="1"><li>重写观测方程</li></ol><p><span class="math display">\[    Y=G_tX+C_tN\]</span></p><p>其中，矩阵<span class="math inline">\(G_t\)</span>变成如下形式：</p><p><span class="math display">\[\begin{aligned}    G_t =    \begin{bmatrix}        I_{3x3} &amp; 0_{3x3} &amp; 0_{3x3} &amp; 0_{3x6} \\        0_{3x3} &amp; C_n^b &amp; -C_n^b(V_n \times) &amp; 0_{3x6}\\        0_{3x3} &amp; 0_{3x3} &amp; I_{3x3} &amp; 0_{3x6}    \end{bmatrix}\end{aligned}\]</span></p><blockquote><p>与之前的<span class="math inline">\(G_t\)</span>矩阵相比，增加了中间那行</p></blockquote><p>矩阵<span class="math inline">\(C_t\)</span>变成如下：</p><p><span class="math display">\[\begin{aligned}    C_t=    \begin{bmatrix}        I_{3x3} &amp; 0_{3x3} &amp; 0_{3x3}\\        0_{3x3} &amp; I_{3x3} &amp; 0_{3x3} \\        0_{3x3} &amp; 0_{3x3} &amp; I_{3x3}    \end{bmatrix}\end{aligned}\]</span></p><p>观测噪声向量变成如下：</p><p><span class="math display">\[\begin{aligned}    N &amp;=    \begin{bmatrix}        n_{P_{3x1}} \\        n_{Vb_{3x1}} \\        n_{\phi_{3x1}}    \end{bmatrix} \\    &amp;=    \begin{bmatrix}        n_{P_E} \\        n_{P_N} \\        n_{P_U} \\        n_{V_{bx}} \\        n_{V_{by}} \\        n_{V_{bz}} \\        n_{\phi_E} \\        n_{\phi_N} \\        n_{\phi_U}    \end{bmatrix}\end{aligned}\]</span></p><blockquote><p>如果考虑imu安装误差的情况，具体推导参见： *</p></blockquote><h2 id="观测方程基于gps获得位置观测">观测方程（基于GPS获得位置观测）</h2><p>观测方程基本形式：</p><p><span class="math display">\[    Y=G_tX+C_tN\]</span></p><p>由于这是观测，因此<span class="math inline">\(G_t\)</span>矩阵不是偏导</p><hr><p>假设观测量是GPS给出的位置，因此取观测向量<span class="math inline">\(Y\)</span>:</p><p><span class="math display">\[\begin{aligned}    Y=    \begin{bmatrix}        \delta P \\    \end{bmatrix}\end{aligned}\]</span></p><p>又由于</p><p><span class="math display">\[\begin{aligned}    X=    \begin{bmatrix}        \delta P_{3x1} \\        \delta V_{3x1} \\        \phi_{3x1} \\        \epsilon_{3x1} \\        \triangledown_{3x1}    \end{bmatrix}_{15x1}\end{aligned}\]</span></p><p>观测方程中的N为观测噪声：</p><p><span class="math display">\[\begin{aligned}    N &amp;=    \begin{bmatrix}        n_{P_{3x1}}    \end{bmatrix} \\    &amp;=    \begin{bmatrix}        n_{P_E} \\        n_{P_N} \\        n_{P_U}    \end{bmatrix}\end{aligned}\]</span></p><p>因此有：</p><p><span class="math display">\[\begin{aligned}    G_t =    \begin{bmatrix}        I_{3x3} &amp; 0_{3x3} &amp; 0_{3x3} &amp; 0_{3x6}     \end{bmatrix}\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}    C_t&amp;=    \begin{bmatrix}        I_{3x3}    \end{bmatrix} \\    &amp;=    \begin{bmatrix}        1 &amp; 0 &amp; 0 \\        0 &amp; 1 &amp; 0 \\        0 &amp; 0 &amp; 1     \end{bmatrix}\end{aligned}\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于误差状态的滤波分析&quot;&gt;基于误差状态的滤波分析&lt;/h1&gt;
&lt;p&gt;根据《惯导解算原理——捷联惯导更新算法及误差分析》分析，已经得到了三个误差方程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;姿态误差方程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math di
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>滤波器融合_1_惯导解算原理——捷联惯导更新算法及误差分析</title>
    <link href="http://yoursite.com/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-20T00:36:46.000Z</published>
    <updated>2020-12-07T03:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="捷联惯导更新算法">捷联惯导更新算法</h1><h2 id="姿态更新算法">姿态更新算法</h2><p>选取“东-北-天”地理坐标系作为惯导系统的导航参考坐标系，后面记为<code>n系</code>，则以<code>n</code>系作为参考系的姿态微分方程为：</p><p><span class="math display">\[    \dot{C}_b^n = C_b^n(\omega_{nb}^b \times)\]</span></p><p>其中，矩阵<span class="math inline">\(C_b^n\)</span>表示载体坐标系（b系）相对于导航坐标系（n系）的姿态矩阵，由于陀螺仪输出的是b系相对于惯性系（i系）的角速度<span class="math inline">\(\omega_{ib}^b\)</span>，而角速度信息<span class="math inline">\(\omega_{nb}^b\)</span>不能直接测量获得，因此，进一步分解，有：</p><p><span class="math display">\[\begin{aligned}        \dot{C}_b^n = C_b^n(\omega_{nb}^b \times)&amp;= C_b^n[(\omega_{ib}^b-\omega_{in}^b)\times] \\         &amp;= C_b^n(\omega_{ib}^b\times)-C_b^n(\omega_{in}^b\times) \\        &amp;= C_b^n(\omega_{ib}^b\times)-C_b^n(\omega_{in}^b\times)C_b^bC_b^n \\        &amp;= C_b^n(\omega_{ib}^b\times)-(\omega_{in}^n\times)C_b^n\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\omega_{in}^n\)</span>表示n系相对于i系的旋转，它包含两部分：地球自转引起的导航系旋转、以及惯导系统在地球表明附近运动因地球表面弯曲而引起的n系旋转，因此，有<span class="math inline">\(\omega_{in}^n=\omega_{ie}^n+\omega_{en}^n\)</span></li></ul><p><span class="math display">\[\omega_{ie}^n=\begin{bmatrix}    0 \\ \omega_{ie} \cos L \\ \omega_{ie} \sin L\end{bmatrix}\]</span></p><p><span class="math display">\[\omega_{en}^n=\begin{bmatrix}    -\frac{v_N}{R_M+h} \\ \frac{v_E}{R_N+h} \\ \frac{v_E}{R_N+h} \tan L\end{bmatrix}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\omega_{ie}\)</span>为地球自转角速率</li><li><span class="math inline">\(L\)</span>表示地理纬度</li><li><span class="math inline">\(h\)</span>表示高度</li></ul><p>与矩阵微分方程<span class="math inline">\(\dot{C}_b^n = C_b^n(\omega_{nb}^b \times)\)</span>相比，上面推导出来的离散化求解更麻烦，一般不会直接求解该方程，而是用如下方法解决姿态矩阵更新问题，</p><p>根据矩阵乘法，有:</p><p><span class="math display">\[    C_{b(m)}^{n(m)}=C_{i}^{n(m)}C_{b(m)}^{i}\]</span></p><p>其中，</p><ul><li>角标符号m表示<span class="math inline">\(t_m\)</span>时刻</li><li>由于i系是不动的惯性参考坐标系，其与时间无关，不需要标注时刻</li></ul><p>由:</p><p><span class="math display">\[    C_{b(m)}^i=C_{b(m-1)}^iC_{b(m)}^{b(m-1)}\]</span></p><p><span class="math display">\[    C_{i}^{n(m)}=C_{n(m-1)}^{n(m)}C_{i}^{n(m-1)}\]</span></p><p>其中，</p><ul><li>矩阵<span class="math inline">\(C_{b(m)}^{b(m-1)}\)</span>表示以i系作为参考基准，b系从<span class="math inline">\(t_{m-1}\)</span>时刻到<span class="math inline">\(t_{m}\)</span>时刻的旋转变化，也就是以<span class="math inline">\(m-1\)</span>时刻下的载体坐标系作为基准，<span class="math inline">\(t_m\)</span>时刻下的载体姿态，同时也是载体从<span class="math inline">\(t_{m}\)</span>时刻载体坐标系到<span class="math inline">\(t_{m-1}\)</span>时刻载体坐标系的变换</li><li><span class="math inline">\(C_{b(m)}^{b(m-1)}\)</span>可由陀螺仪角速度确定</li><li><span class="math inline">\(C_{n(m-1)}^{n(m)}\)</span>表示以i系作为参考基准，n系从<span class="math inline">\(t_{m}\)</span>时刻到<span class="math inline">\(t_{m-1}\)</span>时刻的旋转变化</li><li><span class="math inline">\(C_{n(m-1)}^{n(m)}\)</span>可以由计算角速度<span class="math inline">\(\omega_{in}^n\)</span>确定</li></ul><p>结合上面3条等式，有:</p><p><span class="math display">\[\begin{aligned}    C_{b(m)}^{n(m)}&amp;=C_{i}^{n(m)}C_{b(m)}^{i} \\    &amp;=C_{n(m-1)}^{n(m)}C_{i}^{n(m-1)} C_{b(m-1)}^iC_{b(m)}^{b(m-1)} \\    &amp;=C_{n(m-1)}^{n(m)}C_{b(m-1)}^{n(m-1)}C_{b(m)}^{b(m-1)}\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(C_{b(m-1)}^{n(m-1)}\)</span>表示<span class="math inline">\(t_{m-1}\)</span>时刻的姿态阵</li><li><span class="math inline">\(C_{b(m)}^{n(m)}\)</span>表示<span class="math inline">\(t_m\)</span>时刻的姿态阵</li></ul><p>若陀螺仪在时间段<span class="math inline">\([t_{m-1},t_m]\)</span>内<span class="math inline">\((T=t_m-t_{m-1})\)</span>进行了两次等间隔采样，角增量分别是<span class="math inline">\(\Delta \theta_{m1}\)</span>和<span class="math inline">\(\Delta \theta_{m2}\)</span>，采用二子样圆锥误差补偿算法，有：</p><p><span class="math display">\[    C_{b(m)}^{b(m-1)}=M_{RV}(\phi_{ib(m)}^b)=\exp (\phi_{ib(m)}^b\times)\]</span></p><p><span class="math display">\[    \phi_{ib(m)}^b=(\Delta \theta_{m1}+\Delta \theta_{m2})+\frac{2}{3} \Delta \theta_{m1} \times \Delta \theta_{m2}\]</span></p><blockquote><p>对于单子样，只需要把 <span class="math inline">\(\frac{2}{3}\)</span> 改成 <span class="math inline">\(\frac{1}{12}\)</span></p></blockquote><p>通常，在导航更新期间<span class="math inline">\([t_{m-1},t_m]\)</span>内，可以认为由速度和位置引起的<span class="math inline">\(\omega_{in}^n\)</span>变化很小，视为常数，记为<span class="math inline">\(\omega_{in(m)}^n\)</span>，则有：</p><p><span class="math display">\[    C_{n(m-1)}^{n(m)}=(C_{n(m)}^{n(m-1)})^T = [M_{RV}(\phi_{in(m)}^n)]^T \approx [M_{RV}(T*\omega_{in(m)}^n)]^T\]</span></p><h2 id="速度更新算法">速度更新算法</h2><h3 id="比力方程">比力方程</h3><p>比力方程是在地球表面附近进行惯性导航解算的基本方程</p><p>参见图，假设在地球表面附近有一运载体（惯导系统），其中心为<span class="math inline">\(o_g\)</span>点，以<span class="math inline">\(o_g\)</span>为原点定义当地地理坐标系（g系）,<span class="math inline">\(o_g\)</span>在地球坐标系（e系）下的矢径记为<span class="math inline">\(R_{eg}\)</span> ，则<span class="math inline">\(R_{eg}\)</span>在惯性坐标系（i系）和e系之间的投影变换关系为:</p><p><span class="math display">\[    R_{eg}^e = C_{i}^e R_{eg}^i\]</span></p><p><img src="/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/2020-11-20-09-56-19.png"></p><p>对上式两边同时微分，可得</p><p><span class="math display">\[    \dot{R}_{eg}^e =C_i^e \dot{R}_{eg}^i+\dot C_{i}^e R_{eg}^i = C_i^e \dot{R}_{eg}^i + [C_i^e (\omega_{ei}^i \times)]R_{eg}^i = C_{i}^e(\dot{R}_{eg}^i-\omega_{ie}^i \times R_{eg}^i)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\dot{R}_{eg}^e\)</span>表示g系原点<span class="math inline">\(o_g\)</span>的速度，它是以e系作为参考坐标系的（即在e系观察得到的），即地速，<span class="math inline">\(v_{eg}^e=\dot{R}_{eg}^e\)</span></li></ul><p>使用变换阵<span class="math inline">\(C_e^g\)</span>同时对上式两边左乘:</p><p><span class="math display">\[\begin{aligned}    C_e^g v_{eg}^e &amp;= C_e^g C_{i}^e(\dot{R}_{eg}^i-\omega_{ie}^i \times R_{eg}^i) \\    &amp;= C_i^g (\dot{R}_{eg}^i-\omega_{ie}^i \times R_{eg}^i)\end{aligned}\]</span></p><p>其中，上式左侧的<span class="math inline">\(C_e^g v_{eg}^e\)</span>表示地速在g系的投影，记为<span class="math inline">\(v_{eg}^g=C_e^g v_{eg}^e\)</span></p><p>所以，有：</p><p><span class="math display">\[\begin{aligned}    v_{eg}^g = C_i^g (\dot{R}_{eg}^i-\omega_{ie}^i \times R_{eg}^i)\end{aligned}\]</span></p><p>用<span class="math inline">\(C_{g}^i\)</span>同时对上式两边左乘后，整理：</p><p><span class="math display">\[    C_{g}^i v_{eg}^g =  (\dot{R}_{eg}^i-\omega_{ie}^i \times R_{eg}^i)\]</span></p><p><span class="math display">\[    \dot{R}_{eg}^i = C_{g}^i v_{eg}^g + \omega_{ie}^i \times R_{eg}^i\]</span></p><p>对上式两边同时微分，可得：</p><p><span class="math display">\[\begin{aligned}        \dot{v}_{eg}^g &amp;= \dot{C}_{i}^g(\dot{R}_{eg}^i-\omega_{ie}^i \times R_{eg}^i) + C_i^g (\ddot{R}_{eg}^i - \omega_{ie}^i \times \dot{R}_{eg}^i) \\        &amp;= \underbrace{C_i^g(\omega_{gi}^i \times)C_g^i v_{eg}^g}_{\dot{C}_{i}^g(\dot{R}_{eg}^i-\omega_{ie}^i \times R_{eg}^i)} + C_i^g[\ddot{R}_{eg}^i - \omega_{ie}^i \times (C_g^i v_{eg}^g + \omega_{ie}^i \times R_{eg}^i)] \\        &amp;= C_i^g[\ddot{R}_{eg}^i-(\omega_{ie}^i \times)^2R_{eg}^i] + C_i^g[(\omega_{gi}^i-\omega_{ie}^i)\times]C_{g}^i v_{eg}^g \\        &amp;= C_i^g[\ddot{R}_{eg}^i-(\omega_{ie}^i \times)^2R_{eg}^i] - (\omega_{ie}^g+ \omega_{ig}^g) \times v_{eg}^g \\        &amp;= C_i^g[\ddot{R}_{eg}^i-(\omega_{ie}^i \times)^2R_{eg}^i] - (\omega_{ie}^g+ \omega_{ie}^g+ \omega_{eg}^g ) \times v_{eg}^g \\        &amp;= C_i^g[\ddot{R}_{eg}^i-(\omega_{ie}^i \times)^2R_{eg}^i] - (2\omega_{ie}^g+ \omega_{eg}^g) \times v_{eg}^g\end{aligned}\]</span></p><p>由于<span class="math inline">\(R_{ig}^i=R_{ie}^i+R_{eg}^i\)</span>，当选择地心惯性系作为i系时，则i系和e系的坐标原点<strong>始终重合</strong>，即有<span class="math inline">\(R_{ie}^i=0\)</span>和<span class="math inline">\(\ddot{R}_{eg}^i=\ddot{R}_{ig}^i\)</span></p><p>根据牛顿第二定律，有<span class="math inline">\(\ddot{R}_{ig}^i=f_{sf}^i+G^i\)</span>，其中:</p><ul><li><span class="math inline">\(f_{sf}^i\)</span>为比力</li><li><span class="math inline">\(G^i\)</span>为地球引力加速度(注意，不是重力)</li></ul><p>再根据地球重力公式<span class="math inline">\(g^i=G^i - (\omega_{ie}^i \times)^2 R_{eg}^i\)</span></p><p>可得：</p><p><span class="math display">\[\begin{aligned}    \dot{v}_{eg}^g &amp;= C_i^g[\ddot{R}_{eg}^i-(\omega_{ie}^i \times)^2R_{eg}^i] - (2\omega_{ie}^g+ \omega_{eg}^g) \times v_{eg}^g \\    &amp;= C_i^g(f_{sf}+g^i)-(2\omega_{ie}^g+ \omega_{eg}^g) \times v_{eg}^g \\    &amp;= C_b^g f_{sf}^b - (2 \omega_{ie}^g+\omega_{eg}^g) \times v_{eg}^g +g^g\end{aligned}\]</span></p><p>将上式的地理过坐标系g系替换成“东-北-天”导航坐标系（n系），即可得到<strong>比力方程</strong>：</p><p><span class="math display">\[    \dot{v}_{en}^n = C_b^n f_{sf}^b - (2 \omega_{ie}^n + \omega_{en}^n )\times v_{en}^n + g^n\]</span></p><p>其中，</p><ul><li><span class="math inline">\(f_{sf}^b\)</span>为加速度的输出（比力）</li><li><span class="math inline">\((2 \omega_{ie}^n ) \times v_{en}^n\)</span> 为由载体运动和地球自转引起的哥氏加速度</li><li><span class="math inline">\((\omega_{en}^n) \times v_{en}^n\)</span>为载体运动引起的对地向心加速度</li><li><span class="math inline">\(g^n\)</span>为重力加速度</li><li><span class="math inline">\(- (2 \omega_{ie}^n + \omega_{en}^n )\times v_{en}^n + g^n\)</span>统称为有害加速度</li><li>以东北天坐标系为导航坐标系，则<span class="math inline">\(g^n=[0,0,-9.81]\)</span></li></ul><p>比力方程表明，加速度计输出中扣除有害加速度后，才能获取载体再导航坐标系的<strong>几何运动加速度</strong><span class="math inline">\(\dot{v}_{en}^n\)</span></p><blockquote><p>有时，为了计算简便，会把哥氏加速度和向心加速度忽略，即<span class="math inline">\(\dot{v}_{en}^n = C_b^n f_{sf}^b + g^n\)</span></p></blockquote><hr><p>综上，可得，速度更新方程:</p><p><span class="math display">\[\begin{aligned}    V_{m}=V_{m-1}+[\dot{v}_{en}^n]\Delta T\end{aligned}\]</span></p><p>或者由简化形式:</p><p><span class="math display">\[\begin{aligned}    V_{m}=V_{m-1}+\frac{1}{2}( C_{b(m-1)}^{n(m-1)}f_{sf(m-1)}^b + C_{b(m)}^{n(m)}f_{sf(m)}^b )\Delta T\end{aligned}\]</span></p><h2 id="位置更新算法">位置更新算法</h2><p>由位置微分方程：</p><p><span class="math display">\[    \dot{P} = V\]</span></p><p>可得，位置更新方程：</p><p><span class="math display">\[\begin{aligned}    P_{m}=P_{m-1}+\frac{1}{2}(V_m+V_{m-1})\Delta T\end{aligned}\]</span></p><h1 id="捷联惯导误差分析">捷联惯导误差分析</h1><h2 id="基本方法误差分析的思路">基本方法——误差分析的思路</h2><p><strong>误差方程的形式</strong>——需要求的是啥？</p><p>假设给定微分方程:</p><p><span class="math display">\[\begin{aligned}    \dot{z}=x+y\end{aligned} \]</span></p><p>且:</p><p><span class="math display">\[\begin{aligned}    \tilde{z}&amp;=z+\delta z \\    \tilde{x}&amp;=x+\delta x \\    \tilde{y}&amp;=y+\delta y\end{aligned} \]</span></p><p>则误差方程的形式为:</p><p><span class="math display">\[\begin{aligned}    \delta \dot{z}= ???\end{aligned}\]</span></p><hr><ol type="1"><li>写出原微分方程</li></ol><p><span class="math display">\[\begin{aligned}    \dot{z}=x+y\end{aligned} \tag{1}\]</span></p><ol start="2" type="1"><li><p>写出考虑误差时的微分方程</p><p>即把<span class="math inline">\(\dot{z}=x+y\)</span>使用带有误差的变量代替，得到:</p></li></ol><p><span class="math display">\[\begin{aligned}    \tilde{\dot{z}}=\tilde{x}+\tilde{y} \end{aligned} \tag{2}\]</span></p><ol start="3" type="1"><li><p>求出误差关系（真实值与理想值的关系）</p><p>这一步中，并非所有的关系都是已知的，有些需要自己推</p></li></ol><p><span class="math display">\[\begin{aligned}    \tilde{z}&amp;=z+\delta z \\    \tilde{x}&amp;=x+\delta x \\    \tilde{y}&amp;=y+\delta y\end{aligned} \tag{3}\]</span></p><ol start="4" type="1"><li>把(3)的误差关系代入到等式(2)</li></ol><p><span class="math display">\[\begin{aligned}    \dot{z}+\delta{\dot{z}}=x+\delta x+ y+ \delta y \end{aligned} \tag{4}\]</span></p><ol start="5" type="1"><li>取原微分方程(1)，代入(4)</li></ol><p><span class="math display">\[\begin{aligned}    \because \dot{z}&amp;=x+y \\    \therefore x+y + \delta \dot{z}&amp;=x + y+ \delta x+\delta y\end{aligned}   \tag{5}\]</span></p><ol start="6" type="1"><li>化简</li></ol><p><span class="math display">\[    \delta \dot{z} =\delta x+ \delta y\]</span></p><h2 id="姿态误差方程">姿态误差方程</h2><ol type="1"><li><p>写出原微分方程</p><p>以“东-北-天(E-N-U)”坐标系为导航坐标系(n系)，“右-前-上”坐标系为(b系)时，姿态微分方程可以表示为</p></li></ol><p><span class="math display">\[    \dot{C}_b^n = C_b^n(\omega_{nb}^b \times)\]</span></p><p>当考虑地球自转角速度时，不易直接测量，因此上面的微分方程可以拆解为：</p><p><span class="math display">\[\begin{aligned}        \dot{C}_b^n = C_b^n(\omega_{nb}^b \times)&amp;= C_b^n[(\omega_{ib}^b-\omega_{in}^b)\times] \\         &amp;= C_b^n(\omega_{ib}^b\times)-C_b^n(\omega_{in}^b\times) \\        &amp;= C_b^n(\omega_{ib}^b\times)-C_b^n(\omega_{in}^b\times)C_b^bC_b^n \\        &amp;= C_b^n(\omega_{ib}^b\times)-(\omega_{in}^n\times)C_b^n\end{aligned} \tag{1}\]</span></p><p>其中，<span class="math inline">\(\omega_{in}^n\)</span>表示导航系(n系)相对于惯性系(i系)的旋转，它包含地球自转和导航系相对于地球的旋转，其表达式为：</p><p><span class="math display">\[    \omega_{in}^n = \omega_{ie}^n + \omega_{en}^n\]</span></p><ol start="2" type="1"><li>写出考虑误差的微分方程:</li></ol><p><span class="math display">\[\begin{aligned}    \dot{\tilde{C}_b^n}= \tilde{C}_b^n( \tilde{\omega}_{ib}^b\times)-( \tilde{\omega}_{in}^n\times) \tilde{C}_b^n\end{aligned} \tag{2}\]</span></p><ol start="3" type="1"><li>求出误差关系（真实值与理想值的关系）</li></ol><ul><li>姿态误差关系</li><li>imu角速度误差关系</li><li>导航系计算误差关系</li></ul><p><strong>姿态误差关系</strong></p><p>理想情况下，从载体坐标系(b系)到导航坐标系(n系)的变换矩阵为<span class="math inline">\(C_b^n\)</span>，而姿态计算时会有误差，一般假设误差在n系(global)上。</p><p>有误差的导航坐标系称为计算导航坐标系，简记为<span class="math inline">\(n&#39;\)</span>系。此时有误差的姿态矩阵<span class="math inline">\(\tilde{C}_b^n\)</span>表示为</p><p><span class="math display">\[    \tilde{C}_b^n = C_b^{n&#39;}=C_n^{n&#39;}C_b^n\]</span></p><p>以n系作为参考坐标系，记从 n' 系到 n 系的旋转矩阵为<span class="math inline">\(C_\phi\)</span>，n'系在n系中的姿态为<span class="math inline">\(C_\phi\)</span>，对应的等效旋转矢量为<span class="math inline">\(\phi\)</span>(其3个元素也被称作失准角)，也就是说，n系绕等效旋转矢量为<span class="math inline">\(\phi\)</span>旋转之后，得到n' 系</p><p>当<span class="math inline">\(\phi\)</span>为小量时，根据等效旋转矢量与方向余弦阵关系式——罗德里格斯公式：</p><p><span class="math display">\[    C_{n&#39;}^{n}=I+\frac{\sin \phi}{\phi}(\phi \times)+ \frac{1-\cos \phi}{ \phi^2}(\phi  \times)^2 \approx I+(\phi \times)\]</span></p><p><span class="math display">\[    C_n^{n&#39;}=I-\frac{\sin \phi}{\phi}(\phi \times)+ \frac{1-\cos \phi}{ \phi^2}(\phi \times)^2 \approx I-(\phi \times)\]</span></p><blockquote><p>这个怎么理解，假设n系矩阵<span class="math inline">\(C_n\)</span>等于<span class="math inline">\(I\)</span>, 对n系绕z轴逆时针旋转<span class="math inline">\(30\)</span>度，得到n'系，这个等效旋转矢量是<span class="math inline">\(\phi=[0,0,\frac{1}{6} \pi]\)</span>，那么n'系在n系的姿态是<span class="math inline">\(I+(\phi \times)\)</span>，n'系到n系的旋转变换为<span class="math inline">\(C_{n&#39;}^{n}=I+(\phi \times)\)</span></p></blockquote><p>因此，带误差的姿态矩阵表示为：</p><p><span class="math display">\[\begin{aligned}    \tilde{C}_b^{n}=C_b^{n&#39;} = C_n^{n&#39;}C_b^n = [I-(\phi \times)] C_b^n\end{aligned} \tag{3}\]</span></p><p><strong>IMU角速度误差关系</strong></p><p>陀螺仪测量误差关系：</p><p><span class="math display">\[    \tilde{\omega}_{ib}^b = \omega_{ib}^b + \delta \omega_{ib}^b\]</span></p><blockquote><p>一般来说，imu内参的影响会在imu测量的时候先补偿掉，这里就不用考虑了 <img src="/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/2020-11-20-16-00-14.png"></p></blockquote><p><strong>导航系计算误差</strong></p><p><span class="math display">\[    \tilde{\omega}_{in}^n=\tilde{\omega}_{ie}^n+\tilde{\omega}_{en}^n = \omega_{ie}^n + \delta \omega_{ie}^n  + \omega_{en}^n + \delta \omega_{en}^n\]</span></p><p>在实际使用过程中，对于mems惯导，可以忽略这误差：</p><ul><li>在中等精度及以下的惯性导航中，这两项角速度误差相比于器件误差，量级太小，没有考虑的必要;</li><li>在组合导航中，速度误差和位置误差一直被修正，会使他们的量级进一步减小。</li></ul><blockquote><p>两项误差的具体推导如下：</p><p><img src="/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/2020-11-20-16-06-38.png"></p></blockquote><ol start="4" type="1"><li>将(3)中的误差关系代入(2)</li></ol><ul><li>姿态误差关系： <span class="math inline">\(\tilde{C}_b^{n} = [I-(\phi \times)] C_b^n\)</span></li><li>imu测量误差关系: <span class="math inline">\(\tilde{\omega}_{ib}^b = \omega_{ib}^b + \delta \omega_{ib}^b\)</span></li><li>导航系计算误差关系: <span class="math inline">\(\tilde{\omega}_{in}^n= \omega_{ie}^n + \delta \omega_{ie}^n + \omega_{en}^n + \delta \omega_{en}^n\)</span></li></ul><p>对式(2)重新抄写如下：</p><p><span class="math display">\[\begin{aligned}    \dot{\tilde{C}_b^n}= \tilde{C}_b^n( \tilde{\omega}_{ib}^b\times)-( \tilde{\omega}_{in}^n\times) \tilde{C}_b^n\end{aligned} \tag{2}\]</span></p><p>代入之后，可得：</p><p><span class="math display">\[\begin{aligned}    (-\dot{\phi}\times)C_{b}^n +[I-(\phi\times)]\dot{C}_n^b = [I-(\phi \times)]C_b^n[(\omega_{ib}^b+\delta \omega_{ib}^b)\times]-(\omega_{in}^n\times)[I-(\phi \times)]C_b^n\end{aligned} \tag{4}\]</span></p><ol start="5" type="1"><li>将(1)中的原微分方程代入(4)</li></ol><p><span class="math display">\[\begin{aligned}    (-\dot{\phi}\times)C_b^n + [I - (\phi \times)][C_b^n (\omega_{ib}^b\times)-(\omega_{in}^n)C_b^n] \\    = [I-(\phi \times)]C_b^n[(\omega_{ib}^b+\delta \omega_{ib}^b)\times]-(\omega_{in}^n\times)[I-(\phi \times)]C_b^n\end{aligned}\]</span></p><ol start="6" type="1"><li>化简</li></ol><ol type="1"><li>两边同时右乘<span class="math inline">\(C_n^b\)</span><br></li><li>展开，忽略其中的二阶项<br></li><li>利用定理<span class="math inline">\((a\times)(b\times)-(b\times)(a\times)=[(a\times b)\times]\)</span> 进一步化简</li></ol><p>最终，得到:</p><p><span class="math display">\[    (\dot{\phi}\times)=[(\phi \times \omega_{in}^n -\delta \omega_{ib}^n)\times]\]</span></p><p>最后，把两边的反对称符号同时去掉</p><p><span class="math display">\[    \dot{\phi} = \phi \times \omega_{in}^n - \delta \omega_{ib}^n\]</span></p><h2 id="速度误差方程">速度误差方程</h2><ol type="1"><li>写出原微分方程</li></ol><p><span class="math display">\[\begin{aligned}    \dot{V}^n=C_b^n f^b + g^n\end{aligned} \tag{1}\]</span></p><ol start="2" type="1"><li>写出考虑误差的微分方程</li></ol><p><span class="math display">\[\begin{aligned}    \dot{\tilde{V}}^n = \tilde{C}_b^n \tilde{f}^b + \tilde{g}^n\end{aligned} \tag{2}\]</span></p><ol start="3" type="1"><li>求出误差关系（真实值与理想值的关系）</li></ol><p><span class="math display">\[\begin{aligned}    &amp; \tilde{V}^n = V^n +\delta V^n \\    &amp; \tilde{C}_b^n = [I-\phi\times]C_b^n \\    &amp; \tilde{f}^b = f^b +\delta f^b \\    &amp; \tilde{g}^n = g^n +\delta g^n\end{aligned} \tag{3}\]</span></p><p>其中：</p><ul><li><span class="math inline">\(\delta f^b\)</span>表示加速度测量误差</li><li><span class="math inline">\(g^n\)</span>表示重力误差，非高精度模型下可忽略</li></ul><ol start="4" type="1"><li>将(3)代入(2)</li></ol><p><span class="math display">\[\begin{aligned}    \dot{V}^n+\delta \dot{V}^n = (I-\phi \times)C_b^n(f^b+\delta f^b)+g^n\end{aligned} \tag{4}\]</span></p><ol start="5" type="1"><li>将原微分方程代入(4)</li></ol><p><span class="math display">\[\begin{aligned}    C_b^n f^b +g^n + \delta \dot{V}^n = (I-\phi \times)C_b^n(f^b+\delta f^b)+g^n\end{aligned} \tag{5}\]</span></p><ol start="6" type="1"><li>化简</li></ol><p><span class="math display">\[\begin{aligned}    \delta \dot{V}^n &amp;= C_b^n \delta f^b - (\phi \times)C_b^n(f^b +\delta f^b) \\    &amp; \approx C_b^n \delta f^b - (\phi \times)C_b^n(f^b) \\    &amp;= \delta f^n + (f^n \times)(\phi)\end{aligned} \tag{6}\]</span></p><h2 id="位置误差方程">位置误差方程</h2><ol type="1"><li>写出原微分方程</li></ol><p><span class="math display">\[\begin{aligned}    \dot {P} = V\end{aligned} \tag{1}\]</span></p><ol start="2" type="1"><li>写出考虑误差的微分方程</li></ol><p><span class="math display">\[\begin{aligned}    \dot{\tilde{P}}=\tilde{V}\end{aligned} \tag{2}\]</span></p><ol start="3" type="1"><li>求出误差关系（真实值与理想值的关系）</li></ol><p><span class="math display">\[\begin{aligned}    \tilde{P} = P + \delta P \\    \tilde{V} = V + \delta V \end{aligned} \tag{3}\]</span></p><ol start="4" type="1"><li>将(3)代入(2)</li></ol><p><span class="math display">\[\begin{aligned}    \dot{P} + \delta \dot{P} = V+ \delta V\end{aligned}\]</span></p><ol start="5" type="1"><li>将原微分方程代入(4)</li></ol><p><span class="math display">\[\begin{aligned}    V+\delta \dot{P} = V+ \delta V\end{aligned} \tag{5}\]</span></p><ol start="6" type="1"><li>化简</li></ol><p><span class="math display">\[\begin{aligned}    \delta \dot{P} = \delta V\end{aligned} \tag{6}\]</span></p><h2 id="整理">整理</h2><p><strong>姿态误差方程</strong></p><p><span class="math display">\[\begin{aligned}    \dot{\phi} = \phi \times \omega_{in}^n - \delta \omega_{ib}^n\end{aligned}\]</span></p><p><strong>速度误差方程</strong></p><p><span class="math display">\[\begin{aligned}    \delta \dot{V}^n = \delta f^n + (f^n \times)(\phi)\end{aligned}\]</span></p><p><strong>位置误差方程</strong></p><p><span class="math display">\[\begin{aligned}    \delta \dot{P} = \delta V\end{aligned}\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;捷联惯导更新算法&quot;&gt;捷联惯导更新算法&lt;/h1&gt;
&lt;h2 id=&quot;姿态更新算法&quot;&gt;姿态更新算法&lt;/h2&gt;
&lt;p&gt;选取“东-北-天”地理坐标系作为惯导系统的导航参考坐标系，后面记为&lt;code&gt;n系&lt;/code&gt;，则以&lt;code&gt;n&lt;/code&gt;系作为参考系的姿态微分方
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>第五章-(2)-组合导航常见现象解释</title>
    <link href="http://yoursite.com/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/"/>
    <id>http://yoursite.com/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/</id>
    <published>2020-11-16T14:36:46.000Z</published>
    <updated>2020-12-07T09:07:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组合导航工程经验重要">组合导航工程经验(重要)</h1><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-15-52-27.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-15-55-12.png"></p><blockquote><p>初始对准：航向收敛</p></blockquote><h1 id="公式上理解现象">公式上理解现象</h1><h2 id="mems为什么不能做静态初始对准">mems为什么不能做静态初始对准</h2><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-00-02.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-00-28.png"></p><blockquote><p>如果要解方程(3)</p><p>待求变量为：</p><ul><li><span class="math inline">\(\phi_E\)</span></li><li><span class="math inline">\(\phi_N\)</span></li><li><span class="math inline">\(\phi_U\)</span></li></ul><p>前两个比较好解,解<span class="math inline">\(\phi_U\)</span>还需要用到方程组(4)</p></blockquote><p>对方程组(3)展开，有：</p><p><span class="math display">\[\begin{aligned}    &amp; \delta \dot{V}_E = -g \phi_N +\triangledown_E \\    &amp; \delta \dot{V}_N = g \phi_E + \triangledown_N \\    &amp; \delta \dot{V}_U = \triangledown_U\end{aligned}\]</span></p><p>如果对于高精度惯导，那么<span class="math inline">\(\triangledown_E , \triangledown_N \approx (1e-5g_0)\)</span>可以忽略，所以，可以求得:</p><p><span class="math display">\[\begin{aligned}    &amp; \phi_E = \frac{\delta \dot{V}_N}{-g} \\    &amp; \phi_N = \frac{\delta \dot{V}_E}{g}\end{aligned}\]</span></p><p>对方程组(4)展开，有:</p><p><span class="math display">\[\begin{aligned}    \dot{\phi}_E = \phi_N (\omega_{ie}\sin L) - \phi_U (\omega_{ie}\cos L) + \epsilon_E\end{aligned}\]</span></p><p>由于<span class="math inline">\(\phi_E,\phi_N\)</span>在前面已经求出来了，并且高精度惯导的<span class="math inline">\(\epsilon_E \approx 0.01\deg/h\)</span>可以忽略</p><p><span class="math display">\[\begin{aligned}    \phi_U = \frac{C-\epsilon_E}{\omega_{ie} \cos L}\end{aligned}\]</span></p><p>其中，<span class="math inline">\(C\)</span>是<span class="math inline">\(\phi_E,\phi_N\)</span>组成的量</p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-20-57.png"></p><h2 id="mems初始对准为什么需要绕8字">mems初始对准为什么需要绕8字</h2><p>增加观测，增加矩阵的秩</p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-31-33.png"></p><h2 id="加减速的收敛速度">加减速的收敛速度</h2><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-35-52.png"></p><h2 id="mems直线行驶相关现象">mems直线行驶相关现象</h2><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-42-32.png"></p><h1 id="从物理意义上理解">从物理意义上理解</h1><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-55-30.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-16-59-06.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-17-03-19.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E7%BB%84%E5%90%88%E5%AF%BC%E8%88%AA%E7%8E%B0%E8%B1%A1%E8%A7%A3%E9%87%8A/2020-12-07-17-07-03.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组合导航工程经验重要&quot;&gt;组合导航工程经验(重要)&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>第五章-(1)-基于滤波器的融合算法-进阶</title>
    <link href="http://yoursite.com/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/</id>
    <published>2020-11-16T14:36:46.000Z</published>
    <updated>2020-12-07T09:29:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于滤波器的融合算法-进阶">基于滤波器的融合算法-进阶</h1><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-16-23-17-47.png"></p><h1 id="编码器融合">编码器融合</h1><h2 id="不考虑imu和车体之间的旋转">不考虑imu和车体之间的旋转</h2><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-16-23-23-55.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-16-23-32-02.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-16-23-40-36.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-16-23-41-38.png"></p><h2 id="考虑imu和车体之间的旋转">考虑imu和车体之间的旋转</h2><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-22-44-01.png"></p><blockquote><p>上述框框来源于：第三章-姿态误差方程的推导</p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-22-45-46.png"></p></blockquote><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-22-52-43.png"></p><p>上述框框同样来源于上面的推导，只不过方向相反了而已</p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-22-57-46.png"></p><blockquote><p>从直观来看， - 假设imu与车体有俯仰角偏差，那么，车的前向速度与imu的前向速度就会有偏差，可以反应出来 - 假设imu与车体有航向角偏差，同理 - 假设imu与车体有横滚角误差，但是车体的前向速度与imu的速度仍然一致，所以无法反映出来。</p></blockquote><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-23-04-24.png"></p><p>其中，</p><ul><li><span class="math inline">\(\tilde{V}_m=\tilde{C}_b^m\tilde{C}_n^b\tilde{V}_n\)</span> 表示根据当前的状态得到的投影到车体上的速度观测估计</li></ul><h1 id="运动约束融合">运动约束融合</h1><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-23-25-36.png"> <img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-23-25-45.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-23-27-17.png"></p><h1 id="基于磁力计的融合">基于磁力计的融合</h1><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-23-36-32.png"> <img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-23-37-43.png"> <img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-11-19-23-40-11.png"></p><h1 id="lins融合思路">LINS融合思路</h1><blockquote><p>滤波器方法实现激光里程计，核心是观测怎么做，lins使用了点云的特征做紧耦合</p></blockquote><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-07-17-14-17.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-07-17-19-33.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-07-17-20-26.png"></p><blockquote><p>论文中的<span class="math inline">\(F_t\)</span>矩阵可能有错</p></blockquote><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-07-17-24-37.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-07-17-27-17.png"></p><p><img src="/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_%E8%BF%9B%E9%98%B6/2020-12-07-17-29-36.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于滤波器的融合算法-进阶&quot;&gt;基于滤波器的融合算法-进阶&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/11/16/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章-(2)-基于滤波器的融合算法及可观测性分析</title>
    <link href="http://yoursite.com/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/"/>
    <id>http://yoursite.com/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/</id>
    <published>2020-11-14T04:36:46.000Z</published>
    <updated>2020-11-22T04:21:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于滤波的融合方法">基于滤波的融合方法</h1><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-12-50-09.png"></p><h1 id="基于误差状态的滤波方法基于角误差">基于误差状态的滤波方法(基于角误差)</h1><h2 id="姿态误差方程">姿态误差方程</h2><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-02-56.png"></p><h2 id="速度误差方程位置误差方程">速度误差方程、位置误差方程</h2><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-04-02.png"></p><h2 id="状态方程预测">状态方程(预测)</h2><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-22-12-21-27.png"> <img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-09-28.png"></p><ul><li><span class="math inline">\(B_t\)</span>来源于<span class="math inline">\(F_t\)</span>的后两列，二者等价，因为bias和噪声传入的通道是同一个</li></ul><h2 id="观测方程">观测方程</h2><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-14-14.png"></p><h2 id="离散化">离散化</h2><ul><li>因为观测方程不是微分方程，因此不需要离散化</li></ul><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-22-55.png"></p><h2 id="滤波流程">滤波流程</h2><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-14-02-56.png"></p><h1 id="基于四元数状态的滤波">基于四元数状态的滤波</h1><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-26-05.png"> <img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-29-27.png"></p><ul><li>上图中圈中的<span class="math inline">\(F_{Vq}\)</span> 表示的是速度状态对姿态项<span class="math inline">\(q\)</span>的各个分量的求导</li><li>另外，<span class="math inline">\((f^b+\triangledown+\omega_a)\)</span>实际上就是加速度计的输出值(读数)</li></ul><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-51-42.png"> <img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-52-51.png"></p><h2 id="滤波流程-1">滤波流程</h2><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-13-57-59.png"></p><h1 id="基于误差状态的滤波器与普通状态滤波器对比">基于误差状态的滤波器与普通状态滤波器对比</h1><p><img src="/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-2/2020-11-14-14-09-58.png"></p><h1 id="可观测性分析待补充">可观测性分析(待补充)</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于滤波的融合方法&quot;&gt;基于滤波的融合方法&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/11/14/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%A
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章-(1)-概率基础及滤波器原理</title>
    <link href="http://yoursite.com/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/"/>
    <id>http://yoursite.com/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/</id>
    <published>2020-11-12T01:36:46.000Z</published>
    <updated>2020-11-14T04:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于滤波的融合方法">基于滤波的融合方法</h1><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-45-25.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-46-02.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-46-45.png"></p><h1 id="概率相关基础">概率相关基础</h1><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-49-33.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-52-29.png"></p><p><strong>贝叶斯公式和贝叶斯推断——核心</strong></p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-55-56.png"></p><p><strong>高斯概率密度函数——核心</strong></p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-56-46.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-09-59-09.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-10-00-00.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-10-03-02.png"></p><blockquote><p>上式说明，如果有(x,y)的联合概率密度函数，同时又有y的分布，那么就可以求出x关于y的条件概率密度，假设y是传感器观测的分布，而x是待求的状态量的话，那么相当于可以求出后验概率</p></blockquote><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-10-13-38.png"></p><ul><li>上图专门用来求后面观测量的均值和方差的</li></ul><h1 id="滤波器基本原理">滤波器基本原理</h1><blockquote><p>滤波器的目的是求最大后验概率</p></blockquote><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-10-20-09.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-11-12-34.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-11-12-58.png"></p><h2 id="贝叶斯滤波器">贝叶斯滤波器</h2><p><strong>详细推导</strong></p><p>待估计的后验概率密度：</p><p><span class="math display">\[\begin{aligned}    p(x_k|x_0,v_{1:k},y_{0:k})\end{aligned}\]</span></p><blockquote><p>意思为，给定</p><ul><li>初始状态<span class="math inline">\(x_0\)</span></li><li>1-k时刻的输入<span class="math inline">\(v_{1:k}\)</span></li><li>以及0-k时刻的观测<span class="math inline">\(y_{0:k}\)</span></li></ul><p>发生状态为<span class="math inline">\(x_k\)</span>的概率，我们后面的操作，就是为了求解<span class="math inline">\(x_k\)</span>，使得这个概率最大化</p></blockquote><p><span class="math display">\[\begin{aligned}    p(x_k|x_0,v_{1:k},y_{0:k})&amp;= p(x_k|x_0,v_{1:k},y_{0:k-1},y_k) \\    &amp;= \frac{p(x_k,x_0,v_{1:k},y_{0:-1},y_k)}{p(x_0,v_{1:k},y_{0:k-1},y_k)} \\    &amp;=\frac{p(y_k|x_k,x_0,v_{1:k},y_{0:k-1}) p(x_k|x_0,v_{1:k},y_{0:k-1}) p(x_0,v_{1:k},y_{0:k-1})}{p(y_k|x_0,v_{1:k},y_{0:k-1}) p(x_0,v_{1:k},y_{0:k-1})} \\    &amp;= \frac{p(y_k|x_k,x_0,v_{1:k},y_{0:k-1}) p(x_k|x_0,v_{1:k},y_{0:k-1})}{p(y_k|x_0,v_{1:k},y_{0:k-1})} \\    &amp;= \eta  p(y_k|x_k,x_0,v_{1:k},y_{0:k-1}) p(x_k|x_0,v_{1:k},y_{0:k-1})\end{aligned}\]</span></p><p>又因为观测方程中，<span class="math inline">\(y_k\)</span>仅和<span class="math inline">\(x_k\)</span>有关，所以进一步简化：</p><p><span class="math display">\[    p(x_k|x_0,v_{1:k},y_{0:k})=\eta p(y_k|x_k) p(x_k|x_0,v_{1:k},y_{0:k-1})\]</span></p><p>接下来进一步化简上式右侧一项<span class="math inline">\(p(x_k|x_0,v_{1:k},y_{0:k-1})\)</span></p><p>根据<span class="math inline">\(p(x)=\int p(x|y) p(y) dy\)</span>可得:</p><p><span class="math display">\[\begin{aligned}    p(x_k|x_0,v_{1:k},y_{0:k-1}) &amp;= \frac{p(x_k,x_0,v_{1:k},y_{0:k-1})}{p(x_0,v_{1:k},y_{0:k-1})} \\    &amp;= \int \frac{p(x_k,x_0,v_{1:k},y_{0:k-1}|x_{k-1}) p(x_{k-1})}{p(x_0,v_{1:k},y_{0:k-1})} d x_{k-1} \\    &amp;= \int \frac{p(x_k,x_{k-1},x_0,v_{1:k},y_{0:k-1})}{p(x_{k-1},x_0,v_{1:k},y_{0:k-1})} \frac{p(x_{k-1},x_0,v_{1:k},y_{0:k-1})}{p(x_0,v_{1:k},y_{0:k-1})} d x_{k-1} \\    &amp;= \int p(x_k|x_{k-1},x_0,v_{1:k},y_{0:k-1}) p(x_{k-1}|x_0,v_{1:k},y_{0:k-1}) d x_{k-1} \\    &amp;= \int p(x_k| x_{k-1},v_k) p(x_{k-1}|x_0,v_{1:k},y_{0:k-1}) d x_{k-1}\end{aligned}\]</span></p><blockquote><p>最后一步的化简是因为，k时刻的状态仅与k-1时刻的状态<span class="math inline">\(x_{k-1}\)</span>和对应的输入有关</p></blockquote><p>最终后验概率可以写成</p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-14-32-58.png"></p><p>其中，先验项就是k-1时刻下的后验概率。</p><blockquote><p>如何使用上面的推导？ ————贝叶斯滤波器</p></blockquote><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-14-39-03.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-14-41-21.png"></p><h2 id="卡尔曼滤波器">卡尔曼滤波器</h2><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-14-44-53.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-14-56-04.png"></p><blockquote><p>回顾： 多元联合高斯概率密度的分解 <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-10-00-00.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-10-03-02.png"> - <a href="http://epsilonjohn.club/2020/02/14/VIO/%E7%AC%AC%E5%9B%9B%E8%AE%B2/%E7%AC%AC%E5%9B%9B%E8%AE%B2(%E6%8B%93%E5%B1%95)_%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B(%E8%BE%B9%E7%BC%98%E5%8C%96%E4%B8%8E%E6%9D%A1%E4%BB%B6%E4%BD%9C%E7%94%A8)/#%E8%81%94%E5%90%88%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83%E7%9A%84%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">可参考：第四讲(拓展)_高斯过程(边缘化与条件作用)-联合高斯分布的分解</a> - 舒尔布顺序不一样，得到的结果不一样，但是实际上是等价的</p></blockquote><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-14-56-04.png"></p><blockquote><p>回顾: 这里可用来求观测方程的均值和方差 <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-10-13-38.png"></p></blockquote><p>因此，</p><ul><li><span class="math inline">\(\Sigma_{xx}=\check{P_k}\)</span></li><li><span class="math inline">\(\Sigma_{xy}=\Sigma_{xx}G_k^T=\check{P}_k G_k^T\)</span></li><li><span class="math inline">\(\Sigma_{yx}=\Sigma_{xy}^T=G_k\check{P}_k^T=G_k\check{P}_k\)</span></li><li><span class="math inline">\(\Sigma_{yy}=G_k\check{P}_kG_k^T+C_k R_k C_k^T\)</span></li></ul><p>所以，最终有:</p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-15-12-10.png"></p><ul><li><span class="math inline">\(R\)</span>: 观测噪声</li><li><span class="math inline">\(Q\)</span>: 输入噪声，IMU噪声</li></ul><h2 id="扩展卡尔曼滤波器">扩展卡尔曼滤波器</h2><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-15-21-05.png"></p><ul><li><span class="math inline">\(\hat{x}_{k-1}\)</span> 预测方程线性化点，上一个时刻的更新值</li><li><span class="math inline">\(\check{x}_k\)</span> 观测方程线性化点，是由预测方程得到的</li></ul><p>对运动方程进行线性化之后，输入k-1时刻的更新后的状态<span class="math inline">\(\hat{x_{k-1}}\)</span>以及控制输入<span class="math inline">\(w_k\)</span>，即可推导出预测值的均值和方差：</p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-15-25-17.png"></p><p>对观测方程进行线性化之后，即可得到观测的均值和方差：</p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-15-49-14.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-16-24-08.png"></p><h2 id="推导套路">推导套路</h2><p><strong>卡尔曼滤波</strong></p><ol type="1"><li>写出运动(预测)方程</li><li>写出观测方程</li><li>写出上一时刻(k-1)的后验分布，即更新后的状态值和方差</li><li>求预测值<span class="math inline">\(x_k\)</span>的均值和方差 (利用线性高斯的性质)</li><li>求观测值<span class="math inline">\(y_k\)</span>的均值和方差 (利用线性高斯的性质)</li><li>联合概率密度函数<span class="math inline">\(p(x_k,y_k)\)</span>分解，得到后验概率<span class="math inline">\(p(x_k|y_k)\)</span>的表示形式</li><li>将(4)(5)步求出来的均值和方差，带入(6)</li></ol><h2 id="迭代扩展卡尔曼滤波iekf">迭代扩展卡尔曼滤波(IEKF)</h2><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-16-42-10.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-16-44-33.png"></p><h2 id="sigmapoint卡尔曼滤波ukfspkf">sigmapoint卡尔曼滤波(UKF/SPKF)</h2><p><strong>基本原理</strong></p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-16-47-12.png"></p><p>使用sigmapoint点进行采样，得到一个新的分布，并且计算均值和方差</p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-16-50-01.png"></p><h3 id="预测步骤">预测步骤</h3><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-17-07-04.png"></p><h3 id="更新步骤">更新步骤</h3><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-17-07-26.png"></p><h2 id="粒子滤波器pf">粒子滤波器(PF)</h2><p>UKF还是依赖高斯分布假设，而蒙特卡洛方法则基于大数定律</p><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-17-08-33.png"></p><h3 id="预测步骤-1">预测步骤</h3><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-17-10-54.png"></p><h3 id="更新步骤-1">更新步骤</h3><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-12-17-27-26.png"></p><h2 id="几种滤波方法对比">几种滤波方法对比</h2><p><img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-14-12-31-04.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-14-12-31-21.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-14-12-31-31.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-14-12-32-14.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-14-12-34-44.png"> <img src="/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88-1/2020-11-14-12-35-36.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于滤波的融合方法&quot;&gt;基于滤波的融合方法&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/11/12/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%A
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>BALM论文阅读</title>
    <link href="http://yoursite.com/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2020-11-03T00:20:46.000Z</published>
    <updated>2021-01-20T00:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="balm-bundle-adjustment-for-lidar-mapping">BALM: Bundle Adjustment for Lidar Mapping</h1><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-08-21-31.png"></p><h1 id="摘要">摘要</h1><p>提出的方法通过最小化协方差矩阵的特征值来使得特征点分布在同一个边缘线或者平面上。为了加速求解，推到了微分，二阶闭式解。此外，还提出了自适应的体素滤波方法用来快速搜索特征关联。</p><h1 id="介绍">介绍</h1><p>增量式构建地图会由于环境退化或者较小视场角雷达而导致累计误差快速增大。降低这种漂移的其中一种方法是在激光雷达扫描的滑动窗口上执行局部BA，这使我们能够基于后续扫描中的新信息来重新评估过去的扫描，该方法已广泛用于视觉导航，并被证明是非常有效的。</p><p>由于直接进行深度测量，虽然激光雷达BA看起来比视觉BA更简单，但其公式实际上更复杂。因为在视觉BA，观测是高分辨率的图像，即每一个像素都可关联一个空间特征，如下图1，因此目标很明确，即最小化重投影误差。</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-08-29-11.png"></p><p>然而，这个并不适用于激光雷达，因为激光雷达点云非常稀疏，甚至是非重复的，因此无法进行精确的点对点匹配。</p><p>文章贡献：</p><ul><li>提出了激光雷达BA框架，不像视觉ba那样，而是通过最小化协方差矩阵来约束特征点到边缘线或者平面的距离，还推到了cost func(如特征值)对激光雷达位姿的梯度和Hessian矩阵</li><li>提出了自适应体素化方法来快速搜索特征关联</li></ul><p>效果：</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-08-36-25.png"></p><h1 id="ba推导">BA推导</h1><h2 id="问题描述">问题描述</h2><p>给定一组稀疏特征点<span class="math inline">\(p_{fi}(i=1,\cdots,N)\)</span> ——从M帧扫描中提取的，并且都关联到同一个特征上（平面或者边缘线），如图3</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-08-53-28.png"></p><p>假设第i个特征点从第<span class="math inline">\(s_i\)</span>帧提取，其中</p><ul><li><span class="math inline">\(i\in \{1,\cdots,N\}\)</span></li><li><span class="math inline">\(s_i \in \{1,\cdots,M\}\)</span></li><li>M帧的位姿记为<span class="math inline">\(T=(T_1,\cdots,T_M)\)</span></li></ul><p>那么，在全局地图上的特征点可以这样表示:</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-08-57-00.png"></p><p>如先前所定义，激光雷达BA的问题是共同确定M扫描的姿势和全局3D点，现在3D地图是一个单一特征（边缘或平面），然后BA问题是联合确定姿态T和该特征的位置位置，这由特征上的点q和单位矢量n表示（n是平面的法线向量或边缘的方向）</p><h3 id="对于平面特征">对于平面特征</h3><p>直接BA公式是最小化每个平面特征点到平面的距离，即：</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-09-01-03.png"></p><ul><li><span class="math inline">\(p_i\)</span>：根据待估计位姿投影到全局地图上的特征点</li><li><span class="math inline">\(q\)</span>：某个特征上的点（边缘线内、平面内）</li><li><span class="math inline">\(\vec{n}\)</span>: 边缘线的方向向量或者是平面法向量</li><li>因此，上式即为最小化投影点到特征的距离 <!-- - $\lambda_3(A)$记为矩阵A的最小特征值，当$u_3=\vec{n}$是对应的特征向量，同时也是边缘线的方向向量或者是平面法向量 --></li><li>当<span class="math inline">\(u_3=\vec{n}\)</span>，即当边缘线的方向向量或者是平面法向量是最小的特征向量<span class="math inline">\(u_3\)</span>时，并且<span class="math inline">\(q\)</span>为投影点的质心<span class="math inline">\(\bar{p}\)</span>时，此时特征值<span class="math inline">\(\lambda_3(A)\)</span>就表示投影点到特征的距离。</li></ul><p>质心<span class="math inline">\(\bar{p}\)</span>和A如下：</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-09-15-26.png"></p><p>式(3)表明，优化特征点位置以及特征法向量（方向向量）可以写成关于位姿T的函数，因此只需要对位姿T进行优化。</p><p>同时，对位姿T的优化简化为最小化(4)中定义的点协方差矩阵A的最小特征值<span class="math inline">\(\lambda_3\)</span></p><h3 id="对于边缘线特征">对于边缘线特征</h3><p>类似于平面特征，只是把特征值<span class="math inline">\(\lambda_3(A)\)</span>变成<span class="math inline">\(\lambda_2(A)\)</span></p><p>总而言之，激光雷达BA的目标是最小化每个项之和，其中每个项的形式如下：</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-03-09-31-13.png"></p><p>为了快速优化求解，下面推导对于位姿T的微分的闭式解，最高2阶。</p><p>根据链式法则，首先对点<span class="math inline">\(p\)</span>求导</p><h2 id="微分">微分</h2><h3 id="定理一">定理一</h3><p>对于一组点<span class="math inline">\(p_i(i=1,\cdots,N)\)</span>以及式(4)定义的协方差矩阵<span class="math inline">\(A\)</span>。假设矩阵<span class="math inline">\(A\)</span>有特征值<span class="math inline">\(\lambda_k\)</span>及其对应的特征向量<span class="math inline">\(u_k(k=1,2,3)\)</span>，则有<span class="math inline">\(\lambda_k\)</span>对点<span class="math inline">\(p_i\)</span>的偏导：</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-18-14-36-57.png"></p><p>其中，<span class="math inline">\(p\)</span>是N个点的均值。</p><h3 id="定理二">定理二</h3><p>对于一组点<span class="math inline">\(p_i(i=1,\cdots,N)\)</span>以及式(4)定义的协方差矩阵<span class="math inline">\(A\)</span>。假设矩阵<span class="math inline">\(A\)</span>有特征值<span class="math inline">\(\lambda_k\)</span>及其对应的特征向量<span class="math inline">\(u_k(k=1,2,3)\)</span>，则有<span class="math inline">\(\lambda_k\)</span>对点<span class="math inline">\(p_j\)</span>的偏导*<span class="math inline">\(\lambda_k\)</span>对点<span class="math inline">\(p_i\)</span>的偏导：</p><ul><li>当<span class="math inline">\(i \neq k\)</span>时, <span class="math inline">\(\lambda_i \neq \lambda_k\)</span></li></ul><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-18-14-47-33.png"></p><h2 id="二阶微分">二阶微分</h2><p>利用上述的一阶导和二阶导，可以使用如下二阶近似来近似式(5)的cost function</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-18-14-50-10.png"></p><p>其中，</p><ul><li><span class="math inline">\(J(p)\)</span> 是雅可比矩阵，第i个元素按式(6)计算</li><li><span class="math inline">\(H(p)\)</span> 是Hessian矩阵，其中第i行第j列元素按式(7)计算</li></ul><p>回想一下，点向量p进一步依赖于式(1)中的扫描位姿<span class="math inline">\(T\)</span></p><p>因此，按照链式求导法则，还需要求出 点对位姿的导数，这个可以参考 《14讲》</p><p>如果对位姿<span class="math inline">\(T_j\)</span>在其切平面进行扰动<span class="math inline">\(\delta T_j[\phi_j^T , \delta t_j^T]^T\)</span>，使用<span class="math inline">\(\boxplus\)</span>表示，则有：</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-18-15-00-05.png"></p><p>和</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-18-15-00-51.png"></p><p>将式(12)带入式(8)，可得：</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-18-15-03-54.png"></p><p>也就是说，特征值<span class="math inline">\(\lambda_k\)</span>对位姿的求导实际上是: <span class="math inline">\(JD\)</span></p><p>最后，就可以使用LM迭代求解增量了</p><p><img src="/2020/11/03/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/BALM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/2020-11-18-15-05-09.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;balm-bundle-adjustment-for-lidar-mapping&quot;&gt;BALM: Bundle Adjustment for Lidar Mapping&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;/2020/11/03/%E6%96%87%E7%8C%AE
      
    
    </summary>
    
    
      <category term="文献阅读" scheme="http://yoursite.com/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>第三章-(3)-补充内容</title>
    <link href="http://yoursite.com/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/"/>
    <id>http://yoursite.com/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/</id>
    <published>2020-11-02T12:36:46.000Z</published>
    <updated>2020-12-07T03:29:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="地球模型">地球模型</h1><h2 id="概念">概念</h2><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-01-29.png"> <img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-01-46.png"></p><h2 id="坐标系">坐标系</h2><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-04-01.png"></p><h1 id="高精度的惯导解算">高精度的惯导解算</h1><blockquote><p>指考虑精确的地球模型的导航解算</p></blockquote><h2 id="解算中的体现">解算中的体现</h2><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-16-42.png"></p><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-17-08.png"></p><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-19-27.png"></p><h2 id="误差方程">误差方程</h2><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-19-59.png"></p><h2 id="简化求解">简化求解</h2><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-21-31.png"></p><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-21-45.png"></p><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-21-59.png"></p><h1 id="中等精度imu处理方法">中等精度IMU处理方法</h1><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-26-39.png"></p><h1 id="组合导航与基于点云定位的区别">组合导航与基于点云定位的区别</h1><p><img src="/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E5%8E%9F%E7%90%86%E5%8F%8A%E8%AF%AF%E5%B7%AE%E5%88%86%E6%9E%90-3%E8%A1%A5%E5%85%85/2020-12-07-11-29-09.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;地球模型&quot;&gt;地球模型&lt;/h1&gt;
&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/2020/11/02/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8
      
    
    </summary>
    
    
      <category term="多传感器融合定位" scheme="http://yoursite.com/categories/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/"/>
    
    
  </entry>
  
</feed>
