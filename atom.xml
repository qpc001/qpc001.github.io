<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EpsilonJohn&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-03-10T01:52:57.299Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>EpsilonJohn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ROLI激光雷达IMU初始化及标定</title>
    <link href="http://yoursite.com/2022/03/06/Fast-LIO%E7%B3%BB%E5%88%97/ROLI%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEIMU%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%A0%87%E5%AE%9A/"/>
    <id>http://yoursite.com/2022/03/06/Fast-LIO%E7%B3%BB%E5%88%97/ROLI%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BEIMU%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E6%A0%87%E5%AE%9A/</id>
    <published>2022-03-06T04:02:22.000Z</published>
    <updated>2022-03-10T01:52:57.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="robust-and-online-lidar-inertial-initialization">Robust and Online LiDAR-inertial Initialization</h1><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306201811.png"></p><h1 id="介绍">介绍</h1><p>摘要：对于大多数LiDAR惯性里程计来说，精确的初始状态，包括时间偏差和LiDAR与6轴IMU之间的外参，起着重要的作用，通常被认为是前提条件。然而，在定制的激光雷达惯性系统中，这样的信息并不总是可用的，本文提出了一种完全在线的激光雷达惯性系统初始化过程，该过程通过校准激光雷达和IMU之间的时间偏差和外参，并通过将激光雷达测量的状态估计值与IMU测量的状态值对齐来校正重力矢量和IMU偏差。我们将所提出的方法实现为一个初始化模块，如果启用该模块，它将自动检测采集数据的激发程度，同时校准时间偏移量、外参偏移量、重力矢量和惯性测量单元偏差，然后将其用作在线激光雷达惯性里程仪系统的高质量初始状态值。对不同类型的激光雷达和激光雷达-惯性组合进行的实验表明了该初始化方法的鲁棒性、适应性和有效性。</p><p>我们的LiDAR-惯性初始化法的主要目的之一是在<strong>没有任何初始估计</strong>的情况下校准LiDAR和IMU之间的外特性。现有的一些外部标定方法是基于批量优化的，数据关联性很强，耗时较大。例如，Lveal。[14]提出了一种基于连续时间批优化的标定方法。B样条的使用使得需要估计的参数较多，计算量也较大。[15]使用扩展卡尔曼过滤估计运动补偿复杂的外域变换，收敛速度有限。与这些方法相比，我们的方法更轻量级，能够快速运行，同时仍然可以获得足够精确的外部校准，以便后续的在线估计(例如，通过[1])。我们的方法还校准了[14，15]中没有考虑的时间偏移。此外，文献[14，15]所采用的基于NDT的扫描-扫描匹配通常不适用于具有非重复扫描模式的激光雷达。相比之下，我们的方法采用了扫描到地图的匹配策略，可以很容易地应用重复扫描和非重复扫描的LiDAR。</p><h1 id="方法">方法</h1><h2 id="系统框架">系统框架</h2><p>由于IMU只有在运动时才被激发[15]，所以我们的初始化过程是基于运动的方法，这意味着充分的激励是必要的。我们工作流程的概述如图2所示，一些重要符号如表一所示。我们建议的LiDAR里程计(参见第III-B节)由FAST-LIO2[1]改进而来，采用恒定(角和线)速度(CV)模型来预测LiDAR运动并进行畸变矫正。</p><p>为了缓解恒速模型与传感器实际运动之间的失配，通过将输入帧分割成几个子帧来提高LiDAR里程计速率。</p><p>如果LiDAR里程计没有失效(例如，退化)，并且估计的LiDAR角速度和线速度满足我们建议的评估标准(参见第III-C5节)，则认为激励是足够的，并且LiDAR里程计输出和相应的IMU数据都被馈送到初始化模块(参见第III-C节)</p><p>在初始化中，首先通过移动IMU测量值来校准时间偏移，以与LiDAR里程计对准，然后进行优化处理，进一步细化时间偏移，校准外参，估计IMU偏差和重力矢量。通过融合后续的LiDAR和IMU数据，可以将初始化的状态附加到紧耦合的LiDAR惯性里程计(例如，[1])，用于在线状态估计。</p><h2 id="激光里程计">激光里程计</h2><p>我们的LiDAR里程计是建立在恒速(CV)运动模型上的，该模型假设在tk和tk+1接收到的两个连续扫描之间的角速度和线速度是恒定的，即，在tk和tk+1接收到的两个连续扫描之间，有：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306215022.png"></p><p>其中<span class="math inline">\(\Delta t\)</span>是两帧扫描的时间间隔，状态向量<span class="math inline">\(\mathbf{x}\)</span>、噪声<span class="math inline">\(\mathbf{w}\)</span>和离散的状态转移函数<span class="math inline">\(\mathbf{f}\)</span>定义如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306215311.png"></p><p>其中：</p><ul><li><span class="math inline">\({ }^{G} \mathbf{R}_{L} \in S O(3)\)</span>和<span class="math inline">\({ }^{G} \mathbf{p}_{L}\)</span>分别表示激光雷达在全局坐标系（此处为第0帧激光坐标系）的姿态的位置</li><li><span class="math inline">\({ }^{G} \mathbf{v}_{L}\)</span>是激光雷达在全局坐标系的速度表示</li><li><span class="math inline">\(\omega_{L}\)</span>是激光雷达线速度（在激光雷达坐标系）</li><li>上述两个速度被分别被建模为由高斯噪声<span class="math inline">\(\mathbf{n}_{\mathbf{v}}\)</span>和<span class="math inline">\(\mathbf{n}_{\omega}\)</span>驱动的随机游走过程。</li></ul><p>在对于公式（1），使用文献[22]的记号<span class="math inline">\(\boxplus / \boxminus\)</span>紧凑地表示状态流形上的“+”。具体地说，对于公式(2)中的状态流形<span class="math inline">\(S O(3) \times \mathbb{R}^{n}\)</span>，运算及其逆定义如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306220010.png"></p><p>其中：</p><ul><li><span class="math inline">\(\mathbf{R}, \mathbf{R}_{1}, \mathbf{R}_{2} \in S O(3)\)</span>，</li><li><span class="math inline">\(\mathbf{r}, \mathbf{a}, \mathbf{b} \in \mathbb{R}^{n}\)</span></li><li><span class="math inline">\(\operatorname{Exp}(\cdot): \mathbb{R}^{3} \mapsto S O(3)\)</span> 表示指数映射</li><li><span class="math inline">\(\log (\cdot): S O(3) \mapsto \mathbb{R}^{3}\)</span>是指数映射的逆，即对数映射</li></ul><p>在实践中，传感器的运动可能不具有恒定速度。<strong>为了减轻这种模型误差的影响，我们可以将输入的LiDAR扫描分割成多个持续时间较短的子帧</strong>，在这些子帧上传感器的运动更符合CV模型。</p><h3 id="误差迭代卡尔曼">误差迭代卡尔曼</h3><p>基于流形上的系统表示(1)，我们使用误差状态迭代卡尔曼过滤(ESIKF)[23]来估计其状态，ESIKF的预测步骤由状态预测和协方差传播组成，如下所示：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306220634.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{P}\)</span>表示状态估计的协方差</li><li><span class="math inline">\(\mathbf{Q}\)</span>表示过程噪声<span class="math inline">\(\mathbf{w}\)</span>对应的协方差</li></ul><p><span class="math inline">\(\mathbf{F}_{\tilde{\mathbf{x}}}\)</span> 和 <span class="math inline">\(\mathbf{F}_{\mathbf{w}}\)</span>定义如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306220815.png"></p><blockquote><p>由误差状态微分方程可导出（上述Fx Fw是离散时间下的）</p></blockquote><h3 id="运动补偿">运动补偿</h3><p>在我们考虑的问题中，<strong>IMU和LiDAR是不同步的</strong>，因此文献[14，15]所采用的IMU辅助运动补偿方法是不可行的。</p><p>在时间戳<span class="math inline">\(t_{k+1}\)</span>处接收到新的激光雷达扫描之后，为了补偿运动失真，我们将在时间戳<span class="math inline">\(\rho_{j} \in\left(t_{k}, t_{k+1}\right)\)</span>处采样的每个包含点<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{j}\)</span>投影到扫描端激光雷达帧<span class="math inline">\(L_{k+1}\)</span>中，也就是将激光矫正<strong>到扫描结束时刻</strong>。</p><p>在恒速模型下，我们有<span class="math inline">\({}^G \widehat{\mathbf{v}}_{L_{k+1}}={}^G{\overline{\mathbf{v}}}_{L_{k}}, \widehat{\boldsymbol{\omega}}_{L_{k+1}}=\overline{\boldsymbol{\omega}}_{L_{k}}\)</span>，因此，可以导出<span class="math inline">\({}^{L_{k+1}} \check{\mathbf{T}}_{L_{j}}=\left({ }^{L_{k+1}} \check{\mathbf{R}}_{L_{j}},{ }^{L_{k+1}} \check{\mathbf{p}}_{L_{j}}\right)\)</span>的计算如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306221754.png"></p><p>然后，在时间段<span class="math inline">\(\rho_{j} \in\left(t_{k}, t_{k+1}\right)\)</span>内的测量<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{j}\)</span>可以被投影到扫描结束时刻，即：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306222001.png"></p><p>矫正之后的激光扫描<span class="math inline">\(\left\{ {}^{L_{k+1}} \mathbf{p}_{j}\right\}\)</span>用于提供未知状态<span class="math inline">\({}^G \mathbf{T}_{L_{k+1}}\)</span>的隐式测量，表示为点到面距离残差，在此基础上，在迭代卡尔曼滤波器框架中迭代估计完整状态<span class="math inline">\(\mathbf{x}_{k+1}\)</span>，直到收敛。这种迭代估计的细节可以参考FAST-LIO2[1]或[23]，以便更一般地处理流形约束。</p><p>收敛后的状态估计记为<span class="math inline">\(\overline{\mathbf{x}}_{k+1}\)</span>，将用于传播后续IMU测量，如第III-B1节所述。</p><p>图3中示出了使用有运动补偿和无运动补偿的扫描的映射结果比较。</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306222357.png"></p><h3 id="激光-惯性初始化">激光-惯性初始化</h3><p>第III-B节中的激光雷达里程计在每个扫描结束时间<span class="math inline">\(t_{k}\)</span>输出激光雷达的角速度<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>和线速度<span class="math inline">\({ }^{G} \mathbf{V}_{L_{k}}\)</span>。同时，惯性测量单元提供了原始测量，包括时间戳<span class="math inline">\(\tau_{i}\)</span>的body系角速度<span class="math inline">\(\omega_{m}\)</span>和线加速度<span class="math inline">\(\mathbf{a}_{m_{i}}\)</span>。这些数据按照第III-C5节所示的激励标准进行累积和重复评估。</p><p>一旦收集到足够激励的数据，就调用初始化模块，然后输出如下信息：</p><ul><li>时间偏移<span class="math inline">\({ }^{I} t_{L} \in \mathbb{R}\)</span></li><li>外参<span class="math inline">\({ }^{I} \mathbf{T}_{L}=\left({ }^{I} \mathbf{R}_{L},{ }^{I} \mathbf{p}_{L}\right) \in SE(3)\)</span></li><li>IMU Bias<span class="math inline">\(\mathbf{b}_{\omega}, \mathbf{b}_{\mathbf{a}} \in \mathbb{R}^{3}\)</span></li><li>以及全局坐标系下的重力向量<span class="math inline">\({ }^{G} \mathbf{g} \in \mathbb{R}^{3}\)</span></li></ul><ol type="1"><li>数据处理</li></ol><p>IMU原始测量数据收到噪声<span class="math inline">\(\mathbf{n}_{\omega_{i}}\)</span> 和 <span class="math inline">\(\mathbf{n}_{\mathbf{a}}\)</span>的影响，因此IMU测量模型如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306223946.png"></p><p>其中，</p><ul><li><span class="math inline">\(\omega_{i}^{\mathrm{gt}}, \mathbf{a}_{i}^{\mathrm{gt}}\)</span>是测量真值</li><li>同时，从激光里程计估计出来的<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},{ }^{G} \mathbf{v}_{L_{k}}\)</span>也包含了噪声</li></ul><p>为了消除这些通常是高频的噪声，使用了非因果零阶低通滤波器[24]来过滤噪声，而不会引入任何过滤延迟。<strong>零相位过滤是通过巴特沃斯低通滤波器的前向和后向运行来实现</strong>的[24]，得到噪声衰减（去除噪声影响的测量）的IMU测量<span class="math inline">\(\boldsymbol{\omega}_{I_{i}}=\boldsymbol{\omega}_{i}^{\mathrm{gt}}+\mathbf{b}_{\omega}, \mathbf{a}_{I_{i}}=\mathbf{a}_{i}^{\mathrm{gt}}+\mathbf{b}_{\mathbf{a}}\)</span>为表示简单起见，噪声衰减的激光里程计速度估计值仍然表示为<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},{ }^{G} \mathbf{v}_{L_{k}}\)</span>。</p><p>从激光雷达里程计得到的<span class="math inline">\(\boldsymbol{\omega}_{L_{k}},^{G} \mathbf{v}_{L_{k}}\)</span>，通过非因果中心差分[25]得到激光雷达角加速度和线加速度<span class="math inline">\(\boldsymbol{\Omega}_{L_{k}},{ }^{G} \mathbf{a}_{L_{k}}\)</span>，因此，根据激光里程计得到的数据记为：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306233851.png"></p><p>类似地，我们从噪声衰减的陀螺测量<span class="math inline">\(\omega_{I}\)</span>得到角加速度<span class="math inline">\(\boldsymbol{\Omega}_{I_{i}}\)</span>，因此有：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306234056.png"></p><p>由于IMU频率通常高于LiDAR odometer的频率，因此两个序列<span class="math inline">\(\mathcal{I}_{i}\)</span>和<span class="math inline">\(\mathcal{L}_{k}\)</span>的长度并不相同。为了解决这一问题，我们提取在同一时间段内接收的LiDAR和IMU数据，并通过在每个LiDAR里程计时间<span class="math inline">\(t_{k}\)</span>对<span class="math inline">\(\mathcal{I}_{i}\)</span>进行线性插值来实现下采样(参见图4)。</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306234448.png"></p><p>降采样的IMU数据记为<span class="math inline">\(\mathcal{I}_{k}\)</span>：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306234533.png"></p><p>其中，<span class="math inline">\(\mathcal{I}_{k}\)</span>具有与<span class="math inline">\(\mathcal{L}_{k}\)</span>相同的时间戳<span class="math inline">\(t_{k}\)</span>(但是数据实际上被已知的时间常数<span class="math inline">\({ }^{I} t_{L}\)</span>延迟)。</p><ol start="2" type="1"><li>用互相关法进行时间初始化(Temporal Initialization by Cross-Correlation)</li></ol><p>在大多数情况下，由于LiDAR惯性里程计模块受到接收数据之前不可避免的传输和处理延迟，在LiDAR <span class="math inline">\(\mathcal{L}_{k}\)</span>和IMU <span class="math inline">\(\mathcal{I}_{k}\)</span>之间将存在未知但恒定的偏移<span class="math inline">\({ }^{I} t_{L}\)</span>（例如IMU数据，全部向前推进<span class="math inline">\({ }^{I} t_{L}\)</span>，则与激光雷达数据对齐）。</p><p>由于激光雷达数据公式(9)和IMU数据公式(11)处于离散时间<span class="math inline">\(t_{k}\)</span>，因此IMU数据的推进实质上是以离散时间步<span class="math inline">\(d={ }^{I} t_{L} / \Delta t\)</span>进行的，其中<span class="math inline">\(\Delta t\)</span>是两次激光雷达扫描之间的时间间隔。具体地说，对于角速度，我们有：</p><p>[[Pasted image 20220306235340.png]]</p><p>忽略通常很小的陀螺偏置bω，我们发现<span class="math inline">\(\boldsymbol{\omega}_{I_{k+d}}\)</span>和<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>的大小(模长)应该是相同的，而与外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>无关。受[16]的启发，我们使用互相关来量化它们之间的相似度。然后，偏移量<span class="math inline">\(d\)</span>可以从下面的优化问题中求解：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/06/20220306235549.png"> 通过枚举<span class="math inline">\(\mathcal{L}_{k}\)</span>的索引范围内的偏移量<span class="math inline">\(d\)</span>。</p><blockquote><p>这里是通过对IMU数据逐个前挪来实现对齐，所以<span class="math inline">\(d\)</span>的理解是：IMU前移1个数据，即前移了<span class="math inline">\(\Delta t\)</span>时间，所以<span class="math inline">\({ }^{I} t_{L}= d * \Delta t\)</span></p></blockquote><ol start="3" type="1"><li>统一的旋转外参和时间校准</li></ol><p>(2)中的互相关法对噪声和小尺度陀螺偏差具有较强的鲁棒性。但其的一个明显缺陷是，时间偏移的校准分辨率只能达到激光雷达里程计的一个采样间隔<span class="math inline">\(\Delta t\)</span>，不能识别任何小于<span class="math inline">\(\Delta t\)</span>的剩余偏移δt。</p><p>设<span class="math inline">\({ }^{I} t_{L}\)</span>为激光雷达里程计ωL与IMU数据ωi之间的总偏移量，则<span class="math inline">\({ }^{I_{t}} t_{L}=d^{*} \Delta t+\delta t\)</span>。与公式(12)类似，如果IMU测量<span class="math inline">\(\boldsymbol{\omega}_{I}\)</span>提前时间<span class="math inline">\({ }^{I} t_{L}\)</span>，则通过下式将与激光雷达里程计<span class="math inline">\(\omega_{L}\)</span>对齐：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/08/20220308094706.png"></p><p>由于公式(9)中的实际激光雷达里程计<span class="math inline">\(\boldsymbol{\omega}_{L}\)</span>仅在时间戳<span class="math inline">\(t_{k}\)</span>处可用，用<span class="math inline">\(t=t_{k}\)</span>和<span class="math inline">\({ }^{I} t_{L}=d^{*} \Delta t+\delta t\)</span>代入到公式(14)，并注意到<span class="math inline">\(\boldsymbol{\omega}_{L}\left(t_{k}\right)=\boldsymbol{\omega}_{L_{k}}\)</span>，我们有：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/08/20220308094924.png"></p><p>注意到，<span class="math inline">\(\boldsymbol{\omega}_{I}\left(t_{k}+d^{*} \Delta t+\delta t\right)\)</span>是在时间戳为<span class="math inline">\(t_{k}+d^{*} \Delta t\)</span>之后紧跟的IMU角速度，而时间戳为<span class="math inline">\(t_{k}+d^{*} \Delta t\)</span>对应的角速度和角加速度分别为<span class="math inline">\(\omega_{I}\left(t_{k}+d^{*} \Delta t\right)=\omega_{I_{k}}\)</span>和<span class="math inline">\(\boldsymbol{\Omega}_{I}\left(t_{k}+d^{*} \Delta t\right)=\boldsymbol{\Omega}_{I_{k^{\prime}}}\)</span>，假设角加速度在小量<span class="math inline">\(\delta t\)</span>上恒定，我们可以插值得到<span class="math inline">\(\boldsymbol{\omega}_{I}\left(t_{k}+d^{*} \Delta t+\delta t\right)\)</span>：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/08/20220308095413.png"></p><p>将上式（16）代入公式（16），可以获得：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/08/20220308095500.png"></p><p>最后，基于公式(17)中的约束，统一的时空优化问题可以表述为：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/08/20220308095721.png"></p><p>上述问题可通过<code>Ceres</code>迭代求解(由于非线性约束<span class="math inline">\({ }^{I} \mathbf{R}_{L} \in S O(3)\)</span>)，并且给定初始值为<span class="math inline">\(\left({ }^{I} \mathbf{R}_{L}, \mathbf{b}_{\omega}, \delta t\right)=\left(\mathbf{I}_{3 \times 3}, \mathbf{0}_{3 \times 1}, 0\right)\)</span></p><ol start="4" type="1"><li>平移外参与重力向量初始化</li></ol><p>在第III-C3节中，我们得到了外旋转<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>、陀螺偏置<span class="math inline">\(\mathbf{b}_{\omega}\)</span>和时间偏移量<span class="math inline">\({ }^{I} t_{L}\)</span>。在这一部分中，我们将固定这些值，然后进行平移外参、重力矢量和加速度偏差的校准。</p><p>首先，我们使用之前得到的偏移<span class="math inline">\(d^{*}\)</span>和<span class="math inline">\(\delta t\)</span>来对齐IMU数据<span class="math inline">\(\mathcal{I}_{k}\)</span>和雷达数据<span class="math inline">\(\mathcal{L}_{k}\)</span>。对齐的IMU数据表示为̄<span class="math inline">\(\overline{\mathcal{I}}_{k}\)</span>，现在认为它与<span class="math inline">\(\mathcal{L}_{k}\)</span>完全对齐，没有时间偏移。</p><p>具体地，在时间<span class="math inline">\(t_{k}\)</span>对应于LiDAR角速度̄<span class="math inline">\(\boldsymbol{\omega}_{L_{k}}\)</span>的IMU角速度<span class="math inline">\(\bar{\omega}_{I_{k}}\)</span>为（其实就是公式（15））：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/09/20220309230908.png"></p><p>相似的，与时刻<span class="math inline">\(t_{k}\)</span>的LiDAR加速度<span class="math inline">\({ }^{G} \mathbf{a}_{L_{k}}\)</span>对应的IMU加速度̄<span class="math inline">\(\overline{\mathbf{a}}_{I_{k}}\)</span>为：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/09/20220309231105.png"></p><p>与公式（14）类似，我们可以找到IMU和LiDAR之间的加速度约束。如文献[26]所述，具有固定外参的两个坐标系A、B的加速度具有以下关系：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/09/20220309231254.png"></p><p>其中，</p><ul><li><span class="math inline">\({ }^{A} \mathbf{R}_{B},{ }^{A} \mathbf{p}_{B}\)</span>表示从B系到A系的外参变换</li><li><span class="math inline">\(\mathbf{a}_{A}, \mathbf{a}_{B}\)</span>分别是加速度在两个坐标系的表示</li></ul><blockquote><p>上面公式（21）怎么来的，为啥不是 <span class="math inline">\({ }^{A} \mathbf{R}_{B} \mathbf{a}_{B}=\mathbf{a}_{A}\)</span></p></blockquote><p>对于LiDAR-惯性系统，我们有两种选择：A用于IMU，B用于LiDAR，或者相反的情况。值得注意的是，在第一种情况下，<span class="math inline">\(\boldsymbol{\omega}_{A}=\overline{\boldsymbol{\omega}}_{I_{k}}-\mathbf{b}_{\omega}\)</span>的精度受到陀螺仪偏差估计的影响，并且<span class="math inline">\(\boldsymbol{\Omega}_{A}\)</span>的误差会因角速度测量中的噪声而被放大。</p><p>为了避免这一问题，增加外源平移校准的鲁棒性，我们将LiDAR设置为A，将IMU设置为B，由于LiDAR的加速度<span class="math inline">\({ }^{G} \mathbf{a}_{L_{k}}\)</span>是在全局坐标系中（即第0帧激光坐标系）描述的，所以我们需要将这个加速度转换到激光雷达坐标系下，记为<span class="math inline">\(\mathbf{a}_{L_{k}}\)</span>：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/09/20220309232853.png"></p><p>其中，<span class="math inline">\({ }^{G} \mathbf{R}_{L}\)</span>是LiDAR在激光里程计全局坐标系的姿态，由第III-B节中的LiDAR里程计获得。</p><p>最后，平移外参、加速度计偏置和重力矢量可以从以下优化问题中联合估计：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/09/20220309233109.png"></p><p>上述问题可以由<code>ceres</code>求解器迭代求解(由于约束<span class="math inline">\({ }^{G} \mathbf{g} \in \mathrm{S}_{2}\)</span>)，并且指定初始值<span class="math inline">\(\left({ }^{I} \mathbf{p}_{L}, \mathbf{b}_{\mathbf{a}},{ }^{G} \mathbf{g}\right)= \left(\mathbf{0}_{3 \times 1}, \mathbf{0}_{3 \times 1}, 9.81 \mathbf{e}_{3}\right)\)</span>。</p><p>在估计<span class="math inline">\({ }^{L} \mathbf{p}_{I}\)</span>之后，从激光雷达到IMU的转换计算如下：<span class="math inline">\({ }^{I} \mathbf{p}_{L}=-{ }^{I} \mathbf{R}_{L}^{L} \mathbf{p}_{I}\)</span></p><ol start="5" type="1"><li>数据累积评估</li></ol><p>提出的初始化方法依赖于LiDAR惯性器件的充分激励(充分运动)。因此，系统应该能够自行评估激励是否足以执行初始化。</p><p>理想情况下，可以通过公式（18）关于<span class="math inline">\(\left({ }^{I} \mathbf{R}_{L}, \mathbf{b}_{\omega}, \delta t\right)\)</span>和公式（23）关于<span class="math inline">\(\left({ }^{I} \mathbf{p}_{L}, \mathbf{b}_{\mathbf{a}},{ }^{G} \mathbf{g}\right)\)</span>的的全雅可比矩阵的秩来评估激励。</p><p>在实际中，我们发现，使用关于外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>和<span class="math inline">\({ }^{I} \mathbf{p}_{L}\)</span>的雅可比来评估运动就足够了，因为对外参的激发通常需要复杂的运动，这也会激发其他状态。因此，记<span class="math inline">\(\mathbf{J}_{r}\)</span>为公式（18）对旋转外参<span class="math inline">\({ }^{I} \mathbf{R}_{L}\)</span>的雅可比，<span class="math inline">\(\mathbf{J}_{t}\)</span>为公式（23）对平移外参<span class="math inline">\({ }^{I} \mathbf{p}_{L}\)</span>的雅可比，如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/10/20220310094624.png"></p><p>那么，激励可以通过对以下矩阵的秩来进行评估：</p><ul><li><span class="math inline">\(\mathbf{J}_{r}^{T} \mathbf{J}_{r}=\sum\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor{ }_{\wedge}^{T}\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor \wedge\)</span></li><li><span class="math inline">\(\mathbf{J}_{t}^{T} \mathbf{J}_{t}=\sum\left(\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor_{\wedge}^{2}+ \left\lfloor\boldsymbol{\Omega}_{\left.L_{k}\right\rfloor}\right\rfloor_{\wedge}\right)^{T}\left(\left\lfloor\boldsymbol{\omega}_{L_{k}}\right\rfloor_{\Lambda}^{2}+\left\lfloor\boldsymbol{\Omega}_{L_{k}}\right\rfloor \wedge\right)\)</span></li></ul><p>更定量地，用<span class="math inline">\(\mathbf{J}_{r}^{T} \mathbf{J}_{r}\)</span>和<span class="math inline">\(\mathbf{J}_{t}^{T} \mathbf{J}_{t}\)</span>的奇异值来表示激发的程度。<strong>根据这一原理，我们开发了一个评估程序，可以指导用户如何移动他们的设备以获得足够的激励</strong>。我们根据雅可比矩阵的奇异值来量化激励，并用来评估激励是否充分。</p><h1 id="参考">参考</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;robust-and-online-lidar-inertial-initialization&quot;&gt;Robust and Online LiDAR-inertial Initialization&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>IEKF迭代扩展卡尔曼滤波器</title>
    <link href="http://yoursite.com/2022/02/28/Fast-LIO%E7%B3%BB%E5%88%97/IEKF%E8%BF%AD%E4%BB%A3%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>http://yoursite.com/2022/02/28/Fast-LIO%E7%B3%BB%E5%88%97/IEKF%E8%BF%AD%E4%BB%A3%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%99%A8/</id>
    <published>2022-02-28T14:02:22.000Z</published>
    <updated>2022-03-12T12:56:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="performance-evaluation-of-iterated-extended-kalman-filterwith-variable-step-length">Performance evaluation of iterated extended Kalman filterwith variable step-length</h1><h1 id="介绍">介绍</h1><p>优化方法主要基于最小化均方误差准则，对于线性高斯系统，导致了著名的卡尔曼滤波。与提供状态的条件PDF的贝叶斯方法不同，最优化方法提供状态的点估计和估计误差的相应协方差矩阵(CM)。与贝叶斯方法一样，基于最优化方法的状态估计问题只能在少数特殊情况下得到解析解。对于其他情况，估计方法通常遵循卡尔曼滤波框架，并利用非线性函数的线性化等逼近技术，例如，扩展(EKF)和二阶扩展卡尔曼滤波器[6]、[1]分别通过围绕当前估计到一阶或二阶的泰勒级数展开来逼近非线性函数，当线性化误差的影响往往会扰乱过滤的性能或其收敛性时，在更新状态附近重新线性化测量方程可能会减轻困难。</p><p>这种方法被称为迭代扩展卡尔曼过滤(IEKF)[6]。</p><p>IEKF计算状态估计不是作为近似条件平均值(就像EKF那样)，而是作为最大后验(MAP)估计[7]。文献[8]证明了IEKF量测更新是高斯-牛顿(GN)方法的应用，而EKF是仅用一次GN方法迭代的IEKF的特例。</p><p>第二节简要介绍了EKF和IEKF的非线性状态估计及其求解方法。第三节简要介绍了IEKF的最新发展。第四节介绍了分析中使用的各种性能度量。接下来，在第五节中，通过两个数值例子对两种滤波器进行了比较，并在第六节中对本文进行了总结。</p><h1 id="nonlinear-state-estimation-by-ekf-and-iekf">Nonlinear state estimation by EKF and IEKF</h1><h2 id="系统描述">系统描述</h2><p>离散时间非线性随机系统的状态空间形式如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228191455.png"></p><p>其中，</p><ul><li><p>向量<span class="math inline">\(\mathbf{x}_{k} \in \mathbb{R}^{n_{x}}\)</span>和<span class="math inline">\(\mathbf{z}_{k} \in \mathbb{R}^{n_{z}}\)</span>分别表示在时间k下，系统的状态和观测。</p></li><li><p><span class="math inline">\(\mathbf{f}_{k}: \mathbb{R}^{n_{x}} \rightarrow \mathbb{R}^{n_{x}}\)</span> and <span class="math inline">\(\mathbf{h}_{k}: \mathbb{R}^{n_{x}} \rightarrow \mathbb{R}^{n_{z}}\)</span>是已知的向量函数。</p></li><li><p><span class="math inline">\(\mathbf{w}_{k} \in \mathbb{R}^{n_{x}}\)</span>和<span class="math inline">\(\mathbf{v}_{k} \in \mathbb{R}^{n_{z}}\)</span>是相互独立的状态白噪声和测量白噪声。</p></li></ul><p>噪声的概率密度函数是零均值且已知协方差矩阵<span class="math inline">\(\Sigma_{k}^{\mathbf{w}}\)</span> and <span class="math inline">\(\Sigma_{k}^{\mathbf{v}}\)</span>的高斯分布，即有<span class="math inline">\(p\left(\mathbf{w}_{k}\right)=\mathcal{N}\left\{\mathbf{w}_{k} ; \mathbf{0}_{n_{x} \times 1}, \Sigma_{k}^{\mathbf{w}}\right\} *\)</span>和<span class="math inline">\(p\left(\mathbf{v}_{k}\right)=\mathcal{N}\left\{\mathbf{v}_{k} ; \mathbf{0}_{n_{z} \times 1}, \Sigma_{k}^{\mathbf{v}}\right\}\)</span>。初始态的概率密度函数是高斯的，也是已知的，即<span class="math inline">\(p\left(\mathbf{x}_{0}\right)=\mathcal{N}\left\{\mathbf{x}_{0} ; \hat{\mathbf{x}}_{0}, \mathbf{P}_{0}\right\}\)</span>。初始状态与噪声无关</p><h2 id="扩展卡尔曼">扩展卡尔曼</h2><p>最初，卡尔曼过滤是在1960年利用正交性原理[13]推导出来的。给出了具有线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>的系统(1)和(2)的最小均方误差估计。</p><p>对于非线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>，必须使用近似，例如在EKF中使用的近似。EKF基于一阶泰勒级数展开(TE1)。在假设状态预测平均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k-1}=\mathrm{E}\left[\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right]\)</span>(定义线性化点)已知的条件下，函数<span class="math inline">\(\mathbf{h}_{k}\)</span>的泰勒一阶展开由下式给出：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228192900.png"></p><p>其中，矩阵<span class="math inline">\(\mathbf{H}_{k}=\left.\frac{\partial \mathbf{h}\left(\mathbf{x}_{k}\right)}{\partial \mathbf{x}_{k}}\right|_{\mathbf{x}_{k}=\hat{\mathbf{x}}_{k \mid k-1}}\)</span>是测量函数<span class="math inline">\(\mathbf{h}_{k}(\cdot)\)</span>关于<span class="math inline">\(\mathbf{X}_{k}\)</span>在线性化点<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>的雅可比。</p><p>预测更新步骤的TE1近似的使用是类似的。在已知滤波均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}=\mathrm{E}\left[\mathbf{x}_{k} \mid \mathbf{z}^{k}\right]\)</span>的假设下，(1)中的<span class="math inline">\(\mathbf{f}_{k}\)</span>的TE1具有如下形式：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228193333.png"></p><p>其中，<span class="math inline">\(\mathbf{F}_{k}=\left.\frac{\partial \mathbf{f}\left(\mathbf{x}_{k}\right)}{\partial \mathbf{x}_{k}}\right|_{\mathbf{x}_{k}=\hat{\mathbf{x}}_{k \mid k}}\)</span>是系统矩阵<span class="math inline">\(\mathbf{f}_{k}(\cdot)\)</span>关于关于<span class="math inline">\(\mathbf{X}_{k}\)</span>在线性化点<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k}\)</span>的雅可比。</p><p>扩展卡尔曼算法如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228193529.png"></p><blockquote><p>对于具有轻度非线性函数<span class="math inline">\(\mathbf{f}_{k}\)</span> and <span class="math inline">\(\mathbf{h}_{k}\)</span>的系统，扩展卡尔曼滤波性能良好，但是如果测量方程(2)是强非线性的(例如在纯方位跟踪问题中)，滤波器的性能就会恶化。在这种情况下，IEKF往往比EKF提供更准确的估计。</p></blockquote><h2 id="迭代扩展卡尔曼">迭代扩展卡尔曼</h2><p>IEKF[6]的想法是在存在显著非线性的情况下改进参考轨迹，从而改进估计。这些改进是通过EKF测量更新的局部迭代实现的(参见算法2)。迭代通常在连续迭代中没有显著变化或满足其他标准(如最大迭代次数)时停止。算法如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228193907.png"></p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228200156.png"></p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228193927.png"></p><p>翻译一下，就是以下步骤:</p><ol type="1"><li><p>初始化：设置迭代次数<span class="math inline">\(i=0\)</span>，此时有<span class="math inline">\(\hat{\mathbf{x}}_{k}^{0}=\hat{\mathbf{x}}_{k \mid k-1}\)</span>，表示在第k次观测的第0次迭代的状态<span class="math inline">\(\mathbf{x}_{k}^{0}\)</span>等于利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span></p></li><li><p>测量更新：计算测量函数在迭代状态<span class="math inline">\(\mathbf{x}_{k}^{i}\)</span>处的雅可比<span class="math inline">\(\mathbf{H}_{k}^{i}\)</span>，更新第i次迭代的卡尔曼增益<span class="math inline">\(\mathbf{K}_{k}^{i}\)</span>，更新第i次迭代后的状态<span class="math inline">\(\hat{\mathbf{x}}_{k}^{i+1}\)</span>,如下：</p></li></ol><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228200516.png"></p><p>其中，</p><ul><li><p><span class="math inline">\(\mathbf{H}_{k}^{i}\)</span>是测量函数在迭代状态<span class="math inline">\(\mathbf{x}_{k}^{i}\)</span>处</p></li><li><p><span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>是利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的协方差，即第0次迭代前的协方差</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k \mid k-1}\)</span>是利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态，即第0次迭代前的状态</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k}^{i}\)</span>是第k观测下，迭代i次后的状态</p></li><li><p><span class="math inline">\(\hat{\mathbf{x}}_{k}^{i+1}\)</span>是第k观测下，迭代i+1次后的状态</p></li></ul><ol start="3" type="1"><li>迭代完成后，需要更新（保存）状态和协方差：</li></ol><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228201345.png"></p><p>即协方差是在迭代结束后再更新的，迭代过中一直使用的是<span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>，即上一次更新完后又预测到k时刻的协方差。</p><p>值得一提的是，即使在IEKF算法中发生的重新线性化也不能保证滤波器的收敛性，IEKF也不总是比扩展卡尔曼滤波性能好。不过，IEKF测量更新有两个非常有趣的属性：</p><ul><li><p>它可以看作是高斯-牛顿法的一种应用</p></li><li><p>它生成最大后验（MAP）估计：<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}^{\mathrm{MAP}}=\underset{\mathbf{x}_{k}}{\arg \max } p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span></p></li></ul><h2 id="对迭代扩展卡尔曼过滤算法的改进">对迭代扩展卡尔曼过滤算法的改进</h2><p>如上所述，IEKF可以看作是求解非线性最小二乘问题的GN方法的一种应用。因此，在IEKF中可以使用对GN方法的改进来提高方法的性能和收敛性，以提高估计的质量。改变步长是常用的改进措施之一。首先，介绍了IEKF最小化的MAP准则。</p><h3 id="map-criterion">MAP criterion</h3><p>如果使用系统(1)和(2)的概率描述，则使用先验的概率密度函数<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>来求后验PDF<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span>。</p><p>先验的概率分布<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的均值<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>和协方差<span class="math inline">\(\mathbf{P}_{k \mid k-1}\)</span>在算法1的时间更新步骤中计算。其假设为高斯，并且在算法2的测量更新中计算后验PDF<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的均值<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}\)</span>和方差<span class="math inline">\(\mathbf{P}_{k \mid k}\)</span>。</p><p>后验概率<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k}\right)\)</span>与似然<span class="math inline">\(p\left(\mathbf{z}_{k} \mid \mathbf{x}_{k}\right)=p_{\mathbf{v}_{k}}\left(\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right)\)</span>与先验<span class="math inline">\(p\left(\mathbf{x}_{k} \mid \mathbf{z}^{k-1}\right)\)</span>的乘积成正比，即有：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228202344.png"></p><p>其中，为方便起见，不依赖于<span class="math inline">\(\mathbf{X}_{k}\)</span>的项已被删除。然后由下式给出MAP估计：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228202535.png"></p><p>现在，有了MAP模型，可以使用GN方法来找到<span class="math inline">\(\hat{\mathbf{x}}_{k \mid k}\)</span>，以达到最小化函数。理想情况下，每次GN方法迭代(即IEKF测量更新迭代)都应该减小准则<span class="math inline">\(\mathbf{V}_{k}\)</span>。</p><p>IEKF测量更新(16)可以用隐式方式被重写：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228202910.png"></p><p>本次迭代更新偏移量<span class="math inline">\(\Delta_{k}^{i}\)</span>如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/28/20220228202946.png"></p><p>其中，<span class="math inline">\(\hat{\mathbf{x}}_{k}^{0}=\hat{\mathbf{x}}_{k \mid k-1}\)</span>，即在第k次观测的第0次迭代的状态<span class="math inline">\(\mathbf{x}_{k}^{0}\)</span>等于利用前<span class="math inline">\(k-1\)</span>次观测以及所预测的k时刻的状态<span class="math inline">\(\hat{\mathbf{X}}_{k \mid k-1}\)</span>（先验）</p><p><strong>对于高斯牛顿方法</strong>，也可以求出更新偏移量<span class="math inline">\(\Delta_{k}^{i}\)</span>的另一种表达形式：</p><p>高斯牛顿法就是将<span class="math inline">\(f(\mathbf{x})\)</span>进行一届泰勒展开（注意这里的<span class="math inline">\(f(\mathbf{x})\)</span>不是目标函数，而是原函数，即<span class="math inline">\(f(\mathbf{x}) = z-h(\mathbf{x})\)</span></p><p>因此，有：</p><p><span class="math display">\[    f(\mathbf{x}+\Delta{\mathbf{x}}) \approx f(\mathbf{x}) + \mathbf{J}(\mathbf{x})\Delta{\mathbf{x}}\]</span></p><p>其中，<span class="math inline">\(\mathbf{J}(\mathbf{x})\)</span>为<span class="math inline">\(f(\mathbf{x})\)</span>关于<span class="math inline">\(\mathbf{x}\)</span>的雅克比。</p><p>经过系列变换，最终可以得到正规方程：</p><p><span class="math display">\[    \mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x}) \Delta{\mathbf{x}} = -\mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \]</span></p><p>因此有：</p><p><span class="math display">\[    \Delta{\mathbf{x}} = - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \]</span></p><p>对于式（17）（18）所展示的MAP问题，可以进一步建模为：</p><p><span class="math display">\[\begin{aligned}\hat{\mathbf{x}}_{k \mid k} &amp;=\underset{\mathbf{x}_{k}}{\arg \min } \frac{1}{2}\left(\left[\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right]^{T}\left(\Sigma_{k}^{v}\right)^{-1}\left[\mathbf{z}_{k}-\mathbf{h}_{k}\left(\mathbf{x}_{k}\right)\right]+\left[\hat{\mathbf{x}}_{k \mid k-1}-\mathbf{x}_{k}\right]^{T} \mathbf{P}_{k \mid k-1}^{-1}\left[\hat{\mathbf{x}}_{k \mid k-1}-\mathbf{x}_{k}\right]\right) \\&amp;=\underset{\mathbf{x}_{k}}{\arg \min } \frac{1}{2} r(\mathbf{X})^{T}r(\mathbf{X})\end{aligned}\]</span></p><p>其中，</p><p><span class="math display">\[r(\mathbf{X})=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_k-h(\mathbf{x}_k)) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k \right)\end{array}\right]\]</span></p><p>雅克比<span class="math inline">\(J(\mathbf{X})\)</span>如下：</p><p><span class="math display">\[\mathbf{J}_{k}=-\left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]\]</span></p><p><span class="math display">\[\mathbf{H}_{k}=\left.\frac{\partial h(s)}{\partial s}\right|_{s=\mathbf{x}_{k}}\]</span></p><p>将信息回代到高斯牛顿正规方程，可以得到增量<span class="math inline">\(\Delta{\mathbf{x}}\)</span>如下：</p><p><span class="math display">\[ \begin{aligned}    \Delta{\mathbf{x}} &amp;= - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x}) \\    &amp;=     \left(        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]^{T}        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]    \right)^{-1}        \left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k} \\\mathbf{P}_{k \mid k-1}^{-1 / 2}\end{array}\right]^{T}        \left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_k-h(\mathbf{x}_k)) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k \right)\end{array}\right]\\    &amp;=     \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        (\mathbf{z}_k-h(\mathbf{x}_k))    +    \mathbf{P}_k^{-1}(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    \right)    \\    &amp;=    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \{    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        (\mathbf{z}_k-h(\mathbf{x}_k) - \mathbf{H}_k (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k))    +    \\    &amp;  \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k    (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    +    \mathbf{P}_k^{-1}(\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)    \}    \\    &amp;=    \hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k +    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}    \left (        \mathbf{z}_k-h(\mathbf{x}_k) - \mathbf{H}_k (\hat{\mathbf{x}}_{k \mid k-1}- \mathbf{x}_k)        \right)\end{aligned} \]</span></p><p>此时，如果令<span class="math inline">\(\mathbf{K}_{k}\)</span>满足:</p><p><span class="math display">\[\mathbf{K}_{k} = \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k + \mathbf{P}_k^{-1}    \right)^{-1}    \mathbf{H}_k^{T} \mathbf{R}_k^{-1}\]</span></p><p>定睛一看，这货不就是公式（20）由IEKF的增量吗？</p><p>所以，<strong>IEKF实际上是高斯牛顿的一种应用</strong>，如果多个观测放在一起来求解，就是最小二乘，如果迭代的求解，就成了IEKF。</p><h1 id="iekf在fast-lio系列的应用">IEKF在Fast-LIO系列的应用</h1><p>回顾Fast-LIO1论文，公式(17)，要优化的目标函数是：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/12/20220312105428.png"></p><p>其中，包含了先验项和观测项</p><h2 id="先验项">先验项</h2><ol type="1"><li>第一项<span class="math inline">\(\left\|\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\right\|_{\widehat{\mathbf{P}}_{k}^{-1}}^{2}\)</span>是先验项，其表述有点奇怪</li></ol><hr><p>原文描述如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/12/20220312105720.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{X}_{k}\)</span>表示状态真值</li><li><span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>表示k时刻预测值</li><li><span class="math inline">\(\mathbf{J}^{\kappa}\)</span>表示<span class="math inline">\(\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxplus \widetilde{\mathbf{x}}_{k}^{\kappa}\right) \boxminus \widehat{\mathbf{x}}_{k}\)</span>关于误差状态<span class="math inline">\(\tilde{\mathbf{x}}_{k}^{\kappa}\)</span>的雅克比</li></ul><p>按照原文的意思是，<span class="math inline">\(\left\|\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\right\|_{\widehat{\mathbf{P}}_{k}^{-1}}^{2}\)</span>用于约束预测值<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>不应该离状态真值太远，即误差状态应尽可能小（这个先验看起来跟平时的形式不一样，<strong>难以理解</strong>）。</p><hr><p>下面，按照我们通用的理解去描述：</p><p>先验一般约束着迭代状态值<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa}\)</span>不应该离预测值<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>太远，因此，先验对应的残差项可以写为：</p><p><span class="math display">\[\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\]</span></p><blockquote><p>因此，个人认为，原文公式（17）第一项不应该为<span class="math inline">\(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k}\)</span>，替换为<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\)</span>更合理</p></blockquote><h2 id="观测项">观测项</h2><ol start="2" type="1"><li>第二项<span class="math inline">\(\left\|\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>在原文中的表述比较牵强：</li></ol><hr><p>原文公式如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/03/12/20220312174507.png"> <img src="http://s1.nsloop.com:59080/images/2022/03/12/20220312173821.png"></p><p>上面<span class="math inline">\(\mathbf{h}_{j}\left(\mathbf{x}_{k},{ }^{L_{j}} \mathbf{n}_{f_{j}}\right)\)</span>的意思是，给定状态真值<span class="math inline">\(\mathbf{x}_{k}\)</span>和测量噪声<span class="math inline">\({ }^{L_{j}} \mathbf{n}_{f_{j}}\)</span>，那么理论上得到的观测值（即点到平面的距离）为0。</p><p>然而，由于无法得知状态真值，因此使用一阶近似得到的公式（14）。此处使用的<span class="math inline">\(\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\)</span>让人容易混淆，还是看下文的另外一种描述。</p><hr><p>前面提到，实际的观测值其实不用去观测，因为点就在平面上，所以实际的观测值为0，即<span class="math inline">\(\mathbf{z_{true}} = 0\)</span>。</p><p>为了衡量当前估计的状态是否足够接近真值，我们利用迭代的状态去计算点-面距离，<strong>这一个操作称为观测预测</strong>，<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\)</span>为观测预测模型，即通过给定状态来计算在该状态下得到的观测值，此处为计算得到的点-面距离。</p><p>因此，残差项可以写为：</p><p><span class="math display">\[    \mathbf{z_{true}} -\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\]</span></p><p>其中，已知<span class="math inline">\(\mathbf{z_{true}} = 0\)</span>，因此，残差项就是利用迭代的状态计算得到的点-面距离<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}\right)\)</span>。</p><blockquote><p>因此，个人认为，原文描述的第二项不应该为<span class="math inline">\(\left\|\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>，替换为<span class="math inline">\(\left\| \mathbf{z_{true}} -\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\right\|_{\mathbf{R}_{j}^{-1}}^{2} = \left\|\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\right\|_{\mathbf{R}_{j}^{-1}}^{2}\)</span>更为合适。</p></blockquote><h2 id="推导">推导</h2><p>综上，我们继续使用上面的方法再一次推导：</p><p>假设目标函数<span class="math inline">\(r(\mathbf{X})\)</span>如下:</p><p><span class="math display">\[r(\mathbf{X})=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}\left ( \mathbf{z_{true}} -\mathbf{h}_{j}(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}) \right) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k} \right)\end{array}\right] = \left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}\left ( \mathbf{h}_{j}(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}) \right) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{x}_{k} \boxminus \widehat{\mathbf{x}}_{k} \right)\end{array}\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right)\)</span>是观测模型，对其进行泰勒一阶展开，可得：<span class="math inline">\(\mathbf{h}_{j}\left(\widehat{\mathbf{x}}_{k}^{\kappa}\boxplus\tilde{\mathbf{x}}_{k}^{\kappa}, \mathbf{0}\right) \approx \mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \tilde{\mathbf{x}}_{k}^{\kappa}\)</span>，其中<span class="math inline">\(\mathbf{z}_{j}^{\kappa}\)</span>就是利用状态<span class="math inline">\(\widehat{\mathbf{X}}_{k}^{\kappa}\)</span>计算得到的点到平面距离</li><li><span class="math inline">\(j\)</span>表示第j个激光点</li></ul><p>根据高斯牛顿的思想，对残差函数进行一阶泰勒展开如下：</p><p><span class="math display">\[\begin{aligned}r(\mathbf{X^{\kappa} +\Delta \mathbf{x}}) = r(\mathbf{X^{\kappa} +\tilde{\mathbf{x}}_{k}^{\kappa}}) &amp;=r(\mathbf{X^{\kappa}})+ J(\mathbf{X}^{\kappa})\tilde{\mathbf{x}}_{k}^{\kappa}\\&amp;=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}+\mathbf{H}_{j}^{\kappa} \tilde{\mathbf{x}}_{k}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}+\mathbf{J}^{\kappa} \widetilde{\mathbf{x}}_{k}^{\kappa}\right)\end{array}\right]\\&amp;=\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)\end{array}\right]+\left[\begin{array}{c}\left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{H}_{j}^{\kappa}) \\\mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\mathbf{J}^{\kappa} \right)\end{array}\right]\widetilde{\mathbf{x}}_{k}^{\kappa}\end{aligned}\]</span></p><p>其中</p><ul><li><span class="math inline">\(\mathbf{H}^{\kappa}_{j}\)</span>是激光投影点到地图上最近的平面的距离关于误差状态的雅克比，其推导可从<a href="https://readpaper.com/paper/3131967444" target="_blank" rel="noopener">R2LIVE</a>中找到。</li><li><span class="math inline">\(\mathbf{J}^{\kappa}\)</span>表示<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\)</span>关于误差状态<span class="math inline">\(\tilde{\mathbf{x}}_{k}^{\kappa}\)</span>的雅克比</li></ul><p>雅克比<span class="math inline">\(J(\mathbf{X}^{\kappa})\)</span>如下：</p><p><span class="math display">\[\mathbf{J}_{k}^{\kappa} =\left[\begin{array}{c}\mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\\mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa} \end{array}\right]\]</span></p><p><span class="math display">\[\mathbf{H}_{k}^{\kappa} =\left.\frac{\partial h(s)}{\partial s}\right|_{s=\mathbf{x}_{k}^{\kappa} }\]</span></p><p><span class="math display">\[\mathbf{J}^{\kappa}=\left[\begin{array}{cc}\mathbf{A}\left({ }^{G} \widehat{\mathbf{R}}_{I_{k}}^{\kappa} \boxminus^{G} \widehat{\mathbf{R}}_{I_{k}}\right)^{-T} &amp; \mathbf{0}_{3 \times 15} \\\mathbf{0}_{15 \times 3} &amp; \mathbf{I}_{15 \times 15}\end{array}\right]\]</span></p><p>这里注意区分<span class="math inline">\(\mathbf{J}_{k}\)</span>和<span class="math inline">\(\mathbf{J}^{\kappa}\)</span>。</p><p>将<span class="math inline">\(r(\mathbf{X^{\kappa}})\)</span>以及雅克比<span class="math inline">\(J(\mathbf{X}^{\kappa})\)</span>回代到高斯牛顿正规方程，可以得到增量<span class="math inline">\(\Delta{\mathbf{x}}\)</span>如下：</p><p><span class="math display">\[\begin{aligned}    \Delta{\mathbf{x}} &amp;= - \left (\mathbf{J}(\mathbf{x})^{T}\mathbf{J}(\mathbf{x})\right)^{-1} \mathbf{J}(\mathbf{x})^{T} f(\mathbf{x})     \\    &amp;= -    \left(        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]^{T}        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]    \right)^{-1}        \left[\begin{array}{c}        \mathbf{R}_{k}^{-1 / 2} \mathbf{H}_{k}^{\kappa} \\        \mathbf{P}_{k \mid k-1}^{-1 / 2} \mathbf{J}^{\kappa}         \end{array}\right]^{T}    \left[\begin{array}{c}    \left(\mathbf{R}_{k}\right)^{-\frac{1}{2}}(\mathbf{z}_{j}^{\kappa}) \\    \mathbf{P}_{k \mid k-1}^{-\frac{1}{2}}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \end{array}\right]    \\    &amp;= -    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    \left \{        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        \mathbf{z}_k^{\kappa} +        (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right \}    \\    &amp;= -    \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    \{        \mathbf{H}_k^{T} \mathbf{R}_k^{-1}        \mathbf{z}_k^{\kappa} +        (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \\    &amp;+ \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k (\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) - \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k (\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \}    \\    &amp;= -(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) -     \left(        \mathbf{H}_k^{T} \mathbf{R}_k^{-1} \mathbf{H}_k +  (\mathbf{J}^{\kappa})^{T}\mathbf{P}_k^{-1}(\mathbf{J}^{\kappa})    \right)^{-1}    (\mathbf{H}_k^{T} \mathbf{R}_k^{-1})    \left (        \mathbf{z}_k^{\kappa} +        \mathbf{H}_k(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right )    \\    &amp;= -(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right) -      \mathbf{K}_{k}^{\kappa}    \left (        \mathbf{z}_k^{\kappa} +        \mathbf{H}_k(\mathbf{J}^{\kappa})^{-1}        \left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)    \right )    \\    &amp;=    -\mathbf{K} \mathbf{z}_{k}^{\kappa}-(\mathbf{I}-\mathbf{K} \mathbf{H})\left(\mathbf{J}^{\kappa}\right)^{-1}\left(\widehat{\mathbf{x}}_{k}^{\kappa} \boxminus \widehat{\mathbf{x}}_{k}\right)\end{aligned}\]</span></p><p>按照上述推导，即可得到与论文公式（18）一致的结果。</p><h1 id="参考">参考</h1><p><a href="https://zhuanlan.zhihu.com/p/141018958" target="_blank" rel="noopener">知乎：迭代扩展卡尔曼滤波(IEKF)</a></p><p><a href="https://readpaper.com/pdf-annotate/note?noteId=658232918830911488&amp;pdfId=658232843626635264" target="_blank" rel="noopener">论文：Performance evaluation of iterated extended Kalman filter with variable step-length</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;performance-evaluation-of-iterated-extended-kalman-filterwith-variable-step-length&quot;&gt;Performance evaluation of iterated extended Kalm
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>IKFOM论文阅读</title>
    <link href="http://yoursite.com/2022/02/27/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/02/27/Fast-LIO%E7%B3%BB%E5%88%97/IKFOM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-02-27T12:22:58.000Z</published>
    <updated>2022-02-28T16:01:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kalman-filters-on-differentiable-manifolds">Kalman Filters on Differentiable Manifolds</h1><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227202357.png"></p><h1 id="摘要">摘要</h1><p>卡尔曼滤波是现代控制系统中最重要和应用最广泛的滤波技术之一。然而，几乎所有当前的卡尔曼滤波器的变体都是在欧几里得空间Rn中制定的，而许多现实世界的系统(例如，机器人系统)实际上是在流形上进化的。</p><p>在本文中，我们提出了一种为这类流形上系统设计卡尔曼滤波器的方法。利用运算<span class="math inline">\(\boxplus \backslash \boxminus\)</span>，并进一步定义了相应流形上的⊕运算，给出了流形上系统的规范表示。这种非正则形式使我们能够在卡尔曼过滤的每一步中将多种约束从系统行为中分离出来，最终产生一个在流形上自然演化的通用的和象征性的卡尔曼过滤框架。</p><p>此外，这种流形上的卡尔曼滤波器集成了C++包实现，它使用户能够实现集成卡尔曼滤波器，就像在<span class="math inline">\(\mathbb{R}^{n}\)</span>空间中的普通卡尔曼过滤一样：用户只需要提供系统特定的描述，然后调用各自的过滤步骤(例如，预测、更新)，而不需要处理任何流形约束。</p><h1 id="preliminaries-of-differentiable-manifolds">PRELIMINARIES OF DIFFERENTIABLE MANIFOLDS</h1><h2 id="可微分流形differentiable-manifolds">可微分流形（Differentiable manifolds）</h2><p>如文[34]所示，维数为n的流形是局部同胚于<span class="math inline">\(\mathbb{R}^{n}\)</span>的集合M(称为homeomorphicspace)。、</p><p>也就是说，对于任意一个点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>以及一个包含该点的开子集<span class="math inline">\(U \subset \mathcal{M}\)</span>，存在一个双射函数(称为homeomorphism)φ，它将<span class="math inline">\(U\)</span>中的点映射到<span class="math inline">\(\mathbb{R}^{n}\)</span>的开子集。该对<span class="math inline">\((\phi, U)\)</span>称为局部坐标图，如果任何两个图<span class="math inline">\((\phi, U)\)</span>和<span class="math inline">\((\psi, V)\)</span>共享重叠的合成映射<span class="math inline">\(\phi \circ \psi^{-1}\)</span>是可微的，则该流形称为可微流形。</p><h2 id="boxplus-backslash-boxminus操作"><span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作</h2><p>流形M中任意点周围<code>homeomorphisms</code>的存在使我们能够封装两个算子<span class="math inline">\(\boxplus_{\mathcal{M}}\)</span>(“boxplus”)和<span class="math inline">\(\boxminus_{\mathcal{M}}\)</span>(“boxminus”)到流形[25]：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227204348.png"></p><p>其中，<span class="math inline">\(\mathcal{M}_{\varphi_{\mathrm{x}}}\)</span>是点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>的一个<code>homeomorphism</code>.</p><p><span class="math inline">\(\mathbf{y}=\mathbf{x} \boxplus_{\mathcal{M}} \mathbf{u}\)</span>的物理含义是向点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>添加一个扰动<span class="math inline">\(\mathbf{u}\)</span>，然后产生了流形上的<span class="math inline">\(\mathbf{y} \in \mathcal{M}\)</span>， 如图2所示。</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227204921.png"></p><p>其中，逆操作<span class="math inline">\(\mathbf{u}=\mathbf{y} \boxminus_{\mathcal{M}} \mathbf{x}\)</span>可以确定扰动量<span class="math inline">\(\mathbf{u}\)</span>，该扰动量<span class="math inline">\(\mathbf{u}\)</span>就是产生<span class="math inline">\(\mathbf{y} \in \mathcal{M}\)</span>时，对点<span class="math inline">\(\mathbf{x} \in \mathcal{M}\)</span>进行<span class="math inline">\(\boxplus_{\mathcal{M}^{-}}\)</span>操作所添加的扰动。</p><p>这两个操作符创建了一个局部的、矢量化视角，对应于流形上复杂的全局结构。</p><p>对于李群来说，当<span class="math inline">\(\mathcal{M}\)</span>是Lie group (e.g., <span class="math inline">\(\left.\mathbb{R}^{n}, S O(3), S E(3)\right)\)</span>，正切空间具有表示为m的李代数结构和指数映射<span class="math inline">\(\exp : \mathfrak{m} \mapsto \mathcal{M}\)</span>。</p><p>令<span class="math inline">\(\mathfrak{f}: \mathbb{R}^{n} \mapsto \mathfrak{m}\)</span>作为从最小参数化空间到李代数、指数映射<span class="math inline">\(\operatorname{Exp}=\exp \circ f\)</span>以及其逆操作<span class="math inline">\(\log\)</span>的的映射，那么<span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作的定义如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227210416.png"></p><p>其中·是M上的二元运算，使得<span class="math inline">\((\mathcal{M}, \cdot)\)</span>形成李群，<span class="math inline">\(\mathbf{x}^{-1}\)</span>是<span class="math inline">\(\mathbf{X}\)</span>的逆，对于李群上的元素，它总是存在。</p><p>当流形M不是李群时，找出流形与其切空间参数化之间的同胚没有一般准则。例如，2球面流形<span class="math inline">\(\mathbb{S}^{2}(r) \triangleq\{\mathbf{x} \in \left.\mathbb{R}^{3} \mid\|\mathbf{x}\|=r, r&gt;0\right\}\)</span>在点x处的切线空间就是在点<span class="math inline">\(\mathbf{X}\)</span>的简单正切平面，如图3所示。</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227211039.png"><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227211039.png"><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227211039.png"></p><p>对于点<span class="math inline">\(\mathbf{x} \in \mathbb{S}^{2}(r)\)</span>，扰动可以通过沿着正切平面上的向量旋转来实现，结果仍将保留在<span class="math inline">\(\mathbb{S}^{2}(r)\)</span>上。</p><p>正切平面中的旋转向量被<span class="math inline">\(\mathbf{u} \in \mathbb{R}^{2}\)</span>最小参数化表达，其中，所在的空间为由两个bias向量<span class="math inline">\(\mathbf{b}_{1}, \mathbf{b}_{2} \in \mathbb{R}^{3}\)</span>所展开的正切平面。也就是说：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227212601.png"></p><p>其中，<span class="math inline">\(\mathbf{R}(\mathbf{w})=\operatorname{Exp}(\mathbf{w}) \in S O(3)\)</span>记为关于由向量<span class="math inline">\(\mathbf{w} \in \mathbb{R}^{3}\)</span>所表示的轴-角旋转。特别的，<span class="math inline">\(\mathbf{b}_{1}, \mathbf{b}_{2}\)</span>的选择不是唯一的，只要它们是正交的并且都垂直于x。</p><blockquote><p><span class="math inline">\(\mathbb{S}^{2}\)</span>常用于重力的表示，如VINS-Mono就用这个来表示并进一步refine重力向量。</p></blockquote><h2 id="oplus操作符"><span class="math inline">\(\oplus\)</span>操作符</h2><p>现实世界的系统通常是由一些外在的输入驱动的。为了模拟这一现象，除了描述流形本身所在的状态之外，还需要一个额外的操作来描述流形上的状态是如何在无限小的时间周期内由恒定的外生速度驱动的。</p><p>尽管速度对状态的影响增加了对流形上其原始位置的扰动，这在流形上有很好的描述运算符<span class="math inline">\(\boxplus\)</span>，则外部速度不一定在相同的homeomorphic空间(即，切线空间)中，该空间定义操作，因此需要表示为<span class="math inline">\(\oplus_{\mathcal{M}}\)</span>的新操作。</p><p>假设外部速度的维度是l，那么新的操作为：<span class="math inline">\(\oplus_{\mathcal{M}}: \mathcal{M} \times \mathbb{R}^{l} \mapsto \mathcal{M}\)</span></p><p>具体地说，当<span class="math inline">\(\mathcal{M}\)</span>是李群时，外生速度通常位于正切空间，同时也定义了公式(2)中的<span class="math inline">\(\boxplus \backslash \boxminus\)</span>操作，因此操作⊕与<span class="math inline">\(\boxplus\)</span>重合，即：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227214214.png"></p><p>。。。</p><h2 id="差分">差分</h2><p><span class="math inline">\((((\mathbf{x} \boxplus \mathbf{u}) \oplus \mathbf{v}) \boxminus \mathbf{y})\)</span>相对于<span class="math inline">\(\mathbf{u}\)</span>和<span class="math inline">\(\mathbf{V}\)</span>的差分将会在后面的卡尔曼滤波器中用到，其中，<span class="math inline">\(\mathbf{x}, \mathbf{y} \in \mathcal{M}, \mathbf{u} \in \mathbb{R}^{n}\)</span>，<span class="math inline">\(\mathbf{v} \in \mathbb{R}^{l}\)</span>。</p><p>由链式法则，可得：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227214416.png"></p><p>对于某些流形(例如，SO(3))，计算微分通常更为方便，而不用使用链式法则展开。</p><h2 id="复合可微流形">复合可微流形</h2><p>基于流形的笛卡儿积原理，给出了流形的定义由两个子流形(归纳为任意个子流形)组成的复合流形上的<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>操作定义如下：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227214841.png"></p><p>因此复合流形上的偏微分满足(见引理)：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227214913.png"></p><p><span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>运算及其在复合流形上的偏微分非常有用，使用户能够定义<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>运算及其导数(例如，<span class="math inline">\(\mathbb{R}^{n}, S O(3), \mathbb{S}^{2}(r)\)</span>)，然后将这些定义推广到更复杂的复合流形。</p><p>例如，根据前面讨论<span class="math inline">\(\boxplus \backslash \boxminus\)</span> and <span class="math inline">\(\oplus\)</span>的定义，总结了几个重要流形，包括<span class="math inline">\(\mathbb{R}^{n}, S O(3), \mathbb{S}^{2}(r)\)</span>的运算，并在表中总结了它们的局部微分，其中：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227215246.png"></p><p>其中，<span class="math inline">\(\lfloor\mathbf{u}\rfloor\)</span>记为反对称矩阵，并且有：</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227215356.png"></p><p>总结表如下： （详细推导见附录B）</p><p><img src="http://s1.nsloop.com:59080/images/2022/02/27/20220227215458.png"></p><h2 id="流形系统的规范表示">流形系统的规范表示</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;kalman-filters-on-differentiable-manifolds&quot;&gt;Kalman Filters on Differentiable Manifolds&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com:59080/
      
    
    </summary>
    
    
      <category term="Fast-LIO系列" scheme="http://yoursite.com/categories/Fast-LIO%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/02/01/M_LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2022/02/01/M_LOAM%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2022-02-01T12:41:23.436Z</published>
    <updated>2021-10-05T09:51:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="robust-odometry-and-mapping-for-multi-lidar-systems-with-online-extrinsic-calibration">Robust Odometry and Mapping for Multi-LiDAR Systems with Online Extrinsic Calibration</h1><p><img src="http://s1.nsloop.com:59080/images/2021/10/02/20211002092755.png"></p><h1 id="摘要">摘要</h1><p>组合多个LIDARS使机器人能够最大化其对环境的感知意识，并获得足够的测量。本文提出了一种实现鲁棒和同步的外参标定，里程计和多个LIDAR的建图系统。</p><p>我们的方法从测量预处理开始，从原始测量中提取边缘和平面特征，在运动和外参初始化过程之后，基于滑动窗口的多激光雷达里程计将板载运行，以估计具有在线标定和收敛性检测的位姿。</p><p>我们进一步开发了一种建图算法来构造全局地图，并优化具有足够特征的Pose以及捕获和减少数据不确定性的方法。</p><h1 id="介绍">介绍</h1><p>如果没有手动干预，我们的系统可以从多个未知外参的激光雷达开始，自动校准其外参，并提供准确的姿势以及全局一致的地图。先前的工作（LIOM），启发了本文，我们尝试解决多激光雷达融合问题的地方。此外，我们介绍了一种基于运动的方法[4]以初始化外参的方法，并使用[19]中的工具来表示不确定性。 本文贡献如下：</p><ul><li>自动初始化，计算所有关键状态，包括连续帧之间的运动以及后续阶段的外参。它可以在任意位置开始，而无需任何先前的机械配置或校准对象知识(Section VI)</li><li>使用常规收敛准则的在线自标定与里程计同时执行，它具有以完全无监督的方式监控收敛性和触发终止的能力(Section VII-B)</li><li>基于滑动窗口的里程计，充分利用来自多个 LiDAR 的信息，该实现可以解释为小规模的帧到地图注册表，这进一步减少了连续帧到帧的帧累积的漂移(Section VII-C)</li><li>使用二阶段方法进行建图，捕获传感器噪声并传播不确定性，来消除姿势估计和外参估计的外部扰动，这种方法使建图过程能够了解不确定性，并有助于我们保持全局地图的一致性以及提高系统的鲁棒性以进行长期导航任务。</li></ul><p>据我们所知，M-LOAM是第一个对多激光雷达外参标定和SLAM的完整解决方案，该系统在手持设备和自动驾驶汽车上进行了广泛的实验评估，从室内办事处到户外城市道路的各种情景，优于基于Sota Lidar的方法。关于各种平台上的校准，我们的方法实现了外参上的平移的厘米级精度和旋转的分数。对于不同尺度的SLAM，已成功应用M-LOAM以提供准确的姿势和地图结果。 图1可视化每个阶段的M-Loam的输出。</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/02/20211002095249.png"></p><h1 id="相关工作">相关工作</h1><h2 id="lidar-based-slam">LiDAR-Based SLAM</h2><h2 id="multi-sensor-calibration">Multi-Sensor Calibration</h2><p>Kummerle等 [52]开创了一个超图优化框架，用于校准带轮式编码器的车载激光扫描仪，Teichman等人[53] 同时，提出了一种迭代的SLAM-Fitting Pipline，以解决两个RGB-D相机的畸变，为了恢复多摄像时系统的空间偏移，恒等人[54]将问题转换为为<code>Bundle Adjustment</code>，而欧阳展鹏等[55]采用<code>Ackermann</code>转向模型来限制外参。</p><p>如[47]所示，[56] - [58]，传感器之间的时间偏移的在线估计对IMU的系统至关重要。 Qin等 [56]利用QIU等人的视觉特征的重新注入误差制定时间校准问题。 [58]提出了一种通过分析传感器的运动相关来校准异质传感器的更一般的方法。</p><p>本文隐含地同步了基于硬件的外部时钟的多个激光雷达的时间系统，并明确关注外参标定。 我们的方法包括在线程序，以实现灵活的多激光雷达外参标定。 要监控估计的外部的融合，我们提出了一般标准。 此外，我们对外部扰动进行建模，以减少其对长期导航任务的负面影响。</p><h1 id="问题描述">问题描述</h1><p>我们根据最大似然估计（Maximum Like- lihood Estimation， MLE）制定M-LOAM，MLE导致非线性优化问题，其中，高斯协方差的逆对残差函数进行加权。</p><p>在深入研究 M-LOAM 的细节之前，我们先介绍一些基本概念：</p><ul><li>第 III-A 节介绍了符号</li><li>第 III-B 节介绍了 MLE</li><li>第 III-C 节描述了合适的模型来表示 <span class="math inline">\(\mathbb{R}^{3}\)</span>中的不确定测量和 SE(3) 中的变换。</li><li>最后，第 III-D 节简要介绍了 MLE 在 M-LOAM 中具有近似高斯噪声的实现</li></ul><h2 id="符号约定">符号约定</h2><p>命名法如表I所示</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/02/20211002103027.png"></p><p>我们考虑一个由一个主要激光雷达和多个辅助灵敏器组成的系统，主激光雷达作为<code>base_frame</code>，我们使用()<span class="math inline">\(^{l^{1}} /()^{b}\)</span>来表示，对于其他辅助雷达，使用()<span class="math inline">\(^{l^{i, i&gt;1}}\)</span>来表示。</p><p>我们记<span class="math inline">\(\mathcal{F}\)</span>为从原始激光雷达提取的有效特征，每个特征都表示为3D空间中的一个点：<span class="math inline">\(\mathbf{p}=[x, y, z]^{\top}\)</span>。</p><p>状态向量，由平移和旋转部件组成，记为<span class="math inline">\(\mathbf{x}=[\mathbf{t}, \mathbf{q}]\)</span>，其中<span class="math inline">\(\mathbf{t}\)</span>是3x1向量，<span class="math inline">\(\mathbf{q}\)</span>是汉密尔顿四元数，但在我们需要旋转向量的情况下，我们在SO(3)中使用3×3旋转矩阵<span class="math inline">\(\mathbf{R}\)</span>.</p><p>第VIII节将不确定性与矢量空间上的构成相关联，我们使用SE（3）中的4×4变换矩阵T表示Pose:</p><p><span class="math display">\[\mathbf{T}=\left[\begin{array}{cc}\mathbf{R} &amp; \mathbf{p} \\\mathbf{0}^{\top} &amp; 1\end{array}\right]\]</span></p><h2 id="最大似然估计">最大似然估计</h2><p>我们为MLE问题制定了多激光雷达系统的姿势和外参估计[60] 式（1）：</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \max } p\left(\mathcal{F}_{k} \mid \mathbf{x}_{k}\right)=\underset{\mathbf{x}_{k}}{\arg \min } f\left(\mathbf{x}_{\mathbf{k}}, \mathcal{F}_{k}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{F}_{k}\)</span>表示第k帧的有效特征</li><li><span class="math inline">\(\mathbf{x}_{k}\)</span>表示待优化的状态</li><li><span class="math inline">\(f(\cdot)\)</span>表示目标函数</li></ul><p>假设观测模型使用高斯噪声[3]来替换，那么式（1）变成非线性最小二乘(NLS)问题:</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \min } \sum_{i=1}^{m} \rho\left(\left\|\mathbf{r}\left(\mathbf{x}_{k}, \mathbf{p}_{k i}\right)\right\|_{\mathbf{\Sigma}_{i}}^{2}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\rho(\cdot)\)</span>表示鲁棒性Huber损失[61]，用于处理outlier</li><li><span class="math inline">\(\mathbf{r}(\cdot)\)</span>表示残差函数</li><li><span class="math inline">\(\Sigma_i\)</span>表示协方差矩阵</li></ul><p>迭代方法如高斯牛顿、LM等方法常用于解决NLS问题，这些方法通过计算目标函数相对于状态向量<span class="math inline">\(\mathbf{x}_k\)</span>的<code>Jacobian</code>来进行局部线性化，即<span class="math inline">\(\mathbf{J}=\partial f / \partial \mathbf{x}_{k}\)</span>。通过给定初始值，<span class="math inline">\(\mathbf{x}_k\)</span>通过使用<span class="math inline">\(\mathbf{J}\)</span>进行迭代优化，直到收敛到局部最优。</p><p>在最终的迭代中，状态的最小二乘协方差计算为<span class="math inline">\(\boldsymbol{\Xi}=\boldsymbol{\Lambda}^{-1}\)</span>[62]，其中，<span class="math inline">\(\boldsymbol{\Lambda}=\mathbf{J}^{\top} \mathbf{J}\)</span>称为<code>信息矩阵</code>。</p><h2 id="不确定性表示">不确定性表示</h2><p>我们使用[19]中的工具来表示数据不确定性，首先，考虑噪声的激光点如下，式（3）：</p><p><span class="math display">\[\mathbf{p}=\overline{\mathbf{p}}+\boldsymbol{\zeta}, \quad \boldsymbol{\zeta} \sim \mathcal{N}(\mathbf{0}, \mathbf{Z})\]</span></p><p>其中,</p><ul><li><span class="math inline">\(\bar{\mathbf{p}}\)</span>表示不含噪声的点</li><li><span class="math inline">\(\zeta \in \mathbb{R}^{3}\)</span>是零均值的高斯扰动变量，<span class="math inline">\(\mathbf{Z}\)</span>是激光测量的噪声协方差</li><li>为了使得式（3）与转换矩阵(i.e., <span class="math inline">\(\left.\mathbf{p}_{h}^{\prime}=\mathbf{T} \mathbf{p}_{h}\right)\)</span>更加紧凑，我们使用齐次坐标系来表示：</li></ul><p><span class="math display">\[\mathbf{p}_{h}=\left[\begin{array}{l}\overline{\mathbf{p}} \\1\end{array}\right]+\mathbf{D} \boldsymbol{\zeta}=\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}, \quad \boldsymbol{\zeta} \sim \mathcal{N}(\mathbf{0}, \mathbf{Z})\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{D}\)</span>是将3x1向量转换为齐次坐标的矩阵</li></ul><p>如[63]中的研究，LIDARS深度测量误差（也称为传感器噪声）主要受目标距离的影响，矩阵<span class="math inline">\(\mathbf{Z}\)</span>被简单的设置为常值矩阵。</p><blockquote><p><img src="http://s1.nsloop.com:59080/images/2021/10/02/20211002114842.png"></p></blockquote><p>然后，我们定义SE(3)中受小扰动的随机变量：</p><p><span class="math display">\[\mathbf{T}=\exp \left(\boldsymbol{\xi}^{\wedge}\right) \overline{\mathbf{T}}, \quad \boldsymbol{\xi} \sim \mathcal{N}(\mathbf{0}, \boldsymbol{\Xi})\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\overline{\mathbf{T}}\)</span>是不含噪声的变换矩阵</li><li><span class="math inline">\(\xi \in \mathbb{R}^{6}\)</span>是协方差为<span class="math inline">\(\Xi\)</span>的小扰动变量</li></ul><p>这种表示允许我们在状态空间中储存变换的均值作为<span class="math inline">\(\overline{\mathbf{T}}\)</span>，并使用<span class="math inline">\(\xi\)</span>作为扰动。</p><blockquote><p><img src="http://s1.nsloop.com:59080/images/2021/10/02/20211002114918.png"></p></blockquote><p>我们考虑<span class="math inline">\(\Xi\)</span>包含两个部分的来源：</p><ul><li>Degenerate Pose Estimatio，来自案例，例如在受限制的环境中缺乏几何结构[34]，它通常在其退化方向上不确定姿势[62]，[64]，现有工程诉诸基于模型和基于学习的[65]方法来估算ICP的背景下的姿势协方差。</li><li>Extrinsic Perturbation，该项始终存在，由于外参误差的存在[12]。这种扰动不利于多传感器系统的测量精度 [66]、[67] 但很难测量。</li></ul><p>特别的，<span class="math inline">\(\Xi\)</span>的详细计算在Section VIII</p><h2 id="m-loam中的mle问题">M-LOAM中的MLE问题</h2><p>我们扩展了 MLE 以设计多个 M-LOAM 估计器，以从粗到细的方式解决机器人姿态和外参。最重要的步骤是将高斯噪声协方差<span class="math inline">\(\Sigma\)</span>近似于现实的测量模型。</p><p>根据第 III-C 节中的（上述）讨论，我们确定了三个可能使地标不确定的误差源：传感器噪声、退化姿态估计和外参扰动。</p><p>帧到帧运动估计（部分VI-A）归结于传感器噪声，紧耦合的里程计（第VII-C部分）建立了局部地图用于位姿优化，因此我们应该<code>传播位姿的不确定性到每一个地图点</code>。尽管如此，如果涉及更多的雷达和滑动窗口，这种操作通常是耗时的（大约10ms-20ms）。为了保证里程计的实时性，我们不在此处计算的位姿不确定性。</p><p>因此，我们简单地设置<span class="math inline">\(\Sigma=\mathbf{Z}\)</span>作为残差的协方差。在建图部分，我们有足够的时间来获得准确的姿势和全局地图，因此，我们考虑所有不确定性来源。 第VIII部分解释了姿势不确定性如何影响建图精度和<span class="math inline">\(\Sigma\)</span>的传播。</p><h1 id="系统概览">系统概览</h1><p>我们制作三个假设来简化系统设计</p><ul><li>Lidars是同步的，这意味着不同雷达之间的时间延迟几乎为零</li><li>该平台在校准初始化期间经历了足够的旋转和平移运动</li><li>主激光雷达的局部地图应与辅助LIDAR共享重叠的FOV，用于在改进中匹配以缩短校准阶段，这可以通过移动机器人来实现</li></ul><p>图 2 展示了 M-LOAM 的流水线。 系统从测量预处理（第 V 部分）开始，即从去噪点云中提取和跟踪边缘和平面特征</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/02/20211002195854.png"></p><p>初始化模块（第VI部分）提供了所有必要的值，包括姿势和外参，用于启动后续的非线性优的M-LO。M-LO融合多激光雷达测量在滑动窗口内优化里程计和外参，如果外参已经收敛，我们跳过外参初始化以及细化步骤，然后进入纯里程计和建图阶段。</p><p>概率建图模块（第VIII节）构造了一种具有足够特征的全局地图，以消除里程计累计漂移。 里程计和建图模块分别运行在隔离的线程上。</p><h1 id="测量预处理">测量预处理</h1><p>我们实施三个顺序步骤来处理LiDARS'raw测量，我们首先将点云分割成许多簇以去除嘈杂的对象，然后提取边缘和平面特征。 为了将连续帧之间的特征关联起来，我们匹配了一系列的对应关系。 <code>在本节中，每个 LiDAR 都是独立处理的</code>。</p><h2 id="噪声去除分割">噪声去除分割</h2><p>通过了解LIDAR的垂直扫描角度，我们可以将原始点云投影到没有数据丢失的范围图像上,在图像中，每个有效点由像素表示。像素值记录了该点到原点的欧几里德距离。我们将[68]中提出的分割方法应用于将像素分组到多个集群中。</p><p>我们假设，如果两个相邻点的连接线大致垂直于（大于60度）激光束，则认为这两个相邻点属于相同的对象。我们采用广度第一搜索算法来遍历所有像素，确保恒定的时间复杂度，特别的，我们丢弃小集群，因为它们可能会在优化中提供不可靠的约束。</p><h2 id="特征提取和匹配">特征提取和匹配</h2><p>我们有兴趣提取一般边缘和平面特征，我们遵循[16]选择根据其曲率从测量中选择一组特征点。该组提取的特征<span class="math inline">\(\mathcal{F}\)</span>由两个子集组成：边缘子集（高曲率）<span class="math inline">\(\mathcal{E}\)</span>和平面子集（低曲率）<span class="math inline">\(\mathcal{H}\)</span>。我们进一步从<span class="math inline">\(\mathcal{E}\)</span>收集曲率最高边缘点，从平面<span class="math inline">\(\mathcal{H}\)</span>收集曲率最低的平面点，得到另外两组点<span class="math inline">\(\hat{\mathcal{E}},\hat{\mathcal{H}}\)</span>。</p><p>下一步是确定两个连续帧之间的特征对应关系，()<span class="math inline">\(^{l_{k-1}^{i}} \rightarrow()^{l_{k}^{i}}\)</span>，以构造几何约束：</p><ul><li>对于边缘点集合<span class="math inline">\(\hat{\mathcal{E}}^{l_{k}^{i}}\)</span>中的点，将从前一帧的边缘点集合<span class="math inline">\(\mathcal{E}^{l_{k-1}^{i}}\)</span>中查找两个最近邻的边缘点以形成边缘线关联。</li><li>对于平面点集合<span class="math inline">\(\hat{\mathcal{H}}^{l_{k}^{i}}\)</span>中的点，则从上一帧的边缘点集合<span class="math inline">\(\mathcal{H}^{l_{k-1}^{i}}\)</span>中查找3个最近邻点作为平面关联。</li></ul><p><img src="http://s1.nsloop.com:59080/images/2021/10/03/20211003174638.png"></p><h1 id="初始化">初始化</h1><p>优化多个LIDARS的状态是高度非线性的，需要给出初始估计值。本节介绍了我们的运动和外在初始化方法，不需要任何先前的传感器套件的机械配置。 它还不涉及任何手动努力，使其对自主机器人特别有用。</p><h2 id="scan-based-motion-estimation">Scan-Based Motion Estimation</h2><p>在每个LIDAR的两个连续帧之间找到了相应的对应关系，我们通过最小化所有功能的残差误差来估计帧到帧变换。如图3所示，残差由边缘和平面对应关系制定，设<span class="math inline">\(\mathbf{x}_k\)</span>为第k帧的相对变换，对于平面特征，对于平面点<span class="math inline">\(\mathbf{p} \in \hat{\mathcal{H}}^{l_{k}^{i}}\)</span>，如果<span class="math inline">\(\Pi\)</span>是关联的平面，那么该平面点对应的残差如下计算，式（6）：</p><p><span class="math display">\[\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi\right)=a \mathbf{w}, \quad a=\mathbf{w}^{\top}\left(\mathbf{R}_{k} \mathbf{p}+\mathbf{t}_{k}\right)+d\]</span></p><p>其中，</p><ul><li><span class="math inline">\(a\)</span>是点到平面的距离</li><li><span class="math inline">\([\mathbf{w}, d]\)</span>是平面的参数</li></ul><p>对于边缘线特征点<span class="math inline">\(\mathbf{p} \in \hat{\mathcal{E}}^{l_{k}^{i}}\)</span>，如果<span class="math inline">\(L\)</span>是与之关联的边缘线，那么我们使用如式（6）的两个平面特征的组合来表示点与边缘线的残差：</p><p><span class="math display">\[\mathbf{r}_{\mathcal{E}}\left(\mathbf{x}_{k}, \mathbf{p}, L\right)=\left[\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi_{1}\right), \mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi_{2}\right)\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\left[\mathbf{w}_{1}, d_{1}\right]\)</span>,<span class="math inline">\(\left[\mathbf{w}_{2}, d_{2}\right]\)</span>分别是平面<span class="math inline">\(\Pi_{1}\)</span>、<span class="math inline">\(\Pi_{2}\)</span>的系数</li><li><span class="math inline">\(\mathbf{w}_{1}\)</span>恰好与点<span class="math inline">\(\mathbf{p}\)</span>到直线<span class="math inline">\(L\)</span>的投影方向一致</li><li>并且平面<span class="math inline">\(\Pi_{2}\)</span>垂直于<span class="math inline">\(\Pi_{1}\)</span>，满足s.t. <span class="math inline">\(\mathbf{w}_{2} \perp \mathbf{w}_{1}\)</span>, and <span class="math inline">\(\mathbf{w}_{2} \perp L\)</span></li><li>上述定义与<code>LOAM</code>[16]有所不同，其中有两个好处，一是边缘残差为状态量提供了额外的约束，其次，残差可以使用向量表示，这允许我们乘以3x3的协方差矩阵</li></ul><p>我们最小化所有残差项的总和以获得MLE：</p><p><span class="math display">\[\hat{\mathbf{x}}_{k}=\underset{\mathbf{x}_{k}}{\arg \min } \sum_{\mathbf{p} \in \hat{\mathcal{F}}^{i \atop k}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\]</span></p><p><span class="math display">\[\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{k}, \mathbf{p}\right)=\left\{\begin{array}{ll}\mathbf{r}_{\mathcal{E}}\left(\mathbf{x}_{k}, \mathbf{p}, L\right) &amp; \text { if } \mathbf{p} \in \hat{\mathcal{E}}^{i_{k}^{i}} \\\mathbf{r}_{\mathcal{H}}\left(\mathbf{x}_{k}, \mathbf{p}, \Pi\right) &amp; \text { if } \mathbf{p} \in \hat{\mathcal{H}}^{i_{k}^{i}}\end{array}\right.\]</span></p><p>特别的，关于<span class="math inline">\(\mathbf{r}_{\mathcal{F}}(\cdot)\)</span>的雅克比在Appendix A进行详细讨论。</p><p>在实践中，在带滚动快门扫描的LiDars运动后，点存在一些倾斜畸变，在求出增量运动<span class="math inline">\(\mathbf{x}_k\)</span>后，我们将这些点转换到前一帧扫描的最后时刻（即第k帧扫描的起始）以矫正畸变。</p><p>令<span class="math inline">\(t_{k-1},t_{k}\)</span>表示激光扫描的起始和结束，对于每一个扫描点<span class="math inline">\(\mathbf{p}\)</span>，都可以进行转换如下：</p><p><span class="math display">\[\mathbf{p}^{l_{k-1}^{i}}=\mathbf{R}_{k}^{\tau} \mathbf{p}+\mathbf{t}_{k}^{\tau}, \quad \tau=\frac{t-t_{k-1}}{t_{k}-t_{k-1}}\]</span></p><p>其中，旋转和平移部分使用se(3)进行插值？参考文献[5]</p><p><span class="math display">\[\mathbf{R}_{k}^{\tau}=\exp \left(\boldsymbol{\phi}_{k}^{\wedge}\right)^{\tau}=\exp \left(\tau \boldsymbol{\phi}_{k}^{\wedge}\right), \quad \mathbf{t}_{k}^{\tau}=\tau \mathbf{t}_{k}\]</span></p><h2 id="calibration-of-multi-lidar-system">Calibration of Multi-LiDAR System</h2><p>通过对准两个传感器的运动序列来获得初始外参，即这被称为手眼标定问题<span class="math inline">\(\mathbf{A X}=\mathbf{X B}\)</span>，其中<span class="math inline">\(\mathbf{A},\mathbf{B}\)</span>是两个传感器的位姿增量，<span class="math inline">\(\mathbf{B}\)</span>是他们的外参。</p><p>当机器人移动时，第i个激光雷达的第k帧时刻，有：</p><p>式（11）：</p><p><span class="math display">\[\mathbf{R}_{l_{k}^{i}}^{l_{k-1}^{i}} \mathbf{R}_{l^{i}}^{b}=\mathbf{R}_{l^{i}}^{b} \mathbf{R}_{b_{k}}^{b_{k-1}}\]</span></p><p>式（12）：</p><p><span class="math display">\[\left(\mathbf{R}_{l_{k}^{i}}^{l_{k-1}^{i}}-\mathbf{I}_{3}\right) \mathbf{t}_{l^{i}}^{b}=\mathbf{R}_{l^{i}}^{b} \mathbf{t}_{b_{k}}^{b_{k-1}}-\mathbf{t}_{l_{k}^{i}}^{l_{k-1}^{i}}\]</span></p><p>上面两式实际上是根据[14]，将情况下原始问题<span class="math inline">\(\mathbf{A X}=\mathbf{X B}\)</span>分解为旋转和平移部分。我们实现了此方法可在线初始化外参。</p><h3 id="旋转初始化">旋转初始化</h3><p>通过使用四元数，可以将式（11）重写成如下式（13）：</p><p><span class="math display">\[\begin{aligned}&amp; \mathbf{q}_{l_{k}^{i}}^{l_{k-1}} \otimes \mathbf{q}_{l^{i}}^{b}=\mathbf{q}_{l^{i}}^{b} \otimes \mathbf{q}_{b_{k}}^{b_{k-1}} \\\Rightarrow &amp;\left[\mathbf{Q}_{1}\left(\mathbf{q}_{l_{k-1}^{i}}^{l_{k}}\right)-\mathbf{Q}_{2}\left(\mathbf{q}_{b_{k}}^{b_{k-1}}\right)\right] \mathbf{q}_{l^{i}}^{b}=\mathbf{Q}_{k}^{k-1} \mathbf{q}_{l^{i}}^{b} = 0\end{aligned}\]</span></p><p>其中，<span class="math inline">\(\otimes\)</span>表示四元数乘法，<span class="math inline">\(\mathbf{Q}_{1}(\cdot)，\mathbf{Q}_{1}(\cdot)\)</span>表示四元数的左乘、右乘等价矩阵[59]。</p><p>通过多次时间间隔，可以将式（13）就行堆叠，形成超定线性方程组：</p><p>式（14）：</p><p><span class="math display">\[\left[\begin{array}{c}w_{1}^{0} \cdot \mathbf{Q}_{1}^{0} \\\vdots \\w_{K}^{K-1} \cdot \mathbf{Q}_{K}^{K-1}\end{array}\right]_{4 K \times 4} \mathbf{q}_{l^{i}}^{b}=\mathbf{Q}_{K} \mathbf{q}_{l^{i}}^{b}=\mathbf{0}_{4 K \times 4}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(K\)</span>表示约束的数量</li><li><span class="math inline">\(w_{k}^{k-1}\)</span>是鲁棒性权重，定义为残差四元素的角度轴表示中的角度？</li></ul><p><span class="math display">\[w_{k}^{k-1}=\rho^{\prime}(\phi), \quad \phi=2 \arctan \left(\left\|\mathbf{q}_{x y z}\right\|, q_{w}\right)\]</span></p><p><span class="math display">\[\mathbf{q}=\left(\check{\mathbf{q}}_{l^{i}}^{b}{ }\right)^{*}\otimes\left(\mathbf{q}_{l_{k}^{i}}^{l_{k-1}^{i}}\right)^{*} \otimes \check{\mathbf{q}}_{l^{i}}^{b} \otimes \mathbf{q}_{b_{k}}^{b_{k-1}}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\rho^{\prime}(\cdot)\)</span>是Huber loss的微分</li><li><span class="math inline">\(\check{\mathbf{q}}_{l^{i}}^{b}\)</span>是当前估计的旋转外参</li><li><span class="math inline">\(\mathbf{q}^{*}\)</span>是<span class="math inline">\(\mathbf{q}\)</span>的逆</li></ul><p>令<span class="math inline">\(\| \mathbf{q}_{l^{\prime}}^{b}\|=1\)</span>，我们可以使用<code>SVD</code>来获取式（14）的<code>close form</code>解。</p><p>对于3-DOF旋转的全部可观察性，需要足够的运动激励，在足够的约束下，<span class="math inline">\(Q_k\)</span>的零空间的秩应为1，也就是说，我们只有1个零奇异值（4个变量，3个维度，剩下一个为0）。</p><p>否则，由于在一个轴或多个轴上的运动退化会导致<span class="math inline">\(Q_k\)</span>的零空间&gt;1。因此，我们需要确保第二小的奇异值<span class="math inline">\(\sigma_{min2}\)</span>足够大以确保条件满足。我们设置了阈值<span class="math inline">\(\sigma_{\mathbf{R}}\)</span>，<code>and terminate the rotation calibration if σmin2&gt; σR.</code> ???</p><p>越来越多的数据会使得<span class="math inline">\(Q_k\)</span>行数迅速增长，为了维持计算时间，我们使用优先级队列[69]，长度k = 300逐渐存储历史约束，并删除小旋转的约束。</p><h3 id="平移初始化">平移初始化</h3><p>一旦旋转校准完成，我们通过式（12）将所有可用数据结合，构造一个线性系统：</p><p>式（16）：</p><p><span class="math display">\[\left[\begin{array}{c}\mathbf{R}_{l_{1}^{i}}^{l_{0}}-\mathbf{I}_{3} \\\vdots \\\mathbf{R}_{l_{K}^{i}}^{l_{K-1}^{i}}-\mathbf{I}_{3}\end{array}\right]_{3 K \times 3} \mathbf{\mathbf { t }}_{l^{i}}^{b}=\left[\begin{array}{c}\hat{\mathbf{R}}_{l^{i}}^{b} \mathbf{t}_{b_{1}}^{b_{0}}-\mathbf{t}_{l_{1}^{i}}^{l_{0}^{i}} \\\vdots \\\hat{\mathbf{R}}_{l^i}^{b} \mathbf{t}_{b_{K}}^{b_{K-1}}-\mathbf{t}_{l_{K}^{i}}^{l^{i}_{K-1}}\end{array}\right]_{3 K \times 1}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{t}_{l^{i}}^{b}\)</span>通过使用最小二乘法获取</li></ul><p>然而，如果机器人只在平面上运动，z轴方向上的平移是不可观的，在这种情况下，我们设置<span class="math inline">\(t_z=0\)</span>然后重写式（16）以移除<span class="math inline">\(\mathbf{t}_{l^{i}}^{b}\)</span>中的Z轴分量。</p><p>不像文献[4]，我们的方法不能通过地面来初始化<span class="math inline">\(t_z\)</span>，因此需要在后续的<code>refinement</code>阶段来恢复<span class="math inline">\(t_z\)</span>.(Section VII-B)</p><h1 id="具备传感器外参细化的紧耦合多激光雷达里程计">具备传感器外参细化的紧耦合多激光雷达里程计</h1><p>将最初的猜测作为输入，我们提出了一个紧密耦合的M-LO，以优化滑动窗口内的所有状态，该过程的灵感来自多传感器系统的<code>BA</code>，<code>Graph-Based</code>和<code>marginalization</code>的启发[5],[15],[70].</p><h2 id="问题构造">问题构造</h2><p>滑动窗口中的全部状态向量如下定义：</p>$$<span class="math display">\[\begin{aligned}\mathcal{X} &amp;=[\mathcal{X}_{f},\qquad \mathcal{X}_{v},  \qquad  \qquad \qquad \mathcal{X}_{e}] \\&amp;=[\mathbf{x}_{1}, \cdots, \mathbf{x}_{p}, \mathbf{x}_{p+1}, \cdots, \mathbf{x}_{N+1}, \mathbf{x}_{l^{2}}^{b}, \cdots, \mathbf{x}_{l^{l}}^{b}]\end{aligned}\]</span><p>$$</p><p><span class="math display">\[\begin{aligned}\mathbf{x}_{k} &amp;=\left[\mathbf{t}_{b_{k}}^{w}, \mathbf{q}_{b_{k}}^{w}\right], \quad k \in[1, N+1] \\\mathbf{x}_{l^{i}}^{b} &amp;=\left[\mathbf{t}_{l^{i}}^{b}, \mathbf{q}_{l^{i}}^{b}\right], \quad i \in[1, I],\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_k\)</span>是主激光雷达在世界坐标系下不同时间戳的状态</li><li><span class="math inline">\(\mathbf{x}_{l^{i}}^{b}\)</span>表示主激光雷达到第i辅助激光雷达的外参</li><li><span class="math inline">\(N+1\)</span>是滑动窗口中的状态数量</li></ul><p>为了建立这些状态之间的数据关联，我们建立了局部地图</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/04/20211004171829.png"></p><p>图4对<code>Graph-base</code>的构造进行了可视化，我们使用<span class="math inline">\(p\)</span>来索引滑动窗口中的枢轴状态，并设置<span class="math inline">\(\mathbf{x}_p\)</span>作为局部地图的原点（起始）。</p><p>利用从枢轴帧到其他帧的相对变换，通过连接前N帧（如<span class="math inline">\(\mathcal{F}^{l_{k}^{i}}, k \in[1, N]\)</span>）的特征点来构造局部地图。第i个激光雷达的局部特征地图由局部边缘地图和局部平面地图组成，记为<span class="math inline">\(\mathcal{M}^{l^{i}}\)</span>。</p><p>我们分割全状态向量<span class="math inline">\(\mathcal{X}\)</span>为3个部分：<span class="math inline">\(\mathcal{X}_{f},\mathcal{X}_{v},\mathcal{X}_e\)</span>：</p><ul><li><span class="math inline">\(\mathcal{X}_{f}=[\mathbf{x}_1,\dots,\mathbf{x}_p]\)</span>是由已经固定的准确状态组成</li><li><span class="math inline">\(\mathcal{X}_{v}=\left[\mathbf{x}_{p+1}, \cdots, \mathbf{x}_{N+1}\right]\)</span>被考虑作为在优化过程中迭代更新的变量</li><li><span class="math inline">\(\mathcal{X}_{e}=\left[\mathbf{x}_{l^{2}}^{b}, \cdots, \mathbf{x}_{l^I}^{b}\right]\)</span>是外参向量，它们的设置取决于在线校准的收敛性。</li><li></li><li>我们最小化滑动窗口内所有残差的总和以获得 MAP 估计为：</li></ul><p><span class="math display">\[\hat{\mathcal{X}}=\underset{\mathcal{X}}{\arg \min }\left\{\left\|\mathbf{r}_{p r i}(\mathcal{X})\right\|^{2}+f_{\mathcal{M}}(\mathcal{X})\right\}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{r}_{p r i}(\mathcal{X})\)</span>是VII-E节中定义的边缘化状态的先验项</li><li><span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>是基于地图的残差的总和，其式（18）的雅克比矩阵推导见Appendix A</li></ul><p>本文呈现的滑动窗口估计器与帧到帧估计不同，该估计器联合优化了窗口中的所有状态。这种方法，输出更准确的结果，因为局部地图提供了密集和可靠的对应关系。如果传感器精确标定，还使用来自其他雷达的约束。根据标定的收敛性，我们将问题分为两个子任务：</p><ul><li>在线标定online calibration (variable <span class="math inline">\(\mathcal{X}_e\)</span>)</li><li>纯里程计pure odometry (fixed <span class="math inline">\(\mathcal{X}_e\)</span>)</li></ul><p>在每个任务中，<span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>的定义是不同的，我们在第 VII-B 和 VII-C 节中介绍了详细信息</p><h2 id="考虑在线标定的优化">考虑在线标定的优化</h2><p>我们利用基于地图的测量来改进粗略初始化结果，在这里，我们将标定问题视为配准问题，<span class="math inline">\(f_{\mathcal{M}}(\mathcal{X})\)</span>分为两个函数，分别相对于<span class="math inline">\(\mathcal{X}_{v}\)</span>和<span class="math inline">\(\mathcal{X}_{e}\)</span>。</p><p><strong>对于<span class="math inline">\(\mathcal{X}_{v}\)</span>中的状态</strong>，这些约束由主传感器的最新帧的特征如<span class="math inline">\(\mathcal{F}^{b_{k}}, k \in[p+1, N+1]\)</span>，与主激光雷达的局部地图<span class="math inline">\(\mathcal{M}^{b}\)</span>之间的关联构成。</p><p><strong>对于<span class="math inline">\(\mathcal{X}_{e}\)</span>中的状态</strong>，这些约束由第i辅助激光雷达的第p帧的特征<span class="math inline">\(\mathcal{F}^{l_{p}^{i}}\)</span>与局部地图<span class="math inline">\(\mathcal{M}^{b}\)</span>的特征关联构成。</p><p><span class="math inline">\(\mathcal{F}^{b_{k}}\)</span>与局部特征地图<span class="math inline">\(\mathcal{M}^{b}\)</span>的关联使用[16]中的方法进行寻找，其中特征地图<span class="math inline">\(\mathcal{M}^{b}\)</span>使用了KD-TREE进行索引。</p><ol type="1"><li><p>对于边缘点，我们在局部边缘地图中的指定范围查找与之最近邻的点集合，记为<span class="math inline">\(\mathcal{S}\)</span>，然后计算点集的方差。点集的最大特征值对应的特征向量表示了与该边缘点所关联的直线的方向。通过计算点集的均值，即可确定边缘点对应的边缘线。</p></li><li><p>对于平面点，通过求解线性系统<span class="math inline">\(\mathbf{w s}+d=0, \forall \mathbf{s} \in \mathcal{S}\)</span>，可以得到在局部平面点云地图中与之关联的平面的系数，同样的，我们寻找<span class="math inline">\(\mathcal{F}^{l_{p}^{i}}\)</span>和<span class="math inline">\(\mathcal{M}^{b}\)</span>的关联。</p></li></ol><p>最后，我们将目标定义为在线标定的所有测量残差的总和，式（19）：</p><p><span class="math display">\[\begin{aligned}f_{\mathcal{M}}(\mathcal{X}) &amp;=f_{\mathcal{M}}\left(\mathcal{X}_{v}\right)+f_{\mathcal{M}}\left(\mathcal{X}_{e}\right) \\&amp;=\sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{b_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\Sigma_{\mathrm{p}}}^{2}\right)+\sum_{i=2}^{I} \sum_{\mathbf{p} \in \mathcal{F}^{l_{p}^{i}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}\)</span>表示从中枢坐标系到第k帧的变换</li><li><span class="math inline">\(\mathbf{x}_{p}\)</span>作为局部地图的起点状态</li></ul><h2 id="纯里程计的优化">纯里程计的优化</h2><p>一旦我们通过满足收敛标准完成在线校准（VII-D部分），然后就可以在给定准确外参的情况下进行纯里程计的优化。在这种情况下，我们没有优化外参，并利用基于地图的测量来改善单激光的里程计。</p><p>我们将所有 LiDAR 和局部地图的特征之间的约束合并到成本函数中：</p><p><span class="math display">\[\begin{aligned}f_{\mathcal{M}}(\mathcal{X}) &amp;=f_{\mathcal{M}}\left(\mathcal{X}_{v}\right) \\&amp;=\sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{b_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k}, \mathbf{p}\right)\right\|_{\Sigma_{\mathbf{p}}}^{2}\right) \\&amp;+\sum_{i=2}^{I} \sum_{k=p+1}^{N+1} \sum_{\mathbf{p} \in \mathcal{F}^{l^{i}_{k}}} \rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{p}^{-1} \mathbf{x}_{k} \mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{x}_{p}^{-1} \mathbf{x}_{k} \mathbf{x}_{l^{i}}^{b}\)</span>表示第k帧下，从主激光雷达的局部地图坐标系（pivot frame）到辅助激光雷达坐标系的变换。</li></ul><h2 id="外参标定收敛性管理">外参标定收敛性管理</h2><p>在以无人监督的方式工作在线标定时，判断标定是否收敛是有意义的，收敛后，我们就可以固定外参。这对我们的系统有益，因为里程计和建图都是从辅助雷达获得更多几何约束，以便更准确地进行位姿估计。</p><p>如[34]中得出，作为信息矩阵的最小特征值的退化因子λ揭示了基于优化的状态估计问题的条件。通过这项工作的影响，我们使用λ表示是否包含足够的约束来获取准确的外参。</p><p>更新外参和收敛性监视器的详细流水线总结如算法1所示：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/04/20211004233254.png"></p><p>算法采用式（19）定义的函数<span class="math inline">\(f_{\mathcal{M}}(\cdot)\)</span>，以及使用当前的外参作为输入，并返回优化后的外参。</p><ul><li>在第4行，我们从<code>cost function</code>的信息矩阵中计算<span class="math inline">\(\lambda\)</span>，</li><li>在5-7行，如果<span class="math inline">\(\lambda\)</span>大于阈值，则对外参进行更新。</li><li>在第8行，我们使用的外参候选值来检查收敛性。</li><li>在第9-10行，收敛性判断条件满足，因此触发停止标定。然后计算<span class="math inline">\(\mathcal{L}\)</span>的采样均值，作为输出的外参结果，并且采样协方差作为标定的协方差。</li></ul><h2 id="边缘化">边缘化</h2><p>我们应用边缘化技术来删除滑动窗口中的最旧变量状态，边缘化是将历史约束作为目标融合的过程，这是维持里程计和标定结果一致性的重要步骤。</p><p>在我们的系统中，<span class="math inline">\(\mathbf{x}_{p}\)</span>是在每次优化后被边缘化的唯一的状态，通过应用<code>Schur Complement</code>，我们得到关于保留状态的信息矩阵<span class="math inline">\(\mathbf{A}_{rr}^{*}\)</span>和残差<span class="math inline">\(\mathbf{g}_{r}^{*}\)</span>。因此，由边缘化得到的先验残差项可写成：<span class="math inline">\(\left\|\mathbf{r}_{p r i}\right\|^{2}=\mathbf{g}_{r}^{* \top} \boldsymbol{\Lambda}_{r r}^{*-1} \mathbf{g}_{r}^{*}\)</span>，<code>Appendix B</code>会给出更加详细的数学推导。</p><h1 id="考虑不确定性的多激光雷达建图">考虑不确定性的多激光雷达建图</h1><p>我们首先回顾了典型 LiDAR SLAM 系统的建图模块的管道 [16]-[18]，以里程计先验作为输入，算法构建全局地图并使用足够的约束来对pose关键帧进行精细化调整。这通过最小化所有基于地图的残差项之和来实现，式（21）：</p><p><span class="math display">\[\hat{\mathbf{x}}_{b_{k}}^{w}=\underset{\mathbf{x}_{b_{k}}^{w}}{\arg \min } \sum_{i=1}^{I}\sum_{\mathbf{p} \in \mathcal{F}_{k}^{l^{i}_{k}}}\rho\left(\left\|\mathbf{r}_{\mathcal{F}}\left(\mathbf{x}_{b_{k}}^{w} \mathbf{x}_{l^{i}}^{b}, \mathbf{p}\right)\right\|_{\boldsymbol{\Sigma}_{\mathbf{p}}}^{2}\right)\]</span></p><p>其中,</p><ul><li><span class="math inline">\(\mathcal{F}^{l_{k}^{i}}\)</span>是第k帧点云的特征点</li><li><span class="math inline">\(\mathcal{G}_{\mathcal{F}}^{w_{k}}\)</span>是全局地图</li><li><span class="math inline">\(\mathbf{x}_{b_{k}}^{w} \mathbf{x}_{l^{i}}^{b}\)</span>表示第k帧时刻第i个激光雷达的状态</li></ul><p>我们使用Section VII-B中的方法查找<span class="math inline">\(\mathcal{F}^{l_{k}^{i}}\)</span>和<span class="math inline">\(\mathcal{G}_{\mathcal{F}}^{w_{k}}\)</span>之前的特征关联。在求解式（21）之后，求解的位姿将用于将特征点转换到世界坐标系，然后添加到全局地图上。为了降低计算和内存复杂性，地图也使用体素滤波器[71]进行降采样。但是，优化的精度取决于地图质量。图5展示了使用不确定的pose得到的带有噪声的地图点。我们认为，三个不确定性来源使地图点嘈杂：传感器噪声，退化姿态估计和外参扰动。</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/05/20211005104501.png"></p><p>在下一节中，我们将激光测量点和位姿求解的不确定性传播到地图点上。结果，每个地图点都被建模为高斯变量。 然后，我们提出了一种考虑不确定性的方法来提高多激光雷达建图算法的鲁棒性和准确性。</p><h2 id="不确定性传播">不确定性传播</h2><p>继续在第III-C节中描述，我们现在计算协方差<span class="math inline">\(\Xi\)</span>，mapping的位姿通过求解式（21）的NLS问题得到，我们直接计算信息矩阵的逆，即<span class="math inline">\(\mathbf{\Xi}_{\mathbf{x}_{b_{k}}^{w}}=\boldsymbol{\Lambda}^{-1}\)</span>作为协方差。</p><p>外参协方差的设置取决于特定的情况，我们通用的把外参协方差定义如下：</p><p><span class="math display">\[\boldsymbol{\Xi}_{\mathbf{x}_{l^{i}}^{b}}=\alpha \cdot \boldsymbol{\Xi}_{\text {calib }}, \quad \boldsymbol{\xi}_{l^{i}}^{b} \sim \mathcal{N}\left(\mathbf{0}, \boldsymbol{\Xi}_{\mathbf{x}_{l^{i}}^{b}}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\boldsymbol{\xi}_{l^{i}}^{b}\)</span>是外参的扰动变量</li><li><span class="math inline">\(\boldsymbol{\Xi}_{\text {calib }}\)</span>是通过算法1计算得到的标定协方差</li><li><span class="math inline">\(\alpha\)</span>是缩放系数，用于控制协方差的量级</li></ul><p>如果多激光雷达系统最近被标定过，我们设置<span class="math inline">\(\alpha=1\)</span>，如果系统使用了很长时间且没有进行重新标定，激光雷达之间的外参会存在小的偏差，<span class="math inline">\(\alpha\)</span>将被设置为更大的值。它具有与时间和外部影响的隐含关系，以及温度漂移。</p><p>给定主激光雷达的pose均值以及外参的均值和协方差，然后计算其他雷达pose的均值和协方差，如<span class="math inline">\(\left\{\mathbf{T}_{l_{k}^{i}}^{w}, \boldsymbol{\Xi}_{l_{k}^{i}}^{w}\right\}\)</span>，这是一个关于两个含有噪声的复合pose的问题，我们遵循[19]中的4阶近似来计算他们。</p><p>然后，我们需要通过一个包含噪声的位姿变换来传播高斯不确定性，以产生新的地图点（landmark），如<span class="math inline">\(\mathbf{y} \in \mathcal{G}_{\mathcal{F}}^{w_{k+1}}\)</span>，其均值和方差为<span class="math inline">\(\{\overline{\mathbf{y}}, \boldsymbol{\Sigma}\}\)</span>，利用将点进行坐标变换的公式，可得：</p><p><span class="math display">\[\begin{aligned}\mathbf{y} \triangleq \mathbf{T}_{l_{k}^{i}}^{w} \mathbf{p}_{h} &amp;=\exp \left(\boldsymbol{\xi}_{e l_{k}^{i}}^{w^{\wedge}}\right) \overline{\mathbf{T}}_{l_{k}^{i}}^{w}\left(\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}\right) \\&amp; \approx\left(\mathbf{I}+\boldsymbol{\xi}_{l_{k}^{i}}^{w^{\wedge}}\right) \mathbf{\mathbf { T }}_{l_{k}^{i}}^{w}\left(\overline{\mathbf{p}}_{h}+\mathbf{D} \boldsymbol{\zeta}\right)\end{aligned}\]</span></p><p>其中，我们只保留指数映射<span class="math inline">\(\exp(\cdot)\)</span>的一阶近似。</p><p>进一步的，如果我们展开等式，并仅保留一阶项，我们有：</p><p><span class="math display">\[\mathbf{y} \approx \mathbf{h}+\mathbf{H} \boldsymbol{\theta}\]</span></p><p>其中，</p><p><span class="math display">\[\mathbf{h}=\overline{\mathbf{T}}_{l_{k}^{i}}^{w} \overline{\mathbf{p}}_{h}, \quad \mathbf{H}=\left[\left(\overline{\mathbf{T}}_{l_{k}^{i}}^{w} \overline{\mathbf{p}}_{h}\right)^{\odot} \quad \overline{\mathbf{T}}_{l_{k}^{i}}^{w} \mathbf{D}\right]\]</span></p><p><span class="math display">\[\boldsymbol{\theta}=\left[\boldsymbol{\xi}_{l_{k}^{i}}^{w \top}, \boldsymbol{\zeta}^{\top}\right]^{\top}, \quad \boldsymbol{\theta} \sim \mathcal{N}(\mathbf{0}, \boldsymbol{\Theta}), \quad \boldsymbol{\Theta}=\operatorname{diag}\left(\boldsymbol{\Xi}_{l_{k}^{i}}^{w}, \mathbf{Z}\right)\]</span></p><p>特别的，操作符<span class="math inline">\(\odot\)</span>表示将4x1的向量转换为4x6的矩阵：</p><p><span class="math display">\[\left[\begin{array}{l}\varepsilon \\\eta\end{array}\right]^{\odot}=\left[\begin{array}{cc}\eta \mathbf{I} &amp; -\boldsymbol{\varepsilon}^{\wedge} \\\mathbf{0}^{\top} &amp; \mathbf{0}^{\top}\end{array}\right], \quad \boldsymbol{\varepsilon} \in \mathbb{R}^{3}, \quad \eta=1\]</span></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;robust-odometry-and-mapping-for-multi-lidar-systems-with-online-extrinsic-calibration&quot;&gt;Robust Odometry and Mapping for Multi-LiDAR S
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2022/02/01/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_6/"/>
    <id>http://yoursite.com/2022/02/01/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/LIDAR_CAMERA%E6%A0%87%E5%AE%9A_6/</id>
    <published>2022-02-01T12:41:23.436Z</published>
    <updated>2022-01-03T02:48:17.997Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    <summary type="html">
    
      
      
        

      
    
    </summary>
    
    
      <category term="传感器标定" scheme="http://yoursite.com/categories/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/"/>
    
    
  </entry>
  
  <entry>
    <title>Cyber-RT系列之中枢调度Scheduler</title>
    <link href="http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E6%9E%A2%E8%B0%83%E5%BA%A6Scheduler/"/>
    <id>http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E6%9E%A2%E8%B0%83%E5%BA%A6Scheduler/</id>
    <published>2021-11-28T15:10:29.000Z</published>
    <updated>2021-12-27T14:19:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>Scheduler是Cyber-RT的调度核心，是协程的调度载体。特别的，对于自动驾驶任务而言，任务调度的实时性发挥至关重要的作用，因此有必要对各种任务的优先级进行分类排序，如对于控制任务而言，需要单独分配CPU以供实时运行，Cyber-RT通过Scheduler来实现这种功能。</p><h1 id="cyberscheduler目录">Cyber/Scheduler目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">├── BUILD</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── common</span><br><span class="line">│   ├── cv_wrapper.h</span><br><span class="line">│   ├── mutex_wrapper.h</span><br><span class="line">│   ├── pin_thread.cc</span><br><span class="line">│   ├── pin_thread.h</span><br><span class="line">├── policy</span><br><span class="line">│   ├── choreography_context.cc</span><br><span class="line">│   ├── choreography_context.h</span><br><span class="line">│   ├── classic_context.cc</span><br><span class="line">│   ├── classic_context.h</span><br><span class="line">│   ├── scheduler_choreography.cc</span><br><span class="line">│   ├── scheduler_choreography.h</span><br><span class="line">│   ├── scheduler_classic.cc</span><br><span class="line">│   └── scheduler_classic.h</span><br><span class="line">├── processor.cc</span><br><span class="line">├── processor_context.cc</span><br><span class="line">├── processor_context.h</span><br><span class="line">├── processor.h</span><br><span class="line">├── processor_test.cc</span><br><span class="line">├── scheduler.cc</span><br><span class="line">├── scheduler_factory.cc</span><br><span class="line">├── scheduler_factory.h</span><br><span class="line">├── scheduler.h</span><br><span class="line">└── scheduler_test.cc</span><br></pre></td></tr></table></figure><h1 id="scheduler类图">Scheduler类图</h1><p><img src="http://s1.nsloop.com:59080/images/2021/11/29/Scheduler.png"></p><h1 id="两种策略">两种策略</h1><p>通过阅读上面的类图可以发现，Scheduler类是基类，其拥有两个子类，分别为<code>SchedulerClassic</code>和<code>SchedulerChoreography</code>，分别对应两种策略，Classic(经典)策略与Choreophgray(编排)策略。两者并不是互斥关系，后者可看作对前者的扩展。它们的介绍和示例可参考官方文档 <a href="https://github.com/ApolloAuto/apollo/blob/master/docs/cyber/CyberRT_Scheduler_cn.md" target="_blank" rel="noopener">Cyber RT Scheduler</a>，这里暂不详细展开，下面的叙述以<code>SchedulerClassic</code>策略为主。</p><p>调度策略配置文件用protobuf定义，协议格式文件在cyber/proto目录下：<code>scheduler_conf.proto</code>，<code>classic_conf.proto</code>和<code>choreography_conf.proto</code>。调度策略配置文件在cyber/conf目录下。对于上面mkz_close_loop.pb.txt中的两个process group：compute_sched和control_sched，根据调度策略不同分别有两个版本</p><p><img src="http://s1.nsloop.com:59080/images/2021/11/29/20211129002744.png"></p><h1 id="一个scheduler实例">一个Scheduler实例</h1><p><code>Scheduler</code>是个单例，因此在程序启动时就被初始化了，尽管它不是程序的入口，但是从它却是系统子模块Component调度的管理者。</p><h2 id="实例化">实例化</h2><p><code>Scheduler</code>的实例化过程由<code>scheduler_factory.cc</code>提供，其调用函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">Scheduler</span>* <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// instance是原子模板的</span></span><br><span class="line">  <span class="built_in">Scheduler</span>* obj = instance.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="comment">// 如果obj为空</span></span><br><span class="line">  <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    obj = instance.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 双检查</span></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 默认策略</span></span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">policy</span><span class="params">(<span class="string">"classic"</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">conf</span><span class="params">(<span class="string">"conf/"</span>)</span></span>;</span><br><span class="line">      <span class="comment">// conf = conf/xxxxx.conf</span></span><br><span class="line">      conf.append(GlobalData::Instance()-&gt;ProcessGroup()).append(<span class="string">".conf"</span>);</span><br><span class="line">      <span class="comment">// cfg_file = CYBER_PATH + 相对路径</span></span><br><span class="line">      <span class="keyword">auto</span> cfg_file = GetAbsolutePath(WorkRoot(), conf);</span><br><span class="line">      <span class="comment">// 检查配置文件是否存在，并读取配置到proto类型</span></span><br><span class="line">      apollo::cyber::proto::CyberConfig cfg;</span><br><span class="line">      <span class="keyword">if</span> (PathExists(cfg_file) &amp;&amp; GetProtoFromFile(cfg_file, &amp;cfg)) &#123;</span><br><span class="line">        <span class="comment">// 从配置文件读取策略</span></span><br><span class="line">        policy = cfg.scheduler_conf().policy();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AWARN &lt;&lt; <span class="string">"No sched conf found, use default conf."</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 根据策略，实例化不同的调度器</span></span><br><span class="line">      <span class="keyword">if</span> (!policy.compare(<span class="string">"classic"</span>)) &#123;</span><br><span class="line">        obj = <span class="keyword">new</span> SchedulerClassic();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!policy.compare(<span class="string">"choreography"</span>)) &#123;</span><br><span class="line">        obj = <span class="keyword">new</span> SchedulerChoreography();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        AWARN &lt;&lt; <span class="string">"Invalid scheduler policy: "</span> &lt;&lt; policy;</span><br><span class="line">        obj = <span class="keyword">new</span> SchedulerClassic();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保存到instance单例</span></span><br><span class="line">      instance.store(obj, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化主要做了几个事情：</p><ol type="1"><li>获取配置文件<code>conf/xxxx.conf</code></li><li>读取策略配置项<code>policy</code></li><li>根据<code>policy</code>配置项来选择实例化<code>SchedulerClassic()</code>还是<code>SchedulerChoreography()</code>，如果没有提供，则默认选择实例化<code>SchedulerClassic()</code></li><li>这个实现确保了线程安全，即<code>Scheduler</code>单例只能被创建一个</li></ol><p>以<code>SchedulerClassic()</code>为例，接下来看其实例化过程（构造函数）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SchedulerClassic::SchedulerClassic()&#123;</span><br><span class="line">    <span class="comment">// 由于函数篇幅较长，下面用文字描述</span></span><br><span class="line">    <span class="number">1.</span> 再次获取配置文件<span class="string">"conf/xxxxx.conf"</span></span><br><span class="line">    <span class="number">2.</span> 解析proto配置文件</span><br><span class="line">    <span class="number">3.</span> 读取threads字段的配置 ===&gt; 这个暂时还不知道用来干嘛</span><br><span class="line">    <span class="number">4.</span> 读取cpu编号配置[process_level_cpuset_]，根据这个配置项来设置当前调度线程的CPU亲和性,这样就指定了该进程中的所有任务都只能在限定的CPU核上运行</span><br><span class="line">    <span class="number">5.</span> 读取[classic_conf]配置项，遍历配置项中的每一个[group]配置，而每个[group]内又包含若干个[task]，目的是把所有[task]的配置都保存下来，记录到成员变量cr_confs_内。需要注意的点是，在这个过程中，会根据每个[task]所在的[group]填充group_name，后面会用到。</span><br><span class="line">    <span class="number">6.</span> 最后为每个group创建对应数量的Processor，并设置相关策略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化过程中，有很多部分都与配置文件直接相关，这里我们以<code>conf/example_sched_classic.conf</code>为例展开：</p><p><img src="http://s1.nsloop.com:59080/images/2021/11/29/20211129005008.png"></p><p>我们从第4点开始看，首先是读取配置项<code>process_level_cpuset_</code>,根据配置文件，这个字符串一般填<code>"0-7,16-23"</code>形式的内容，表示当前调度线程可以由0-7,16-23号CPU核心来执行。最终实现这个功能的函数是<code>Scheduler::ProcessLevelResourceControl()</code>，其内部是通过glibc提供的接口<code>pthread_setaffinity_np(pthread_self(), sizeof(set), &amp;set);</code>来实现对线程设置CPU亲和性。</p><p><strong>注意配置文件中有两个优先级：</strong></p><ul><li>一个是<code>processor_prio</code>，对应系统Linux中线程的优先级，即nice值，范围从-20到19，值越低优先级越高，默认值为0；</li><li>另一个是task的<code>prio</code>，它是Cyber RT中的协程调度的优先级，共20级，值越高优先越高</li></ul><p>接下来第5点，简单来说就是读取每个[task]字段的配置项，并保存下来，其代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">classic_conf_ = cfg.scheduler_conf().classic_conf();</span><br><span class="line"><span class="comment">// 遍历每一个group</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; group : classic_conf_.groups()) &#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp; group_name = group.name();</span><br><span class="line">  <span class="comment">// 遍历group内的task配置项</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> task : group.tasks()) &#123;</span><br><span class="line">    <span class="comment">// 对task反过来设置group_name</span></span><br><span class="line">    task.set_group_name(group_name);</span><br><span class="line">    <span class="comment">// 保存起来</span></span><br><span class="line">    cr_confs_[task.name()] = task;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应配置文件举例如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/11/29/20211129005901.png"></p><p>这里有一点需要注意的是，由于配置文件中每个[task]内部没有写明其所在的[group]名称，因此在读取配置的时候，通过<code>task.set_group_name(group_name);</code>进行了设置，这个<code>group_name</code>相当的重要，接下来会用到。</p><p>最后看第6点，为每个group创建对应数量的Processor，并设置相关策略，这是由函数<code>SchedulerClassic::CreateProcessor()</code>来实现的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SchedulerClassic::CreateProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历每一个group</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; group : classic_conf_.groups()) &#123;</span><br><span class="line">    <span class="number">1.</span> 获取该group的group_name、proc_num配置参数</span><br><span class="line">    <span class="number">2.</span> 获取该group的affinity、processor_policy、processor_prio配置参数</span><br><span class="line">    <span class="number">3.</span> 内部再进行一次遍历，为每个组创建对应数量的processor,部分代码如下：</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; proc_num; i++) &#123;</span><br><span class="line">      <span class="number">3.1</span> 先创建执行器的上下文ClassicContext，并放入全局的pctxs_队列中</span><br><span class="line">      <span class="keyword">auto</span> ctx = <span class="built_in">std</span>::make_shared&lt;ClassicContext&gt;(group_name);</span><br><span class="line">      pctxs_.emplace_back(ctx);</span><br><span class="line">      <span class="number">3.2</span> 创建执行器Processor，并将上面创建的上下文与之绑定</span><br><span class="line">      <span class="keyword">auto</span> proc = <span class="built_in">std</span>::make_shared&lt;Processor&gt;();</span><br><span class="line">      <span class="number">3.3</span> 关键：</span><br><span class="line">      proc-&gt;BindContext(ctx);</span><br><span class="line">      <span class="number">3.4</span> 设置该Processor的CPU亲和性，根据affinity = <span class="string">"range"</span> <span class="keyword">or</span> <span class="string">"1to1"</span>来决定该Processor在多个CPU上进行还是单个CPU上进行</span><br><span class="line">      SetSchedAffinity(proc-&gt;Thread(), cpuset, affinity, i);</span><br><span class="line">      <span class="number">3.5</span> 设置调度策略</span><br><span class="line">      SetSchedPolicy(proc-&gt;Thread(), processor_policy, processor_prio,</span><br><span class="line">                     proc-&gt;Tid());</span><br><span class="line">      <span class="number">3.6</span> 将这个新创建的Processor保存到容器</span><br><span class="line">      processors_.emplace_back(proc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，通过<code>SetSchedAffinity()</code>函数对新创建的某个Processor对象内部的thread进行CPU亲和性设置，以实现CPU的分配，特别的，根据该<code>group</code>的<code>affinity</code>配置项，有两种CPU分配策略：</p><ul><li>range: 采用range策略，即每个Processor对象内部的thread都可以由<code>cpuset</code>字段给定的范围内自由调度，即范围内的CPU都可以处理</li><li>1to1: 即每个Processor对象内部的thread只能对应一个CPU核心，<code>cpuset</code>字段提供的是有多少个CPU可分配，但是个Processor对象内部的thread只能对应<code>cpuset</code>字段的第i个核心</li></ul><p>以上是关于线程的CPU亲和性设置，接下来的一个关键问题是，创建这么多Processor，如何真正处理我们的任务?</p><p>代码片段中的<code>3.3</code>是关键，<code>proc-&gt;BindContext(ctx)</code>将新创建的ProcessorContext上下文保存到成员变量<code>Processor::context_</code>，然后开启线程来执行<code>Processor::Run</code>，该函数代码不长，就两句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processor::BindContext</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ProcessorContext&gt;&amp; context)</span> </span>&#123;</span><br><span class="line">  context_ = context;</span><br><span class="line">  <span class="built_in">std</span>::call_once(thread_flag_,</span><br><span class="line">                 [<span class="keyword">this</span>]() &#123; thread_ = <span class="built_in">std</span>::thread(&amp;Processor::Run, <span class="keyword">this</span>); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先保存传进来的<code>ProcessorContext</code>对象指针，然后启动了一个线程，看来<code>Processor::Run</code>这个线程就是实际执行任务的线程了，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Processor::Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 暂时先忽略snap_shot_这个对象的内容</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是一个循环，只要Processor的running_状态weitrue</span></span><br><span class="line">  <span class="keyword">while</span> (cyber_likely(running_.load())) &#123;</span><br><span class="line">    <span class="comment">// 检查context_不为空</span></span><br><span class="line">    <span class="keyword">if</span> (cyber_likely(context_ != <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="comment">// 尝试从cr_group_获取下一个协程</span></span><br><span class="line">      <span class="keyword">auto</span> croutine = context_-&gt;NextRoutine();</span><br><span class="line">      <span class="comment">// 如果获取成功</span></span><br><span class="line">      <span class="keyword">if</span> (croutine) &#123;</span><br><span class="line">        <span class="comment">// 恢复协程运行</span></span><br><span class="line">        croutine-&gt;Resume();</span><br><span class="line">        <span class="comment">// 释放协程锁( 上面获取协程context_-&gt;NextRoutine()时，调用了croutine-&gt;Aquire() )</span></span><br><span class="line">        croutine-&gt;Release();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 阻塞等待，超时自动解除阻塞</span></span><br><span class="line">        context_-&gt;Wait();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果context_为空，阻塞10毫秒，超时后结束阻塞，下一次循环</span></span><br><span class="line">      <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mtx_ctx_);</span><br><span class="line">      cv_ctx_.wait_for(lk, <span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Processor::Run</code>这个线程不断的尝试从<code>context_</code>成员变量中获取协程，并恢复协程运行，一个协程的任务处理完后，继续从上下文获取下一个协程<code>context_-&gt;NextRoutine();</code>。至于这个协程的切入和切出，到后面协程篇章的时候再详细讨论。接下来，就要看看这个上下文成员变量<code>context_</code>是啥。</p><p><code>processor.h</code>头文件内可知，成员变量<code>context_</code>声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessorContext只是基类，实际保存下来的是 ClassicContext 或 ChoreographyContext</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ProcessorContext&gt; context_;</span><br></pre></td></tr></table></figure><p>即每个<code>Processor</code>对象内维护着一个<code>ProcessorContext</code>。</p><h1 id="processorcontext">ProcessorContext</h1><p>实际上，<code>ProcessorContext</code>只是基类，根据Scheduler的两种策略，分别对应着两种<code>ProcessorContext</code>，分别是:</p><ul><li>ClassicContext</li><li>ChoreographyContext</li></ul><p>uml类图如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/11/29/processorContext.png"></p><p>接下来，以<code>ClassicContext</code>为主进行展开：</p><h2 id="processorcontext实例化">ProcessorContext实例化</h2><p>ProcessorContext实例化不是在<code>Processor</code>内部进行，而是在上面提到的<code>SchedulerClassic::CreateProcessor()</code>函数中进行，具体代码片段为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ctx = <span class="built_in">std</span>::make_shared&lt;ClassicContext&gt;(group_name);</span><br></pre></td></tr></table></figure><p>接下来，看<code>ClassicContext</code>的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ClassicContext::ClassicContext()</span><br><span class="line">&#123;</span><br><span class="line">  InitGroup(DEFAULT_GROUP_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassicContext::ClassicContext(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; group_name) &#123;</span><br><span class="line">  InitGroup(group_name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ClassicContext</code>类有两个构造函数，其中一个需要传参[group_name],另外一个不需传参。两个构造函数内部都调用了<code>ClassicContext::InitGroup</code>函数，<strong>该函数从全局静态容器中取对应<code>[group_name]</code>的引用并保存到<code>ClassicContext</code>类的成员变量中，目的是，当其他地方向全局静态容器添加元素时，直接调用<code>ClassicContext</code>类的成员变量即可访问到新增加的元素</strong>。该函数代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClassicContext::InitGroup</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; group_name)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// cr_group_是ClassicContext类静态成员变量</span></span><br><span class="line">  <span class="comment">// cr_group_包含了多个组，每个组有分为多个优先级，每个优先级对应着多个协程</span></span><br><span class="line">  multi_pri_rq_ = &amp;cr_group_[group_name]; <span class="comment">// 取cr_group_中对应group_name的组，保存到multi_pri_rq_</span></span><br><span class="line">  lq_ = &amp;rq_locks_[group_name];           <span class="comment">// 取rq_locks_中对应group_name的组，保存到lq_</span></span><br><span class="line">  mtx_wrapper_ = &amp;mtx_wq_[group_name];    <span class="comment">// 取mtx_wrapper_中对应group_name的组，保存到mtx_wrapper_</span></span><br><span class="line">  cw_ = &amp;cv_wq_[group_name];              <span class="comment">// 取cv_wq_中对应group_name的组，保存到cw_</span></span><br><span class="line">  notify_grp_[group_name] = <span class="number">0</span>;</span><br><span class="line">  current_grp = group_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="classiccontext的静态容器">ClassicContext的静态容器</h2><p>上面提到<code>ClassicContext</code>类里面有几个全局静态容器，其在<code>classic_context.h</code>中声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Class ClassicContext&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// CR_GROUP: 容器[组名] = std::array&lt;std::vector&lt;std::shared_ptr&lt;CRoutine&gt;&gt;, MAX_PRIO&gt;&gt;</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> CR_GROUP cr_group_;  <span class="comment">///&lt; cr_group_包含了多个组，每个组有分为多个优先级，每个优先级对应着多个协程</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// RQ_LOCK_GROUP: 容器[组名] = std::array&lt;base::AtomicRWLock, MAX_PRIO&gt;;</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> RQ_LOCK_GROUP rq_locks_; <span class="comment">///&lt; rq_locks_包含多个组，每组分为多个优先级，每个优先级对应一个base::AtomicRWLock，关于cr_group_变量的锁</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// GRP_WQ_CV: 容器[组名] = CvWrapper</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> GRP_WQ_CV cv_wq_;  <span class="comment">///&lt; cv_wq_包含多个组，每组对应一个CvWrapper</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// GRP_WQ_MUTEX: 容器[组名] = MutexWrapper</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> GRP_WQ_MUTEX mtx_wq_;  <span class="comment">///&lt; mtx_wq_包含多个组，每组对应一个MutexWrapper，是关于notify_grp_[group_name]的锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// NOTIFY_GRP: 容器[组名] = int</span></span><br><span class="line">  <span class="keyword">alignas</span>(CACHELINE_SIZE) <span class="keyword">static</span> NOTIFY_GRP notify_grp_;  <span class="comment">///&lt; notify_grp_包含多个组，每组对应一个int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个容器都是<code>Public</code>的且静态的，所以其他地方可以直接往里面读写数据，而线程问题则通过<code>rq_locks_</code>容器和<code>mtx_wq_</code>容器进行加锁控制。</p><p>实际上，<code>Scheduler</code>要调度的任务，都保存到了这几个静态容器内部，如何存进去，以及存了什么进去，<code>SchedulerClassic::DispatchTask</code>函数给出了答案，该函数以一个协程指针作为参数，做了以下几个工作:</p><ol type="1"><li>首先把这个新协程放入<code>Scheduler::id_cr_</code>中，</li><li>然后根据[协程名]查找保存的构造Scheduler单例时，产生的<code>cr_confs_</code>中是否有该task对应的策略，如果有就根据策略设置该协程的[优先级]和[group_name]</li><li>最后往<code>ClassicContext</code>中的全局静态变量<code>ClassicContext::cr_group_</code>中对应该协程的[group_name]和优先级的队列中加入该协程</li><li>最后调用<code>ClassicContext::Notify(</code>来通知该协程所属的组，让<code>Processor::Run()</code>结束阻塞，马上运行一次</li></ol><p>这个函数，着重看以下代码块:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SchedulerClassic::DispatchTask</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;CRoutine&gt;&amp; cr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据协程名进行查表，cr_confs_在实例化SchedulerClassic对象时，就根据配置文件读取配置进去了，对应的是sched_classic.conf配置文件中的"tasks:"项</span></span><br><span class="line">  <span class="keyword">if</span> (cr_confs_.<span class="built_in">find</span>(cr-&gt;name()) != cr_confs_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 找到配置项，则取对应的value</span></span><br><span class="line">    ClassicTask task = cr_confs_[cr-&gt;name()];</span><br><span class="line">    <span class="comment">// 协程设置属性（从ClassicTask获取）</span></span><br><span class="line">    cr-&gt;set_priority(task.prio());    <span class="comment">// 设置优先级?</span></span><br><span class="line">    cr-&gt;set_group_name(task.group_name());  <span class="comment">// 设置分组名? 如果没有给这个值呢？ ==&gt; 在SchedulerClassic::SchedulerClassic()构造时，会设置值的</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果cr_confs_没有这个协程名的条目，直接设置分组名为默认的 classic_conf_.groups(0).name()</span></span><br><span class="line">    <span class="comment">// croutine that not exist in conf</span></span><br><span class="line">    cr-&gt;set_group_name(classic_conf_.groups(<span class="number">0</span>).name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enqueue task.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 取ClassicContext::cr_group_对应该组该优先级的写锁</span></span><br><span class="line">    <span class="function">WriteLockGuard&lt;AtomicRWLock&gt; <span class="title">lk</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ClassicContext::rq_locks_[cr-&gt;group_name()].at(cr-&gt;priority()))</span></span>;</span><br><span class="line">    <span class="comment">// 将输入参数中的协程添加到ClassicContext::cr_group_，等待被调度</span></span><br><span class="line">    ClassicContext::cr_group_[cr-&gt;group_name()]</span><br><span class="line">        .at(cr-&gt;priority())</span><br><span class="line">        .emplace_back(cr);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，需要调度的协程，都通过这个函数，根据协程所在的组，把协程指针保存到<code>ClassicContext::cr_group_</code>静态变量中。</p><h3 id="classiccontextcr_group数据结构">ClassicContext::cr_group数据结构</h3><p><img src="http://s1.nsloop.com:59080/images/2021/12/01/cr_group_.drawio.png"></p><p><code>ClassicContext::cr_group_</code>是一张大的表格，分为多个[group]，每个[group]又分多个优先级，每个优先级对应着一个<code>std::vector</code>，<code>vector</code>内部存放着多个协程。</p><p>一个需要注意的点是，由于<code>ClassicContext::cr_group_</code>是静态变量，多个线程访问时会有<code>data race</code>的问题，因此cyber-rt增加了对应的锁<code>ClassicContext::rq_locks_</code>来解决。</p><h3 id="classiccontextrq_locks数据结构">ClassicContext::rq_locks数据结构</h3><p><img src="http://s1.nsloop.com:59080/images/2021/12/04/rq_locks_.drawio.png"></p><p>显然，<code>ClassicContext::rq_locks_</code>内按<code>group_name</code>进行分组，每个组内又按优先级进行划分，因此，这里一个锁对应<code>ClassicContext::cr_group_</code>中的一个<code>std::vector&lt;CRoutine&gt;</code>，其对应关系如下图所示：</p><p><img src="http://s1.nsloop.com:59080/images/2021/12/04/rq_locak_and_cr_group.drawio1f9420f739656693.png"></p><h2 id="classiccontext的动态容器">ClassicContext的动态容器</h2><p>前面讨论了<code>ClassicContext</code>的静态成员变量，接下来我们看其类内动态成员变量。代码片段如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassicContext</span> :</span> <span class="keyword">public</span> ProcessorContext &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// std::array&lt;std::vector&lt;std::shared_ptr&lt;CRoutine&gt;&gt;, MAX_PRIO&gt;</span></span><br><span class="line">MULTI_PRIO_QUEUE *multi_pri_rq_ = <span class="literal">nullptr</span>; <span class="comment">///&lt; 优先队列，每个优先级有一个协程列表</span></span><br><span class="line">LOCK_QUEUE *lq_ = <span class="literal">nullptr</span>;</span><br><span class="line">MutexWrapper *mtx_wrapper_ = <span class="literal">nullptr</span>; <span class="comment">///&lt; 这个是对成员notify_grp_[current_grp]的锁</span></span><br><span class="line">CvWrapper *cw_ = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_grp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="classiccontextmulti_pri_rq队列">ClassicContext::multi_pri_rq队列</h3><p>在函数<code>ClassicContext::InitGroup</code>中，将<code>ClassicContext::cr_group_</code>的某个组的引用赋值给了成员变量<code>ClassicContext::multi_pri_rq_</code>，因此，<code>ClassicContext::multi_pri_rq_</code>的数据结构如下:</p><p><img src="http://s1.nsloop.com:59080/images/2021/12/05/multi_pri_rq.drawio.png"></p><p><code>ClassicContext::multi_pri_rq_</code>与<code>ClassicContext::cr_group_</code>的映射关系如下:</p><p><img src="http://s1.nsloop.com:59080/images/2021/12/05/multi_pri_rq.drawiofeae01cd4a05a6ac.png"></p><p>所以，通过向全局静态表<code>ClassicContext::cr_group_</code>写入协程后，可以通过<code>ClassicContext::multi_pri_rq_</code>来读取对应的协程，最后通过<code>Processor::Run</code>来完成协程的调用。</p><h1 id="重要过程时序流图">重要过程时序流图</h1><h2 id="创建schedulerclassic实例">创建SchedulerClassic实例</h2><p><img src="http://s1.nsloop.com:59080/images/2021/12/05/SchedulerClassicSchedulerClassic.jpg"></p><h2 id="创建processor并绑定上下文">创建Processor并绑定上下文</h2><p><img src="http://s1.nsloop.com:59080/images/2021/12/05/SchedulerClassicCreateProcessor.jpg"></p><h2 id="创建task并分配给processor">创建Task并分配给Processor</h2><p><code>Scheduler::CreateTask</code>这个函数是<code>Scheduler</code>基类的函数，其内部会调用子类<code>SchedulerClassic</code>或<code>SchedulerChoreography</code>的<code>DispatchTask()</code>函数，最后将子类的<code>NotifyProcessor</code>函数注册给<code>DataVistor</code>对象，其详细的时序流程如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/12/05/SchedulerCreateTaskbdbced6bb306a41f.jpg"></p><h2 id="运转核心processorrun">运转核心Processor::Run</h2><p><img src="http://s1.nsloop.com:59080/images/2021/12/05/ProcessorRun.jpg"></p><h2 id="唤醒机制schedulerclassicnotifyprocessor">唤醒机制SchedulerClassic::NotifyProcessor</h2><p><img src="http://s1.nsloop.com:59080/images/2021/12/07/SchedulerClassicNotifyProcessor.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;Scheduler是Cyber-RT的调度核心，是协程的调度载体。特别的，对于自动驾驶任务而言，任务调度的实时性发挥至关重要的作用，因此有必要对各种任务的优先级进行分类排序，如对于控制任务而言，需要单独分配CPU以供实时运行，Cybe
      
    
    </summary>
    
    
    
      <category term="Cyber_RT" scheme="http://yoursite.com/tags/Cyber-RT/"/>
    
  </entry>
  
  <entry>
    <title>Cyber-RT系列之协程Croutine</title>
    <link href="http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%8F%E7%A8%8BCroutine/"/>
    <id>http://yoursite.com/2021/11/28/Cyber-RT%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8D%8F%E7%A8%8BCroutine/</id>
    <published>2021-11-28T15:10:29.000Z</published>
    <updated>2022-02-27T12:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>协程是Cyber-RT的实现任务轮转的最小单位，是处理数据回调的运行模块。协程可以理解为“可以暂停”的函数，相比于线程，其具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即可达到类似线程的效果。</p><p>为什么选用协程，因为基于协程的特性再加上Cyber中枢调度<code>Scheduler</code>的线程调度，可以避免回调时由于阻塞导致其他回调不能被执行的情况；此外，协程是在用户态来完成上下文切换的，所以切换耗时只有区区100ns多一些，比进程切换要高30倍。</p><h1 id="cybercroutine目录">Cyber/croutine目录</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── BUILD</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── croutine.cc</span><br><span class="line">├── croutine.h</span><br><span class="line">├── detail</span><br><span class="line">│   ├── routine_context.cc</span><br><span class="line">│   ├── routine_context.h</span><br><span class="line">│   ├── swap_aarch64.S</span><br><span class="line">│   └── swap_x86_64.S</span><br><span class="line">└── routine_factory.h</span><br></pre></td></tr></table></figure><h1 id="croutine类图">Croutine类图</h1><p>...</p><h1 id="结构图">结构图</h1><h1 id="协程的创建">协程的创建</h1><p>Cyber-RT中有两个地方创建了协程：</p><ul><li><code>Component</code>的初始化</li><li><code>Reader</code>的初始化</li></ul><p>两处地方的创建大同小异，这里给出<code>Component&lt;M0, NullType, NullType, NullType&gt;::Initialize</code>函数中关于创建协程的代码片段:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0&gt;</span><br><span class="line"><span class="keyword">bool</span> Component&lt;M0, NullType, NullType, NullType&gt;::Initialize(</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// lambda函数 （这个后面作为）</span></span><br><span class="line">  <span class="keyword">auto</span> func = [self](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;M0&gt;&amp; msg) &#123;</span><br><span class="line">    <span class="comment">// 处理msg</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 构造 data::DataVisitor</span></span><br><span class="line">  <span class="keyword">auto</span> dv = <span class="built_in">std</span>::make_shared&lt;data::DataVisitor&lt;M0&gt;&gt;(conf);</span><br><span class="line">  <span class="comment">// 创建协程工厂</span></span><br><span class="line">  croutine::RoutineFactory factory =</span><br><span class="line">      croutine::CreateRoutineFactory&lt;M0&gt;(func, dv);</span><br><span class="line">  <span class="keyword">auto</span> sched = scheduler::Instance();</span><br><span class="line">  <span class="keyword">return</span> sched-&gt;CreateTask(factory, node_-&gt;Name());</span><br></pre></td></tr></table></figure><p>其流程大概是这样:</p><ol type="1"><li>写出一个lambda函数，内部进行msg的回调处理</li><li>构造一个<code>DataVistor</code></li><li>将lambda函数和创建的<code>DataVistor</code>一并作为参数，用于创建协程工厂croutine::RoutineFactory</li><li>将协程工厂作为参数，调用中枢调度Scheduler::CreateTask(...)函数</li></ol><h2 id="why-routinefactory">Why RoutineFactory?</h2><p>看到上面的代码片段可能会觉得奇怪，为什么需要协程工厂这一层，直接创建一个协程不好吗？</p><p>这其实是一种封装，假设我们直接创建一个协程，那么需要传入一个回调函数，用于处理msg，然而Cyber-RT一共考虑了1-4种msg的情况，那么创建协程时传入的回调函数的参数就有4种情况，这使得接口不能统一。使用协程工厂就是为了对4种情况进行封装，并统一接口，即创建协程时只需要把协程工厂传入作为参数即可。</p><h2 id="what-is-routinefactory">What is RoutineFactory?</h2><h1 id="重要过程时序流图">重要过程时序流图</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;协程是Cyber-RT的实现任务轮转的最小单位，是处理数据回调的运行模块。协程可以理解为“可以暂停”的函数，相比于线程，其具有中断可恢复的特性，那么只需要在开一个全局的数组存储所有的协程，在协程中断时，不断轮转调用下一个协程继续运行即
      
    
    </summary>
    
    
    
      <category term="Cyber_RT" scheme="http://yoursite.com/tags/Cyber-RT/"/>
    
  </entry>
  
  <entry>
    <title>FAST-LIO论文阅读</title>
    <link href="http://yoursite.com/2021/10/13/FAST-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/10/13/FAST-LIO%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-10-13T13:03:53.000Z</published>
    <updated>2022-02-27T04:38:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fast-lio-a-fast-robust-lidar-inertial-odometry-package-by-tightly-coupled-iterated-kalman-filter">FAST-LIO: A Fast, Robust LiDAR-inertial Odometry Package by Tightly-Coupled Iterated Kalman Filter</h1><p><img src="http://s1.nsloop.com:59080/images/2021/10/13/20211013205305.png"></p><h1 id="摘要">摘要</h1><h1 id="方法">方法</h1><h2 id="架构总览">架构总览</h2><p>本文使用的符号如表一所示</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/13/20211013205455.png"></p><p>系统的流图如图2所示</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/13/20211013205632.png"></p><p>将激光雷达输入输入特征提取模块，获取平面和边缘特征。然后将提取的特征和IMU测量值输入状态估计模块进行10Hz和50Hz的状态估计。然后，估计的姿态将特征点注册到全局坐标系，并将它们与到目前为止建立的特征点地图合并，最后，在下一步中使用更新后的特征地图来注册更多的新点。</p><h2 id="系统描述">系统描述</h2><h3 id="操作符">操作符</h3><p>设M为考虑维度n的流形(如： <span class="math inline">\(\mathcal{M}=S O(3)\)</span>），因为流形对于<span class="math inline">\(\mathbb{R}^{n}\)</span>是局部homeomorphic的，因此我们可以建立双向的映射，即通过操作符<span class="math inline">\(\boxplus,\boxminus\)</span>[23]，从流形 <span class="math inline">\(\mathcal{M}\)</span>的局部邻域映射到其正切空间<span class="math inline">\(\mathbb{R}^{n}\)</span>：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/14/20211014094942.png"></p><p>其中，<span class="math inline">\(\operatorname{Exp}(\mathbf{r})=\mathbf{I}+\frac{\mathbf{r}}{\|\mathbf{r}\|} \sin (\|\mathbf{r}\|)+\frac{\mathbf{r}^{2}}{\|\mathbf{r}\|^{2}}(1-\cos (\|\mathbf{r}\|))\)</span>是指数映射[23]，<span class="math inline">\(\log (\cdot)\)</span>则是其逆映射。对于组合的流形<span class="math inline">\(\mathcal{M}=S O(3) \times \mathbb{R}^{n}\)</span>，我们有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/14/20211014095245.png"></p><p>利用上述定义，我们可以得到：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/14/20211014095319.png"></p><h3 id="连续时间模型">连续时间模型</h3><p>假设IMU与激光雷达之间是刚体变换，其中外参是<span class="math inline">\({ }^{I} \mathbf{T}_{L}=\left({ }^{I} \mathbf{R}_{L},{ }^{I} \mathbf{p}_{L}\right)\)</span>。以IMU坐标系（记为<span class="math inline">\(I\)</span>）作为body坐标系，可得运动学模型：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/14/20211014095614.png"></p><p>其中，</p><ul><li><span class="math inline">\({ }^{G} \mathbf{p}_{I},{ }^{G} \mathbf{R}_{I}\)</span>分别是IMU在全局坐标系（如第一帧IMU坐标系，记为<span class="math inline">\(G\)</span>）的位置和姿态。</li><li><span class="math inline">\({ }^{G} \mathbf{g}\)</span>是全局坐标系下未知的重力向量</li><li><span class="math inline">\(\mathbf{a}_{m}\)</span>,<span class="math inline">\(\boldsymbol{\omega}_{m}\)</span>是IMU测量</li><li><span class="math inline">\(\mathbf{n}_{\mathbf{a}}\)</span> and <span class="math inline">\(\mathbf{n}_{\boldsymbol{\omega}}\)</span>是IMU测量白噪声</li><li><span class="math inline">\(\mathbf{b}_{\mathbf{a}}\)</span> and <span class="math inline">\(\mathbf{b}_{\boldsymbol{\omega}}\)</span>是由高斯噪声<span class="math inline">\(\mathbf{n}_{\mathbf{b a}}\)</span> , <span class="math inline">\(\mathbf{n}_{\mathbf{b} \omega}\)</span>随机游走过程建模的bias</li><li><span class="math inline">\(\lfloor\mathbf{a}\rfloor_{\wedge}\)</span>表示向量<span class="math inline">\(\mathbf{a} \in \mathbb{R}^{3}\)</span>的反对称矩阵</li></ul><h3 id="离散时间模型">离散时间模型</h3><p>基于上面的<span class="math inline">\(\boxplus\)</span>操作符，我们在IMU采样周期<span class="math inline">\(\Delta t\)</span>内使用零阶保持器来对式（1）的连续时间模型进行离散化，得到：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/14/20211014173846.png"></p><p>其中，i表示IMU测量的索引，函数<span class="math inline">\(\mathbf{f}\)</span>，状态<span class="math inline">\(\mathbf{x}\)</span>，输入<span class="math inline">\(\mathbf{u}\)</span>，噪声<span class="math inline">\(\mathbf{w}\)</span>定义如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/14/20211014174415.png"></p><h3 id="激光测量预处理">激光测量预处理</h3><p>激光雷达测量是点坐标在它的局部坐标系。由于原始激光雷达点的采样速率非常高(例如，200kHz)，通常不可能在接收到每个新点后马上进行处理，一种更实际的方法是在一段时间内积累这些点，然后一次性处理它们。</p><p><code>FAST-LIO</code>中，最小积累间隔设置为20毫秒，可产生高达50 Hz的全状态估计(即里程计输出)和地图更新，如图2 （a）所示。这种累积的点集称为scan，其处理时间记为<span class="math inline">\(t_k\)</span>(见图2 (b)。</p><p>我们从原始点中提取局部光滑度高的平面点[8]和局部光滑度低的边缘点[10]，假设特征点的数量为m，每个特征点在<span class="math inline">\(\rho_{j} \in\left(t_{k-1}, t_{k}\right]\)</span>时刻采样，特征点记为<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{f_{j}}\)</span>，其中<span class="math inline">\(L_{j}\)</span>是<span class="math inline">\(\rho_{j}\)</span>时刻下激光雷达坐标系。</p><p>在激光扫描期间，通常会收到几帧IMU测量，假设每一个IMU采样时间<span class="math inline">\(\tau_{i} \in\left[t_{k-1}, t_{k}\right]\)</span>，其对应的状态<span class="math inline">\(\mathbf{x}_i\)</span>如式（2）。注意，最后一个激光雷达特征点是扫描的结束，即<span class="math inline">\(\rho_{m}=t_{k}\)</span>，而IMU测量值不一定与扫描开始或结束时对齐。</p><h3 id="状态估计">状态估计</h3><p>为了估计状态公式(2)中的状态，我们使用了迭代扩展卡尔曼滤波器，此外，我们刻画了状态估计的正切空间中的估计协方差，如[23,24]。</p><p>假设在<span class="math inline">\(t_{k-1}\)</span>时刻下最后一次激光雷达扫描的最佳状态估计为<span class="math inline">\(\bar{\mathbf{x}}_{k-1}\)</span>，协方差为<span class="math inline">\(\overline{\mathbf{P}}_{k-1}\)</span>。其中，<span class="math inline">\(\overline{\mathbf{P}}_{k-1}\)</span>代表了如下误差状态向量的协方差：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/14/20211014214313.png"></p><p>其中，</p><ul><li><span class="math inline">\(\delta \boldsymbol{\theta}=\log \left({ }^{G} \overline{\mathbf{R}}_{I}^{T G} \mathbf{R}_{I}\right)\)</span>是姿态误差</li><li>剩下的其他都是直接相减</li></ul><p>直觉的，<span class="math inline">\(\delta \boldsymbol{\theta}\)</span>描述了姿态真值和估计值之间的小偏差，使用这个来定义姿态误差的好处是允许使用3x3协方差矩阵<span class="math inline">\(\mathbb{E}\left\{\delta \boldsymbol{\theta} \delta \boldsymbol{\theta}^{T}\right\}\)</span>来描述姿态的不确定性。因为姿态是3自由度，因此这是最小表达。</p><p>1）前向传播</p><p>一旦接收到IMU输入，则执行一次前向传播（如图2所示），特别的，前向传播根据式（2）进行，且把噪声<span class="math inline">\(\mathbf{W}_{i}\)</span>设置为零，（相当于nominal state）：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/15/20211015095745.png"></p><p>其中，<span class="math inline">\(\Delta t=\tau_{i+1}-\tau_{i}\)</span>，为了传播协方差，我们使用下面的误差状态动态模型：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/15/20211015095952.png"></p><p>矩阵<span class="math inline">\(\mathbf{F}_{\widetilde{\mathbf{x}}}\)</span>和<span class="math inline">\(\mathbf{F}_{\mathbf{w}}\)</span>为误差状态模型(实际上就是误差分析，可参考<a href="http://epsilonjohn.club/2020/11/20/%E5%A4%9A%E4%BC%A0%E6%84%9F%E5%99%A8%E8%9E%8D%E5%90%88%E5%AE%9A%E4%BD%8D/%E6%BB%A4%E6%B3%A2%E5%99%A8%E8%9E%8D%E5%90%88_1_%E6%83%AF%E5%AF%BC%E8%A7%A3%E7%AE%97%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">博客</a>)，具体计算见附录A.</p><p>此处直接给出结果：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/16/20211016095853.png"></p><p>其中，</p><ul><li><span class="math inline">\(\widehat{\boldsymbol{\omega}}_{i}=\boldsymbol{\omega}_{m_{i}}-\widehat{\mathbf{b}}_{\boldsymbol{\omega}_{i}}\)</span></li><li><span class="math inline">\(\widehat{\mathbf{a}}_{i}=\mathbf{a}_{m_{i}}-\widehat{\mathbf{b}}_{\mathbf{a}_{i}}\)</span></li></ul><p>且<span class="math inline">\(\mathbf{A}(\mathbf{u})^{-1}\)</span>遵循[25]中的定义，如下计算：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/16/20211016100101.png"></p><p>记白噪声<span class="math inline">\(\mathbf{w}\)</span>的协方差为Q，然后可以通过下式来迭代传播协方差<span class="math inline">\(\widehat{\mathbf{P}}_{i}\)</span>：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/16/20211016100233.png"></p><p>前向传播直到新的一帧数据结束<span class="math inline">\(t_k\)</span>，传播的状态和协方差分别记为<span class="math inline">\(\widehat{\mathbf{x}}_{k}, \widehat{\mathbf{P}}_{k}\)</span>，协方差表示状态真值与传播值之间的误差协方差。</p><p>2）反向传播和运动补偿</p><p>当在时间<span class="math inline">\(t_k\)</span>，新一帧的特征点应该与传播状态<span class="math inline">\(\widehat{\mathbf{x}}_{k}\)</span>和协方差<span class="math inline">\(\widehat{\mathbf{P}}_{k}\)</span>进行结合以产生最优状态更新。然而，尽管新的一帧是在<span class="math inline">\(t_k\)</span>到达，实际上特征点是在各自的采样时刻<span class="math inline">\(\rho_j\)</span>下得到的，因此要进行运动畸变矫正。</p><p>为了补偿<span class="math inline">\(\rho_j\)</span>到<span class="math inline">\(t_k\)</span>之间的相对运动（即运动畸变），根据式（2），可得传播方程<span class="math inline">\(\check{\mathbf{x}}_{j-1}=\check{\mathbf{x}}_{j}\)</span> 田 <span class="math inline">\(\left(-\Delta t \mathbf{f}\left(\check{\mathbf{x}}_{j}, \mathbf{u}_{j}, \mathbf{0}\right)\right)\)</span>。</p><p>向后传播在特征点的频率下执行，这通常远高于IMU速率，对于在两个IMU测量之间采样的所有特征点，我们使用左IMU测量作为后传播中的输入。</p><p>此外，注意到<span class="math inline">\(\mathbf{f}\left(\mathbf{x}_{j}, \mathbf{u}_{j}, \mathbf{0}\right)\)</span>中最后三个块元素（对应于gyro bias，accelerometer bias和外参）都是零，因此，反向传播可以简化为：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/16/20211016101449.png"></p><p>其中，</p><ul><li><span class="math inline">\(\rho_{j-1} \in\left[\tau_{i-1}, \tau_{i}\right)\)</span>表示一帧扫描内的某个时刻</li><li><span class="math inline">\(\Delta t=\rho_{j}-\rho_{j-1}\)</span>表示两个点之间的时间差</li><li><span class="math inline">\(s.f.\)</span>表示“starting form”的意思</li></ul><p>反向传播会计算出时间<span class="math inline">\(\rho_{j}\)</span>到时间<span class="math inline">\(t_k\)</span> 的相对位姿变换<span class="math inline">\({ }^{I_{k}} \check{\mathbf{T}}_{I_{j}}=\left({ }^{I_{k}} \check{\mathbf{R}}_{I_{j}},{ }^{I_{k}} \check{\mathbf{p}}_{I_{j}}\right)\)</span>，这个相对位姿变换运行我们将激光扫描观测点<span class="math inline">\({ }^{L_{j}} \mathbf{p}_{f_{j}}\)</span>投影到扫描结束时刻下的坐标系，如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/16/20211016102337.png"></p><p>其中，<span class="math inline">\({ }^{I} \mathbf{T}_{L}\)</span>是已知外参，投影点<span class="math inline">\({ }^{L_{k}} \mathbf{p}_{f_{j}}\)</span>用于下一步构造残差。</p><p>3）残差计算</p><p>使用式（10）的运动补偿，我们可以看到在<span class="math inline">\(t_k\)</span>时刻下所有特征点<span class="math inline">\(\left\{ { }^{L_{k}} \mathbf{p}_{f_{j}}\right\}\)</span>正确的位置，并且用来构造残差。</p><p>假设当前IEKF迭代为<span class="math inline">\(\kappa\)</span>，对应的状态估计为<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa}\)</span>。当<span class="math inline">\(\kappa=0\)</span>，<span class="math inline">\(\widehat{\mathbf{x}}_{k}^{\kappa}=\widehat{\mathbf{x}}_{k}\)</span>，预测的状态即为式（4）传播的状态。因此，特征点可以被投影到全局坐标系，如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/17/20211017225552.png"></p><p>对于每一个激光特征点，假设其附近的附近特征点定义的最接近的平面或边缘是与之关联的特征。残差即为特征点与关联特征（平面、边缘）的欧式距离（全局坐标系下）。</p><p>记<span class="math inline">\(\mathbf{u}_{j}\)</span>为平面法向量或者边缘方向，对于根据状态估计投影到全局坐标系的特征点<span class="math inline">\({ }^{G} \widehat{\mathbf{p}}_{f_{j}}^{\kappa}\)</span>，假设平面/边缘上有点<span class="math inline">\({ }^{G} \mathbf{q}_{j}\)</span>，残差<span class="math inline">\(\mathbf{z}_{j}^{\kappa}\)</span>如下计算：</p><p><img src="http://s1.nsloop.com:59080/images/2021/10/17/20211017230052.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{G}_{j}=\mathbf{u}_{j}^{T}\)</span>是平面特征</li><li><span class="math inline">\(\mathbf{G}_{j}=\left\lfloor\mathbf{u}_{j}\right\rfloor_{\wedge}\)</span>是边缘特征</li><li><span class="math inline">\(\mathbf{u}_{j}\)</span>的计算和最近邻点的搜索是通过构建局部地图KD-TREE来实现的</li><li>此外，我们只考虑<code>norm</code>低于某些阈值（例如，0.5米）的残差。 超过此阈值的残差是异常值或新观察点</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fast-lio-a-fast-robust-lidar-inertial-odometry-package-by-tightly-coupled-iterated-kalman-filter&quot;&gt;FAST-LIO: A Fast, Robust LiDAR-ine
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>FAST-LIO2论文阅读</title>
    <link href="http://yoursite.com/2021/09/11/FAST-LIO2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/09/11/FAST-LIO2%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-09-11T06:03:53.000Z</published>
    <updated>2022-02-27T04:38:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fast-lio2-fast-direct-lidar-inertial-odometry">FAST-LIO2: Fast Direct LiDAR-inertial Odometry</h1><p><img src="http://s1.nsloop.com:59080/images/2021/09/12/20210912151410.png"></p><h1 id="摘要">摘要</h1><p>在高效的紧密耦合迭代卡尔曼滤波器上，FAST-LiO2有两个关键的新科技，可允许快速，强大，准确的LIDAR导航（和建图）。</p><ul><li>直接将原始点注册到地图（随后更新地图）而不提取特征点。这使得能够利用环境中的微妙特征，因此提高了准确性。取消手工设计的特征提取模块也使其自然适应不同扫描模式的新兴 LiDAR。</li><li>第二个主要新颖性是通过增量K-D树数据结构，来维护地图，该映射可以增量更新（即点插入，删除）和动态重新平衡。与现有的动态数据结构相比（Octree，R * -tree，Nanoflann K-D树），IKD-Tree实现了卓越的整体性能，同时支持基于数的降采样</li></ul><p>我们在来自各种开放式LIDAR数据集中的19个序列中进行详尽的基准比较，与其他最先进的 LiDAR 惯性导航系统相比，FAST-LIO2 以更低的计算负载持续实现更高的精度，还进行了关于具有小FOV的固态激光雷达的各种真实实验。</p><p>总的来说，FAST-LiO 2是计算上有效的（例如，高达100 Hz的里程计和大型环境中的建图），鲁棒（例如，杂乱的室内环境中具有旋转的杂乱的室内环境的可靠姿态估计，多功能（即， 适用于多线和固态LIDARS，UAV和手持平台，英特尔和基于ARM的处理器），同时仍然比现有方法实现更高的准确性。</p><h1 id="介绍">介绍</h1><p>我们开发一个增量K-D树数据结构，IKD树，有效地表示大规模稠密点云地图。 除了有效的最近邻搜索之外，新的数据结构还支持增量地图更新（即，点插入，基于数的降采样，点删除）和最小计算成本的动态重新平衡。</p><p>这些功能使IKD树非常适合基于激光雷达的里程计和建图应用，在计算限制平台上实现100 Hz 里程计和建图，如微型UAV板载计算机（英特尔I7）甚至基于ARM的处理器。</p><p>通过增加IKD树的计算效率允许，我们直接将原始点注册到地图，即使具有激进的运动和非常杂乱的环境，也能够更准确和可靠的扫描配准。我们将此使用原始点的配准称为类似于Visual Slam的直接方法[21]。消除手工工程特征提取使得系统自然适用于不同的激光雷达传感器。</p><p>我们将以上两个改进整合到先前的工作<code>FAST-LIO</code>中，该系统使用IMU通过严格的反向传播步骤来遵从每个点的运动，并通过迭代扩展卡尔曼滤波器估计系统的完整状态。为了进一步加速计算，使用新的和数学上等同的计算卡尔曼增益的公式用于<strong>将计算复杂性降低到状态的维度（而不是观测的维度）</strong>。</p><p>新的系统称为<code>FAST-LIO2</code>，关于各种尺寸的18个序列的实验表明，IKD树在应用激光雷达测量和测绘时实现了相比于现有动态数据结构（Octree，R * -Tree，Nanoflann K-D树）的卓越性能</p><h1 id="系统概述">系统概述</h1><p><img src="http://s1.nsloop.com:59080/images/2021/09/12/20210912200058.png"></p><p><code>FAST-LIO2</code>的数据流如图所示，为了执行状态估计，新扫描中的点被通过紧密耦合的迭代卡尔曼滤波器框架（有红色的大虚线块）注册到大型局部地图中。大型局部地图中的全局地图点由增量K-D树结构IKD-Tree组织（蓝色虚线块）。如果当前LIDAR的FOV范围交叉地图边界，则将删除IKD树中，从LIDAR位置到最远地图区域中的历史点。</p><p>结果，IDK-TREE跟踪在一个大范围立方体区域（<code>map size</code>）中的所有地图点，并用于计算状态估计模块中的残差。优化后的位姿最后将新扫描中的点注册到全局坐标系，并通过以里程计频率插入到IKD树，来将它们合并到地图中。</p><h1 id="状态估计">状态估计</h1><p><code>FAST-LIO2</code>的状态估计是从<code>FAST-LIO</code>[22]继承的，且进一步整合了Lidar-IMU的外参在线标定。在这里，我们简要解释滤波器的基本配方和工作流程，并参考[22]了解更多细节。</p><h2 id="系统模型">系统模型</h2><p>我们首先导出系统模型，由状态转换模型和测量模型组成</p><h3 id="状态转移模型">状态转移模型</h3><p>取第一个 IMU 帧（记为 I）作为全局帧（记为 G），记<span class="math inline">\({ }^{I} \mathbf{T}_{L}=\left({ }^{I} \mathbf{R}_{L},{ }^{I} \mathbf{p}_{L}\right)\)</span>为激光雷达到IMU的外参（未知），那么模型如下：</p><p><span class="math display">\[\begin{aligned}{ }^{G} \dot{\mathbf{R}}_{I} &amp;={ }^{G} \mathbf{R}_{I}\left\lfloor\boldsymbol{\omega}_{m}-\mathbf{b}_{\boldsymbol{\omega}}-\mathbf{n}_{\boldsymbol{\omega}}\right\rfloor_{\wedge}\\ { }^{G} \dot{\mathbf{p}}_{I} &amp;={ }^{G} \mathbf{v}_{I} \\{ }^{G} \dot{\mathbf{v}}_{I} &amp;={ }^{G} \mathbf{R}_{I}\left(\mathbf{a}_{m}-\mathbf{b}_{\mathbf{a}}-\mathbf{n}_{\mathbf{a}}\right)+{ }^{G} \mathbf{g} \\\dot{\mathbf{b}}_{\boldsymbol{\omega}} &amp;=\mathbf{n}_{\mathbf{b} \omega}, \dot{\mathbf{b}}_{\mathbf{a}}=\mathbf{n}_{\mathbf{b a}} \\{ }^{G} \dot{\mathbf{g}} &amp;=\mathbf{0},{ }^{I} \dot{\mathbf{R}}_{L}=\mathbf{0},{ }^{I} \dot{\mathbf{p}}_{L}=\mathbf{0}\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\({ }^{G} \mathbf{p}_{I},{ }^{G} \mathbf{R}_{I}\)</span>分别为全局坐标系下的IMU的位置和姿态</li><li><span class="math inline">\({ }^{G} \mathbf{g}\)</span>是全局坐标系下的重力向量</li><li><span class="math inline">\(\mathbf{a}_{m}\)</span>，<span class="math inline">\(\omega_{m}\)</span>是IMU测量</li><li><span class="math inline">\(\mathbf{b}_{\mathbf{a}}\)</span>，<span class="math inline">\(\mathbf{b}_{\boldsymbol{\omega}}\)</span>是由噪声<span class="math inline">\(\mathbf{n}_{\mathbf{b a}},\mathbf{n}_{\mathbf{b \omega}}\)</span>驱动的随机游走过程建模的IMU偏置</li><li><span class="math inline">\(\lfloor\mathbf{a}\rfloor_{\wedge}\)</span>表示由向量<span class="math inline">\(\mathbf{a}\)</span>构成的反对称矩阵</li></ul><p>记<span class="math inline">\(i\)</span>为IMU测量的索引，基于[22]中定义的<span class="math inline">\(\boxplus\)</span> 操作符，连续时间下的动态模型可以根据IMU采样周期<span class="math inline">\(\Delta t\)</span>进行离散化，如下：</p><p><span class="math display">\[\mathbf{x}_{i+1}=\mathbf{x}_{i} \boxplus \left(\Delta t \mathbf{f}\left(\mathbf{x}_{i}, \mathbf{u}_{i}, \mathbf{w}_{i}\right)\right)\]</span></p><p>其中，函数<span class="math inline">\(\mathbf{f}\)</span>，状态<span class="math inline">\(\mathbf{x}\)</span>，输入<span class="math inline">\(\mathbf{u}\)</span>和噪声<span class="math inline">\(\mathbf{w}\)</span>定义如下：</p><p><span class="math display">\[\mathcal{M} \triangleq S O(3) \times \mathbb{R}^{15} \times S O(3) \times \mathbb{R}^{3} ; \operatorname{dim}(\mathcal{M})=24\]</span></p><p><span class="math display">\[\mathbf{x} \triangleq\left[\begin{array}{llllllll}{ }^{G} \mathbf{R}_{I}^{T} &amp; { }^{G} \mathbf{p}_{I}^{T} &amp; { }^{G} \mathbf{v}_{I}^{T} &amp; \mathbf{b}_{\boldsymbol{\omega}}^{T} &amp; \mathbf{b}_{\mathbf{a}}^{T} &amp; { }^{G} \mathbf{g}^{T} &amp; { }^{I} \mathbf{R}_{L}^{T} &amp; { }^{I} \mathbf{p}_{L}^{T}\end{array}\right]^{T} \in \mathcal{M}\]</span></p><p><span class="math display">\[\mathbf{u} \triangleq\left[\begin{array}{ll}\boldsymbol{\omega}_{m}^{T} &amp; \mathbf{a}_{m}^{T}\end{array}\right]^{T}\]</span></p><p><span class="math display">\[\mathbf{w} \triangleq\left[\begin{array}{llll}\mathbf{n}_{\boldsymbol{\omega}}^{T} &amp; \mathbf{n}_{\mathbf{a}}^{T} &amp; \mathbf{n}_{\mathbf{b} \boldsymbol{\omega}}^{T} &amp; \mathbf{n}_{\mathbf{b a}}^{T}\end{array}\right]^{T}\]</span></p><p><span class="math display">\[\mathbf{f}(\mathbf{x}, \mathbf{u}, \mathbf{w})=\left[\begin{array}{c}\boldsymbol{\omega}_{m}-\mathbf{b}_{\boldsymbol{\omega}}-\mathbf{n}_{\boldsymbol{\omega}} \\{ }^{G} \mathbf{v}_{I}+\frac{1}{2}\left({ }^{G} \mathbf{R}_{I}\left(\mathbf{a}_{m}-\mathbf{b}_{\mathbf{a}}-\mathbf{n}_{\mathbf{a}}\right)+{ }^{G} \mathbf{g}\right) \Delta t \\{ }^{G} \mathbf{R}_{I}\left(\mathbf{a}_{m}-\mathbf{b}_{\mathbf{a}}-\mathbf{n}_{\mathbf{a}}\right)+{ }^{G} \mathbf{g} \\\mathbf{n}_{\mathbf{b} \omega} \\\mathbf{n}_{\mathbf{b a}} \\\mathbf{0}_{3 \times 1} \\\mathbf{0}_{3 \times 1} \\\mathbf{0}_{3 \times 1}\end{array}\right] \in \mathbb{R}^{24}\]</span></p><h3 id="量测模型">量测模型</h3><p>LIDAR通常是一个接一个地点的样品。 因此，当激光雷达经历连续运动时，所得到的点在不同的姿势处采样，为了纠正这种扫描运动，我们采用[22]中提出的反向传播，<strong>其估计每个激光点时刻下的激光雷达位姿相对于该帧激光扫描最后时刻的激光雷达位姿</strong>。估计的相对姿势使我们能够基于扫描中每个单独点的精确采样时间将所有点投影到扫描结束时间，以实现校正。</p><p>记<span class="math inline">\(k\)</span>为激光扫描的索引，<span class="math inline">\(\{ { }^{L} \mathbf{p}_{j}, j = 1,\dots,m\}\)</span>是第<span class="math inline">\(k\)</span>帧激光坐标系下的激光点（扫描结束时刻），由于激光测量存在噪声，每一个点<span class="math inline">\(\mathbf{p}_{j}\)</span>都会受到由测距和方向组合的噪声项<span class="math inline">\({ }^{L} \mathbf{n}_{j}\)</span>影响。因此，真正的激光点与测量值之间存在如下关系：</p><p><span class="math display">\[{ }^{L} \mathbf{p}_{j}^{\mathrm{gt}}={ }^{L} \mathbf{p}_{j}+{ }^{L} \mathbf{n}_{j}\]</span></p><p>真正的激光点<span class="math inline">\({ }^{L} \mathbf{p}_{j}^{\mathrm{gt}}\)</span>，根据对应的激光雷达位姿<span class="math inline">\({ }^{\mathbf{G}}\mathbf{T}_{I_{k}}=\left({ }^{G} \mathbf{R}_{I_{k}},{ }^{G} \mathbf{p}_{I_{k}}\right)\)</span>以及外参<span class="math inline">\({ }^{I} \mathbf{T}_{L}\)</span>进行坐标转换，其应该准确的位于地图中的局部的平面上，满足：</p><p><span class="math display">\[\mathbf{0}={ }^{G} \mathbf{u}_{j}^{T}\left({ }^{G} \mathbf{T}_{I_{k}}{ }^{I} \mathbf{T}_{L}\left({ }^{L} \mathbf{p}_{j}+{ }^{L} \mathbf{n}_{j}\right)-{ }^{G} \mathbf{q}_{j}\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\({ }^{G} \mathbf{u}_{j}\)</span>是对应关联平面的法向量</li><li><span class="math inline">\({ }^{G} \mathbf{q}_{j}\)</span>是平面上的点</li><li>值得注意的是，<span class="math inline">\({ }^{G} \mathbf{T}_{I_{k}},{ }^{I} \mathbf{T}_{L}\)</span>都包含在状态向量<span class="math inline">\(\mathbf{x}_k\)</span>中</li></ul><p>因此，第<span class="math inline">\(j\)</span>个点的测量<span class="math inline">\({ }^{L} \mathbf{p}_{j}\)</span>，可以写成统一紧凑形式如下：</p><p><span class="math display">\[\mathbf{0}=\mathbf{h}_{j}\left(\mathbf{x}_{k},{ }^{L} \mathbf{p}_{j}+{ }^{L} \mathbf{n}_{j}\right)\]</span></p><p>这定义了状态矢量<span class="math inline">\(\mathbf{x}_k\)</span>的隐式测量模型</p><h2 id="迭代卡尔曼滤波器">迭代卡尔曼滤波器</h2><p>基于上面的状态模型和基于流形<span class="math inline">\(\mathcal{M} \triangleq S O(3) \times \mathbb{R}^{15} \times S O(3) \times \mathbb{R}^{3}\)</span>的量测模型，我们使用迭代卡尔曼滤波器直接在流形<span class="math inline">\(\mathcal{M}\)</span>上进行操作，遵循文献[55][22]。</p><p>其包含两个关键步骤：</p><ul><li>在每个IMU测量上传播</li><li>在每一帧激光扫描上进行迭代</li></ul><p>这两个步骤都自然地估计流形<span class="math inline">\(\mathcal{M}\)</span>上的状态，从而避免了<code>renormalization</code>。</p><h3 id="传播">1）传播</h3><p>假设最优状态估计在融合完最后一帧（如<span class="math inline">\(k-1\)</span>帧）激光扫描后的状态为<span class="math inline">\(\overline{\mathbf{x}}_{k-1}\)</span>，且协方差矩阵为<span class="math inline">\(\overline{\mathbf{P}}_{k-1}\)</span>，前向传播是在IMU测量到达时进行的，更具体地说，通过将过程噪声<span class="math inline">\(\mathbf{w}_i\)</span>设置为零，状态和协方差将按照状态转移模型进行传播：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fast-lio2-fast-direct-lidar-inertial-odometry&quot;&gt;FAST-LIO2: Fast Direct LiDAR-inertial Odometry&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>Camera与单线激光标定</title>
    <link href="http://yoursite.com/2021/09/04/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/Camera%E4%B8%8E%E5%8D%95%E7%BA%BF%E6%BF%80%E5%85%89%E6%A0%87%E5%AE%9A/"/>
    <id>http://yoursite.com/2021/09/04/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/Camera%E4%B8%8E%E5%8D%95%E7%BA%BF%E6%BF%80%E5%85%89%E6%A0%87%E5%AE%9A/</id>
    <published>2021-09-04T08:44:05.000Z</published>
    <updated>2021-09-12T07:09:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="camera-单线激光标定">Camera-单线激光标定</h1><blockquote><p>本文来源于 <a href="https://zhuanlan.zhihu.com/p/137501892" target="_blank" rel="noopener">《标定系列三 | 实践之Camera-Lidar标定》</a></p></blockquote><h2 id="前言"><strong>1. 前言</strong></h2><p>从理论上看，相机和激光之间外参数的标定原理非常简单，但在实际标定过程中，特别是一个初学者采集数据进行标定时，却发现标定结果非常不理想。如何采集有效的标定数据（何种运动轨迹，如何晃动标定板）对于激光相机标定而言非常重要。</p><p>读完本文，你会发现原来<strong>采集数据时标定板和传感器之间只做纯粹的平移运动是没有意义的</strong>。本文也对相机激光标定的一些基础知识和小细节进行讨论，主要贡献点有三：</p><ol type="1"><li>从理论开始对激光（单线、多线都适用）和相机外参数的标定进行简要推导（公式多但简单），然后给出一些可以提升标定精度的改进建议。</li><li>给出一个简单的开源代码对上述标定原理进行实践。</li><li>提供一个仿真程序，可以直观感受标定数据对系统可观性的影响。</li></ol><h2 id="理论">2.理论</h2><p>通常，标定激光和相机之间的外参数有两类方法：一类是利用 3D-3D 的约束，即利用激光测量的三维激光点 (3D) 和相机测量的标定板三维坐标 (3D) 两者来构建约束；另一类是利用 3D-2D 的约束，即利用激光测量的三维激光点 (3D) 和图像二维特征（2D、点特征、线段特征）来构建约束。</p><p>本文主要讲解利用 3D-3D 约束来进行外参数标定的方法，而 3D-2D 这一方法和 PnP 或 PnL 问题类似，这里不做展开。另外，标定过程的通常做法是先利用少量观测求解外参数的初始值，然后利用多帧数据的约束进行最小二乘优化对初始值进行 refine。接下来，将按照这个逻辑对标定算法进行讲解并推荐一些改进的算法。</p><h3 id="基于平面约束的相机激光标定算法"><strong>2.1 基于平面约束的相机激光标定算法</strong></h3><p>如下图所示，相机可以通过标定板平面的二维码或棋盘格来计算标定板平面在相机坐标系下的表示。同时，激光发出的光束落在标定板平面上（图中红点），利用激光点在激光坐标系下的坐标和平面方程在相机坐标系下的坐标，构建点在平面上的约束从而求解外参数。</p><p><img src="http://s1.nsloop.com:59080/images/2021/09/04/20210904170031.png"></p><p><strong>2.1.1 平面约束</strong></p><p>假设标定板平面在相机坐标系<span class="math inline">\(c\)</span>中的参数为<span class="math inline">\(\pi^{c}=\left[\mathrm{n}^{c}, d\right] \in \mathbb{R}^{4}\)</span>，其中<span class="math inline">\(\mathrm{n}^{c} \in \mathbb{R}^{3}\)</span>是平面法向量，<span class="math inline">\(d\)</span>是相机坐标系原点到平面的距离。</p><p>假设平面上的一个三维空间点在相机坐标系的坐标为<span class="math inline">\(\mathbf{P}^{c} \in \mathbb{R}^{3}\)</span>，那么该点满足如下约束方程：</p><p><span class="math display">\[\mathbf{n}^{c \top} \mathbf{P}^{c}+d=0\]</span></p><p>假设从激光雷达坐标系<span class="math inline">\(l\)</span>到相机坐标系<span class="math inline">\(c\)</span>的旋转和平移表示为：<span class="math inline">\(\mathbf{R}_{c l}, \mathbf{t}_{c l}\)</span>，一旦知道激光坐标系中的某个激光点<span class="math inline">\(\mathbf{P}^{l}\)</span>落在标定板上，则通过点在平面上的约束可以构建关于外参的方程（1）：</p><p><span class="math display">\[\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}^{l}+\mathbf{t}_{c l}\right)+d^{c}=0\]</span></p><p>上述方程能够提供一个约束，通过多个这样的约束就能求解外参数。求解时，一个直观的想法是利用 g2o 或者 ceres 等优化工具构建非线性最小二乘进行优化求解。但是对于非线性最小二乘问题，需要知道外参数的一个初始值，如果初始值不准确，则有可能会优化到局部最小值。因此，一个合理的求解流程应该是闭式解提供初始值，对该初始值利用多帧数据进行优化，得到更准确的标定结果。</p><p>虽然平面约束对于 2D 激光和 3D 激光而言是一样的，但 2D 激光和 3D 激光闭式求解外参数的方式稍有不同。因为 3D 激光的激光点更多，从而可以直接计算激光点云的法向量，利用这个法向量简化外参数计算流程，下文将详述。接下来，介绍 2D 激光和相机外参数的求解。</p><h3 id="d-激光和相机外参数初始值求解"><strong>2.1.2 2D 激光和相机外参数初始值求解</strong></h3><p>这里主要参考 2004 年 Zhou 等人的论文【1】，该论文是比较早期的工作，求解思路清晰。论文中估计的参数为从相机坐标系到激光坐标系的变换矩阵<span class="math inline">\(\mathbf{R}_{c l},\mathbf{t}_{c l}\)</span>，因此，激光点从激光雷达坐标系到相机坐标系的变换如下：</p><p><span class="math display">\[\mathbf{P}^{c}=\mathbf{R}_{l c}^{\top}\left(\mathbf{P}^{l}-\mathbf{t}_{l c}\right)\]</span></p><p>考虑到，激光为 2D 激光，激光束形成的平面不妨假设为 xy 平面，即<span class="math inline">\(z=0\)</span>，此时，激光点形如<span class="math inline">\(\mathbf{P}^{l}=[x, y, 0]^{\top}\)</span>，因此，上面的坐标变换可以写成更紧凑（矩阵、向量相乘）的形式：</p><p><span class="math display">\[\mathbf{P}^{c}=\mathbf{R}_{l c}^{\top}\left(\left[\begin{array}{l}x \\y \\0\end{array}\right]-\mathbf{t}_{l c}\right)=\underbrace{\mathbf{R}_{l c}^{\top}\left[\begin{array}{lll}1 &amp; 0 &amp; \\0 &amp; 1 &amp; -\mathbf{t}_{l c} \\0 &amp; 0 &amp;\end{array}\right]}_{\mathbf{H} }\left[\begin{array}{l}x \\y \\1\end{array}\right]=\mathbf{H} \overline{\mathbf{P} }^{l}\]</span></p><p>因此，将紧凑形式的坐标变换代入公式（1），得到：</p><p><span class="math display">\[\mathbf{n}^{c \top} \mathbf{H} \overline{\mathbf{P} }^{l}=-d^{c}\]</span></p><p>如果把 3 乘 3 的<span class="math inline">\(\mathbf{H}\)</span>矩阵当做新的未知量（ 9 个参数）进行估计，那上述约束就变成了一个<strong>线性最小二乘</strong>问题。</p><p>对于单线激光而言，一帧激光可以提供两个有效约束（直线上两个点在平面上即能确定直线在平面上），因此大于等于 5 帧激光（不同姿态）就能得到 10 个以上的约束，来直接求得 9 参数的<span class="math inline">\(\mathbf{H}\)</span>矩阵，然后还原出<span class="math inline">\(\mathbf{R}_{c l}, \mathbf{t}_{c l}\)</span>：</p><p><span class="math display">\[\begin{aligned}\mathbf{R}_{l c} &amp;=\left[\begin{array}{lll}\mathbf{h}_{1} &amp; \mathbf{h}_{2} &amp; \mathbf{h}_{1} \times \mathbf{h}_{2}\end{array}\right]^{\top} \\\mathbf{t}_{l c} &amp;=-\left[\begin{array}{lll}\mathbf{h}_{1} &amp; \mathbf{h}_{2} &amp; \mathbf{h}_{1} \times \mathbf{h}_{2}\end{array}\right]^{\top} \mathbf{h}_{3}\end{aligned}\]</span></p><p>简单推导：</p><p><img src="http://s1.nsloop.com:59080/images/2021/09/04/20210904180148.png"></p><p>但是，利用上述方式求得的旋转矩阵并不满足旋转矩阵的性质<span class="math inline">\(\mathbf{R}^{\top} \mathbf{R}=\mathbf{I}_{3 \times 3}\)</span>，假设期望的旋转矩阵为<span class="math inline">\(\hat{\mathbf{R} }_{l c}\)</span>，则可通过计算带约束的最小化F范数问题来估计出期望的旋转矩阵<span class="math inline">\(\hat{\mathbf{R} }_{l c}\)</span>：</p><p><span class="math display">\[\arg \min \left\|\hat{\mathbf{R} }_{l c}-\mathbf{R}_{l c}\right\|_{F}, \quad \text { subject to } \hat{\mathbf{R} }_{l c}^{\top} \hat{\mathbf{R} }_{l c}=\mathbf{I}\]</span></p><p>其意义为：找一个最接近<span class="math inline">\(\mathbf{R}_{c l}\)</span>又满足旋转矩阵质<span class="math inline">\(\mathbf{R}^{\top} \mathbf{R}=\mathbf{I}_{3 \times 3}\)</span>的矩阵<span class="math inline">\(\hat{\mathbf{R} }_{l c}\)</span>作为要求的旋转矩阵。此外，参考文献【2，3】给出了闭式解。</p><p>然而，文献【3】指出，上述方式求解的精度不高，实际应用过程并不推荐，正如多视角几何中估计本征矩阵<code>E</code>矩阵一样，也分为 DLT 算法（直接计算 8 个参数）和其他算法。</p><p>因此，在这里，优雅的方式应该是<strong>直接闭式求解 6 自由度的外参数</strong>，即旋转矩阵只用 3 个参数而不是上述方法中先估计 9 个参数。参考文献【4】给出了一种闭式求解 6 自由度外参数的方法，由于估计的参数为 6 ，因此需要的最少激光观测变成了 3 帧（每帧提供两个有效约束）。</p><h3 id="d-激光和相机外参数初始值求解-1"><strong>2.1.3 3D 激光和相机外参数初始值求解</strong></h3><p>跟 2D 激光的单线数据仅仅能提供一条线相比， 3D 激光的多线数据能提供点云面的信息。因此，同样是利用激光点在标定板平面上这个约束，3D 激光的约束可以比 2D 激光更多一个。</p><p>3D 的激光的点云平面和标定板平面重合，意味着单帧 3D激光提供的有效约束为 3 个（即点云平面上的3个点落在标定板平面上），从而可以用 3 个激光点来构建公式 (1) 的约束。这样两帧激光（6个约束）就能求解外参数了，求解方式可以利用前面 2D 激光所描述的方法（则同样存在 DLT 方法初始值不准的问题）。</p><p>这里给出了 3D 激光求解外参数的<strong>另一个思路</strong>，该方法中，求解的旋转矩阵能自然地满足旋转矩阵的性质：<span class="math inline">\(\mathbf{R}^{\top} \mathbf{R}=\mathrm{I}, \operatorname{det}(\mathrm{R})=1\)</span>。</p><p>将单帧激光的点云平面和标定板平面重合的约束进行简单置换，如下公式（2）：</p><p><span class="math display">\[\begin{aligned}\mathbf{R}_{c l} \mathbf{n}^{l} &amp;=\mathbf{n}^{c} \\\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}^{l}+\mathbf{t}_{c l}\right)+d^{c} &amp;=0\end{aligned}\]</span></p><p>公式 (2) 中的两个方程中，第一个方程能提供 2 个有效约束，第二个方程提供 1 个有效约束。虽然公式 (2) 和三个点落在平面上的物理意义一样，但是，公式 (2) 中<strong>第一个方程只和旋转矩阵有关</strong>，和平移无关。意味着可以先求解旋转矩阵，再线性求解平移向量，从而简化参数估计。</p><p>当激光帧数 N 大于等于 2 时，可以求解如下非线性最小二乘问题来计算旋转矩阵，如下公式（3）：</p><p><span class="math display">\[C=\sum_{i=1}^{N}\left\|\mathbf{n}_{i}^{c}-\mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right\|^{2}\]</span></p><p>这里基于参考文献【5】介绍上述问题的通用解法。将公式 (3) 进行展开有：</p><p><span class="math display">\[\begin{aligned}C &amp;=\sum_{i=1}^{N}\left(\mathbf{n}_{i}^{c}-\mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right)^{\top}\left(\mathbf{n}_{i}^{c}-\mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right) \\&amp;=\sum_{i=1}^{N}\left(\mathbf{n}_{i}^{c \top} \mathbf{n}_{i}^{c}+\mathbf{n}_{i}^{l \top} \mathbf{n}_{i}^{l}-2 \mathbf{n}_{i}^{c \top} \mathbf{R}_{c l} \mathbf{n}_{i}^{l}\right)\end{aligned}\]</span></p><p>由于两个坐标系下的平面法向量<span class="math inline">\(n\)</span>已知，因此，最小化损失函数 C 转化成最大化如下目标：</p><p><span class="math display">\[\begin{aligned}F &amp;=\sum_{i=1}^{N} \mathbf{n}_{i}^{c \top} \mathbf{R}_{c l} \mathbf{n}_{i}^{l} \\&amp;=\operatorname{Trace}\left(\sum_{i=1}^{N} \mathbf{R}_{c l} \mathbf{n}_{i}^{l} \mathbf{n}_{i}^{c \top}\right)=\operatorname{Trace}(\mathbf{R} \mathbf{H})\end{aligned}\]</span></p><blockquote><p>此处应用了迹的性质 （跟ICP的推导一样） - 常数等于常数的迹 - 迹内的元素顺序可交换</p></blockquote><p>其中，这里引入了一个中间矩阵<span class="math inline">\(\mathbf{H}\)</span></p><p><span class="math display">\[\mathbf{H}=\sum_{i=1}^{N} \mathbf{n}_{i}^{l} \mathbf{n}_{i}^{c \top}\]</span></p><p>下面还要用到一个引理：</p><p>对于任意的正定矩阵<span class="math inline">\(\mathrm{AA}^{\top}\)</span>以及任意正交矩阵B，有下面的不等式成立：</p><p><span class="math display">\[\operatorname{Trace}\left(\mathbf{A} \mathbf{A}^{\top}\right) \geq \operatorname{Trace}\left(\mathbf{B A A}^{\top}\right)\]</span></p><p>接下来，回到之前的推导，我们对中间矩阵<span class="math inline">\(\mathbf{H}\)</span>进行SVD分解，有：</p><p><span class="math display">\[\mathbf{H}=\mathbf{U} \mathbf{\Lambda} \mathbf{V}^{\top}\]</span></p><p>其中，<span class="math inline">\(\mathbf{U}, \mathbf{V}\)</span>是3x3矩阵，<span class="math inline">\(\mathbf{\Lambda}\)</span> 是3x3的对角阵，其元素非负。</p><p>下面做一个假设，令<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>，那么上面的<span class="math inline">\(\operatorname{Trace}(\mathbf{R} \mathbf{H})\)</span>可以重写为：</p><p><span class="math display">\[\begin{aligned}\mathbf{R}_{c l} \mathbf{H} &amp;=\mathbf{V} \mathbf{U}^{\top} \mathbf{U} \mathbf{\Lambda} \mathbf{V}^{\top} \\&amp;=\mathbf{V} \mathbf{\Lambda} \mathbf{V}^{\top}\end{aligned}\]</span></p><p>此时，<span class="math inline">\(\mathbf{R}_{c l} \mathbf{H}\)</span>是对称的正定矩阵，这时候就要使用前面埋下的引理，来证明<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>即为解。</p><p>反证：如果<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>不是解，那么它和正确解之前存在一个增量旋转矩阵<span class="math inline">\(\mathbf{R}_{\Delta}\)</span>，即<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{R}_{\Delta}\mathbf{V} \mathbf{U}^{\top}\)</span> ，此时根据上面的引理，可得，这个解不会使得损失函数F的值取最大，因为：</p><p><span class="math display">\[\operatorname{Trace}\left(\mathbf{R}_{c l} \mathbf{H}\right) \geq \operatorname{Trace}\left(\mathbf{R}_{\Delta} \mathbf{R}_{c l} \mathbf{H}\right)\]</span></p><p>最后，还需要做旋转矩阵性质的判断，如果<span class="math inline">\(\operatorname{det}\left(\mathbf{V} \mathbf{U}^{\top}\right)=1\)</span>，则说明所求得的正交矩阵<span class="math inline">\(\mathbf{R}_{c l}=\mathbf{V} \mathbf{U}^{\top}\)</span>是旋转矩阵。如果<span class="math inline">\(\operatorname{det}\left(\mathbf{V} \mathbf{U}^{\top}\right)=-1\)</span>，则说明这个正交矩阵是镜面反射矩阵，不是旋转矩阵。幸运的是，在实际应用中，采集的多帧不同姿态下的激光数据并不会出现镜面反射矩阵的情况。</p><p>在旋转矩阵已知的情况下，利用公式 (1) 就可以求解平移向量<span class="math inline">\(\mathbf{t}_{c l}\)</span>，这时候求解只涉及到平移，是个线性最小二乘问题<span class="math inline">\(\mathbf{A} \mathbf{t}_{c l}=\mathbf{b}\)</span>，可以使用闭式解求解。</p><p>最后，关于上面使用的引理<span class="math inline">\(\operatorname{Trace}\left(\mathbf{A} \mathbf{A}^{\top}\right) \geq \operatorname{Trace}\left(\mathbf{B A A}^{\top}\right)\)</span>，证明如下：</p><p>假设<span class="math inline">\(a_{i}\)</span>是矩阵<span class="math inline">\(\mathbf{A}\)</span>的第i列，则有：</p><p><span class="math display">\[\begin{aligned}\operatorname{Trace}\left(\mathbf{B A} \mathbf{A}^{\top}\right) &amp;=\operatorname{Trace}\left(\mathbf{A}^{\top} \mathbf{B} \mathbf{A}\right) \\&amp;=\sum_{i} \mathbf{a}_{i}^{\top}\left(\mathbf{B} \mathbf{a}_{i}\right)\end{aligned}\]</span></p><p>根据<code>Cauchy-Schwarz</code>不等式<span class="math inline">\(x y \leq \sqrt{x^{2} y^{2} }\)</span>，且矩阵B为正交矩阵，有：</p><p><span class="math display">\[\mathbf{a}_{i}^{\top}\left(\mathbf{B} \mathbf{a}_{i}\right) \leq \sqrt{\left(\mathbf{a}_{i}^{\top} \mathbf{a}_{i}\right)\left(\mathbf{a}_{i}^{\top} \mathbf{B}^{\top} \mathbf{B a}_{i}\right)}=\mathbf{a}_{i}^{\top} \mathbf{a}_{i}\]</span></p><p>因此，可证得：</p><p><span class="math display">\[\operatorname{Trace}\left(\mathbf{A} \mathbf{A}^{\top}\right)=\sum_{i} a_{i}^{\top} a_{i} \geq \operatorname{Trace}\left(\mathbf{B A} \mathbf{A}^{\top}\right)\]</span></p><h3 id="联合优化进行调优"><strong>2.1.4 联合优化进行调优</strong></h3><p>通过上述方式计算出外参数的初始值之后，再对采集的N组数据进行联合优化得到最优估计，假设第i帧激光有<span class="math inline">\(N_{i}\)</span>个激光点落在标定板上，同时第i帧激光时刻下对应的标定板平面方程在相机坐标系的表示为<span class="math inline">\(\left[\mathbf{n}_{i}^{c}, d_{i}^{c}\right]^{\top}\)</span>，则问题可以描述为：</p><p><span class="math display">\[\hat{\mathbf{R} }_{c l}, \hat{\mathbf{t} }_{c l}=\arg \min _{\mathbf{R}_{cl}, t_{cl} } \sum_{i=1}^{N} \frac{1}{N_{i} } \sum_{m=1}^{N_{i} }\left\|\mathbf{n}_{i}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}_{i m}^{l}+\mathbf{t}_{c l}\right)+d_{i}^{c}\right\|^{2}\]</span></p><p>优化过程中，对于旋转矩阵<span class="math inline">\(\mathbf{R}_{c l}\)</span>，可以使用 SO3 的参数化方式，也可以采用四元数的参数化方式。优化方法 (LM算法），雅克比的推导等知识点这里不再赘述，大家可以对照开源的代码自行推导验证雅克比。</p><h3 id="推论所有平行的平面提供的约束等价"><strong>2.2 推论：所有平行的平面提供的约束等价</strong></h3><p>前面求解过程中，是假设采集的数据足够有效，即采集了不同姿态下标定板和激光数据的数据。那么，如何摆放标定板来采集数据是有效的呢？这里将证明<strong>只平移标定板对标定没有意义</strong>，标定过程中只需要旋转标定板。推荐阅读参考文献【6】</p><p>平移标定板意味着不同时刻之间的标定板平面是平行的。假设有两个平行平面<span class="math inline">\(\pi_{1}, \pi_{2}\)</span>，它们在相机坐标系中的参数分别为<span class="math inline">\(\left[\mathbf{n}^{c}, d_{1}^{c}\right]^{\top}\)</span>和<span class="math inline">\(\left[\mathbf{n}^{c}, d_{2}^{c}\right]^{\top}\)</span>。另外，假设在激光坐标系下，激光测量了两个平面上任意的一个点<span class="math inline">\(\mathbf{P}_{1}^{l}, \mathbf{P}_{2}^{l}\)</span>，考虑点在平面上的约束有：</p><p><span class="math display">\[\begin{array}{l}\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}_{1}^{l}+\mathbf{t}_{c l}\right)+d_{1}^{c}=0 \\\mathbf{n}^{c \top}\left(\mathbf{R}_{c l} \mathbf{P}_{2}^{l}+\mathbf{t}_{c l}\right)+d_{2}^{c}=0\end{array}\]</span></p><p>通过简单的变换，可以发现上面两个等式能够相互转换，即表示平行的平面只能提供相同的约束信息。</p><p>变换如下：首先将<span class="math inline">\(\mathbf{n}^{c \top} \mathbf{t}_{c l}\)</span>这部分从两个等式中移除，然后有：</p><p><span class="math display">\[\begin{aligned}&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l} \mathbf{P}_{1}^{l}+d_{1}^{c} \\=&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l}\left(\mathbf{P}_{2}^{l}+\mathbf{P}_{1}^{l}-\mathbf{P}_{2}^{l}\right)+d_{2}^{c}+d_{1}^{c}-d_{2}^{c} \\=&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l} \mathbf{P}_{2}^{l}+d_{2}^{c}+\left(\mathbf{n}^{c \top} \mathbf{R}_{c l}\left(\mathbf{P}_{1}^{l}-\mathbf{P}_{2}^{l}\right)+d_{1}^{c}-d_{2}^{c}\right) \\=&amp; \mathbf{n}^{c \top} \mathbf{R}_{c l} \mathbf{P}_{2}^{l}+d_{2}^{c}\end{aligned}\]</span></p><p>其中，<span class="math inline">\(\mathbf{n}^{c \top} \mathbf{R}_{c l}\left(\mathbf{P}_{1}^{l}-\mathbf{P}_{2}^{l}\right)\)</span>和<span class="math inline">\(d_{1}^{c}-d_{2}^{c}\)</span>表示两个平面之间的距离，式中，它们两个方向符号相反可以抵消。</p><p>由此证明：所有平行的平面物体提供的约束是等价的。这意味着：采集数据用于标定时，如果只平移标定板来采集数据，那就做了很多无用功。比如不断平移标定板采集了 100 个时刻的数据，那这 100 次的数据仅相当于 1 次有效数据。所以，采集标定数据时，<strong>只要不断旋转标定板采集数据就足够了</strong>，而不是不断平移。</p><h3 id="拓展标定板的边界约束"><strong>2.3 拓展：标定板的边界约束</strong></h3><p>上述标定过程只利用了平面标定板的平面约束来进行标定，也清楚了这个约束对于单次测量而言，其提供的有效约束 (2个或者3个) 不足以完成单帧标定，而采集多帧数据又容易由于采集轨迹不充分，导致外参在某些维度标定不好。</p><p>因此，如果标定板一次就能够提供 6 个以上的约束，那意味着单帧数据就能完成标定，并且多约束的加入能够提升标定精度。这方面的工作有两类方式，一种是改变标定板的形状，比如两个垂直的标定板，或者三个垂直的标定板，V 形标定板等。</p><p>另一种是充分利用其他约束，比如激光点落在标定板边缘直线上（标定板边缘的直线方程以及哪个激光点落在上面是可以计算出来的）。这里不作详细的推导和解释，仅推荐两篇2018年的经典论文，见参考文献【6】和参考文献【7】。论文【6】是利用标定板的边缘直线约束来标定3D激光，论文【7】对2D激光的多种标定板的有效约束进行了充分讨论。</p><h2 id="实践"><strong>3. 实践</strong></h2><p>根据上述的理论推导，本文完成了一个简单的 2D 激光和相机之间外参数的标定代码：</p><p><a href="https://github.com/MegviiRobot/CamLaserCalibraTool" target="_blank" rel="noopener">https://github.com/MegviiRobot/CamLaserCalibraTool</a></p><h3 id="代码梳理和上手操作"><strong>3.1 代码梳理和上手操作</strong></h3><p>关于数据的采集，标定板的制作，标定的流程以及标定结果等上手操作细节在项目的 README.md 里已经进行了详细说明，这里对系统中的几个主要文件进行简单梳理，帮助大家更快熟悉代码。</p><p>大家关注的外参数的代码大多都在 src 文件夹里的 LaserCamCalCeres.cpp，其中：</p><ul><li>CamLaserCalClosedSolution() ：闭式求解外参数初始值。</li><li>CamLaserCalibration() ：采用非线性最小二乘对初始值进行优化。</li></ul><p>另外，比较重要的为 main 文件夹中的三个主程序：</p><ul><li>kalibratag_detector_node.cpp : 相机利用二维码或者棋盘格估计标定板平面和相机之间的姿态。</li><li>calibr_offline.cpp : 处理激光数据（获取在标定板上的激光点云），读取事先处理好的相机姿态，利用这些数据构建平面约束进行外参数求解。</li><li>calibr_simulation.cpp : 生成仿真数据，验证系统参数是否可观。后面小结讲着重说明。</li></ul><h3 id="仿真代码的特别说明"><strong>3.2 仿真代码的特别说明</strong></h3><p>仿真代码可以帮助大家理解采集数据的有效性对标定结果的影响，对理解系统辨识（系统参数是否可观）非常有意义，因此在这里进行特别说明。</p><p>代码中的 GenerateSimData() 函数主要用来生成仿真数据，原理为利用激光射线和标定板平面相交，从而得到激光点在标定板上的三维坐标，通过不断变换标定板的姿态，得到多组有效数据（激光点云+标定板在相机中的姿态）用来完成标定。</p><p>其中标定板和相机之间的姿态保存在变量<span class="math inline">\(\mathbf{R}_{c a}, \mathbf{t}_{c a}\)</span>，代码中采用利用随机数的方式来生成标定板姿态，并可以通过对标定板参数进行不同的设置来对系统的可观性进行验证。</p><h3 id="系统可观性的判断"><strong>3.2.1 系统可观性的判断</strong></h3><p>熟悉 VIO(visual inertial odometry) 系统也会熟知可观性问题。实际上，系统的可观性在线代控制理论中有专门论述，涉及到可观性矩阵等知识点，但是那套从线性系统出发的理论可能容易让大家迷惑。这里会从大家熟知的非线性优化求解的角度来简单描述可观性问题。</p><p>关于状态量参数是否可观的一个简单解释是：如果改变状态向量<span class="math inline">\(\mathbf{X}\)</span>的值，系统对应的观测函数<span class="math inline">\(\mathrm{f}(\mathrm{x})\)</span>不发生变化，即<span class="math inline">\(\mathbf{f}(\mathbf{x})=\mathbf{f}\left(\mathbf{x}^{\prime}\right)\)</span>，则说明系统在某些维度上不可观。直观的理解就是，系统有无数个解从而使得状态量无法辨识。在非线性最小二乘问题中，通过构建误差函数利用高斯牛顿算法进行优化求解时，通常需要求解如下 normal equation：</p><p><span class="math display">\[\mathbf{J}^{\top} \mathbf{J} \delta \mathbf{x}=-\mathbf{J}^{\top} \mathbf{r} \Rightarrow \mathbf{H} \delta \mathbf{x}=\mathbf{b}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{J}\)</span>是残差对状态量求导的雅克比矩阵</li><li><span class="math inline">\(\mathbf{r}\)</span>是利用约束构建的残差</li></ul><p>如果系统求解过程中<span class="math inline">\(\mathbf{H}\)</span>矩阵不满秩，假设其零空间为<span class="math inline">\(\mathbf{N}\)</span>，有<span class="math inline">\(\mathbf{H} \mathbf{N}=0\)</span>，意味着求解存在多个解：</p><p><span class="math display">\[\begin{array}{r}\mathbf{H} \delta \mathbf{x}=\mathbf{b} \\\mathbf{H} \delta \mathbf{x}+\mathbf{H N}=\mathbf{b}\end{array}\]</span></p><p>即系统有无穷多个解<span class="math inline">\(\delta \mathbf{x}+\lambda \mathbf{N}\)</span>使得残差最小，零空间<span class="math inline">\(\mathbf{N}\)</span>的基底对应不可观的方向。所以可以通过判断<span class="math inline">\(\mathbf{H}\)</span>矩阵的秩来判断系统的可观性，比如<span class="math inline">\(\mathbf{H}\)</span>矩阵为 6 维的方阵，而秩等于 4，则意味着零空间维度为 2 ，有两个不可观的方向，<strong>这个结论在后面将用来指导采集数据</strong>。</p><p>那么，如果你熟悉 VIO，自然要问既然线性系统中的可观性矩阵和优化方法中的 H 矩阵都能够判断系统可观性？这两者之间存在什么样的联系呢？这里不再展开推导，推荐阅读参考文献【8】，读完第二章你将豁然开朗。</p><h3 id="利用仿真代码验证平行平面提供的约束等价"><strong>3.2.2 利用仿真代码验证平行平面提供的约束等价</strong></h3><p>为了生成平行的标定板平面，只需要把代码中的<span class="math inline">\(\mathbf{R}_{c a}\)</span>设置成常数，如单位矩阵。这时，标定板只有平移，意味着生成的所有数据里标定板平行。编译并运行仿真程序后会有如下信息：</p><p><img src="http://s1.nsloop.com:59080/images/2021/09/04/20210904212443.png"></p><p>由于估计的外参数为 6 维，其中 H 矩阵的奇异值有 4 个接近 0，意味着只产生了两个维度的有效信息。这和之前的推论结论一致，即多帧数据中平行的标定板产生的约束等效于一帧，而单线激光落在平面上的有效约束为 2。</p><p>另外利用数值的方法计算了 H 矩阵的零空间基底，从图中可以看到最右边两列的两个基底，它们是对应平移 x,y 不可观，而左边两列对应的的两个基底为旋转矩阵角度的两个维度不可观。不可观基底对应的方向表示外参数对应的维度无法求出正确解。</p><h3 id="利用仿真代码指导采集数据如何充分旋转标定板"><strong>3.2.2 利用仿真代码指导采集数据：如何充分旋转标定板</strong></h3><p>既然采集数据时只平移标定板不行，那是否意味着简单旋转一下标定板就可以了呢？比如标定板只绕着 y 轴旋转。这里可通过设置不同的旋转矩阵去验证 H 矩阵是否有零空间。通过简单修改代码（注释或反注释设置旋转矩阵的那几行代码），运行后会发现：标定时需要充分旋转 x 和 y 两个轴，标定过程中标定板只旋转一个轴一样会存在零空间基底。</p><p>这意味着拿着标定板旋转时，需要充分旋转 roll 和 pitch。更直白一点，假设在长方形的标定板中心画了个十字线，那请绕着十字线的两个轴充分旋转，比如绕着竖轴旋转，然后还要绕着横轴旋转。</p><h2 id="结语"><strong>4. 结语</strong></h2><p>至此，相机和激光标定从理论到实践就基本完成了。本文抛砖引玉，介绍了比较基础的标定原理，开源了相应的代码（包括求解代码、仿真代码、debug 验证代码），大家可以进一步改进和拓展（支持边界约束、V 形标定板等）。</p><p>最后，这种标定相机和激光外参数的方法估计可以有效避开两个传感器之间的时间延时问题，因为两个传感器都是静止的，晃动标定板时每摆好一个 pose 稍微静止几十毫秒就能避免传感器延时的问题。</p><h2 id="参考文献"><strong>5. 参考文献</strong></h2><ol type="1"><li>Qilong Zhang, <a href="https://link.zhihu.com/?target=http%3A//citeseerx.ist.psu.edu/viewdoc/download%3Fdoi%3D10.1.1.80.7118%26rep%3Drep1%26type%3Dpdf">Extrinsic Calibration of a Camera and Laser Range Finder (improves camera calibration)</a></li><li><a href="https://link.zhihu.com/?target=http%3A//www.iri.upc.edu/files/scidoc/2288-On-Closed-Form-Formulas-for-the-3D-Nearest-Rotation-Matrix-Problem.pdf">On Closed-Form Formulas for the 3D Nearest Rotation Matrix Problem</a>,</li><li><a href="https://link.zhihu.com/?target=http%3A//people.csail.mit.edu/bkph/articles/Nearest_Orthonormal_Matrix.pdf">Finding the Nearest Orthonormal Matrix</a>,</li><li><a href="https://link.zhihu.com/?target=https%3A//home.deec.uc.pt/~jpbar/Publication_Source/pami2012.pdf">A Minimal Solution for the Extrinsic Calibration of a Camera and a Laser-Rangefinde</a>r</li><li>K.S. Arun, <a href="https://link.zhihu.com/?target=http%3A//post.queensu.ca/~sdb2/PAPERS/PAMI-3DLS-1987.pdf">Least Squares Fitting of Two 3-d Point Set</a>,</li><li><a href="https://link.zhihu.com/?target=https%3A//www.cs.cmu.edu/~kaess/pub/Zhou18iros.pdf">Automatic Extrinsic Calibration of a Camera and a 3D LiDAR using Line and Plane Correspondences</a></li><li>Wenbo Dong, <a href="https://link.zhihu.com/?target=https%3A//arxiv.org/pdf/1603.04132.pdf">A Novel Method for the Extrinsic Calibration of a 2D Laser Rangefinder and a Camera</a></li><li>B.T. Hinson,<a href="https://link.zhihu.com/?target=https%3A//digital.lib.washington.edu/researchworks/handle/1773/27387">Observability-based guidance and sensor placement</a>,</li></ol><h2 id="作者简介"><strong>作者简介</strong></h2><p>贺一家，中科院自动化所博士毕业，目前为旷视研究院 SLAM 组研究员，研究方向为基于多传感器融合的 SLAM，结构化特征 SLAM 等。乐于分享和开源，对机器人、AR 等领域有浓厚兴趣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;camera-单线激光标定&quot;&gt;Camera-单线激光标定&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文来源于 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/137501892&quot; target=&quot;_blank&quot; rel=&quot;noopen
      
    
    </summary>
    
    
      <category term="传感器标定" scheme="http://yoursite.com/categories/%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A0%87%E5%AE%9A/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>外参未知的立体相机|对极几何</title>
    <link href="http://yoursite.com/2021/08/08/First_Principles_of_CV/%E5%A4%96%E5%8F%82%E6%9C%AA%E7%9F%A5%E7%9A%84%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA_%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95.md/"/>
    <id>http://yoursite.com/2021/08/08/First_Principles_of_CV/%E5%A4%96%E5%8F%82%E6%9C%AA%E7%9F%A5%E7%9A%84%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA_%E5%AF%B9%E6%9E%81%E5%87%A0%E4%BD%95.md/</id>
    <published>2021-08-08T14:42:16.000Z</published>
    <updated>2021-08-08T15:04:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾">回顾</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808224355.png"></p><h1 id="问题描述">问题描述</h1><p>所谓的未标定立体相机问题，就是不知道相机外参而进行3D空间点恢复，其中包含以下几个议题：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808224743.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808225626.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808225922.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808225941.png"></p><p>总结步骤如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808230202.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回顾&quot;&gt;回顾&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com:59080/images/2021/08/08/20210808224355.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;问题描述&lt;/h1&gt;
&lt;p&gt;所谓的未标定立体相机
      
    
    </summary>
    
    
      <category term="First_Principles_of_CV" scheme="http://yoursite.com/categories/First-Principles-of-CV/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>外参未知的立体相机|概述</title>
    <link href="http://yoursite.com/2021/08/08/First_Principles_of_CV/%E5%A4%96%E5%8F%82%E6%9C%AA%E7%9F%A5%E7%9A%84%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA_%E6%A6%82%E8%BF%B0.md/"/>
    <id>http://yoursite.com/2021/08/08/First_Principles_of_CV/%E5%A4%96%E5%8F%82%E6%9C%AA%E7%9F%A5%E7%9A%84%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA_%E6%A6%82%E8%BF%B0.md/</id>
    <published>2021-08-08T14:42:16.000Z</published>
    <updated>2021-08-08T15:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾">回顾</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808224355.png"></p><h1 id="问题描述">问题描述</h1><p>所谓的未标定立体相机问题，就是不知道相机外参而进行3D空间点恢复，其中包含以下几个议题：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808224743.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808225626.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808225922.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808225941.png"></p><p>总结步骤如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808230202.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;回顾&quot;&gt;回顾&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com:59080/images/2021/08/08/20210808224355.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;问题描述&quot;&gt;问题描述&lt;/h1&gt;
&lt;p&gt;所谓的未标定立体相机
      
    
    </summary>
    
    
      <category term="First_Principles_of_CV" scheme="http://yoursite.com/categories/First-Principles-of-CV/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>相机标定|内参和外参矩阵提取</title>
    <link href="http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E6%8F%90%E5%8F%96%E5%86%85%E5%A4%96%E5%8F%82%E7%9F%A9%E9%98%B5.md/"/>
    <id>http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E6%8F%90%E5%8F%96%E5%86%85%E5%A4%96%E5%8F%82%E7%9F%A9%E9%98%B5.md/</id>
    <published>2021-08-08T07:52:26.000Z</published>
    <updated>2021-08-08T08:42:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从投影矩阵提取内外参矩阵">从投影矩阵提取内/外参矩阵</h1><p>首先忽略齐次形式，重写成内参矩阵*旋转矩阵，</p><p>又因为：</p><ul><li>内参矩阵是上三角矩阵</li><li>旋转矩阵是正交矩阵</li><li>qr分解可以将矩阵分解为 [上三角矩阵]和[正交矩阵]</li></ul><p>所以，对投影矩阵的前3x3个元素构成的子矩阵进行qr分解，就可以得到内参矩阵</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808163804.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808164054.png"></p><h1 id="畸变的讨论比较简略">畸变的讨论（比较简略）</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808164214.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从投影矩阵提取内外参矩阵&quot;&gt;从投影矩阵提取内/外参矩阵&lt;/h1&gt;
&lt;p&gt;首先忽略齐次形式，重写成内参矩阵*旋转矩阵，&lt;/p&gt;
&lt;p&gt;又因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内参矩阵是上三角矩阵&lt;/li&gt;
&lt;li&gt;旋转矩阵是正交矩阵&lt;/li&gt;
&lt;li&gt;qr分解可以将矩阵
      
    
    </summary>
    
    
      <category term="First_Principles_of_CV" scheme="http://yoursite.com/categories/First-Principles-of-CV/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>相机标定|相机标定过程</title>
    <link href="http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E8%BF%87%E7%A8%8B.md/"/>
    <id>http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A%E8%BF%87%E7%A8%8B.md/</id>
    <published>2021-08-08T07:52:26.000Z</published>
    <updated>2021-08-08T08:35:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相机标定过程">相机标定过程</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808162337.png"></p><p>以立方体的一个角作为世界坐标系原点，相机拍摄图片，就可以得到一系列3D-2D关联。</p><p>对投影模型展开，得到线性等式如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808162459.png"></p><p>将矩阵中的12个参数作为向量，可以重写方程如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808162605.png"></p><p>由于尺度不确定，所以通常有如下解决方法：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808162942.png"></p><p>对上面的Loss func求导，可以得到一个关于特征值的问题，所以问题转化为求解矩阵<span class="math inline">\(A^TA\)</span>最小特征值对应的特征向量，即</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808163105.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;相机标定过程&quot;&gt;相机标定过程&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com:59080/images/2021/08/08/20210808162337.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;以立方体的一个角作为世界坐标系原点，相机拍摄图片，就
      
    
    </summary>
    
    
      <category term="First_Principles_of_CV" scheme="http://yoursite.com/categories/First-Principles-of-CV/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>相机标定|简单立体相机</title>
    <link href="http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%AE%80%E5%8D%95%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA.md/"/>
    <id>http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%AE%80%E5%8D%95%E7%AB%8B%E4%BD%93%E7%9B%B8%E6%9C%BA.md/</id>
    <published>2021-08-08T07:52:26.000Z</published>
    <updated>2021-08-08T09:11:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="backward-projection-2d-to-3d">Backward Projection: 2D to 3D</h1><p>假设给定一个标定好的相机，如何从2D图像恢复3D点？</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808164803.png"> <img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808164831.png"></p><h1 id="双目">双目</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808170138.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808170213.png"></p><ul><li>深度与视差成反比</li><li>深度与基线成正比</li><li>基线越大，精度越高</li></ul><h1 id="立体匹配寻找视差">立体匹配（寻找视差）</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808170418.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808170530.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808170615.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808170852.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808171023.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808171102.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;backward-projection-2d-to-3d&quot;&gt;Backward Projection: 2D to 3D&lt;/h1&gt;
&lt;p&gt;假设给定一个标定好的相机，如何从2D图像恢复3D点？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com
      
    
    </summary>
    
    
      <category term="First_Principles_of_CV" scheme="http://yoursite.com/categories/First-Principles-of-CV/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>相机标定|线性相机模型</title>
    <link href="http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%BA%BF%E6%80%A7%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B.md/"/>
    <id>http://yoursite.com/2021/08/08/First_Principles_of_CV/%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A_%E7%BA%BF%E6%80%A7%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9E%8B.md/</id>
    <published>2021-08-08T07:52:26.000Z</published>
    <updated>2021-08-08T08:21:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="forward-imaging-model-3d-to-2d">Forward Imaging Model： 3D to 2D</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808155436.png"></p><h1 id="perspective-projection">Perspective Projection</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808160713.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808155532.png"></p><h2 id="相机成像平面与图像的映射">相机成像平面与图像的映射</h2><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808155657.png"> <img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808155756.png"> <img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808155950.png"></p><h2 id="点的齐次坐标表示">点的齐次坐标表示</h2><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808160053.png"></p><h2 id="矩阵表示透视投影模型">矩阵表示透视投影模型</h2><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808160423.png"> <img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808160625.png"></p><h1 id="坐标变换外参">坐标变换（外参）</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808160845.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808161007.png"></p><p>从世界坐标系到相机坐标系的旋转矩阵<span class="math inline">\(R\)</span>的特性：</p><ul><li>第一行： <span class="math inline">\(\hat{x}_c\)</span>在世界坐标系的方向</li><li>第二行： <span class="math inline">\(\hat{y}_c\)</span>的方向</li><li>第三行： <span class="math inline">\(\hat{z}_c\)</span>的方向</li></ul><p>旋转矩阵是正交的，也就是说：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808161243.png"></p><p>因此，当已知：</p><ul><li>从世界坐标系到相机坐标系的旋转矩阵<span class="math inline">\(R\)</span></li><li>相机坐标系在世界坐标系的位移<span class="math inline">\(c_w\)</span></li></ul><p>就可以将一个点从世界坐标系变换到相机坐标系如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808161723.png"></p><p>使用齐次表达如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808161842.png"></p><h1 id="两个过程合起来的表示">两个过程合起来的表示</h1><p><img src="http://s1.nsloop.com:59080/images/2021/08/08/20210808162049.png"></p><blockquote><p>标定相机，就是求解矩阵的12个元素</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;forward-imaging-model-3d-to-2d&quot;&gt;Forward Imaging Model： 3D to 2D&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://s1.nsloop.com:59080/images/2021/08/08/20210
      
    
    </summary>
    
    
      <category term="First_Principles_of_CV" scheme="http://yoursite.com/categories/First-Principles-of-CV/"/>
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>Localization_for_Ground_Robots论文阅读</title>
    <link href="http://yoursite.com/2021/07/25/Localization_for_Ground_Robots%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/07/25/Localization_for_Ground_Robots%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-07-25T11:03:53.000Z</published>
    <updated>2021-08-06T02:00:42.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="localization-for-ground-robots-on-manifold-representation-integration-re-parameterization-and-optimization">Localization for Ground Robots: On Manifold Representation, Integration, Re-Parameterization, and Optimization</h1><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725191637.png"></p><h1 id="摘要">摘要</h1><p>本文专注于通过概率融合里程计和单目相机进行地面机器人定位的任务。具体而言，(1) 提出了一种新的方法，通过参数重表示的方法形成<code>motion manifold</code> (2) 使用轮式里程计进行6D的整合 (3) 重新参数化流形等式，减少误差。最后，提出一种基于流形辅助的滑动窗口估计器的完整定位算法，其中使用轮式里程计、单目相机以及可选的IMU。</p><h1 id="符号标记和传感器模型">符号标记和传感器模型</h1><h2 id="符号">符号</h2><p>在这项工作中，我们假设关于全局参考框架{G}的地面机器人，其车轮始终与路面接触。我们使用{C}和{O}来表示相机和里程计的坐标系。</p><p>里程计坐标系{O}的中心位于机器人的轮子中间，其中x轴向前，z轴向上，如图2所示。</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725192754.png"></p><p>另外，我们使用<span class="math inline">\({ }^{\mathbf{A}} \mathbf{p _ { B }}\)</span>和<span class="math inline">\({ }^{\mathbf{A}}_{\mathbf{B}}\bar {\mathbf{q}}\)</span>来表示B系相对于A系的位置和旋转。<span class="math inline">\({ }^{A}_{B} \mathbf{R}\)</span>表示与<span class="math inline">\({ }^{\mathbf{A}}_{\mathbf{B}}\bar {\mathbf{q}}\)</span>对应的旋转矩阵。</p><p>另外，</p><ul><li><span class="math inline">\(\hat{a}\)</span>表示估计值</li><li><span class="math inline">\(\tilde{a}\)</span>表示误差</li><li><span class="math inline">\(a^{T}\)</span>表示转置</li><li><span class="math inline">\(\dot{a}\)</span>表示微分</li><li><span class="math inline">\(\|a\|\)</span>表示二范数</li><li><span class="math inline">\(e_i\)</span>是 3x1的向量，其中第i个元素为1，其他为0</li><li><span class="math inline">\(e_{ij}=[e_i,e_j]\)</span></li></ul><h2 id="轮式里程计观测模型">轮式里程计观测模型</h2><p>与[1,6,21]相似，在时间t，经过标定后的轮式里程计测量值如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725193727.png"></p><p>其中，</p><ul><li><span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{v}}\)</span>表示车轮坐标系{0}的线速度在车轮坐标系{0}的表示</li><li><span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{\omega}}\)</span>表示车轮坐标系{0}的角速度在车轮坐标系{0}的表示</li><li><span class="math inline">\(n_{v o}\)</span> and <span class="math inline">\(n_{\omega o}\)</span>是测量噪声</li><li><span class="math inline">\(\mathbf{n}_{v}=\left[\begin{array}{lll}n_{v o} &amp; 0 &amp; 0\end{array}\right]^{\top}\)</span></li><li><span class="math inline">\(\mathbf{n}_{\omega}=\left[\begin{array}{lll}0 &amp; 0 &amp; n_{\omega o}\end{array}\right]^{\top}\)</span></li></ul><p>等式(1)清晰的展示了轮式里程计测量仅提供2D的运动信息，即向前的线速度和关于yaw角的旋转速度。因此，通过使用等式1提供的测量值，理论上可以进行基于平面表面的位姿整合，而执行6D姿态集成。</p><h1 id="基于流形的6d位姿整合">基于流形的6D位姿整合</h1><h2 id="流形表示">流形表示</h2><p>为了允许使用车轮测量测量的6D姿态集成，我们首先通过参数方程式进行运动建模。特别的，我们选用了通过二次多项式来对3D位置p的运动流形进行近似：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725194550.png"></p><p>其中，</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725194602.png"></p><p>流形的参数如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725194634.png"></p><p>我们注意到，传统方法[1,6,21]假设平面环境，等同于流形参数为<span class="math inline">\(\mathbf{m}=[c, 0,0,0,0,0]^{T}\)</span>。他们的设计选择不能代表室外路面的一般情况，因此不适合高精度估计</p><p>现有的工作如[6,21]展示了使用里程计观测对6D定位的困难，这主要是轮速计仅提供2D的测量，仅使用这些测量值，在6D空间进行姿态估计是不可行的。</p><p>然而，使用如式(4)的流形参数定义，6D的位姿估计变得可行，为了进一步描述，我们记姿态微分方程：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725195200.png"></p><p>其中，</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725195226.png"> 为了进行旋转积分，由轮速计提供的角速度<span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{\omega}}\)</span>需要知道。然而，显然式(1)中的轮速计只能提供向量<span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{\omega}}\)</span>的第三个元素。</p><p>为了获取另外两个元素，需要使用流形的参数表达，首先：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725195457.png"></p><blockquote><p>这个式子的物理意义是，机器人的旋转矢量与机器人所处位置的流形的法向量是垂直的。</p></blockquote><p>这个式子表达的是，运动流形<span class="math inline">\(\mathcal{M}\)</span>已经显式定义了地面机器人的roll和pitch，其应该与<span class="math inline">\({}_{\mathbf{O}(t)}^{G} {\mathbf{R}}\)</span>具有一致性。换句话说，流形的梯度向量应该与机器人z轴方向平行。</p><p>因此，对式(7)进行微分，得到：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725200153.png"></p><p>通过使用<span class="math inline">\(\mathcal{M}(t)=\mathcal{M}\left({ }^{\mathrm{G}} \mathbf{p}_{\mathbf{O}(t)}\right)\)</span>作为缩写，然后将式（5）和（7）代入式（8），得到：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725201713.png"></p><p>根据上述等式，<span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{\omega}}\)</span>的前两个元素可以被计算，而第3个元素不能被识别，因为<span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{\omega}}\)</span>被<span class="math inline">\([e_3]_{\times}\)</span>左乘，其中：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725202130.png"></p><p>另一方面，<span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{\omega}}\)</span>被<span class="math inline">\([e_3]_{\times}\)</span>的第三个元素起始可以直接从轮速计中读取。这些观测结果验证了我们将轮速计观测和流形表示进行结合的动机，依赖于他们的互补特性，以实现6D的位姿估计。</p><p>为了从式（11）寻找<span class="math inline">\({}^{\mathbf{O}(t)} {\mathbf{\omega}}\)</span>的前两个元素，为了实现这个目的，基于式（7）可以写出如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725202446.png"></p><blockquote><p>这是基于两个向量平行得到的，不信的话等式两边同时叉乘一个<span class="math inline">\(({}_{\mathbf{O}(t)}^{G} {\mathbf{R}} e_3)\)</span></p></blockquote><p>结果，等式（11）变成：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725203623.png"></p><p>其中，还用到了如下性质：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725204222.png"></p><p>且有：<span class="math inline">\({}^{\mathbf{O}^{(t)}} \boldsymbol{\omega}_{12}=\mathbf{e}_{12}^{T} {}^{\mathbf{O}^{(t)}} \boldsymbol{\omega}\)</span></p><p>通过考虑里程计的测量，我们有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725204351.png"></p><p>通过整合式（18），就可以计算3D的旋转估计了。一旦旋转被计算，就可以进一步通过积分计算位置：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725204442.png"></p><p>我们同样注意到我们的流形表示，如式（2），其隐式定义了运动模型的积分位置必须满足<span class="math inline">\(\mathcal{M}\left({ }^{\mathbf{G}} \mathbf{p}_{\mathbf{O}(t)}\right)=0\)</span>。</p><p>实际上，等式（19）确实满足这个流形约束，为了展示，我们记：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/25/20210725204846.png"></p><blockquote><p>应用到了链式求导，矩阵求导法则，以及等式（13）</p></blockquote><p>其中，在等式（21）中<span class="math inline">\({}_{\mathbf{G}}^{\mathbf{O}(t)} \mathbf{R}^{T} \mathbf{e}_{3}\)</span>与<span class="math inline">\(\nabla \mathcal{M}\left({ }^{\mathbf{G}} \mathbf{p}_{\mathbf{O}(t)}\right)\)</span>成比例，（根据等式13的结果）。</p><p>可以发现，等式（19）中<span class="math inline">\({ }^{\mathrm{G}} \mathbf{v}_{\mathbf{O}(t)}\)</span>的表达明确的满足等式（21）中的manifold约束（天向速度为0呗）。</p><p>随着等式（18）和（19），我们可以进行在流形上的基于里程计的6D位姿整合。整个过程不需要IMU的使用，为了直观地解释这个过程，我们注意到，执行6D姿态估计需要使用传感器测量值或者运动约束来解析6个自由度。在我们的系统中，两个自由度来自轮式里程计测量，两个自由度来自车辆约束（非完整性约束），最后两个自由度由流形等式决定（如等式（18）），并且直觉的解释与数学推导相符。</p><blockquote><p>非完整性约束：来源于等式（19），这个约束表明局部线速度只有在x轴有非零值。 然而当底盘是麦克纳姆轮时，机器人不受该约束，并且必须重新设计方程。然而，这类型的底盘不常用于商业户外机器人或车辆。</p></blockquote><h2 id="状态和误差状态预测">状态和误差状态预测</h2><p>本节，将描述使用提出的流形表示来进行状态和误差状态的传播。由于积分过程需要姿态(位置和方向向量)和流形方程的显式表示，我们定义状态向量如下</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726094454.png"></p><p>状态向量微分方程如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726094542.png"></p><p>其中，</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726094603.png"></p><p>我们指出，流形参数的运动动力学将在后面的小节中详细描述，在式（25）这里先忽略。</p><p>进一步的，有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726094747.png"></p><p>其中，</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726094813.png"></p><p>式（27）到（29）可以基于轮式里程计进行数值积分（如龙格库塔）。</p><p>为了描述误差状态的传播细节，我们首先对式（18）进行一阶泰勒展开，得到：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726095241.png"></p><p>其中，</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726095305.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726095335.png"></p><blockquote><p>这是角速度对状态和噪声求导</p></blockquote><hr><p>本文定义的误差角<span class="math inline">\(\delta \theta\)</span>是local的[48]，因此，有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726095523.png"></p><blockquote><p>这个推导可以参见深蓝多传感器融合ppt</p></blockquote><p>进一步的，参考附录，我们可以写出等式（35），关于误差角的微分方程：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726095838.png"></p><blockquote><p>附录A：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726095918.png"></p></blockquote><p>因为<span class="math inline">\(\delta \theta\)</span>是误差状态<span class="math inline">\(\tilde{x}\)</span>的一部分，式（35)的前两项可以结合，因此得到：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726100122.png"></p><p>关于位置项，基于等式（19），可以直接得到如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726100809.png"></p><p>对于流形参数，我们有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726100831.png"></p><p>结合等式（35）（38）（39），误差状态的微分方程已经推导完成，我们可以进行6D的误差状态集成，把所有的等式放到向量中，我们可以得到误差状态模型：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726100939.png"></p><p>其中，</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726100956.png"></p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726101008.png"></p><p>需要注意的是：</p><ul><li><span class="math inline">\((\cdot)_{[:, i]}\)</span>表示矩阵的第i列</li></ul><p>我们注意到，<span class="math inline">\(\mathbf{F}_{c}\)</span>和<span class="math inline">\(\mathbf{G}_{c}\)</span>是连续时间下的误差状态转移矩阵和噪声雅可比矩阵，为了实现离散时间的概率估计器，则需要离散时间下的误差状态转移矩阵<span class="math inline">\(\boldsymbol{\Phi}(t, \tau)\)</span>，这可以通过积分得到：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/26/20210726101304.png"></p><p>数值积分的具体实现和剩下的步骤是离散时间局部化估计的标准步骤，可以参考[12,48]</p><h2 id="流形重新参数化">流形重新参数化</h2><p>等式（2）定义了全局参考坐标系的运动流形，其数值上是正确的，并且能够很容易地给出一个随机估计量。然而，这种表示方式使得流形参数m的传播过程极具挑战性。具体地说，很难描述流形的运动动力学，它随时间而变化。文献[24]简单使用<span class="math inline">\(\dot{\mathbf{m}}=\mathbf{n}_{\omega m}\)</span>，其中<span class="math inline">\(\mathbf{n}_{\omega m}\)</span>是零均值高斯噪声向量。然而，这个方法受限于大规模应用。为了说明细节，让我们以下面的方程为例：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/27/20210727094742.png"></p><p>等式绘制如图3所示。</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/27/20210727094813.png"></p><p>实际上，等式（44）可以考虑为一个二维的流形，如果一个二次二维流形可以用如下方程表示：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/27/20210727094923.png"></p><p>等式（44）实际上是一个分段二次二维流形，其分段形式的参数是：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/27/20210727095419.png"></p><p>可以清晰的看见，当<span class="math inline">\(x=1000\)</span>时，会有明显的jump，在所估计的流形参数，由于我们选择了二次表示来模拟一个非二次方程。</p><p>如果我们能用无穷多个多项式来近似流形，这个问题就不会产生了，然而，这在计算上是不可行的。因此，流形参数的正常传播过程(见Eq. 25)无法捕捉这种类型的变化。</p><p>虽然流形表示在此条件下仍然可行，但通过去除和重新初始化流形参数，这肯定不是高精度姿态估计的首选。为此，我们建议将Eq. 45修改为：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/27/20210727095810.png"></p><p>其中，<span class="math inline">\(x_{o}\)</span>是固定的常值参数，可以通过当前<span class="math inline">\(x\)</span>的估计来得到。如果当<span class="math inline">\(x=1000\)</span>，我们得到一个估计的<span class="math inline">\(x_{o}=999.9\)</span>，来代替等式（46）所展示的jump，即我们的流形参数为：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/27/20210727100145.png"></p><p>通过使用参数<span class="math inline">\(x_{o}\)</span>，流形参数的jump大幅减小。这使得流形的传播等式（状态、误差状态估计）变得可行。</p><p>通过用上面的例子说明我们的动机和高级概念，我们介绍了我们的正式数学-局部流形表示和重新参数化的数学方程。通过假设前一个重新参数化步骤是在时间t k时执行的，下一个步骤是在t k+1时触发的，我们有：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/28/20210728095058.png"></p><p>其中，等式（49）：</p><ul><li><span class="math inline">\(\mathbf{R}_{o}\)</span>和<span class="math inline">\(\mathbf{x}_{o}\)</span>是m(tk)的固定重参数化参数</li><li><span class="math inline">\(\mathbf{R}_{1}\)</span>和<span class="math inline">\(\mathbf{x}_{1}\)</span>是m(tk+1)的固定重参数化参数</li><li><span class="math inline">\(\gamma, \Xi,\boldsymbol{\Psi}\)</span>都是关于<span class="math inline">\(\delta \mathbf{R}\)</span>和<span class="math inline">\(\delta \mathbf{x}\)</span>的函数</li></ul><p>为了选择重新参数化参数，类似于等式（48），我们为<span class="math inline">\(\mathbf{x}_{o}\)</span>的选择<span class="math inline">\({ }^{\mathbf{G}} \mathbf{p}_{\mathbf{O}\left(t_{k}\right)}\)</span>的第一次估计和为<span class="math inline">\(\mathbf{x}_{1}\)</span>选择<span class="math inline">\({ }^{\mathbf{G}} \mathbf{p}_{\mathbf{O}\left(t_{k+1}\right)}\)</span>的第一次估计</p><p>等式（49）的详细推导和 <span class="math inline">\(\mathbf{R}_{o}，\mathbf{R}_{1}\)</span>的选择参见附录C。</p><p>因此，通过式（49），对于状态估计及其相应的不确定性，我们能够在任何时间t周围重新参数化流形表示。我们注意到，这类似于用逆深度参数化重新参数化SLAM特征[15][35]。重要的是要指出，在我们的重新参数化过程中，<span class="math inline">\(\mathbf{R}_{o}，\mathbf{x}_{o}, \mathbf{R}_{1} ，\mathbf{x}_{1}\)</span>被用作固定的常量向量和矩阵，而不是随机变量。这样就不需要计算它们对应的雅可比矩阵，这也是SLAM特征重参数化中广泛使用的技巧[35]，[15]。</p><p><strong>需要指出的是，我们的数值微分和重表示都是基于参数<span class="math inline">\(m\)</span>的，如（Sec. IV-A - IV-B and Appendix B），并且这个参数<span class="math inline">\(m\)</span>还未被任何重新参数化的步骤之前。</strong></p><p>一旦引入重参数化，在<span class="math inline">\(t_{k+1}\)</span>时刻存储在状态向量中的流形变为<span class="math inline">\(m(t_{k+1})\)</span>，而在状态积分中使用的相应流形参数仍为<span class="math inline">\(m\)</span>，这是由于全局流形表示保持不变的事实，<span class="math inline">\(\mathbf{m}\)</span>和<span class="math inline">\(\mathbf{m}(t_{k+1})\)</span>的关系如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/29/20210729094813.png"></p><p>因此，在状态预测和雅可比计算过程中，我们可以简单应用<span class="math inline">\(\mathbf{m}=\left(\prod_{i=0}^{k} \mathbf{\Lambda}\left(t_{i}\right)\right)^{-1} \mathbf{m}\left(t_{k}\right)\)</span>，这允许明确考虑<span class="math inline">\(\mathbf{m}(t_{k+1})\)</span>的不确定性，而不产生额外的计算成本和复杂的软件设计</p><p>通过定义流形的重新参数化过程，我们重新讨论了运动流形的运动动力学特征问题。由于地面机器人所在的表面上导航的流形实际会随着时间的推移而变化，为了保证准确性，必须明确地建模这一事实，具体地说，我们建议在重新参数化过程中考虑这一点：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/29/20210729095318.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathcal{N}\left(0, \sigma_{i, w m}^{2}\right)\)</span>表示零均值且方差为<span class="math inline">\(\sigma_{i, w m}^{2}\)</span>的高斯分布。</li><li>特别的，标准差<span class="math inline">\(\sigma_{i, w m}\)</span>可以定义如下：</li></ul><p><img src="http://s1.nsloop.com:59080/images/2021/07/29/20210729095444.png"></p><p>其中，<span class="math inline">\(\alpha_{i,p},\alpha_{i,q}\)</span>是控制参数。需要指出的是，在我们提出的公式中，流形不确定性(如<span class="math inline">\(\sigma_{i, w m}\)</span>)是空间位移的函数(见Eq. 54)。<strong>这与VIO文献[12]、[30]中的标准噪声传播方程不同，在这些方程中，噪声的特征是时间函数</strong>。因为运动流形是一个空间概念而不是时间概念，所以我们的设计选择更适合我们的定位问题。</p><h1 id="定位算法">定位算法</h1><p>为了实现地面机器人的高精度定位，在本节中，我们提出了一种详细的定位算法，用于融合来自单目摄像机、车轮里程表和可选IMU的测量数据。具体地说，我们提出了一种基于滑动窗口迭代优化的算法来最小化来自传感器测量和流形约束的代价函数。在接下来的内容中，我们首先描述我们提出的不使用IMU的方法，与IMU相关的额外操作将在第二节中讨论。</p><h2 id="数据插值">数据插值</h2><p>在本文中，我们假设车轮里程表和摄像机传感器在硬件上完全同步，摄像机与机器人刚性连接。在介绍概率传感器融合的细节之前，我们首先注意到我们的系统中需要数据插值，这是由于提出的系统中的一些操作需要执行基于里程计的位姿积分（两帧图像之间）。然而，由于多传感器系统的特性，我们可能无法在捕获图像的同时精确地获取里程计信息。为此，我们建议通过插值图像时间戳前后的最近测量值来计算额外的虚拟车轮里程表测量值。由于车轮里程表测量的频率相对较高(例如，在我们的例子中是100Hz)，而且在人造环境中的地面机器人通常处于平滑运动状态，因此我们选择应用线性插值。</p><h2 id="图像处理">图像处理</h2><p>一旦接收到新图像，我们继续执行位姿积分，通过车轮里程表测量和流形表示计算相应的预测位姿，一旦通过姿态预测检测到足够的平移或旋转位移(例如，在我们的测试中，20厘米和3度)，新图像将被处理，否则它将被丢弃。</p><p>对于特征处理，提取FAST特征[49]，计算FREAK[50]描述符，这是由于它们在低成本处理器上的效率，然后是特征匹配和RANSAC几何验证步骤</p><h2 id="状态向量与迭代优化">状态向量与迭代优化</h2><p>为了说明定位算法，首先介绍状态向量，在时间<span class="math inline">\(t_k\)</span>，状态向量为：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/04/20210804123652.png"></p><blockquote><p>为了更简单的表示，我们在本节的介绍中忽略了传感器的外部参数。然而，在我们的一些实际实验中，当离线传感器外部标定精度不高时，这些参数被明确地建模在我们的公式中，并用于优化。</p></blockquote><p>其中，<span class="math inline">\(x\)</span>在等式（22）中定义，<span class="math inline">\(\mathrm{O}_{k}\)</span>式在k时刻下滑动窗口中的位姿：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/06/20210806094717.png"></p><p>当在<span class="math inline">\(t_{k+1}\)</span>记录到新的图像，将会执行pose积分来计算<span class="math inline">\(\mathbf{X} \mathbf{O}_{k+1}\)</span>，随后，我们使用如下cost func来调整我们的状态：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/06/20210806095019.png"></p><p>其中，</p><ul><li><span class="math inline">\(\boldsymbol{\eta}_{k}\)</span>和<span class="math inline">\(\boldsymbol{\Sigma}_{k}\)</span>分别是在之前的时间步中估计的先验信息向量和矩阵。</li><li><span class="math inline">\(\|\mathbf{a}\|_{\Sigma}\)</span>由<span class="math inline">\(\mathbf{a}^{T} \mathbf{\Sigma} \mathbf{a}\)</span>计算得到</li><li><span class="math inline">\(\mathbf{f}_{k+1}\)</span>是被包含到优化过程中的视觉landmarks的集合</li><li><span class="math inline">\(\mathbf{S}_{i, j}\)</span>表示关键帧和观测到的特征的匹配对集合</li><li><span class="math inline">\(\gamma_{i, j}\)</span>是计算的视觉重投影残差向量</li><li><span class="math inline">\(\boldsymbol{\psi}_{i}\)</span>是与运动流形相关联的残差</li><li><span class="math inline">\(\boldsymbol{\beta}_{i}\)</span>是在<span class="math inline">\(t_k\)</span>和<span class="math inline">\(t_{k+1}\)</span>时间内，基于轮速里程计测量的位姿预测残差（Sec. IV-B）</li></ul><p>特别的，视觉重投影残差计算如下：</p><p><img src="http://s1.nsloop.com:59080/images/2021/08/06/20210806095813.png"></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{Z}_{i j}\)</span>表示与位姿<span class="math inline">\(i\)</span>和视觉landmark <span class="math inline">\(\mathbf{f}_{j}\)</span>相关的相机观测 （图像点）</li><li><span class="math inline">\(\boldsymbol{\Sigma}_{C}\)</span>是观测的信息矩阵</li><li>函数<span class="math inline">\(h(\cdot)\)</span>表示经过校准的相机模型[20]</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;localization-for-ground-robots-on-manifold-representation-integration-re-parameterization-and-optimization&quot;&gt;Localization for Ground 
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>MSCKF论文阅读</title>
    <link href="http://yoursite.com/2021/07/20/MSCKF%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/07/20/MSCKF%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-07-20T14:03:53.000Z</published>
    <updated>2021-07-25T11:15:38.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="a-multi-state-constraint-kalman-filter-for-vision-aided-inertial-navigation">A Multi-State Constraint Kalman Filter for Vision-aided Inertial Navigation</h1><p><img src="http://s1.nsloop.com:59080/images/2021/07/20/20210720220945.png"></p><h1 id="摘要">摘要</h1><p>本文介绍了一个基于扩展卡尔曼滤波器的算法，用于实时视觉辅助的惯性导航算法。本项工作的主要贡献是观测模型的导出，其能够表达从多个相机pose观察到静态特征所构成的几何约束。该测量模型不需要在EKF的状态向量中包含3D特征点的位置。</p><p>提出的视觉辅助惯性导航算法的计算复杂性只与特征点数量线性相关，并且能够在大型现实环境中进行高精度的姿态估计。</p><h1 id="系统描述">系统描述</h1><p>目标是估计与IMU固定的坐标系相对于全局参考坐标系的3D位姿。</p><p>为了简化地球自转对IMU测量的影响，本文选取全局坐标系为ECEF坐标系，整体算法流程如<strong>算法1</strong>所示.</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/24/20210724152005.png"></p><p>IMU测量被用于进行实时处理，用于传播EKF状态和协方差（Section III-B）。另一方面，每一帧图像到达时，相机的位姿估计被添加到状态向量中（Section III-C）。状态增广是为了处理特征观测所必须的，因为每个跟踪的特征点的观测用于在所有相机位姿中施加约束，从而用于对观测到该特征点的相机位姿进行约束。</p><p>因此，在任何时候，EKF状态向量都包含：</p><ul><li>IMU状态</li><li>过去Nmax帧相机位姿</li></ul><h2 id="ekf状态向量的结构">EKF状态向量的结构</h2><p>IMU状态：</p><p><span class="math display">\[\mathbf{X}_{\mathrm{IMU} }=\left[\begin{array}{lllll}{ }_{G}^{I} \bar{q}^{T} &amp; \mathbf{b}_{g}{ }^{T} &amp; { }^{G} \mathbf{v}_{I}^{T} &amp; \mathbf{b}_{a}{ }^{T} &amp; { }^{G} \mathbf{p}_{I}^{T}\end{array}\right]^{T}\]</span></p><p>其中，</p><ul><li>单位四元数[19] <span class="math inline">\({ }_{G}^{I} \bar{q}\)</span>用于描述从全局坐标系<span class="math inline">\(G\)</span>到IMU坐标系<span class="math inline">\(I\)</span>的旋转</li><li><span class="math inline">\({ }^{G} \mathbf{p}_{I}\)</span>和<span class="math inline">\({ }^{G} \mathbf{v}_{I}\)</span>分别描述了IMU位置和速度，相对于全局坐标系<span class="math inline">\(G\)</span></li><li><span class="math inline">\(b_g\)</span>和<span class="math inline">\(b_a\)</span>是 3x1的向量，描述IMU的bias，IMU Biases被建模为受高斯噪声<span class="math inline">\(n_{wg},n_{wa}\)</span>驱动的随机游走过程。</li></ul><p>因此，IMU的误差状态模型被定义为如下：</p><p><span class="math display">\[\widetilde{\mathbf{X} }_{\mathrm{IMU} }=\left[\begin{array}{lllll}\boldsymbol{\delta} \boldsymbol{\theta}_{I}^{T} &amp; \widetilde{\mathbf{b} }_{g}^{T} &amp; { }^{G} \widetilde{\mathbf{v} }_{I}^{T} &amp; \widetilde{\mathbf{b} }_{a}^{T} &amp; { }^{G} \widetilde{\mathbf{p} }_{I}^{T}\end{array}\right]^{T}\]</span></p><p>对于位置、速度、biases，使用了标准的误差add定义，如位置误差<span class="math inline">\(\widetilde{x}=x-\hat{x}\)</span>，然而，对于四元数，则使用另外的准则。</p><p>实际上，如果<span class="math inline">\(\hat{\bar{q} }\)</span>是四元数<span class="math inline">\(\bar{q}\)</span>的估计值，那么，旋转误差可以描述为四元数误差<span class="math inline">\(\delta \bar{q}\)</span>，其中<span class="math inline">\(\bar{q}=\delta \bar{q} \otimes \hat{\bar{q} }\)</span> (这个要区分误差是定义在哪里，这里跟ESKF一样，定义在局部的，只不过这里的q是从全局坐标系到机体坐标系)</p><p>此处，误差四元数如下：</p><p><span class="math display">\[\delta \bar{q} \simeq\left[\begin{array}{ll}\frac{1}{2} \boldsymbol{\delta} \boldsymbol{\theta}^{T} &amp; 1\end{array}\right]^{T}\]</span></p><p>直观的，误差四元数<span class="math inline">\(\delta \bar{q}\)</span>描述了一个估计姿态和真实姿态之间的小角度旋转。因为姿态包含了3个自由度，使用<span class="math inline">\(\delta \theta\)</span>来描述姿态误差才是最小的表示。</p><p>假设在时间步骤k的EKF状态向量中包含N个相机姿势，该向量具有以下形式：</p><p><span class="math display">\[\hat{\mathbf{X} }_{k}=\left[\begin{array}{llllll}\hat{\mathbf{X} }_{\mathrm{IMU}_{k} }^{T} &amp; { }_{G}^{C_{1} } \hat{\bar{q} }^{T} &amp; { }^{G} \hat{\mathbf{p} }_{C_{1} }^{T} &amp; \ldots &amp; { }_{G}^{C_{N} } \hat{q}^{T} &amp; { }^{G} \hat{\mathbf{p} }_{C_{N} }^{T}\end{array}\right]^{T}\]</span></p><p>其中，<span class="math inline">\({}_G^{G_i} \hat{\bar{q} }, {}^G {\hat{p}_{C_i}, i=1\dots N}\)</span>是N个相机的姿态和位置。</p><p>因此，EKF的误差状态向量定义如下：</p><p><span class="math display">\[\widetilde{\mathbf{X} }_{k}=\left[\begin{array}{llllll}\widetilde{\mathbf{X} }_{\mathrm{IMU}_{k} }^{T} &amp; \boldsymbol{\delta} \boldsymbol{\theta}_{C_{1} }^{T} &amp; { }^{G} \widetilde{\mathbf{p} }_{C_{1} }^{T} &amp; \ldots &amp; \boldsymbol{\delta} \boldsymbol{\theta}_{C_{N} }^{T} &amp; { }^{T} \widetilde{\mathbf{p} }_{C_{N} }^{T}\end{array}\right]^{T}\]</span></p><h2 id="传播">传播</h2><p>滤波器传播的等式通过连续时间模型的离散化形式导出，定义如下：</p><h3 id="连续时间系统模型">连续时间系统模型</h3><p>IMU状态微分方程描述：</p><p><span class="math display">\[{ }_{G}^{I} \dot{\bar{q} }(t)=\frac{1}{2} \boldsymbol{\Omega}(\boldsymbol{\omega}(t))_{G}^{I} \bar{q}(t)\]</span></p><p><span class="math display">\[\dot{\mathbf{b} }_{g}(t)=\mathbf{n}_{w g}(t)\]</span></p><p><span class="math display">\[{ }^{G} \dot{\mathbf{v} }_{I}(t)={ }^{G} \mathbf{a}(t)\]</span></p><p><span class="math display">\[\dot{\mathbf{b} }_{a}(t)=\mathbf{n}_{w a}(t)\]</span></p><p><span class="math display">\[{ }^{G} \mathbf{p}_{I}(t)={ }^{G} \mathbf{v}_{I}(t)\]</span></p><p>其中，<span class="math inline">\({ }^{G} \mathbf{a}\)</span>表示机体加速度在全局坐标系的表示，<span class="math inline">\(\boldsymbol{\omega}=\left[\begin{array}{lll}\omega_{x} &amp; \omega_{y} &amp; \omega_{z}\end{array}\right]^{T}\)</span>表示IMU坐标系的旋转角速度。</p><p>另外的计算符号定义如下：</p><p><span class="math display">\[\boldsymbol{\Omega}(\boldsymbol{\omega})=\left[\begin{array}{cc}-\lfloor\boldsymbol{\omega} \times\rfloor &amp; \boldsymbol{\omega} \\-\boldsymbol{\omega}^{T} &amp; 0\end{array}\right], \quad\lfloor\boldsymbol{\omega} \times\rfloor=\left[\begin{array}{ccc}0 &amp; -\omega_{z} &amp; \omega_{y} \\\omega_{z} &amp; 0 &amp; -\omega_{x} \\-\omega_{y} &amp; \omega_{x} &amp; 0\end{array}\right]\]</span></p><p>陀螺仪和加速度计的测量描述如下 [20 ]：</p><p><span class="math display">\[\boldsymbol{\omega}_{m}=\boldsymbol{\omega}+\mathbf{C}\left({ }_{G}^{I} \bar{q}\right) \boldsymbol{\omega}_{G}+\mathbf{b}_{g}+\mathbf{n}_{g}\]</span></p><p><span class="math display">\[\begin{aligned}\mathbf{a}_{m}=&amp; \mathbf{C}\left({ }_{G}^{I} \bar{q}\right)\left({ }^{G} \mathbf{a}-{ }^{G} \mathbf{g}+2\left\lfloor\boldsymbol{\omega}_{G} \times\right\rfloor^{G} \mathbf{v}_{I}+\left\lfloor\boldsymbol{\omega}_{G} \times\right\rfloor^{2}{ }^{G} \mathbf{p}_{I}\right) \\&amp;+\mathbf{b}_{a}+\mathbf{n}_{a}\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(C(\cdot)\)</span>表示旋转矩阵</li><li><span class="math inline">\(n_g,n_a\)</span>为零均值高斯白噪声</li><li>值得注意的是，IMU测量结合了星球的旋转，<span class="math inline">\(w_{G}\)</span>的效果</li><li>此外，加速度计测量包括引力加速度,<span class="math inline">\({ }^{G} \mathbf{g}\)</span>, (expressed in the local frame)</li></ul><p>在上面的连续时间状态方程中，应用这些运算符，就可以得到了IMU的状态估计方程：</p><p><span class="math display">\[{}_{G}^{I} \dot{\hat{\bar{q} } }=\frac{1}{2} \boldsymbol{\Omega}(\hat{\boldsymbol{\omega} })_{G}^{I} \hat{\bar{q} }\]</span></p><p><span class="math display">\[\dot{\hat{\mathbf{b} } }_{g}=\mathbf{0}_{3 \times 1}\]</span></p><p><span class="math display">\[{ }^{G} \dot{\hat{\mathbf{v} } }_{I}=\mathbf{C}_{\hat{q} }^{T} \hat{\mathbf{a} }-2\left\lfloor\boldsymbol{\omega}_{G} \times\right\rfloor^{G} \hat{\mathbf{v} }_{I}-\left\lfloor\boldsymbol{\omega}_{G} \times\right\rfloor^{2}{ }^{G} \hat{\mathbf{p} }_{I}+{ }^{G} \mathbf{g}\]</span></p><p><span class="math display">\[\dot{\hat{\mathbf{b} } }_{a}=\mathbf{0}_{3 \times 1}\]</span></p><p><span class="math display">\[{ }^{G} \dot{\hat{\mathbf{p} } }_{I}={ }^{G} \hat{\mathbf{v} }_{I}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{C}_{\hat{q} }=C({}_G^{I}\hat{\bar{q} })\)</span></li><li><span class="math inline">\(\hat{a}=a_m-\bar{b}_{a}\)</span></li><li><span class="math inline">\(\hat{\omega}=\omega_{m}-\hat{b}_{g}-C_{\hat{q} }\omega_{G}\)</span></li></ul><p>IMU误差状态的线性化连续时间模型如下表示：</p><p><span class="math display">\[\dot{\widetilde{\mathbf{X} } }_{\mathrm{IMU} }=\mathbf{F} \tilde{\mathbf{X} }_{\mathrm{IMU} }+\mathbf{G} \mathbf{n}_{\mathrm{IMU} }\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{n}_{\mathrm{IMU} }=\left[\begin{array}{llll}\mathbf{n}_{g}^{T} &amp; \mathbf{n}_{w g}^{T} &amp; \mathbf{n}_{a}^{T} &amp; \mathbf{n}_{w a}^{T}\end{array}\right]^{T}\)</span>是系统噪声</li><li>关于<span class="math inline">\(\mathbf{n}_{IMU}\)</span>的协方差矩阵，<span class="math inline">\(\mathbf{Q}_{\mathrm{IMU} }\)</span>，取决于IMU噪声特性，可以再传感器标定期间离线计算。</li></ul><p>最后，F矩阵和G矩阵可以整理如下：</p><p><span class="math display">\[\mathbf{F}=\left[\begin{array}{ccccc}-\lfloor\hat{\boldsymbol{\omega} } \times\rfloor &amp; \mathbf{- I}_{3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} \\\mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} \\-\mathbf{C}_{\hat{q} }^{T}\lfloor\hat{\mathbf{a} } \times\rfloor &amp; \mathbf{0}_{3 \times 3} &amp; -2\left\lfloor\boldsymbol{\omega}_{G} \times\right\rfloor &amp; -\mathbf{C}_{\hat{q} }^{T} &amp; -\left\lfloor\boldsymbol{\omega}_{G} \times\right\rfloor^{2} \\\mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} \\\mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{I}_{3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3}\end{array}\right]\]</span></p><p><span class="math display">\[\mathbf{G}=\left[\begin{array}{cccc}-\mathbf{I}_{3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} \\\mathbf{0}_{3 \times 3} &amp; \mathbf{I}_{3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} \\\mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; -\mathbf{C}_{\hat{q} }^{T} &amp; \mathbf{0}_{3 \times 3} \\\mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{I}_{3} \\\mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 3}\end{array}\right]\]</span></p><h3 id="离散时间模型实现">离散时间模型实现</h3><p>由于IMU在周期T内进行采样，得到采样信号<span class="math inline">\(\omega_{m},a_{m}\)</span>，每次接收到新的IMU测量时，IMU状态估计采用5阶龙哥库塔(RK-5)记性积分传播。</p><p>此外，EKF的协方差矩阵必须传播，因此，我们介绍对协方差的分区：</p><p><span class="math display">\[\mathbf{P}_{k \mid k}=\left[\begin{array}{ll}\mathbf{P}_{I I_{k \mid k} } &amp; \mathbf{P}_{I C_{k \mid k} } \\\mathbf{P}_{I C_{k \mid k} }^{T} &amp; \mathbf{P}_{C C_{k \mid k} }\end{array}\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{P}_{I I_{k \mid k} }\)</span>是 15x15的协方差矩阵，关于IMU状态</li><li><span class="math inline">\(\mathbf{P}_{C C_{k \mid k} }\)</span>是6Nx6N的协方差矩阵，关于相机位姿估计的</li><li><span class="math inline">\(\mathbf{P}_{I C_{k \mid k} }\)</span>是IMU状态和相机位姿估计误差的相关性</li></ul><p>通过这样的分块，传播状态的协方差矩阵按如下进行：</p><p><span class="math display">\[\mathbf{P}_{k+1 \mid k}=\left[\begin{array}{cc}\mathbf{P}_{I I_{k+1 \mid k} } &amp; \mathbf{\Phi}\left(t_{k}+T, t_{k}\right) \mathbf{P}_{I C_{k \mid k} } \\\mathbf{P}_{I C_{k \mid k} }^{T} \mathbf{\Phi}\left(t_{k}+T, t_{k}\right)^{T} &amp; \mathbf{P}_{C C_{k \mid k} }\end{array}\right]\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{P}_{I I_{k+1 \mid k} }\)</span>有李雅普诺夫(Lyapunov)等式进行数值积分得到：</li></ul><p><span class="math display">\[\dot{\mathbf{P} }_{I I}=\mathbf{F} \mathbf{P}_{I I}+\mathbf{P}_{I I} \mathbf{F}^{T}+\mathbf{G} \mathbf{Q}_{\mathrm{IMU} } \mathbf{G}^{T}\]</span></p><p>数值积分即以初始值<span class="math inline">\(\mathbf{P}_{I I_{k\mid k} }\)</span>对时间间隔<span class="math inline">\((t_k,t_{k+T})\)</span>进行积分。</p><ul><li>误差转移矩阵<span class="math inline">\(\mathbf{\Phi}\left(t_{k}+T, t_{k}\right)\)</span>由微分方程进行数值积分来近似得到：</li></ul><p><span class="math display">\[\dot{\boldsymbol{\Phi} }\left(t_{k}+\tau, t_{k}\right)=\mathbf{F} \boldsymbol{\Phi}\left(t_{k}+\tau, t_{k}\right), \quad \tau \in[0, T]\]</span></p><p>其中，初始条件为</p><p><span class="math display">\[\mathbf{\Phi}\left(t_{k}, t_{k}\right)=\mathbf{I}_{15\times 15}\]</span></p><h3 id="状态增广">状态增广</h3><p>当接受到新的图像时，首先聪IMU姿态估计来计算相机的姿态估计初值：</p><p><span class="math display">\[_{G}^{C} \hat{\bar{q} }=\underset{I}{C} \bar{q} \otimes_{G}^{I} \hat{\bar{q} }\]</span></p><p><span class="math display">\[{ }^{G} \hat{\mathbf{p} }_{C}={ }^{G} \hat{\mathbf{p} }_{I}+\mathbf{C}_{\hat{q} }^{T}{ }^{I} \mathbf{p}_{C}\]</span></p><p>其中，</p><ul><li><span class="math inline">\({}_I^C \bar{q}\)</span>表示从IMU坐标系到相机坐标系的变换</li><li><span class="math inline">\({ }^{I} \mathbf{p}_{C}\)</span>表示相对于IMU坐标系的原点，相机坐标系的位置。</li></ul><p>由于相机位姿估计附加到状态向量中，因此EKF的协方差矩阵也进行增广:</p><p><span class="math display">\[\mathbf{P}_{k \mid k} \leftarrow\left[\begin{array}{c}\mathbf{I}_{6 N+15} \\\mathbf{J}\end{array}\right] \mathbf{P}_{k \mid k}\left[\begin{array}{c}\mathbf{I}_{6 N+15} \\\mathbf{J}\end{array}\right]^{T}\]</span></p><p>其中，雅克比<span class="math inline">\(J\)</span>根据式(14)进行微分推导 （谁对谁求导？）</p><p>式(14)截图如下： <img src="http://s1.nsloop.com:59080/images/2021/07/24/20210724170432.png"></p><p>最后得到雅克比如下：</p><p><span class="math display">\[\mathbf{J}=\left[\begin{array}{cccc}\mathbf{C}\left({ }_{I}^{C} \bar{q}\right) &amp; \mathbf{0}_{3 \times 9} &amp; \mathbf{0}_{3 \times 3} &amp; \mathbf{0}_{3 \times 6 N} \\\left\lfloor\mathbf{C}_{\hat{q} }^{T I} \mathbf{p}_{C} \times\right\rfloor &amp; \mathbf{0}_{3 \times 9} &amp; \mathbf{I}_{3} &amp; \mathbf{0}_{3 \times 6 N}\end{array}\right]\]</span></p><h3 id="测量模型">测量模型</h3><p>我们现在介绍用于更新状态估计的测量模型，这是本文的主要贡献。</p><p>由于EKF用于状态估计，因此对于构造测量模型，需要定义残差r ， 这取决于误差状态<span class="math inline">\(\widetilde{\mathbf{X} }\)</span>，因此，根据通用形式，有：</p><p><span class="math display">\[\mathbf{r}=\mathbf{H} \widetilde{\mathbf{X} }+ noise\]</span></p><p>在这个表达式中，H是测量雅比亚矩阵。对于EKF框架，应用的对于误差状态的噪声项必须是零均值、不相关的白噪声。</p><p>为了衍生我们的测量模型，我们的动机是通过多个相机的静态特征来实现涉及所有这些姿势的约束。在我们的工作中，相机观测按跟踪的特征进行分组，而不是每个相机姿势记录对应的观测（如[7,13,14]）。</p><p>同一个3D点的所有测量值都用于定于约束方程（在后面的等式24），与测量发生的所有相机姿势所相关联。<strong>这样的方法实现了在状态向量中可以不包含特征点的位置</strong>。</p><p>我们通过考虑单个特征 <span class="math inline">\(f_j\)</span> 被多个相机pose<span class="math inline">\(\left({ }_{G}^{C_{i} } \bar{q},{ }^{G} \mathbf{p}_{C_{i} }\right), i \in \mathcal{S}_{j}\)</span>所构成的集合<span class="math inline">\(M_{j}\)</span>所共同观测到的情况来提出测量模型。 <span class="math inline">\(M_{j}\)</span>中的每个观测都可以使用如下模型来描述：</p><p><span class="math display">\[\mathbf{z}_{i}^{(j)}=\frac{1}{ { }^{C_{i} } Z_{j} }\left[\begin{array}{c}{ }^{C_{i} } X_{j} \\{ }^{C_{i} } Y_{j}\end{array}\right]+\mathbf{n}_{i}^{(j)}, \quad i \in \mathcal{S}_{j}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{n}_{i}^{(j)}\)</span>是2x1的图像噪声向量，具有协方差矩阵<span class="math inline">\(\mathbf{R}_{i}^{(j)}=\sigma_{i m}^{2} \mathbf{I}_{2}\)</span></li><li>特征点的位置<span class="math inline">\({ }^{C_{i} } \mathbf{p}_{f_{j} }\)</span>被表示为在相机坐标系中，如下得到：</li></ul><p><span class="math display">\[{ }^{C_{i} } \mathbf{p}_{f_{j} }=\left[\begin{array}{c}{ }^{C_{i} } X_{j} \\{ }^{C_{i} } Y_{j} \\{ }^{C_{i} } Z_{j}\end{array}\right]=\mathbf{C}\left({ }_{G}^{C_{i} } \bar{q}\right)\left({ }^{G} \mathbf{p}_{f_{j} }-{ }^{G} \mathbf{p}_{C_{i} }\right)\]</span></p><p>其中，</p><ul><li><span class="math inline">\({ }^{G} \mathbf{p}_{f_{j} }\)</span>表示特征点在全局坐标系的3D位置，由于这是未知的，在我们的算法的第一步中，我们使用最小二乘最小化以获得估计值<span class="math inline">\({ }^{G} \hat{\mathbf{p} }_{f_{j} }\)</span>。 这是利用观测值<span class="math inline">\(\mathbf{z}_{i}^{(j)}, i \in \mathcal{S}_{j}\)</span>以及滤波器估计值关于相机姿态来实现的（具体参考附录）</li></ul><p>一旦获得了特征位置的估计，我们计算观测的残差：</p><p><span class="math display">\[\mathbf{r}_{i}^{(j)}=\mathbf{z}_{i}^{(j)}-\hat{\mathbf{z} }_{i}^{(j)}\]</span></p><p>其中，</p><p><span class="math display">\[\hat{\mathbf{z} }_{i}^{(j)}=\frac{1}{ {}^{C_{i} } \hat{Z}_{j} }\left[\begin{array}{c}{ }^{C_{i} } \hat{X}_{j} \\{ }^{C_{i} } \hat{Y}_{j}\end{array}\right]\]</span></p><p><span class="math display">\[\left[\begin{array}{c}{ }^{C_{i} } \hat{X}_{j} \\{ }^{C_{i} } \hat{Y}_{j} \\{ }^{C_{i} } \hat{Z}_{j}\end{array}\right]=\mathbf{C}\left({ }_{G}^{C_{i} } \hat{q}\right)\left({ }^{G} \hat{\mathbf{p} }_{f_{j} }-{ }^{G} \hat{\mathbf{p} }_{C_{i} }\right)\]</span></p><p>对上式( 等式20 )中关于相机位姿和特征点位置进行线性化，得到近似如下：</p><p><span class="math display">\[\mathbf{r}_{i}^{(j)} \simeq \mathbf{H}_{\mathbf{X}_{i} }^{(j)} \widetilde{\mathbf{X} }+\mathbf{H}_{f_{i} }^{(j) G} \widetilde{\mathbf{p} }_{f_{j} }+\mathbf{n}_{i}^{(j)}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{H}_{\mathbf{X}_{i} }^{(j)}\)</span>是观测<span class="math inline">\(\mathbf{z}_{i}^{(j)}\)</span>对状态的雅克比</li><li><span class="math inline">\(\mathbf{H}_{f_{i} }^{(j)}\)</span>是观测<span class="math inline">\(\mathbf{z}_{i}^{(j)}\)</span>对特征点位置的雅克比 ( <span class="math inline">\(\mathbf{z}_{i}^{(j)}\)</span> 难道不是直接从图像获取的特征点吗)</li><li><span class="math inline">\(\widetilde{\mathbf{X} }\)</span>滤波器的误差状态</li><li><span class="math inline">\({ }^{G} \widetilde{\mathbf{p} }_{f_{j} }\)</span> 关于特征点<span class="math inline">\(f_j\)</span>的误差</li><li>上面H矩阵的具体推导可参见[21]</li></ul><p>通过叠加关于特征点<span class="math inline">\(f_j\)</span>的相机位姿集合<span class="math inline">\(M_j\)</span>中所有的残差，可以得到：</p><p><span class="math display">\[\mathbf{r}^{(j)} \simeq \mathbf{H}_{\mathbf{X} }^{(j)} \widetilde{\mathbf{X} }+\mathbf{H}_{f}^{(j) G} \widetilde{\mathbf{p} }_{f_{j} }+\mathbf{n}^{(j)}\]</span></p><p>其中，<span class="math inline">\(\mathbf{r}^{(j)}, \mathbf{H}_{\mathbf{X} }^{(j)}, \mathbf{H}_{f}^{(j)}\)</span>, and <span class="math inline">\(\mathbf{n}^{(j)}\)</span>都是分别包含如下元素<span class="math inline">\(\mathbf{r}_{i}^{(j)}, \mathbf{H}_{\mathbf{X}_{i} }^{(j)}, \mathbf{H}_{f_{i} }^{(j)}\)</span>, and <span class="math inline">\(\mathbf{n}_{i}^{(j)}\)</span>的向量或矩阵。 并且由于不同图像中的特征观测是独立的，因此<span class="math inline">\(\mathbf{n}^{(j)}\)</span>的协方差矩阵为<span class="math inline">\(\mathbf{R}^{(j)}=\sigma_{\mathrm{im} }^{2} \mathbf{I}_{2 M_{j} }\)</span>。</p><p>请注意，由于状态估计值<span class="math inline">\(\mathbf{X}\)</span>，用于计算特征点的位置估计（参考附录），式(22) 即线性化后的残差等式与误差状态<span class="math inline">\(\mathbf{\tilde{X} }\)</span>相关联。因此，残差<span class="math inline">\(\mathbf{r}^{(j)}\)</span>并非如等式(17)的形式(<span class="math inline">\(\mathbf{r}=\mathbf{H} \tilde{\mathbf{X} }+\)</span> noise)，不能直接用于EKF的测量更新步骤。</p><p>为了克服这个问题，我们通过将<span class="math inline">\(\mathbf{r}^{(j)}\)</span>投影到矩阵<span class="math inline">\(\mathbf{H}_{f}^{(j)}\)</span>的左零空间，从而定义了一个新的残差<span class="math inline">\(\mathbf{r}_{o}^{(j)}\)</span>。特别的，如果我们使用酉矩阵来表示<span class="math inline">\(\mathbf{A}\)</span>，其中它的列形成了关于<span class="math inline">\(\mathbf{H}_{f}\)</span>左零空间中的bias （这说的啥意思）</p><p><span class="math display">\[\begin{aligned}\mathbf{r}_{o}^{(j)} &amp;=\mathbf{A}^{T}\left(\mathbf{z}^{(j)}-\hat{\mathbf{z} }^{(j)}\right) \simeq \mathbf{A}^{T} \mathbf{H}_{\mathbf{X} }^{(j)} \widetilde{\mathbf{X} }+\mathbf{A}^{T} \mathbf{n}^{(j)} \\&amp;=\mathbf{H}_{o}^{(j)} \widetilde{\mathbf{X} }^{(j)}+\mathbf{n}_{o}^{(j)}\end{aligned}\]</span></p><p>因为 <span class="math inline">\(2M_j \times 3\)</span>的矩阵<span class="math inline">\(\mathbf{H}_{f}^{(j)}\)</span>是列满秩的，他的左零空间维度为<span class="math inline">\(2 M_{j}-3\)</span>。因此<span class="math inline">\(\mathbf{r}_{o}^{(j)}\)</span>是<span class="math inline">\(\left(2 M_{j}-3\right) \times 1\)</span>的向量。这种残差独立于特征坐标中的误差，因此可以基于它执行EKF更新。</p><p>式<span class="math inline">\(\mathbf{H}_{o}^{(j)} \widetilde{\mathbf{X} }^{(j)}+\mathbf{n}_{o}^{(j)}\)</span>定义了所有观测到特征点<span class="math inline">\(f_j\)</span>。这表达了测量<span class="math inline">\(\mathbf{z}_{i}^{(j)}\)</span>为<span class="math inline">\(M_j\)</span>的状态提供所有的有效信息，因此产生的EKF更新是最优的，除了由于线性化所引起的不准确性。</p><p>应该提到的是，为了计算残差<span class="math inline">\(\mathbf{r}_{O}^{(j)}\)</span>和观测矩阵<span class="math inline">\(\mathbf{H}_{o}^{(j)}\)</span>，酉矩阵<span class="math inline">\(\mathbf{A}\)</span>不需要显式地被评估。相反，残差<span class="math inline">\(\mathbf{r}\)</span>和矩阵<span class="math inline">\(\mathbf{H}_{\mathbf{X} }^{(j)}\)</span>在<span class="math inline">\(\mathbf{H}_{f}^{(j)}\)</span>矩阵左零空间的投影可以通过使用<code>Givens</code>旋转[22]来计算得到，操作复杂度为<span class="math inline">\(O\left(M_{j}^{2}\right)\)</span>。另外，<span class="math inline">\(\mathbf{A}\)</span>是酉矩阵，因此向量<span class="math inline">\(\mathbf{n}_{o}^{(j)}\)</span>的协方差可以如下计算：</p><p><span class="math display">\[E\left\{\mathbf{n}_{o}^{(j)} \mathbf{n}_{o}^{(j) T}\right\}=\sigma_{\mathrm{im} }^{2} \mathbf{A}^{T} \mathbf{A}=\sigma_{\mathrm{im} }^{2} \mathbf{I}_{2 M_{j}-3}\]</span></p><h3 id="ekf更新">EKF更新</h3><p>在前面的部分中，我们呈现了一种测量模型，其表示通过观察来自多个相机姿势的静态特征而施加的几何约束。 我们现在详细介绍了EKF的更新阶段，其中使用从观察多个特征的约束。 EKF更新由以下两个事件之一触发</p><ul><li>当检测不到之前在多个图像跟踪的特征时，则使用第III-D部分中呈现的方法处理此特征的所有测量。 这种情况最常出现，因为特征点有可能在相机视野范围之外。</li><li>每次记录新图像时，当前相机姿势估计将被包含在状态向量中，如果已经达到了设定的最大相机位姿数<span class="math inline">\(N_{max}\)</span>，则必须删除最少一个旧的相机位姿。在丢弃状态之前，使用在相应的时间瞬间发生的所有特征观测，以便利用其局部信息。在我们的算法中，从第二最旧的相机位姿开始，我们选择均匀间隔的<span class="math inline">\(\frac{N_{max} }{3}\)</span>的位姿，在使用这些姿势共有的特征的约束执行 EKF 更新后，这些被丢弃。我们选择始终保持最古老的姿势在状态向量中，因为涉及及时进一步姿势的几何结构通常对应于较大的基线，因此携带更有价值的定位信息，这种方法在实践中表现得非常好。</li></ul><p>考虑到在给定的时间步骤中，必须处理由上述两个标准选择的<span class="math inline">\(L\)</span>个特征点的约束。遵循前一节中描述的过程，我们对每一个特征点计算残差向量<span class="math inline">\(\mathbf{r}_{o}^{(j)}, j=1 \ldots L\)</span>以及相关联的观测矩阵<span class="math inline">\(\mathbf{H}_{o}^{(j)}, j=1 \ldots L\)</span>。通过将所有残差堆叠在一个向量中，我们得到：</p><p><span class="math display">\[\mathbf{r}_{o}=\mathbf{H}_{\mathbf{X} } \widetilde{\mathbf{X} }+\mathbf{n}_{o}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{r}_{o}\)</span>的块元素为<span class="math inline">\(\mathbf{r}_{o}^{(j)}\)</span></li><li><span class="math inline">\(\mathbf{n}_{o}\)</span>的块元素为<span class="math inline">\(\mathbf{n}_{o}^{(j)}, j=1 \ldots L\)</span></li><li><span class="math inline">\(\mathbf{H}_{\mathbf{X} }\)</span>矩阵具有行块元素<span class="math inline">\(\mathbf{H}_{\mathbf{X} }^{(j)}, j=1 \ldots L\)</span></li></ul><p>由于特征测量是统计上的，因此噪声向量<span class="math inline">\(\mathbf{n}_{o}^{(j)}\)</span>是不相关的，因此，其协方差矩阵等价于<span class="math inline">\(\mathbf{R}_{o}=\sigma_{\mathrm{im} }^{2} \mathbf{I}_{d}\)</span>，其中 <span class="math inline">\(d=\sum_{j=1}^{L}\left(2 M_{j}-3\right)\)</span> 是残差<span class="math inline">\(\mathbf{r}_{o}\)</span>的维度</p><p>一个实践中的问题是，<span class="math inline">\(d\)</span>可以是一个相当大的数字，例如，如果10个特征点在10个相机位姿中都被观测到，那么残差的维度是170 {(2x10-3)x10=170}.</p><p>为了降低EKF更新的计算复杂度，我们采用QR分解，对<span class="math inline">\(\mathbf{H}_{\mathbf{X} }\)</span>，特别的，我们记分解为如下形式：</p><p><span class="math display">\[\mathbf{H}_{\mathbf{X} }=\left[\begin{array}{ll}\mathbf{Q}_{1} &amp; \mathbf{Q}_{2}\end{array}\right]\left[\begin{array}{c}\mathbf{T}_{H} \\\mathbf{0}\end{array}\right]\]</span></p><p>其中，</p><ul><li>Q1和Q2是关于矩阵<span class="math inline">\(\mathbf{H}_{\mathbf{X} }\)</span>列形式的range和nullspace。</li><li><span class="math inline">\(\mathbf{T}_{H}\)</span>是上三角矩阵</li></ul><p>根据这个定义，等式(25)(<span class="math inline">\(\mathbf{r}_{o}=\mathbf{H}_{\mathbf{X} } \widetilde{\mathbf{X} }+\mathbf{n}_{o}\)</span>) 可以产生如下形式：</p><p><span class="math display">\[\begin{aligned}\mathbf{r}_{o} &amp;=\left[\begin{array}{ll}\mathbf{Q}_{1} &amp; \mathbf{Q}_{2}\end{array}\right]\left[\begin{array}{c}\mathbf{T}_{H} \\\mathbf{0}\end{array}\right] \tilde{\mathbf{X} }+\mathbf{n}_{o} \Rightarrow \\\left[\begin{array}{c}\mathbf{Q}_{1}^{T} \mathbf{r}_{o} \\\mathbf{Q}_{2}^{T} \mathbf{r}_{o}\end{array}\right] &amp;=\left[\begin{array}{c}\mathbf{T}_{H} \\\mathbf{0}\end{array}\right] \widetilde{\mathbf{X} }+\left[\begin{array}{c}\mathbf{Q}_{1}^{T} \mathbf{n}_{o} \\\mathbf{Q}_{2}^{T} \mathbf{n}_{o}\end{array}\right]\end{aligned}\]</span></p><p>从最后一个等式开始，通过投影<span class="math inline">\(\mathbf{H}_{\mathbf{X} }\)</span>范围的基础向量，我们保留了测量中的所有有用信息。</p><p>残差中的<span class="math inline">\(\mathbf{Q}_{2}^{T} \mathbf{r}_{o}\)</span>只是噪声，并且可以完全丢弃。因此，相比于使用等式(25)中的残差表示，我们使用下面形式的残差来执行EKF更新：</p><p><span class="math display">\[\mathbf{r}_{n}=\mathbf{Q}_{1}^{T} \mathbf{r}_{o}=\mathbf{T}_{H} \widetilde{\mathbf{X} }+\mathbf{n}_{n}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\mathbf{n}_{n}=\mathbf{Q}_{1}^{T} \mathbf{n}_{o}\)</span> 是噪声向量，其协方差矩阵等价于<span class="math inline">\(\mathbf{R}_{n}=\mathbf{Q}_{1}^{T} \mathbf{R}_{o} \mathbf{Q}_{1}=\sigma_{\operatorname{im} }^{2} \mathbf{I}_{r}\)</span>，且r为Q1的列数</li></ul><p>EKF更新步骤计算卡尔曼增益：</p><p><span class="math display">\[\mathbf{K}=\mathbf{P} \mathbf{T}_{H}^{T}\left(\mathbf{T}_{H} \mathbf{P} \mathbf{T}_{H}^{T}+\mathbf{R}_{n}\right)^{-1}\]</span></p><p>并且，矫正的状态按下式给出：</p><p><span class="math display">\[\Delta \mathbf{X}=\mathbf{K} \mathbf{r}_{n}\]</span></p><p>最后，状态的协方差矩阵如下更新：</p><p><span class="math display">\[\mathbf{P}_{k+1 \mid k+1}=\left(\mathbf{I}_{\xi}-\mathbf{K} \mathbf{T}_{H}\right) \mathbf{P}_{k+1 \mid k}\left(\mathbf{I}_{\xi}-\mathbf{K} \mathbf{T}_{H}\right)^{T}+\mathbf{K} \mathbf{R}_{n} \mathbf{K}^{T}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(\xi=6N+15\)</span>是协方差矩阵的维度</li></ul><p>审查EKF更新期间所需的操作的计算复杂性很有意思，残差 <span class="math inline">\(\mathbf{r}_{n}\)</span>以及矩阵<span class="math inline">\(\mathbf{T}_{H}\)</span>可以使用 Givens 旋转计算，操作复杂度是<span class="math inline">\(O\left(r^{2} d\right)\)</span>，而无需显式地计算Q1的形式。</p><p>另一方面，等式(31)包含了<span class="math inline">\(\xi\)</span>维度的方阵的乘法计算，是<span class="math inline">\(O\left(\xi^{3}\right)\)</span>的操作。因此，EKF更新的复杂度是<span class="math inline">\(\max \left(O\left(r^{2} d\right), O\left(\xi^{3}\right)\right)\)</span>。</p><p>另一方面，如果使用的残余向量<span class="math inline">\(\mathbf{r}_{o}\)</span>，而不将其投影在<span class="math inline">\(\mathbf{H}_{\mathbf{X} }\)</span>的range内，计算卡尔曼增益的计算成本是<span class="math inline">\(O\left(d^{3}\right)\)</span>，然而，通常<span class="math inline">\(d \gg \xi, r\)</span>，所以可知，使用残差<span class="math inline">\(\mathbf{r}_{n}\)</span>可以减少计算量。</p><h1 id="实验暂略">实验（暂略）</h1><p><img src="http://s1.nsloop.com:59080/images/2021/07/24/20210724205124.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;a-multi-state-constraint-kalman-filter-for-vision-aided-inertial-navigation&quot;&gt;A Multi-State Constraint Kalman Filter for Vision-aided
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>LT-mapper论文阅读</title>
    <link href="http://yoursite.com/2021/07/20/LT-mapper%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/07/20/LT-mapper%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-07-20T01:33:53.000Z</published>
    <updated>2021-07-20T01:56:02.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lt-mapper-a-modular-framework-for-lidar-based-lifelong-mapping">LT-mapper: A Modular Framework for LiDAR-based Lifelong Mapping</h1><p><img src="http://s1.nsloop.com:59080/images/2021/07/20/20210720094022.png"></p><h1 id="摘要">摘要</h1><p>本文开发了一个开源的、模块化的、现成的、基于lidar的城市站点lifelong mapping</p><p>这是通过将问题划分为连续的子问题来实现的：</p><p>- multi-session SLAM (MSS) - high/low dynamic change detection - positive/negative change management</p><p>所提出的方法利用MSS，并处理潜在的轨迹误差，因此，change检测不需要良好的初始对齐，我们的change管理方案保留了内存和计算成本的有效性，提供了从大规模点云图中自动分离对象的功能。通过对多个时间间隔(从一天到一年)的广泛实际实验，我们验证了该框架的可靠性和适用性，甚至在永久的年水平变化。</p><h1 id="介绍">介绍</h1><p>环境的变化如图1所示</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/20/20210720094103.png"></p><p>为了更好地处理这种变化，lifelong mapping必须通过检测、更新和管理环境变化来解决自治的建图维护[1]</p><p>1）Integration to multi-session SLAM for scalability：一些研究认为，变化检测是比较多个预先构建的地图与时间上遥远和独立的后处理过程。在这项工作中，我们集成了多会话SLAM (MSS)，并将会话与锚节点[2]对齐，以在大型城市环境中执行变化检测，而不是在一个小房间，我们的框架包括一个基于激光雷达的多会话三维同步定位和映射(SLAM)模块，称为LT-SLAM。</p><p>2）Change detection under SLAM error：如果地图完全对齐，那么两个地图之间的变化检测就不重要了，早期的地图变化检测工作[5,3,6,7]依赖于全局对齐地图的强假设，没有错误，避免了处理这种模糊性问题。不幸的是，轨迹误差在现实中不可避免地发生。我们在变更检测期间调和了这种潜在的不对准，并使所提出的方法能够稳健地处理潜在的对准误差。为了处理模糊性，我们提出了一种具有投射可见性的scan-to-map方案，使用多个窗口大小的range-image，称为LT-removert</p><p>3）Compact place management：除了变更检测之外，我们还提出并证明了变更组合的概念，一旦检测到更改，就应该遵循地图维护的决定，以确定包含或排除什么，利用这一特性，我们不仅可以维护现有作品[1,3]等最新的地图，还可以提取具有较高placeness的稳定结构。因此，我们构建了一个可靠的3D地图，具有真正有意义的结构，用于其他任务，如跨模式定位[9]和长期定位[10]。这个最后的模块，称为LT-map.</p><p>总结，提出了一个新颖的基于激光雷达的lifelong mapping，称为LT-mapper. 框架中的每一个模块都可独立运行，基于file-based i/o 协议。与最近(但部分)提供的基于视觉的方法不同的是，3D LiDAR几乎没有实现统一和模块化的终身映射[11,12,13,14,15]。据我们所知，LT-mapper是第一个开放的模块化框架，支持基于lidar的复杂城市站点终身绘图，本文主要贡献：</p><p>- LT-SLAM 集成变化检测MSS，通过anchor node来解决会话恢复，只使用激光雷达在共享帧中缝合多个会话。 - LT-removert 利用时空轴上的remove-then-revert算法，克服了会话间的对齐模糊性。 - LT-map 能有效地生成最新地图(实时地图)和持久地图(元地图)，同时将更改存储为增量地图，通过增量建图，减少内存和储存的成本。</p><h1 id="相关工作">相关工作</h1><h1 id="概述">概述</h1><p>LT-mapper是完全模块化的，并支持上述三个功能。整个pipline有3个模块组成(图3)，顺序运行并且模块独立。不像现有的基于激光雷达的变化检测[21]，装备有昂贵的定位设备，我们的系统只需要一个激光雷达（可选的IMU）。</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/20/20210720094454.png"></p><p>在真实的户外环境中，暂时不连接的场景之间的准确对齐是难以捉摸的，如图2(a)所示</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/20/20210720094903.png"></p><p>在LT-SLAM模块中，我们利用多会话SLAM，联合优化多个会话，并使用基于lidar的全局定位器进行鲁棒的会话间闭环检测，在这个模块中，一个查询度量被配准到现有的中心地图中。</p><p>我们同样需要考虑观测的变化，如图2(b)，一个构建的点云图可能包含噪声，由于周围的运动物体(红点)，即使是精确的里程表。这些不稳定的物体对一个地方的显著性的贡献不如静止点，因此，在LT-removert模块中，这些高动态(HD)点应该在计算会话间差异之前预先删除。</p><p>在对齐查询帧和中心会话并移除高清点后，我们通过应用查询测量和中心地图之间的差分操作来检测变化，如图2(c)。我们称之为低动态变化(LD)，进一步分为新出现点(PD)和消失点(ND)两类。</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/20/20210720095539.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;lt-mapper-a-modular-framework-for-lidar-based-lifelong-mapping&quot;&gt;LT-mapper: A Modular Framework for LiDAR-based Lifelong Mapping&lt;/h1&gt;
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
  <entry>
    <title>TEB局部路径规划论文阅读</title>
    <link href="http://yoursite.com/2021/07/19/TEB%E5%B1%80%E9%83%A8%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2021/07/19/TEB%E5%B1%80%E9%83%A8%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/</id>
    <published>2021-07-19T09:03:53.000Z</published>
    <updated>2021-07-19T12:51:34.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="trajectory-modification-considering-dynamic-constraints-of-autonomous-robots">Trajectory modification considering dynamic constraints of autonomous robots</h1><p><img src="http://s1.nsloop.com:59080/images/2021/07/19/20210719174333.png"></p><h1 id="摘要">摘要</h1><p>经典的“松紧带”使由全局规划器生成的路径相对于最短路径长度发生变形，为了避免与障碍物接触。它不直接考虑底层机器人的任何动态约束。本文贡献引入了一种名为“时间弹性带”的新方法，该方法明确地考虑了运动的时间方面的动态约束，如有限的机器人速度和加速度。“时间弹性带”问题用加权多目标优化框架表示。大多数目标是局部的，因为它们依赖于一些邻近的中间配置。这就得到了一个有效的大规模约束最小二乘优化方法存在的稀疏系统矩阵。</p><p>仿真和实际机器人的实验结果表明，该方法具有较好的鲁棒性和计算效率，能够实时生成最优机器人轨迹。“时间弹性带”将由一系列路径点组成的初始路径转换为明确依赖于时间的轨迹，从而实现对机器人的实时控制。由于其模块化的形式，该方法很容易扩展到包含额外的目标和约束。</p><h1 id="介绍">介绍</h1><p>在运动规划的背景下，本文侧重于局部路径修改，假设初始路径已由全局规划器生成[1]。特别是在服务机器人的环境中，由于动态环境可能是动态的，由于其固有的不确定性，修改路径是一种较好的方法。此外，由于局部、不完整的地图和动态障碍，环境模型可能会发生变化，此外，在实时应用中，大规模全局路径的(重新)计算往往是不可行的。这种观测结果导致了局部修改路径的方法，如[2,3]提出的“弹性带”，“松紧带”方法的主要思想是，将原来给定的路径视为受内外力影响的弹性橡皮筋，使其变形，而内外力相互平衡，使路径收缩，同时与障碍物保持一定距离。</p><p>后来这种方法被推广到非完整运动学[4,5,6]、多自由度[7]机器人系统和动态障碍[8]，然而，据我们所知，动态运动约束还没有被认为是对路径变形的一个目标。典型的方法是用样条曲线平滑路径，获得动态可行轨迹。</p><p>我们的方法称为“时间弹性带”，是一种新颖的方法，因为它明确地增加了“弹性带”的时间信息，从而允许考虑机器人的动态约束和直接修改轨迹而不是路径。图1展示了使用时间弹性带架构的机器人系统：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/19/20210719175444.png"></p><p>通过考虑时间信息，“时间弹性带”也可以用来控制机器人的速度和加速度，这个方法也适用于高维的状态空间，尽管本文只考虑了差分驱动机器人的平面环境移动，有三个全局自由度和两个局部自由度。</p><h1 id="时间弹性带">时间弹性带</h1><p>经典的“弹性带”是用n个机器人的中间姿态序列来描述的，<span class="math inline">\(\mathbf{x}_{i}=\left(x_{i}, y_{i}, \beta_{i}\right)^{T} \in \R^{2} \times S^1\)</span>，下面记为位置(x_i,y_i)和旋转<span class="math inline">\(\beta_i\)</span>，如图2所示:</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/19/20210719191833.png"></p><p><span class="math display">\[Q=\left\{\mathbf{x}_{i}\right\}_{i=0 \ldots n} \quad n \in \mathbb{N}\]</span></p><p>TEB由两个连续的配置之间的时间间隔来进行时间调整，因此一个序列中包含<span class="math inline">\(n-1\)</span>个<span class="math inline">\(\Delta T_i\)</span>：</p><p><span class="math display">\[\tau=\left\{\Delta T_{i}\right\}_{i=0 \ldots n-1}\]</span></p><p>每个时间差表示机器人从一个配置依次过渡到下一个配置的时间(图2)，因此TEB定义为元祖序列：</p><p><span class="math display">\[B:=(Q, \tau)\]</span></p><p>其关键思想是通过实时加权多目标优化，在配置和时间间隔两个方面进行调整和优化：</p><p><span class="math display">\[\begin{aligned}f(B) &amp;=\sum_{k} \gamma_{k} f_{k}(B) \\B^{*} &amp;=\underset{B}{\operatorname{argmin}} f(B)\end{aligned}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(B*\)</span>表示优化的TEB</li><li><span class="math inline">\(f(B)\)</span>记为目标函数，在本文中由多个加权成分<span class="math inline">\(f_k\)</span>组成，用于面对不同的方面，这是最基本的多目标优化方法，但它已经产生了非常好的结果。</li></ul><p>目标函数的大部分分量相对于B是局部的，因为它们只依赖于几个连续的配置，而不是整个可配置空间带。</p><p>TEB的这种局部性导致了一个稀疏系统矩阵，为其提供了专门的快速有效的大规模数值优化方法[11]。</p><p>TEB的目标函数分为两类：</p><ul><li>约束例如速度、加速度限制等惩罚项</li><li>目标项如最快、最短路径或者远离障碍等(等式8)</li></ul><p>因此，在“时间弹性带”的背景下，这些约束被表述为一个分段连续、可微的代价函数的目标，该函数会惩罚违反约束的行为：</p><p><span class="math display">\[e_{\Gamma}\left(x, x_{r}, \epsilon, S, n\right) \simeq \begin{cases}\left(\frac{x-\left(x_{r}-\epsilon\right)}{S}\right)^{n} &amp; \text { if } x&gt;x_{r}-\epsilon \\ 0 &amp; \text { otherwise }\end{cases}\]</span></p><p>其中，</p><ul><li><span class="math inline">\(x_r\)</span>表示边界</li><li><span class="math inline">\(S,n,\epsilon\)</span> 影响近似的准确性</li><li>特别的，<span class="math inline">\(S\)</span>表示尺度缩放，<span class="math inline">\(n\)</span>表示阶数，<span class="math inline">\(\epsilon\)</span>是近似的一个位移小量</li></ul><p>图3展示了等式6的两个不同的实现。 Approximation 1 （n = 2, S = 0.1, <span class="math inline">\(\epsilon\)</span>= 0.1） ， Approximation 2 （n = 2, S = 0.05 and <span class="math inline">\(\epsilon\)</span> = 0.1） ， 这个例子展示了约束<span class="math inline">\(x_r=0.4\)</span>的一个近似。</p><p>使用多目标优化框架的一个明显优势是目标函数的模块化表达。目前TEB所采用的目标函数如下：</p><h2 id="way-points-and-obstacles">Way points and obstacles</h2><p>TEB同时考虑原始路径的中间路径点的到达和避免静态或者动态的障碍物。这两个目标函数相似，不同之处在于点吸引橡皮筋，而障碍物排斥它。</p><p>目标函数企图最小化TEB和way point的距离<span class="math inline">\(d_{min,j}\)</span>，如图4所示：</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/19/20210719194704.png"></p><p>对于way point的情况，其距离以最大的目标半径<span class="math inline">\(r_{pmax}\)</span>为界，这些约束由公式6中的惩罚函数实现：</p><p><span class="math display">\[\begin{aligned}f_{\text {path }} &amp;=e_{\Gamma}\left(d_{\min , j}, r_{p_{\max }}, \epsilon, S, n\right) \\f_{o b} &amp;=e_{\Gamma}\left(-d_{\min , j},-r_{o_{\min }}, \epsilon, S, n\right)\end{aligned}\]</span></p><p>由图3可知，必须将Eq. 8中<span class="math inline">\(d_{\min , j}\)</span>和<span class="math inline">\(r_{o_{min}}\)</span>交换符号来实现下界.</p><p>注意，这些目标函数的梯度可以解释为作用在弹性带上的外力</p><h2 id="velocity-and-acceleration">Velocity and acceleration</h2><p>机器人速度和加速度的动力学约束用与几何约束相似的罚函数来描述，图2展示了TEB的结构，线速度和角速度的均值使用两个连续配置<span class="math inline">\(x_i,x_{i+1}\)</span>之间的欧式距离和角距离和时间差<span class="math inline">\(\Delta T_i\)</span>来计算：</p><p><span class="math display">\[\begin{aligned}v_{i} &amp; \simeq \frac{1}{\Delta T_{i}}\left\|\left(\begin{array}{l}x_{i+1}-x_{i} \\y_{i+1}-y_{i}\end{array}\right)\right\| \\\omega_{i} &amp; \simeq \frac{\beta_{i+1}-\beta_{i}}{\Delta T_{i}}\end{aligned}\]</span></p><p>由于配置的临近，欧几里得距离是两个连续姿态之间的圆路径的真实长度的充分近似值。</p><p>加速度涉及两个连续的平均速度，因此考虑三个连续的构型，其中两个对应时间差：</p><p><span class="math display">\[a_{i}=\frac{2\left(v_{i+1}-v_{i}\right)}{\Delta T_{i}+\Delta T_{i+1}}\]</span></p><p>为了清楚起见，用上式两个相关的速度来代替这三个连续的配置，旋转的加速度计算类似。</p><p>考虑一个差分驱动的移动机器人，轮速和位移<span class="math inline">\(v_i\)</span>、旋转速度<span class="math inline">\(w_i\)</span>关于机器人中心点的关系如下：</p><p><span class="math display">\[\begin{aligned}v_{w_{r}, i} &amp;=v_{i}+L \omega_{i} \\v_{w_{l}, i} &amp;=v_{i}-L \omega_{i}\end{aligned}\]</span></p><p>其中，L为机器人轮距的一半</p><p>将公式12和公式13（即上面两个式子）对时间进行微分就得到了相应的车轮加速度。车轮的速度和加速度是有界的，可根据制造商的规格获取。机器人的平移和转动惯量可以以一种明显的方式包括在内，但在这第一个实现中，我们还没有这样做。</p><h2 id="non-holonomic-kinematics非完整约束运动学方程">Non-holonomic kinematics（非完整约束运动学方程）</h2><p>差动驱动的机器人只有两个局部自由度，因此，它们只能在机器人当前航向的方向执行运动，这种运动学约束导致了由圆弧段组成的平滑路径。</p><p>因此，两个相邻的构型需要位于一个常曲率的公共圆弧上，如图5所示</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/19/20210719200953.png"></p><p>初始配置<span class="math inline">\(x_i\)</span>和方向<span class="math inline">\(d_{i,i+1}\)</span>之间的角度<span class="math inline">\(\vartheta_{i}\)</span>必须等于配置<span class="math inline">\(x_{i+1}\)</span>和方向<span class="math inline">\(d_{i,i+1}\)</span>之间的夹角，即：</p><p><span class="math display">\[\vartheta_{i}=\vartheta_{i+1}\]</span></p><p>根据二维叉积（<span class="math inline">\(A \times B=|A|·|B|·\sin \alpha\)</span>），有：</p><p><span class="math display">\[\Leftrightarrow\left(\begin{array}{c}\cos \beta_{i} \\\sin \beta_{i} \\0\end{array}\right) \times \mathbf{d}_{i, i+1}=\mathbf{d}_{i, i+1} \times\left(\begin{array}{c}\cos \beta_{i+1} \\\sin \beta_{i+1} \\0\end{array}\right)\]</span></p><p>其中，机器人的绝对旋转为<span class="math inline">\(\beta_i\)</span>，位移方向向量为：</p><p><span class="math display">\[\mathbf{d}_{i, i+1}:=\left(\begin{array}{c}x_{i+1}-x_{i} \\y_{i+1}-y_{i} \\0\end{array}\right)\]</span></p><p>因此，对应的目标函数为：</p><p><span class="math display">\[f_{k}\left(\mathbf{x}_{i}, \mathbf{x}_{i+1}\right)=\left\|\left[\left(\begin{array}{c}\cos \beta_{i} \\\sin \beta_{i} \\0\end{array}\right)+\left(\begin{array}{c}\cos \beta_{i+1} \\\sin \beta_{i+1} \\0\end{array}\right)\right] \times \mathbf{d}_{i, i+1}\right\|^{2}\]</span></p><p>惩罚违反此约束的二次误差。一个潜在的180方向的变化用一个额外的项来处理</p><h2 id="fastest-path">Fastest path</h2><p>以往的“松紧带”方法通过收缩松紧带的内力获得最短路径。由于我们的方法考虑时间信息作为最短路径的目标，我们可以选择用最快路径的目标代替最短路径的目标，或者将这些目标结合起来。</p><p>最快路径的目标很容易通过最小化所有时间差的和的平方来实现：</p><p><span class="math display">\[f_{k}=\left(\sum_{i=1}^{n} \Delta T_{i}\right)^{2}\]</span></p><p>这一目标导致了一种最快的路径，其中中间配置在时间上均匀分离，而不是在空间上</p><h2 id="实现">实现</h2><p>图6展示了实现TEB的控制流程，在初始化阶段，初始路径被增强为初始轨迹，方法是根据动力学和运动学约束添加默认的时间信息。</p><p>在我们的例子中，初始轨迹是由带有纯旋转和平移的分段线性分段组成的，这种以多边形表示的路径通常由概率路线图规划者提供[9]，另外，reed - shepp路径很容易被增强为允许的轨迹[10]。</p><p>在每一次迭代中，算法动态地添加新的结构或删除以前的结构，以调整空间和时间分辨率以适应剩余的轨迹长度或规划水平。</p><p>一个滞后被实施以避免振荡。将优化问题转化为一个超图，用包含在“g20 -框架”中的大规模稀疏系统优化算法求解[11]</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/19/20210719204210.png"></p><p>所要求的超图是一条边的连接节点数量不受限制的图,因此，一条边可以连接两个以上的节点。</p><p>TEB问题(Eq. 4)可以转化为一个以配置和时间差为节点的超图。它们与表示给定目标函数fk或约束函数的边相连，图7展示了一个两配置一个时间差和一个点状障碍物的超图，</p><p><img src="http://s1.nsloop.com:59080/images/2021/07/19/20210719204524.png"></p><p>速度边界目标函数要求的平均速度与两个配置之间的欧氏距离和所需的时间有关。因此它形成一条连接B的那些状态的边。</p><p>障碍物需要一条与最近的配置相连的边，表示障碍物的节点是固定的(双圆)，因此优化算法无法改变其参数(位置)</p><p>在验证优化后的TEB后，可以通过计算控制变量v和ω来直接命令机器人驱动系统。</p><p>在每一次新的迭代之前，重新初始化阶段将检查新的和变化的way-points，这将会比较有用如果way-points是在分析相机或者激光数据之后才收到的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;trajectory-modification-considering-dynamic-constraints-of-autonomous-robots&quot;&gt;Trajectory modification considering dynamic constraint
      
    
    </summary>
    
    
    
      <category term="SLAM" scheme="http://yoursite.com/tags/SLAM/"/>
    
  </entry>
  
</feed>
